/* Function: FUN_004010e0 */

void FUN_004010e0(void)

{
  return;
}



/* Function: FUN_00401160 */

void FUN_00401160(void)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  return;
}



/* Function: FUN_00401200 */

void FUN_00401200(int param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  
  do {
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < &stack0x00000000) {
      if (param_1 == 0) {
        return;
      }
      for (iVar1 = 0; -1 < iVar1 * 7; iVar1 = iVar1 + 1) {
        if ((*(byte *)(iVar1 + 1 + param_1) & 0x80) == 0) {
          return;
        }
      }
      FUN_00438020();
    }
    FUN_0046d980();
  } while( true );
}



/* Function: FUN_00401280 */

void FUN_00401280(int param_1)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  int in_FS_OFFSET;
  
  do {
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < &stack0x00000000) {
      if (param_1 == 0) {
        return;
      }
      iVar3 = 0;
      uVar4 = 0;
      while( true ) {
        uVar2 = iVar3 * 7;
        bVar1 = *(byte *)(iVar3 + 1 + param_1);
        if ((int)uVar2 < 0) break;
        uVar4 = uVar4 + ((bVar1 & 0x7f) << ((byte)uVar2 & 0x1f) & -(uint)(uVar2 < 0x20));
        if ((bVar1 & 0x80) == 0) {
          if (-1 < (int)uVar4) {
            if (uVar4 <= (uint)-(iVar3 + 2 + param_1)) {
              return;
            }
            FUN_004644d0();
          }
          FUN_004644d0();
          break;
        }
        iVar3 = iVar3 + 1;
      }
      FUN_00438020();
    }
    FUN_0046d980();
  } while( true );
}



/* Function: FUN_00401310 */

void FUN_00401310(void)

{
  int iVar1;
  byte bVar2;
  byte *pbVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  undefined1 *puVar9;
  int in_FS_OFFSET;
  
code_r0x00401310:
  puVar9 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar9 = (undefined1 *)((int)register0x00000010 + -8);
    pbVar3 = *(byte **)((int)register0x00000010 + 4);
    if ((*pbVar3 & 2) == 0) {
      *(undefined4 *)((int)register0x00000010 + 8) = 0;
      *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
      return;
    }
    iVar5 = 0;
    iVar7 = 0;
    while( true ) {
      uVar8 = iVar5 * 7;
      if ((int)uVar8 < 0) break;
      iVar7 = iVar7 + ((pbVar3[iVar5 + 1] & 0x7f) << ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20));
      if ((pbVar3[iVar5 + 1] & 0x80) == 0) {
        iVar6 = 0;
        uVar8 = 0;
        goto LAB_0040138d;
      }
      iVar5 = iVar5 + 1;
    }
    goto LAB_004013f1;
  }
  goto LAB_004013f7;
LAB_0040138d:
  iVar1 = iVar7 + iVar5 + iVar6;
  uVar4 = iVar6 * 7;
  bVar2 = pbVar3[iVar1 + 2];
  if ((int)uVar4 < 0) goto LAB_004013ec;
  *(byte *)((int)register0x00000010 + -5) = bVar2;
  *(int *)((int)register0x00000010 + -4) = iVar6;
  uVar8 = uVar8 + ((bVar2 & 0x7f) << ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20));
  if ((*(byte *)((int)register0x00000010 + -5) & 0x80) == 0) {
    if (-1 < (int)uVar8) {
      if (uVar8 <= (uint)-(int)(pbVar3 + iVar1 + 3)) {
        *(byte **)((int)register0x00000010 + 8) = pbVar3 + iVar1 + 3;
        *(uint *)((int)register0x00000010 + 0xc) = uVar8;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x4013e7;
      FUN_004644d0();
    }
    *(undefined4 *)((int)register0x00000010 + -0xc) = 0x4013ec;
    FUN_004644d0();
    goto LAB_004013ec;
  }
  iVar6 = *(int *)((int)register0x00000010 + -4) + 1;
  goto LAB_0040138d;
LAB_004013ec:
  *(undefined4 *)((int)register0x00000010 + -0xc) = 0x4013f1;
  FUN_00438020();
LAB_004013f1:
  *(undefined4 *)((int)register0x00000010 + -0xc) = 0x4013f6;
  FUN_00438020();
LAB_004013f7:
  *(undefined4 *)(puVar9 + -4) = 0x4013fc;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar9;
  goto code_r0x00401310;
}



/* Function: FUN_004014e0 */

void FUN_004014e0(undefined4 param_1,undefined4 param_2)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004019d0();
  FUN_00401520(param_1,param_2);
  return;
}



/* Function: FUN_00401520 */

void FUN_00401520(void)

{
  short *psVar1;
  undefined4 uVar2;
  uint uVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  uint uVar7;
  uint uVar8;
  undefined4 *puVar9;
  int *piVar10;
  undefined4 *puVar11;
  undefined1 *puVar12;
  undefined4 *puVar13;
  int *piVar14;
  short *psVar15;
  undefined4 *puVar16;
  int in_FS_OFFSET;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x44);
      piVar14 = *(int **)((int)register0x00000010 + 4);
      uVar8 = *(uint *)((int)register0x00000010 + 8);
LAB_00401545:
      do {
        piVar10 = piVar14;
        puVar13 = DAT_005d70f0;
        puVar16 = DAT_005d70f4;
        if (uVar8 == 0) {
          for (; 0 < (int)puVar16; puVar16 = (undefined4 *)((int)puVar16 + -1)) {
            if (*(char *)(puVar13 + 3) != '\0') {
              if ((*(char *)((int)puVar13 + 0xd) == '\0') || (*(char *)puVar13[2] != '\0')) {
                *(char *)puVar13[2] = *(char *)((int)puVar13 + 0xd);
              }
              else {
                *(undefined4 **)((int)register0x00000010 + -0x18) = puVar16;
                *(undefined4 **)((int)register0x00000010 + -4) = puVar13;
                *(undefined4 *)((int)register0x00000010 + -8) = *puVar13;
                *(undefined4 *)((int)register0x00000010 + -0x1c) = puVar13[1];
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4017a5;
                FUN_0043a810();
                *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c8809;
                *(undefined4 *)((int)register0x00000010 + -0x40) = 0x19;
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4017bb;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x44) =
                     *(undefined4 *)((int)register0x00000010 + -8);
                *(undefined4 *)((int)register0x00000010 + -0x40) =
                     *(undefined4 *)((int)register0x00000010 + -0x1c);
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4017cf;
                FUN_0043b060();
                *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c7bca;
                *(undefined4 *)((int)register0x00000010 + -0x40) = 0x17;
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4017e5;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4017ea;
                FUN_0043a870();
                puVar13 = *(undefined4 **)((int)register0x00000010 + -4);
                puVar16 = *(undefined4 **)((int)register0x00000010 + -0x18);
              }
            }
            puVar13 = puVar13 + 4;
          }
          return;
        }
        for (uVar3 = 0; (int)uVar3 < (int)uVar8; uVar3 = uVar3 + 1) {
          if (*(char *)((int)piVar10 + uVar3) == ',') goto LAB_00401559;
        }
        uVar3 = 0xffffffff;
LAB_00401559:
        if ((int)uVar3 < 0) {
          uVar7 = 0;
          piVar14 = (int *)0x0;
          uVar3 = uVar8;
        }
        else {
          if (uVar8 < uVar3) goto LAB_004019bc;
          if (uVar8 < uVar3 + 1) goto LAB_004019b3;
          uVar7 = (uVar8 - uVar3) - 1;
          piVar14 = (int *)((uVar3 + 1 & (int)-uVar7 >> 0x1f) + (int)piVar10);
        }
        uVar8 = uVar7;
      } while (((int)uVar3 < 4) || (*piVar10 != 0x2e757063));
      for (uVar8 = 0; (int)uVar8 < (int)uVar3; uVar8 = uVar8 + 1) {
        if (*(char *)((int)piVar10 + uVar8) == '=') goto LAB_004015a5;
      }
      uVar8 = 0xffffffff;
LAB_004015a5:
      *(int **)((int)register0x00000010 + -8) = piVar14;
      *(uint *)((int)register0x00000010 + -0x18) = uVar7;
      if ((int)uVar8 < 0) {
        *(int **)((int)register0x00000010 + -0xc) = piVar10;
        *(uint *)((int)register0x00000010 + -0x2c) = uVar3;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401703;
        FUN_0043a810();
        *(char **)((int)register0x00000010 + -0x44) =
             "GODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-enco..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x21;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401719;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -0x2c);
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x40172d;
        FUN_0043b060();
        *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c2960;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 2;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401743;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401748;
        FUN_0043a870();
        uVar8 = *(uint *)((int)register0x00000010 + -0x18);
        piVar14 = *(int **)((int)register0x00000010 + -8);
        goto LAB_00401545;
      }
      if (uVar8 <= uVar3) {
        if (3 < uVar8) {
          puVar13 = (undefined4 *)((int)-(uVar8 - 4) >> 0x1f & 4);
          psVar15 = (short *)((int)piVar10 + (int)puVar13);
          if (uVar8 + 1 <= uVar3) {
            *(uint *)((int)register0x00000010 + -0x1c) = uVar8 - 4;
            *(short **)((int)register0x00000010 + -0x10) = psVar15;
            iVar4 = uVar3 - uVar8;
            *(int *)((int)register0x00000010 + -0x30) = iVar4 + -1;
            uVar3 = uVar8 + 1 & -(iVar4 + -1) >> 0x1f;
            psVar1 = (short *)((int)piVar10 + uVar3);
            *(short **)((int)register0x00000010 + -0x14) = psVar1;
            if (iVar4 == 3) {
              if (*psVar1 != 0x6e6f) {
LAB_00401675:
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x40167a;
                FUN_0043a810();
                *(char **)((int)register0x00000010 + -0x44) =
                     "GODEBUG: value \"allowmultiplevcsRCodeFormatError[bisect-match 0xChaCha20Nonce.txtAdjustTokenGroupsIsTokenRestrictedLookupAccountSidWCertFindExtensionCryptDecodeObjectDnsRecordListFreeGetShortPathNameWReadProcessMemoryQueryWorkingSetExGetKeyboardLayoutWSAEnumProtocolsWWTSQueryUserTokenwinreadlinkvolumeRegLoadMUIStringWGTB Standard TimeFLE Standard TimeGMT Standard Timepermission deniedwrong medium typeno data availableexec format errorGetCurrentProcessgoroutine profileAllThreadsSyscallGC assist markingselect (no cases)sync.RWMutex.Lockwait for GC cycletrace proc statusselect (synctest)sync.(*Cond).Wait: missing method notetsleepg on g0bad TinySizeClassruntime: pointer g already scannedmark - bad statusscanobject n == 0swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
                ;
                *(undefined4 *)((int)register0x00000010 + -0x40) = 0x10;
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401690;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x44) =
                     *(undefined4 *)((int)register0x00000010 + -0x14);
                *(undefined4 *)((int)register0x00000010 + -0x40) =
                     *(undefined4 *)((int)register0x00000010 + -0x30);
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4016a4;
                FUN_0043b060();
                *(char **)((int)register0x00000010 + -0x44) =
                     "\" not supported for cpu option \"initial table capacity too largeCryptAcquireCertificatePrivateKeyGetVolumeNameForVolumeMountPointWInitializeProcThreadAttributeListSetupDiGetDeviceRegistryPropertyWSetupDiSetDeviceRegistryPropertyWskip everything and stop the walktoo many levels of symbolic linksslice bounds out of range [%x:%y]runtime: memory allocated by OS [misrounded allocation in sysAllocruntime: failed to decommit pages/cpu/classes/gc/pause:cpu-seconds/cpu/classes/gc/total:cpu-seconds/gc/limiter/last-enabled:gc-cycle/memory/classes/heap/stacks:bytes/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobje..." /* TRUNCATED STRING LITERAL */
                ;
                *(undefined4 *)((int)register0x00000010 + -0x40) = 0x20;
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4016ba;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x44) =
                     *(undefined4 *)((int)register0x00000010 + -0x10);
                *(undefined4 *)((int)register0x00000010 + -0x40) =
                     *(undefined4 *)((int)register0x00000010 + -0x1c);
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4016ce;
                FUN_0043b060();
                *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c2960;
                *(undefined4 *)((int)register0x00000010 + -0x40) = 2;
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4016e4;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4016e9;
                FUN_0043a870();
                uVar8 = *(uint *)((int)register0x00000010 + -0x18);
                piVar14 = *(int **)((int)register0x00000010 + -8);
                goto LAB_00401545;
              }
            }
            else if (((iVar4 != 4) || (*psVar1 != 0x666f)) ||
                    (*(char *)((int)piVar10 + uVar3 + 2) != 'f')) goto LAB_00401675;
            puVar16 = (undefined4 *)(uint)(iVar4 == 3);
            if (((uVar8 == 7) && (*psVar15 == 0x6c61)) &&
               (*(char *)((int)piVar10 + 2 + (int)puVar13) == 'l')) {
              puVar11 = DAT_005d70f4;
              for (puVar5 = (undefined4 *)0x0; (int)puVar5 < (int)puVar11;
                  puVar5 = (undefined4 *)((int)puVar5 + 1)) {
                if (DAT_005d70f4 <= puVar5) {
LAB_0040198e:
                  *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401993;
                  FUN_0046edf0();
                  goto LAB_00401993;
                }
                puVar13 = (undefined4 *)((int)puVar5 * 0x10);
                *(undefined1 *)(DAT_005d70f0 + 3 + (int)puVar5 * 4) = 1;
                if (DAT_005d70f4 <= puVar5) {
                  *(undefined4 *)((int)register0x00000010 + -0x48) = 0x40198e;
                  FUN_0046edf0();
                  goto LAB_0040198e;
                }
LAB_00401945:
                *(char *)((int)DAT_005d70f0 + 0xd + (int)puVar13) = (char)puVar16;
              }
              uVar8 = *(uint *)((int)register0x00000010 + -0x18);
              piVar14 = *(int **)((int)register0x00000010 + -8);
            }
            else {
              *(bool *)((int)register0x00000010 + -0x31) = iVar4 == 3;
              *(undefined4 **)((int)register0x00000010 + -0x20) = DAT_005d70f4;
              puVar11 = *(undefined4 **)((int)register0x00000010 + -0x1c);
              puVar6 = (undefined4 *)0x0;
              puVar9 = DAT_005d70f4;
              while ((int)puVar6 < (int)puVar9) {
                puVar5 = puVar6;
                if (DAT_005d70f4 <= puVar6) {
LAB_00401940:
                  *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401945;
                  FUN_0046edf0();
                  goto LAB_00401945;
                }
                puVar16 = (undefined4 *)DAT_005d70f0[(int)puVar6 * 4 + 1];
                uVar2 = DAT_005d70f0[(int)puVar6 * 4];
                puVar13 = puVar6;
                if (puVar16 == puVar11) {
                  *(undefined4 **)((int)register0x00000010 + -0x24) = puVar6;
                  *(int *)((int)register0x00000010 + -0x28) = (int)puVar6 * 0x10;
                  *(undefined4 *)((int)register0x00000010 + -0x44) = uVar2;
                  *(short **)((int)register0x00000010 + -0x40) = psVar15;
                  *(undefined4 **)((int)register0x00000010 + -0x3c) = puVar16;
                  *(undefined4 *)((int)register0x00000010 + -0x48) = 0x40187b;
                  FUN_00402aa0();
                  puVar13 = DAT_005d70f0;
                  if (*(char *)((int)register0x00000010 + -0x38) != '\0') {
                    puVar5 = *(undefined4 **)((int)register0x00000010 + -0x24);
                    if (puVar5 < DAT_005d70f4) {
                      puVar6 = *(undefined4 **)((int)register0x00000010 + -0x28);
                      *(undefined1 *)((int)(DAT_005d70f0 + 3) + (int)puVar6) = 1;
                      if (puVar5 < DAT_005d70f4) {
                        *(undefined1 *)((int)DAT_005d70f0 + 0xd + (int)puVar6) =
                             *(undefined1 *)((int)register0x00000010 + -0x31);
                        uVar8 = *(uint *)((int)register0x00000010 + -0x18);
                        piVar14 = *(int **)((int)register0x00000010 + -8);
                        goto LAB_00401545;
                      }
                      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x40193b;
                      FUN_0046edf0();
                      puVar11 = puVar13;
                    }
                    *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401940;
                    FUN_0046edf0();
                    puVar13 = puVar6;
                    goto LAB_00401940;
                  }
                  puVar9 = *(undefined4 **)((int)register0x00000010 + -0x20);
                  puVar11 = *(undefined4 **)((int)register0x00000010 + -0x1c);
                  puVar13 = *(undefined4 **)((int)register0x00000010 + -0x24);
                  psVar15 = *(short **)((int)register0x00000010 + -0x10);
                }
                puVar16 = (undefined4 *)(uint)*(byte *)((int)register0x00000010 + -0x31);
                puVar6 = (undefined4 *)((int)puVar13 + 1);
              }
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4018e4;
              FUN_0043a810();
              *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004ca26e;
              *(undefined4 *)((int)register0x00000010 + -0x40) = 0x1e;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4018fa;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x44) =
                   *(undefined4 *)((int)register0x00000010 + -0x10);
              *(undefined4 *)((int)register0x00000010 + -0x40) =
                   *(undefined4 *)((int)register0x00000010 + -0x1c);
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x40190e;
              FUN_0043b060();
              *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c2960;
              *(undefined4 *)((int)register0x00000010 + -0x40) = 2;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401924;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x401929;
              FUN_0043a870();
              uVar8 = *(uint *)((int)register0x00000010 + -0x18);
              piVar14 = *(int **)((int)register0x00000010 + -8);
            }
            goto LAB_00401545;
          }
LAB_00401993:
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x40199e;
          FUN_0046ee50();
        }
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4019aa;
        FUN_0046ee50();
      }
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4019b3;
      FUN_0046ee10();
LAB_004019b3:
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4019bc;
      FUN_0046ee50();
LAB_004019bc:
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4019c5;
      FUN_0046ee10();
    }
    *(undefined4 *)(puVar12 + -4) = 0x4019cb;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
}



/* Function: FUN_004019d0 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_004019d0(void)

{
  int iVar1;
  undefined *puVar2;
  bool bVar3;
  undefined4 *puVar4;
  int iVar5;
  undefined4 uVar6;
  uint uVar7;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  bool bVar8;
  bool bVar9;
  undefined *puVar10;
  undefined4 *in_stack_ffffffd4;
  uint local_28;
  uint local_24;
  undefined *local_20;
  undefined4 *local_1c;
  uint local_18;
  uint local_14;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar10 = &DAT_004ad500;
  FUN_00411710();
  in_stack_ffffffd4[1] = 3;
  *in_stack_ffffffd4 = &DAT_004c2a71;
  in_stack_ffffffd4[2] = &DAT_005f6341;
  in_stack_ffffffd4[5] = 3;
  in_stack_ffffffd4[4] = &DAT_004c2a74;
  in_stack_ffffffd4[6] = &DAT_005f6340;
  in_stack_ffffffd4[9] = 4;
  in_stack_ffffffd4[8] = &DAT_004c2b71;
  in_stack_ffffffd4[10] = &DAT_005f6349;
  in_stack_ffffffd4[0xd] = 4;
  in_stack_ffffffd4[0xc] = &DAT_004c2b75;
  in_stack_ffffffd4[0xe] = &DAT_005f634a;
  in_stack_ffffffd4[0x11] = 9;
  in_stack_ffffffd4[0x10] = &DAT_004c3474;
  in_stack_ffffffd4[0x12] = &DAT_005f634d;
  in_stack_ffffffd4[0x15] = 6;
  in_stack_ffffffd4[0x14] = &DAT_004c2df2;
  in_stack_ffffffd4[0x16] = &DAT_005f634f;
  in_stack_ffffffd4[0x19] = 3;
  in_stack_ffffffd4[0x18] = &DAT_004c2a77;
  in_stack_ffffffd4[0x1a] = &DAT_005f6350;
  DAT_005d70f4 = 7;
  DAT_005d70f8 = 7;
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = in_stack_ffffffd4;
    in_EDI[1] = DAT_005d70f0;
  }
  DAT_005d70f0 = in_stack_ffffffd4;
  FUN_004021d0();
  puVar2 = puVar10;
  if ((int)puVar10 < 2) {
    uVar7 = DAT_005d70f4 + 5;
    puVar4 = DAT_005d70f0;
    if (DAT_005d70f8 < uVar7) {
      local_28 = DAT_005d70f8;
      local_24 = 0;
      local_20 = &DAT_004b87c0;
      FUN_0046a830(DAT_005d70f0,uVar7);
      DAT_005d70f8 = local_14;
      uVar7 = local_18;
      puVar4 = local_1c;
      if (DAT_005f5fd0 != 0) {
        puVar4 = local_1c;
        FUN_0046ed80();
        *in_EDI = puVar4;
        in_EDI[1] = DAT_005d70f0;
      }
    }
    DAT_005d70f0 = puVar4;
    puVar4 = DAT_005d70f0;
    iVar1 = uVar7 - 5;
    iVar5 = iVar1 * 0x10;
    DAT_005d70f4 = uVar7;
    DAT_005d70f0[iVar1 * 4 + 1] = 6;
    *(undefined2 *)(puVar4 + iVar1 * 4 + 3) = 0;
    if (DAT_005f5fd0 != 0) {
      uVar6 = puVar4[iVar1 * 4];
      FUN_0046ede0();
      *in_EDI = uVar6;
      in_EDI[1] = *(undefined4 *)((int)puVar4 + iVar5 + 8);
      in_EDI[2] = *(undefined4 *)((int)puVar4 + iVar5 + 0x10);
      in_EDI[3] = *(undefined4 *)((int)puVar4 + iVar5 + 0x18);
      in_EDI[4] = *(undefined4 *)((int)puVar4 + iVar5 + 0x20);
      in_EDI[5] = *(undefined4 *)((int)puVar4 + iVar5 + 0x28);
      in_EDI[6] = *(undefined4 *)((int)puVar4 + iVar5 + 0x30);
      in_EDI[7] = *(undefined4 *)((int)puVar4 + iVar5 + 0x38);
      uVar6 = *(undefined4 *)((int)puVar4 + iVar5 + 0x40);
      FUN_0046ed80();
      *in_EDI = uVar6;
      in_EDI[1] = *(undefined4 *)((int)puVar4 + iVar5 + 0x48);
    }
    *(undefined **)((int)puVar4 + iVar5) = &DAT_004c2df8;
    *(undefined1 **)((int)puVar4 + iVar5 + 8) = &DAT_005f634e;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x14) = 4;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x1c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x10) = &DAT_004c2b79;
    *(undefined1 **)((int)puVar4 + iVar5 + 0x18) = &DAT_005f6351;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x24) = 5;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x2c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x20) = &DAT_004c2ca0;
    *(undefined1 **)((int)puVar4 + iVar5 + 0x28) = &DAT_005f6353;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x34) = 5;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x3c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x30) = &DAT_004c2ca5;
    *(undefined1 **)((int)puVar4 + iVar5 + 0x38) = &DAT_005f6354;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x44) = 5;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x4c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x40) = &DAT_004c2caa;
    *(undefined1 **)((int)puVar4 + iVar5 + 0x48) = &DAT_005f6352;
  }
  if ((int)puVar2 < 3) {
    uVar7 = DAT_005d70f4 + 5;
    puVar4 = DAT_005d70f0;
    if (DAT_005d70f8 < uVar7) {
      local_28 = DAT_005d70f8;
      local_24 = 0;
      local_20 = &DAT_004b87c0;
      FUN_0046a830(DAT_005d70f0,uVar7);
      DAT_005d70f8 = local_14;
      puVar2 = puVar10;
      uVar7 = local_18;
      puVar4 = local_1c;
      if (DAT_005f5fd0 != 0) {
        puVar4 = local_1c;
        FUN_0046ed80();
        *in_EDI = puVar4;
        in_EDI[1] = DAT_005d70f0;
      }
    }
    DAT_005d70f0 = puVar4;
    puVar4 = DAT_005d70f0;
    iVar1 = uVar7 - 5;
    iVar5 = iVar1 * 0x10;
    DAT_005d70f4 = uVar7;
    DAT_005d70f0[iVar1 * 4 + 1] = 3;
    *(undefined2 *)(puVar4 + iVar1 * 4 + 3) = 0;
    if (DAT_005f5fd0 != 0) {
      uVar6 = puVar4[iVar1 * 4];
      FUN_0046ede0();
      *in_EDI = uVar6;
      in_EDI[1] = *(undefined4 *)((int)puVar4 + iVar5 + 8);
      in_EDI[2] = *(undefined4 *)((int)puVar4 + iVar5 + 0x10);
      in_EDI[3] = *(undefined4 *)((int)puVar4 + iVar5 + 0x18);
      in_EDI[4] = *(undefined4 *)((int)puVar4 + iVar5 + 0x20);
      in_EDI[5] = *(undefined4 *)((int)puVar4 + iVar5 + 0x28);
      in_EDI[6] = *(undefined4 *)((int)puVar4 + iVar5 + 0x30);
      in_EDI[7] = *(undefined4 *)((int)puVar4 + iVar5 + 0x38);
      uVar6 = *(undefined4 *)((int)puVar4 + iVar5 + 0x40);
      FUN_0046ed80();
      *in_EDI = uVar6;
      in_EDI[1] = *(undefined4 *)((int)puVar4 + iVar5 + 0x48);
    }
    *(undefined **)((int)puVar4 + iVar5) = &DAT_004c2a7a;
    *(byte **)((int)puVar4 + iVar5 + 8) = &DAT_005f6342;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x14) = 4;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x1c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x10) = &DAT_004c2b7d;
    *(byte **)((int)puVar4 + iVar5 + 0x18) = &DAT_005f6343;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x24) = 4;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x2c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x20) = &DAT_004c2b81;
    *(undefined1 **)((int)puVar4 + iVar5 + 0x28) = &DAT_005f6347;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x34) = 4;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x3c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x30) = &DAT_004c2b85;
    *(undefined1 **)((int)puVar4 + iVar5 + 0x38) = &DAT_005f6348;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x44) = 3;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x4c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x40) = &DAT_004c2a7d;
    *(undefined1 **)((int)puVar4 + iVar5 + 0x48) = &DAT_005f634b;
  }
  if ((int)puVar2 < 4) {
    uVar7 = DAT_005d70f4 + 3;
    puVar4 = DAT_005d70f0;
    if (DAT_005d70f8 < uVar7) {
      local_28 = DAT_005d70f8;
      local_24 = 0;
      local_20 = &DAT_004b87c0;
      FUN_0046a830(DAT_005d70f0,uVar7);
      DAT_005d70f8 = local_14;
      uVar7 = local_18;
      puVar4 = local_1c;
      if (DAT_005f5fd0 != 0) {
        puVar4 = local_1c;
        FUN_0046ed80();
        *in_EDI = puVar4;
        in_EDI[1] = DAT_005d70f0;
      }
    }
    DAT_005d70f0 = puVar4;
    puVar4 = DAT_005d70f0;
    iVar1 = uVar7 - 3;
    iVar5 = iVar1 * 0x10;
    DAT_005d70f4 = uVar7;
    DAT_005d70f0[iVar1 * 4 + 1] = 7;
    *(undefined2 *)(puVar4 + iVar1 * 4 + 3) = 0;
    if (DAT_005f5fd0 != 0) {
      uVar6 = puVar4[iVar1 * 4];
      FUN_0046edc0();
      *in_EDI = uVar6;
      in_EDI[1] = *(undefined4 *)((int)puVar4 + iVar5 + 8);
      in_EDI[2] = *(undefined4 *)((int)puVar4 + iVar5 + 0x10);
      in_EDI[3] = *(undefined4 *)((int)puVar4 + iVar5 + 0x18);
      in_EDI[4] = *(undefined4 *)((int)puVar4 + iVar5 + 0x20);
      in_EDI[5] = *(undefined4 *)((int)puVar4 + iVar5 + 0x28);
    }
    *(undefined **)((int)puVar4 + iVar5) = &DAT_004c2fa1;
    *(byte **)((int)puVar4 + iVar5 + 8) = &DAT_005f6344;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x14) = 8;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x1c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x10) = &DAT_004c31da;
    *(undefined1 **)((int)puVar4 + iVar5 + 0x18) = &DAT_005f6345;
    *(undefined4 *)((int)puVar4 + iVar5 + 0x24) = 8;
    *(undefined2 *)((int)puVar4 + iVar5 + 0x2c) = 0;
    *(undefined **)((int)puVar4 + iVar5 + 0x20) = &DAT_004c31e2;
    *(undefined1 **)((int)puVar4 + iVar5 + 0x28) = &DAT_005f6346;
  }
  FUN_00402190(0,0);
  if (local_28 != 0) {
    FUN_00402190(0x80000000,0);
    _DAT_005f5eb8 = local_28;
    uVar7 = 0;
    FUN_00402190(1,0);
    DAT_005f6351 = ((uint)local_20 & 1) != 0;
    DAT_005f634d = ((uint)local_20 & 2) != 0;
    DAT_005f6352 = ((uint)local_20 & 0x200) != 0;
    DAT_005f6353 = ((uint)local_20 & 0x80000) != 0;
    DAT_005f6354 = ((uint)local_20 & 0x100000) != 0;
    DAT_005f634e = ((uint)local_20 & 0x800000) != 0;
    DAT_005f6340 = ((uint)local_20 & 0x2000000) != 0;
    DAT_005f634c = ((uint)local_20 & 0x8000000) != 0;
    DAT_005f634b = ((uint)local_20 & 0x1000) != 0 && (bool)DAT_005f634c;
    if (((uint)local_20 & 0x8000000) == 0) {
      bVar3 = false;
      bVar8 = false;
    }
    else {
      FUN_004021b0();
      bVar8 = (uVar7 & 2) != 0;
      bVar9 = (uVar7 & 4) != 0;
      bVar3 = bVar8 && bVar9;
      if (((bVar8 && bVar9) && ((uVar7 & 0x20) != 0)) && ((uVar7 & 0x40) != 0)) {
        bVar8 = (uVar7 & 0x80) != 0;
      }
      else {
        bVar8 = false;
      }
    }
    DAT_005f6342 = ((uint)local_20 & 0x10000000) != 0 & bVar3;
    if (6 < local_28) {
      FUN_00402190(7,0);
      DAT_005f6347 = (local_24 & 8) != 0;
      DAT_005f6343 = bVar3 & (local_24 & 0x20) != 0;
      DAT_005f6348 = (local_24 & 0x100) != 0;
      DAT_005f6349 = (local_24 & 0x200) != 0;
      DAT_005f6341 = (local_24 & 0x80000) != 0;
      DAT_005f6350 = (local_24 & 0x20000000) != 0;
      DAT_005f6344 = bVar8 & (local_24 & 0x10000) != 0;
      if (DAT_005f6344 != 0) {
        DAT_005f6345 = (local_24 & 0x40000000) != 0;
        DAT_005f6346 = (local_24 & 0x80000000) != 0;
      }
      DAT_005f634a = ((uint)local_1c & 0x10) != 0;
      FUN_00402190(0x80000000,0);
      if (local_28 < 0x80000001) {
        return;
      }
      FUN_00402190(0x80000001,0);
      DAT_005f634f = ((uint)local_1c & 0x8000000) != 0;
      return;
    }
    return;
  }
  return;
}



/* Function: FUN_00402190 */

void FUN_00402190(int param_1)

{
  if (param_1 == 0) {
    cpuid_basic_info(0);
  }
  else if (param_1 == 1) {
    cpuid_Version_info(1);
  }
  else if (param_1 == 2) {
    cpuid_cache_tlb_info(2);
  }
  else if (param_1 == 3) {
    cpuid_serial_info(3);
  }
  else if (param_1 == 4) {
    cpuid_Deterministic_Cache_Parameters_info(4);
  }
  else if (param_1 == 5) {
    cpuid_MONITOR_MWAIT_Features_info(5);
  }
  else if (param_1 == 6) {
    cpuid_Thermal_Power_Management_info(6);
  }
  else if (param_1 == 7) {
    cpuid_Extended_Feature_Enumeration_info(7);
  }
  else if (param_1 == 9) {
    cpuid_Direct_Cache_Access_info(9);
  }
  else if (param_1 == 10) {
    cpuid_Architectural_Performance_Monitoring_info(10);
  }
  else if (param_1 == 0xb) {
    cpuid_Extended_Topology_info(0xb);
  }
  else if (param_1 == 0xd) {
    cpuid_Processor_Extended_States_info(0xd);
  }
  else if (param_1 == 0xf) {
    cpuid_Quality_of_Service_info(0xf);
  }
  else if (param_1 == -0x7ffffffe) {
    cpuid_brand_part1_info(0x80000002);
  }
  else if (param_1 == -0x7ffffffd) {
    cpuid_brand_part2_info(0x80000003);
  }
  else if (param_1 == -0x7ffffffc) {
    cpuid_brand_part3_info(0x80000004);
  }
  else {
    cpuid(param_1);
  }
  return;
}



/* Function: FUN_004021b0 */

void FUN_004021b0(void)

{
  return;
}



/* Function: FUN_004021d0 */

void FUN_004021d0(void)

{
  return;
}



/* Function: FUN_00402460 */

void FUN_00402460(void)

{
  return;
}



/* Function: FUN_00402470 */

void FUN_00402470(void)

{
  return;
}



/* Function: FUN_004024d0 */

void FUN_004024d0(void)

{
  int in_FS_OFFSET;
  
  do {
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      *(undefined **)((int)register0x00000010 + -8) = &DAT_004adee0;
      *(undefined ***)((int)register0x00000010 + -4) =
           &PTR_s_unaligned_64_bit_atomic_operatio_00550de8;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x4024fb;
      FUN_00469650();
      register0x00000010 = (BADSPACEBASE *)((int)register0x00000010 + -8);
    }
    *(undefined4 *)((int)register0x00000010 + -4) = 0x402501;
    FUN_0046d980();
  } while( true );
}



/* Function: FUN_00402510 */

void FUN_00402510(void)

{
  return;
}



/* Function: FUN_00402520 */

void FUN_00402520(void)

{
  return;
}



/* Function: FUN_00402530 */

void FUN_00402530(void)

{
  return;
}



/* Function: FUN_00402540 */

void FUN_00402540(int *param_1,int param_2,int param_3)

{
  LOCK();
  if (param_2 == *param_1) {
    *param_1 = param_3;
  }
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402540 */

void thunk_FUN_00402540(int *param_1,int param_2,int param_3)

{
  LOCK();
  if (param_2 == *param_1) {
    *param_1 = param_3;
  }
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402640 */

void thunk_FUN_00402640(long *param_1,long param_2,long param_3)

{
  if (((uint)param_1 & 7) != 0) {
    FUN_004024d0();
  }
  LOCK();
  if (param_2 == *param_1) {
    *param_1 = param_3;
  }
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402540 */

void thunk_FUN_00402540(int *param_1,int param_2,int param_3)

{
  LOCK();
  if (param_2 == *param_1) {
    *param_1 = param_3;
  }
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402540 */

void thunk_FUN_00402540(int *param_1,int param_2,int param_3)

{
  LOCK();
  if (param_2 == *param_1) {
    *param_1 = param_3;
  }
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402510 */

void thunk_FUN_00402510(void)

{
  return;
}



/* Function: thunk_FUN_00402510 */

void thunk_FUN_00402510(void)

{
  return;
}



/* Function: thunk_FUN_00402770 */

void thunk_FUN_00402770(undefined4 *param_1,undefined4 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: thunk_FUN_004027c0 */

void thunk_FUN_004027c0(undefined8 *param_1,undefined8 param_2)

{
  if (((uint)param_1 & 7) != 0) {
    FUN_004024d0();
  }
  *param_1 = param_2;
  LOCK();
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402770 */

void thunk_FUN_00402770(undefined4 *param_1,undefined4 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402690 */

void thunk_FUN_00402690(int *param_1,int param_2)

{
  LOCK();
  *param_1 = *param_1 + param_2;
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402510 */

void thunk_FUN_00402510(void)

{
  return;
}



/* Function: thunk_FUN_004027a0 */

void thunk_FUN_004027a0(uint param_1)

{
  if ((param_1 & 7) != 0) {
    FUN_004024d0();
  }
  return;
}



/* Function: thunk_FUN_00402690 */

void thunk_FUN_00402690(int *param_1,int param_2)

{
  LOCK();
  *param_1 = *param_1 + param_2;
  UNLOCK();
  return;
}



/* Function: thunk_FUN_004026b0 */

void thunk_FUN_004026b0(uint *param_1,uint param_2,int param_3)

{
  long lVar1;
  uint uVar2;
  uint uVar3;
  bool bVar4;
  
  if (((uint)param_1 & 7) != 0) {
    FUN_004024d0();
  }
  uVar2 = *param_1;
  uVar3 = param_1[1];
  do {
    LOCK();
    lVar1 = *(long *)param_1;
    bVar4 = CONCAT44(uVar3,uVar2) == lVar1;
    if (bVar4) {
      *(long *)param_1 = CONCAT44(uVar3 + param_3 + (uint)CARRY4(uVar2,param_2),uVar2 + param_2);
    }
    else {
      uVar3 = (uint)((ulong)lVar1 >> 0x20);
      uVar2 = (uint)lVar1;
    }
    UNLOCK();
  } while (!bVar4);
  return;
}



/* Function: FUN_00402640 */

void FUN_00402640(long *param_1,long param_2,long param_3)

{
  if (((uint)param_1 & 7) != 0) {
    FUN_004024d0();
  }
  LOCK();
  if (param_2 == *param_1) {
    *param_1 = param_3;
  }
  UNLOCK();
  return;
}



/* Function: FUN_00402670 */

void FUN_00402670(int *param_1,int param_2,int param_3)

{
  LOCK();
  if (param_2 == *param_1) {
    *param_1 = param_3;
  }
  UNLOCK();
  return;
}



/* Function: FUN_00402690 */

void FUN_00402690(int *param_1,int param_2)

{
  LOCK();
  *param_1 = *param_1 + param_2;
  UNLOCK();
  return;
}



/* Function: FUN_004026b0 */

void FUN_004026b0(uint *param_1,uint param_2,int param_3)

{
  long lVar1;
  uint uVar2;
  uint uVar3;
  bool bVar4;
  
  if (((uint)param_1 & 7) != 0) {
    FUN_004024d0();
  }
  uVar2 = *param_1;
  uVar3 = param_1[1];
  do {
    LOCK();
    lVar1 = *(long *)param_1;
    bVar4 = CONCAT44(uVar3,uVar2) == lVar1;
    if (bVar4) {
      *(long *)param_1 = CONCAT44(uVar3 + param_3 + (uint)CARRY4(uVar2,param_2),uVar2 + param_2);
    }
    else {
      uVar3 = (uint)((ulong)lVar1 >> 0x20);
      uVar2 = (uint)lVar1;
    }
    UNLOCK();
  } while (!bVar4);
  return;
}



/* Function: FUN_004026f0 */

void FUN_004026f0(undefined1 *param_1,undefined1 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: FUN_00402700 */

void FUN_00402700(undefined4 *param_1,undefined4 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402730 */

void thunk_FUN_00402730(long *param_1,long param_2)

{
  long lVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  bool bVar4;
  
  if (((uint)param_1 & 7) != 0) {
    FUN_004024d0();
  }
  uVar2 = (undefined4)*param_1;
  uVar3 = *(undefined4 *)((int)param_1 + 4);
  do {
    LOCK();
    lVar1 = *param_1;
    bVar4 = CONCAT44(uVar3,uVar2) == lVar1;
    if (bVar4) {
      *param_1 = param_2;
    }
    else {
      uVar3 = (undefined4)((ulong)lVar1 >> 0x20);
      uVar2 = (undefined4)lVar1;
    }
    UNLOCK();
  } while (!bVar4);
  return;
}



/* Function: thunk_FUN_00402700 */

void thunk_FUN_00402700(undefined4 *param_1,undefined4 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: FUN_00402730 */

void FUN_00402730(long *param_1,long param_2)

{
  long lVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  bool bVar4;
  
  if (((uint)param_1 & 7) != 0) {
    FUN_004024d0();
  }
  uVar2 = (undefined4)*param_1;
  uVar3 = *(undefined4 *)((int)param_1 + 4);
  do {
    LOCK();
    lVar1 = *param_1;
    bVar4 = CONCAT44(uVar3,uVar2) == lVar1;
    if (bVar4) {
      *param_1 = param_2;
    }
    else {
      uVar3 = (undefined4)((ulong)lVar1 >> 0x20);
      uVar2 = (undefined4)lVar1;
    }
    UNLOCK();
  } while (!bVar4);
  return;
}



/* Function: FUN_00402760 */

void FUN_00402760(undefined4 *param_1,undefined4 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: FUN_00402770 */

void FUN_00402770(undefined4 *param_1,undefined4 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402770 */

void thunk_FUN_00402770(undefined4 *param_1,undefined4 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: thunk_FUN_00402770 */

void thunk_FUN_00402770(undefined4 *param_1,undefined4 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: FUN_004027a0 */

void FUN_004027a0(uint param_1)

{
  if ((param_1 & 7) != 0) {
    FUN_004024d0();
  }
  return;
}



/* Function: FUN_004027c0 */

void FUN_004027c0(undefined8 *param_1,undefined8 param_2)

{
  if (((uint)param_1 & 7) != 0) {
    FUN_004024d0();
  }
  *param_1 = param_2;
  LOCK();
  UNLOCK();
  return;
}



/* Function: FUN_004027f0 */

void FUN_004027f0(byte *param_1,byte param_2)

{
  LOCK();
  *param_1 = *param_1 | param_2;
  UNLOCK();
  return;
}



/* Function: FUN_00402800 */

void FUN_00402800(byte *param_1,byte param_2)

{
  LOCK();
  *param_1 = *param_1 & param_2;
  UNLOCK();
  return;
}



/* Function: FUN_00402810 */

void FUN_00402810(undefined1 *param_1,undefined1 param_2)

{
  LOCK();
  *param_1 = param_2;
  UNLOCK();
  return;
}



/* Function: FUN_00402820 */

void FUN_00402820(uint *param_1,uint param_2)

{
  LOCK();
  *param_1 = *param_1 | param_2;
  UNLOCK();
  return;
}



/* Function: FUN_00402830 */

void FUN_00402830(uint *param_1,uint param_2)

{
  LOCK();
  *param_1 = *param_1 & param_2;
  UNLOCK();
  return;
}



/* Function: FUN_004029b0 */

void FUN_004029b0(uint *param_1,uint param_2,uint *param_3,uint param_4)

{
  int iVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  undefined1 auVar5 [16];
  
  if ((int)param_2 < (int)param_4) {
    param_4 = param_2;
  }
  if (param_1 != param_3) {
    if (param_4 < 4) {
      if (param_4 * -8 != 0) {
        bVar2 = (byte)(param_4 * -8);
        if ((byte)param_1 < 0xfd) {
          uVar3 = *param_1;
        }
        else {
          uVar3 = *(uint *)((int)param_1 + (param_4 - 4)) >> (bVar2 & 0x1f);
        }
        uVar3 = uVar3 << (bVar2 & 0x1f);
        if ((byte)param_3 < 0xfd) {
          uVar4 = *param_3;
        }
        else {
          uVar4 = *(uint *)((int)param_3 + (param_4 - 4)) >> (bVar2 & 0x1f);
        }
        uVar4 = uVar4 << (bVar2 & 0x1f);
        uVar3 = (uVar4 >> 0x18 | (uVar4 & 0xff0000) >> 8 | (uVar4 & 0xff00) << 8 | uVar4 << 0x18) ^
                (uVar3 >> 0x18 | (uVar3 & 0xff0000) >> 8 | (uVar3 & 0xff00) << 8 | uVar3 << 0x18);
        if (uVar3 != 0) {
          iVar1 = 0x1f;
          if (uVar3 != 0) {
            for (; uVar3 >> iVar1 == 0; iVar1 = iVar1 + -1) {
            }
          }
          return;
        }
      }
    }
    else {
      for (; 0xf < param_4; param_4 = param_4 - 0x10) {
        auVar5[0] = -((char)*param_3 == (char)*param_1);
        auVar5[1] = -(*(char *)((int)param_3 + 1) == *(char *)((int)param_1 + 1));
        auVar5[2] = -(*(char *)((int)param_3 + 2) == *(char *)((int)param_1 + 2));
        auVar5[3] = -(*(char *)((int)param_3 + 3) == *(char *)((int)param_1 + 3));
        auVar5[4] = -((char)param_3[1] == (char)param_1[1]);
        auVar5[5] = -(*(char *)((int)param_3 + 5) == *(char *)((int)param_1 + 5));
        auVar5[6] = -(*(char *)((int)param_3 + 6) == *(char *)((int)param_1 + 6));
        auVar5[7] = -(*(char *)((int)param_3 + 7) == *(char *)((int)param_1 + 7));
        auVar5[8] = -((char)param_3[2] == (char)param_1[2]);
        auVar5[9] = -(*(char *)((int)param_3 + 9) == *(char *)((int)param_1 + 9));
        auVar5[10] = -(*(char *)((int)param_3 + 10) == *(char *)((int)param_1 + 10));
        auVar5[0xb] = -(*(char *)((int)param_3 + 0xb) == *(char *)((int)param_1 + 0xb));
        auVar5[0xc] = -((char)param_3[3] == (char)param_1[3]);
        auVar5[0xd] = -(*(char *)((int)param_3 + 0xd) == *(char *)((int)param_1 + 0xd));
        auVar5[0xe] = -(*(char *)((int)param_3 + 0xe) == *(char *)((int)param_1 + 0xe));
        auVar5[0xf] = -(*(char *)((int)param_3 + 0xf) == *(char *)((int)param_1 + 0xf));
        uVar3 = (ushort)((ushort)(SUB161(auVar5 >> 7,0) & 1) |
                         (ushort)(SUB161(auVar5 >> 0xf,0) & 1) << 1 |
                         (ushort)(SUB161(auVar5 >> 0x17,0) & 1) << 2 |
                         (ushort)(SUB161(auVar5 >> 0x1f,0) & 1) << 3 |
                         (ushort)(SUB161(auVar5 >> 0x27,0) & 1) << 4 |
                         (ushort)(SUB161(auVar5 >> 0x2f,0) & 1) << 5 |
                         (ushort)(SUB161(auVar5 >> 0x37,0) & 1) << 6 |
                         (ushort)(SUB161(auVar5 >> 0x3f,0) & 1) << 7 |
                         (ushort)(SUB161(auVar5 >> 0x47,0) & 1) << 8 |
                         (ushort)(SUB161(auVar5 >> 0x4f,0) & 1) << 9 |
                         (ushort)(SUB161(auVar5 >> 0x57,0) & 1) << 10 |
                         (ushort)(SUB161(auVar5 >> 0x5f,0) & 1) << 0xb |
                         (ushort)(SUB161(auVar5 >> 0x67,0) & 1) << 0xc |
                         (ushort)(SUB161(auVar5 >> 0x6f,0) & 1) << 0xd |
                         (ushort)(SUB161(auVar5 >> 0x77,0) & 1) << 0xe |
                        (ushort)(auVar5[0xf] >> 7) << 0xf) ^ 0xffff;
        if (uVar3 != 0) {
          iVar1 = 0;
          if (uVar3 != 0) {
            for (; (uVar3 >> iVar1 & 1) == 0; iVar1 = iVar1 + 1) {
            }
          }
          return;
        }
        param_1 = param_1 + 4;
        param_3 = param_3 + 4;
      }
      for (; 4 < param_4; param_4 = param_4 - 4) {
        uVar3 = *param_1;
        uVar4 = *param_3;
        if (uVar3 != uVar4) goto LAB_00402939;
        param_1 = param_1 + 1;
        param_3 = param_3 + 1;
      }
      uVar3 = *(uint *)((int)param_1 + (param_4 - 4));
      uVar4 = *(uint *)((int)param_3 + (param_4 - 4));
      if (uVar3 != uVar4) {
LAB_00402939:
        uVar3 = (uVar4 >> 0x18 | (uVar4 & 0xff0000) >> 8 | (uVar4 & 0xff00) << 8 | uVar4 << 0x18) ^
                (uVar3 >> 0x18 | (uVar3 & 0xff0000) >> 8 | (uVar3 & 0xff00) << 8 | uVar3 << 0x18);
        iVar1 = 0x1f;
        if (uVar3 != 0) {
          for (; uVar3 >> iVar1 == 0; iVar1 = iVar1 + -1) {
          }
        }
        return;
      }
    }
  }
  return;
}



/* Function: FUN_00402aa0 */

void FUN_00402aa0(int *param_1,int *param_2,uint param_3)

{
  int iVar1;
  int iVar2;
  undefined1 auVar3 [16];
  undefined1 auVar4 [16];
  undefined1 auVar5 [16];
  undefined1 auVar6 [16];
  
  if (param_1 == param_2) {
    return;
  }
  if (3 < param_3) {
    do {
      if (param_3 < 0x40) {
        do {
          if (param_3 < 5) {
            return;
          }
          iVar1 = *param_1;
          iVar2 = *param_2;
          param_1 = param_1 + 1;
          param_2 = param_2 + 1;
          param_3 = param_3 - 4;
        } while (iVar1 == iVar2);
        return;
      }
      auVar3[0] = -((char)*param_1 == (char)*param_2);
      auVar3[1] = -(*(char *)((int)param_1 + 1) == *(char *)((int)param_2 + 1));
      auVar3[2] = -(*(char *)((int)param_1 + 2) == *(char *)((int)param_2 + 2));
      auVar3[3] = -(*(char *)((int)param_1 + 3) == *(char *)((int)param_2 + 3));
      auVar3[4] = -((char)param_1[1] == (char)param_2[1]);
      auVar3[5] = -(*(char *)((int)param_1 + 5) == *(char *)((int)param_2 + 5));
      auVar3[6] = -(*(char *)((int)param_1 + 6) == *(char *)((int)param_2 + 6));
      auVar3[7] = -(*(char *)((int)param_1 + 7) == *(char *)((int)param_2 + 7));
      auVar3[8] = -((char)param_1[2] == (char)param_2[2]);
      auVar3[9] = -(*(char *)((int)param_1 + 9) == *(char *)((int)param_2 + 9));
      auVar3[10] = -(*(char *)((int)param_1 + 10) == *(char *)((int)param_2 + 10));
      auVar3[0xb] = -(*(char *)((int)param_1 + 0xb) == *(char *)((int)param_2 + 0xb));
      auVar3[0xc] = -((char)param_1[3] == (char)param_2[3]);
      auVar3[0xd] = -(*(char *)((int)param_1 + 0xd) == *(char *)((int)param_2 + 0xd));
      auVar3[0xe] = -(*(char *)((int)param_1 + 0xe) == *(char *)((int)param_2 + 0xe));
      auVar3[0xf] = -(*(char *)((int)param_1 + 0xf) == *(char *)((int)param_2 + 0xf));
      auVar4[0] = -((char)param_1[4] == (char)param_2[4]);
      auVar4[1] = -(*(char *)((int)param_1 + 0x11) == *(char *)((int)param_2 + 0x11));
      auVar4[2] = -(*(char *)((int)param_1 + 0x12) == *(char *)((int)param_2 + 0x12));
      auVar4[3] = -(*(char *)((int)param_1 + 0x13) == *(char *)((int)param_2 + 0x13));
      auVar4[4] = -((char)param_1[5] == (char)param_2[5]);
      auVar4[5] = -(*(char *)((int)param_1 + 0x15) == *(char *)((int)param_2 + 0x15));
      auVar4[6] = -(*(char *)((int)param_1 + 0x16) == *(char *)((int)param_2 + 0x16));
      auVar4[7] = -(*(char *)((int)param_1 + 0x17) == *(char *)((int)param_2 + 0x17));
      auVar4[8] = -((char)param_1[6] == (char)param_2[6]);
      auVar4[9] = -(*(char *)((int)param_1 + 0x19) == *(char *)((int)param_2 + 0x19));
      auVar4[10] = -(*(char *)((int)param_1 + 0x1a) == *(char *)((int)param_2 + 0x1a));
      auVar4[0xb] = -(*(char *)((int)param_1 + 0x1b) == *(char *)((int)param_2 + 0x1b));
      auVar4[0xc] = -((char)param_1[7] == (char)param_2[7]);
      auVar4[0xd] = -(*(char *)((int)param_1 + 0x1d) == *(char *)((int)param_2 + 0x1d));
      auVar4[0xe] = -(*(char *)((int)param_1 + 0x1e) == *(char *)((int)param_2 + 0x1e));
      auVar4[0xf] = -(*(char *)((int)param_1 + 0x1f) == *(char *)((int)param_2 + 0x1f));
      auVar5[0] = -((char)param_1[8] == (char)param_2[8]);
      auVar5[1] = -(*(char *)((int)param_1 + 0x21) == *(char *)((int)param_2 + 0x21));
      auVar5[2] = -(*(char *)((int)param_1 + 0x22) == *(char *)((int)param_2 + 0x22));
      auVar5[3] = -(*(char *)((int)param_1 + 0x23) == *(char *)((int)param_2 + 0x23));
      auVar5[4] = -((char)param_1[9] == (char)param_2[9]);
      auVar5[5] = -(*(char *)((int)param_1 + 0x25) == *(char *)((int)param_2 + 0x25));
      auVar5[6] = -(*(char *)((int)param_1 + 0x26) == *(char *)((int)param_2 + 0x26));
      auVar5[7] = -(*(char *)((int)param_1 + 0x27) == *(char *)((int)param_2 + 0x27));
      auVar5[8] = -((char)param_1[10] == (char)param_2[10]);
      auVar5[9] = -(*(char *)((int)param_1 + 0x29) == *(char *)((int)param_2 + 0x29));
      auVar5[10] = -(*(char *)((int)param_1 + 0x2a) == *(char *)((int)param_2 + 0x2a));
      auVar5[0xb] = -(*(char *)((int)param_1 + 0x2b) == *(char *)((int)param_2 + 0x2b));
      auVar5[0xc] = -((char)param_1[0xb] == (char)param_2[0xb]);
      auVar5[0xd] = -(*(char *)((int)param_1 + 0x2d) == *(char *)((int)param_2 + 0x2d));
      auVar5[0xe] = -(*(char *)((int)param_1 + 0x2e) == *(char *)((int)param_2 + 0x2e));
      auVar5[0xf] = -(*(char *)((int)param_1 + 0x2f) == *(char *)((int)param_2 + 0x2f));
      auVar6[0] = -((char)param_1[0xc] == (char)param_2[0xc]);
      auVar6[1] = -(*(char *)((int)param_1 + 0x31) == *(char *)((int)param_2 + 0x31));
      auVar6[2] = -(*(char *)((int)param_1 + 0x32) == *(char *)((int)param_2 + 0x32));
      auVar6[3] = -(*(char *)((int)param_1 + 0x33) == *(char *)((int)param_2 + 0x33));
      auVar6[4] = -((char)param_1[0xd] == (char)param_2[0xd]);
      auVar6[5] = -(*(char *)((int)param_1 + 0x35) == *(char *)((int)param_2 + 0x35));
      auVar6[6] = -(*(char *)((int)param_1 + 0x36) == *(char *)((int)param_2 + 0x36));
      auVar6[7] = -(*(char *)((int)param_1 + 0x37) == *(char *)((int)param_2 + 0x37));
      auVar6[8] = -((char)param_1[0xe] == (char)param_2[0xe]);
      auVar6[9] = -(*(char *)((int)param_1 + 0x39) == *(char *)((int)param_2 + 0x39));
      auVar6[10] = -(*(char *)((int)param_1 + 0x3a) == *(char *)((int)param_2 + 0x3a));
      auVar6[0xb] = -(*(char *)((int)param_1 + 0x3b) == *(char *)((int)param_2 + 0x3b));
      auVar6[0xc] = -((char)param_1[0xf] == (char)param_2[0xf]);
      auVar6[0xd] = -(*(char *)((int)param_1 + 0x3d) == *(char *)((int)param_2 + 0x3d));
      auVar6[0xe] = -(*(char *)((int)param_1 + 0x3e) == *(char *)((int)param_2 + 0x3e));
      auVar6[0xf] = -(*(char *)((int)param_1 + 0x3f) == *(char *)((int)param_2 + 0x3f));
      auVar3 = auVar3 & auVar4 & auVar5 & auVar6;
      param_1 = param_1 + 0x10;
      param_2 = param_2 + 0x10;
      param_3 = param_3 - 0x40;
    } while ((ushort)((ushort)(SUB161(auVar3 >> 7,0) & 1) |
                      (ushort)(SUB161(auVar3 >> 0xf,0) & 1) << 1 |
                      (ushort)(SUB161(auVar3 >> 0x17,0) & 1) << 2 |
                      (ushort)(SUB161(auVar3 >> 0x1f,0) & 1) << 3 |
                      (ushort)(SUB161(auVar3 >> 0x27,0) & 1) << 4 |
                      (ushort)(SUB161(auVar3 >> 0x2f,0) & 1) << 5 |
                      (ushort)(SUB161(auVar3 >> 0x37,0) & 1) << 6 |
                      (ushort)(SUB161(auVar3 >> 0x3f,0) & 1) << 7 |
                      (ushort)(SUB161(auVar3 >> 0x47,0) & 1) << 8 |
                      (ushort)(SUB161(auVar3 >> 0x4f,0) & 1) << 9 |
                      (ushort)(SUB161(auVar3 >> 0x57,0) & 1) << 10 |
                      (ushort)(SUB161(auVar3 >> 0x5f,0) & 1) << 0xb |
                      (ushort)(SUB161(auVar3 >> 0x67,0) & 1) << 0xc |
                      (ushort)(SUB161(auVar3 >> 0x6f,0) & 1) << 0xd |
                      (ushort)(SUB161(auVar3 >> 0x77,0) & 1) << 0xe |
                     (ushort)(byte)(auVar3[0xf] >> 7) << 0xf) == 0xffff);
    return;
  }
  return;
}



/* Function: FUN_00402ae0 */

void FUN_00402ae0(char *param_1,int param_2,char param_3)

{
  undefined1 in_ZF;
  
  do {
    if (param_2 == 0) break;
    param_2 = param_2 + -1;
    in_ZF = param_3 == *param_1;
    param_1 = param_1 + 1;
  } while (!(bool)in_ZF);
  if (!(bool)in_ZF) {
    return;
  }
  return;
}



/* Function: FUN_00402b10 */

/* WARNING: Removing unreachable block (ram,0x00402d1e) */

void FUN_00402b10(void)

{
  undefined1 uVar1;
  ulong uVar2;
  long lVar3;
  bool bVar4;
  char cVar5;
  uint uVar6;
  int *piVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  undefined1 *puVar11;
  uint uVar12;
  int in_FS_OFFSET;
  
  do {
    puVar11 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar11 = (undefined1 *)((int)register0x00000010 + -0x34);
      iVar8 = *(int *)((int)register0x00000010 + 0xc);
      if (iVar8 == 0) {
        *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004bc7e0;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402b3d;
        FUN_00411710();
        iVar8 = *(int *)((int)register0x00000010 + -0x30);
      }
      *(int *)((int)register0x00000010 + -4) = iVar8;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402b4a;
      FUN_0046a210();
      iVar8 = *(int *)((int)register0x00000010 + -4);
      *(undefined4 *)(iVar8 + 8) = *(undefined4 *)((int)register0x00000010 + -0x34);
      uVar12 = *(uint *)((int)register0x00000010 + 8);
      if (uVar12 < 9) {
        *(int *)((int)register0x00000010 + 0x14) = iVar8;
        return;
      }
      uVar6 = uVar12 * 8;
      uVar6 = ((uint)((ulong)uVar6 * 0x124924925 >> 0x21) |
              (uint)CARRY4(uVar6,(uint)((ulong)uVar6 * 0x24924925 >> 0x20)) << 0x1f) >> 2;
      if (uVar6 < uVar12) {
        *(int *)((int)register0x00000010 + 0x14) = iVar8;
        return;
      }
      *(uint *)((int)register0x00000010 + -0xc) = uVar6;
      uVar12 = (uint)(0xfffffc00 < uVar6) << 0x16 | uVar6 + 0x3ff >> 10;
      if (uVar12 == 0) {
        bVar4 = false;
        uVar12 = 0;
        uVar6 = 0;
LAB_00402ce5:
        if ((bVar4) || (uVar6 != 0)) {
          *(int *)((int)register0x00000010 + 0x14) = iVar8;
          return;
        }
        uVar2 = (ulong)uVar12 * 0x400;
        piVar7 = (int *)uVar2;
        if ((int)(uVar2 >> 0x20) != 0) {
          *(int *)((int)register0x00000010 + 0x14) = iVar8;
          return;
        }
        lVar3 = (ulong)*(uint *)(*(int *)((int)register0x00000010 + 4) + 0x30) *
                (uVar2 & 0xffffffff);
        if (((int)((ulong)lVar3 >> 0x20) != 0) ||
           (*(uint *)((int)register0x00000010 + 0x10) < (uint)lVar3)) {
          *(int *)((int)register0x00000010 + 0x14) = iVar8;
          return;
        }
        *(uint *)((int)register0x00000010 + -0x18) = uVar12;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
        iVar10 = 0;
        if (uVar12 != 0) {
          for (; (uVar12 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
          }
        }
        cVar5 = (char)iVar10;
        if (uVar12 == 0) {
          cVar5 = '@';
        }
        *(char *)(iVar8 + 0x14) = cVar5;
        *(char *)(iVar8 + 0x15) = -(cVar5 + -0x20);
        *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004bf100;
        *(uint *)((int)register0x00000010 + -0x30) = uVar12;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0;
        *(uint *)((int)register0x00000010 + -0x28) = uVar12;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402d54;
        FUN_0044e8b0();
        iVar10 = *(int *)((int)register0x00000010 + -0x20);
        *(int *)((int)register0x00000010 + -8) = iVar10;
        for (iVar8 = 0; iVar9 = *(int *)((int)register0x00000010 + -0x18), iVar8 < iVar9;
            iVar8 = iVar8 + 1) {
          *(int *)((int)register0x00000010 + -0x1c) = iVar8;
          *(undefined4 *)((int)register0x00000010 + -0x34) =
               *(undefined4 *)((int)register0x00000010 + -0xc);
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
          *(int *)((int)register0x00000010 + -0x2c) = iVar9;
          *(undefined4 *)((int)register0x00000010 + -0x28) =
               *(undefined4 *)((int)register0x00000010 + -0x14);
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402dc0;
          FUN_00464c70();
          uVar1 = *(undefined1 *)(*(int *)((int)register0x00000010 + -4) + 0x14);
          *(undefined4 *)((int)register0x00000010 + -0x34) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x30) =
               *(undefined4 *)((int)register0x00000010 + -0x24);
          *(undefined4 *)((int)register0x00000010 + -0x2c) =
               *(undefined4 *)((int)register0x00000010 + -0x20);
          *(undefined4 *)((int)register0x00000010 + -0x28) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined1 *)((int)register0x00000010 + -0x24) = uVar1;
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402df0;
          FUN_00403ee0();
          iVar9 = *(int *)((int)register0x00000010 + -0x20);
          if (DAT_005f5fd0 == 0) {
            iVar8 = *(int *)((int)register0x00000010 + -0x1c);
            iVar10 = *(int *)((int)register0x00000010 + -8);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402e0d;
            FUN_0046ed80();
            *piVar7 = iVar9;
            iVar8 = *(int *)((int)register0x00000010 + -0x1c);
            iVar10 = *(int *)((int)register0x00000010 + -8);
            piVar7[1] = *(int *)(iVar10 + iVar8 * 4);
          }
          *(int *)(iVar10 + iVar8 * 4) = iVar9;
        }
        if (iVar9 != 0) {
          if (DAT_005f5fd0 == 0) {
            iVar8 = *(int *)((int)register0x00000010 + -4);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402e3b;
            FUN_0046ed80();
            *piVar7 = iVar10;
            iVar8 = *(int *)((int)register0x00000010 + -4);
            piVar7[1] = *(int *)(iVar8 + 0xc);
          }
          *(int *)(iVar8 + 0xc) = iVar10;
          *(int *)(iVar8 + 0x10) = iVar9;
          *(int *)((int)register0x00000010 + 0x14) = iVar8;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402e5e;
        FUN_0046edf0();
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402e63;
        FUN_00438020();
      }
      else {
        uVar6 = uVar12 - 1;
        uVar12 = (uVar12 != 0) - 1;
        if (uVar12 == 0) {
          iVar10 = 0;
        }
        else {
          iVar10 = 0x20;
          uVar6 = uVar12;
        }
        if (0xffff < uVar6) {
          uVar6 = uVar6 >> 0x10;
          iVar10 = iVar10 + 0x10;
        }
        if (0xff < uVar6) {
          uVar6 = uVar6 >> 8;
          iVar10 = iVar10 + 8;
        }
        if (uVar6 < 0x100) {
          uVar12 = (uint)(byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                               [uVar6 + 0x1510] + iVar10;
          uVar6 = ((byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                         [uVar6 + 0x1510] - 0x20) + iVar10;
          *(int *)((int)register0x00000010 + -0x10) = 1 << ((byte)uVar12 & 0x1f);
          uVar6 = 1U >> ((byte)-uVar6 & 0x1f) & -(uint)(-uVar6 < 0x20) |
                  -(uint)(uVar6 < 0x20) & 1 << ((byte)uVar6 & 0x1f);
          uVar12 = -(uint)(uVar12 < 0x20) & *(uint *)((int)register0x00000010 + -0x10);
          if (uVar12 == 0 && uVar6 == 0) {
            bVar4 = true;
            uVar12 = 0;
            uVar6 = 0;
          }
          else {
            bVar4 = false;
          }
          goto LAB_00402ce5;
        }
      }
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402e6f;
      FUN_0046ee00();
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x402e7d;
      FUN_0046ee90();
    }
    *(undefined4 *)(puVar11 + -4) = 0x402e83;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar11;
  } while( true );
}



/* Function: FUN_00402e90 */

void FUN_00402e90(void)

{
  int iVar1;
  byte bVar2;
  int *piVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  undefined1 *puVar8;
  uint uVar9;
  int iVar10;
  int *in_EDI;
  int *piVar11;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x1c);
      iVar1 = *(int *)((int)register0x00000010 + 8);
      iVar4 = *(int *)((int)register0x00000010 + 4);
      if (*(char *)(iVar4 + 0x14) != *(char *)(iVar1 + 6)) goto LAB_00402faf;
      iVar1 = *(int *)(iVar4 + 0x10);
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004bf100;
      iVar1 = iVar1 << 1;
      *(int *)((int)register0x00000010 + -0xc) = iVar1;
      *(int *)((int)register0x00000010 + -0x18) = iVar1;
      *(int *)((int)register0x00000010 + -0x14) = iVar1;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x402edb;
      FUN_0046a780();
      iVar5 = *(int *)((int)register0x00000010 + -0x10);
      *(int *)((int)register0x00000010 + -4) = iVar5;
      iVar4 = *(int *)((int)register0x00000010 + 4);
      iVar6 = *(int *)(iVar4 + 0x10);
      *(int *)((int)register0x00000010 + -8) = iVar6;
      uVar7 = *(uint *)((int)register0x00000010 + -0xc);
      for (iVar1 = 0; iVar1 < iVar6; iVar1 = iVar1 + 1) {
        uVar9 = iVar1 * 2;
        in_EDI = *(int **)(*(int *)(iVar4 + 0xc) + iVar1 * 4);
        if (uVar7 <= uVar9) goto LAB_00403089;
        piVar3 = (int *)(iVar5 + iVar1 * 8);
        if (DAT_005f5fd0 != (int *)0x0) {
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x402f2c;
          piVar11 = in_EDI;
          FUN_0046ed80();
          *piVar11 = (int)in_EDI;
          piVar11[1] = *piVar3;
          iVar5 = *(int *)((int)register0x00000010 + -4);
        }
        *piVar3 = (int)in_EDI;
        if (uVar7 <= uVar9 + 1) goto LAB_00403080;
        piVar3 = (int *)(iVar5 + 4 + iVar1 * 8);
        if (DAT_005f5fd0 != (int *)0x0) {
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x402f5b;
          piVar11 = in_EDI;
          FUN_0046ed80();
          *piVar11 = (int)in_EDI;
          piVar11[1] = *piVar3;
          iVar5 = *(int *)((int)register0x00000010 + -4);
        }
        *piVar3 = (int)in_EDI;
        if (in_EDI[2] == iVar1) {
          in_EDI[2] = uVar9;
        }
        iVar6 = *(int *)((int)register0x00000010 + -8);
        iVar4 = *(int *)((int)register0x00000010 + 4);
      }
      *(char *)(iVar4 + 0x14) = *(char *)(iVar4 + 0x14) + '\x01';
      *(char *)(iVar4 + 0x15) = *(char *)(iVar4 + 0x15) + -1;
      if (uVar7 != 0) {
        if (DAT_005f5fd0 != (int *)0x0) {
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x402f9b;
          FUN_0046ed80();
          *in_EDI = iVar5;
          in_EDI[1] = *(int *)(iVar4 + 0xc);
        }
        *(int *)(iVar4 + 0xc) = iVar5;
        *(uint *)(iVar4 + 0x10) = uVar7;
        iVar1 = *(int *)((int)register0x00000010 + 8);
LAB_00402faf:
        iVar5 = *(int *)((int)register0x00000010 + 0xc);
        *(undefined4 *)(iVar5 + 8) = *(undefined4 *)(iVar1 + 8);
        bVar2 = *(char *)(iVar4 + 0x14) - *(char *)(iVar5 + 6);
        for (iVar1 = 0; iVar1 < (int)(-(uint)(bVar2 < 0x20) & 1 << (bVar2 & 0x1f));
            iVar1 = iVar1 + 1) {
          iVar10 = *(int *)(iVar5 + 8) + iVar1;
          iVar6 = *(int *)(iVar4 + 0xc);
          if (DAT_005f5fd0 != (int *)0x0) {
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x402ff5;
            piVar3 = DAT_005f5fd0;
            FUN_0046ed80();
            *piVar3 = iVar5;
            piVar3[1] = *(int *)(iVar6 + iVar10 * 4);
            iVar4 = *(int *)((int)register0x00000010 + 4);
          }
          *(int *)(iVar6 + iVar10 * 4) = iVar5;
        }
        bVar2 = *(char *)(iVar4 + 0x14) - *(char *)(iVar5 + 6);
        iVar1 = *(int *)((int)register0x00000010 + 0x10);
        *(uint *)(iVar1 + 8) = (-(uint)(bVar2 < 0x20) & 1 << (bVar2 & 0x1f)) + *(int *)(iVar5 + 8);
        bVar2 = *(char *)(iVar4 + 0x14) - *(char *)(iVar1 + 6);
        for (iVar5 = 0; iVar5 < (int)(-(uint)(bVar2 < 0x20) & 1 << (bVar2 & 0x1f));
            iVar5 = iVar5 + 1) {
          iVar6 = *(int *)(iVar1 + 8) + iVar5;
          piVar3 = *(int **)(iVar4 + 0xc);
          if (DAT_005f5fd0 != (int *)0x0) {
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x403063;
            piVar11 = piVar3;
            FUN_0046ed80();
            *piVar11 = iVar1;
            piVar11[1] = piVar3[iVar6];
            iVar4 = *(int *)((int)register0x00000010 + 4);
          }
          piVar3[iVar6] = iVar1;
        }
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x403080;
      FUN_0046edf0();
LAB_00403080:
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x403089;
      FUN_0046edf0();
LAB_00403089:
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x403092;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar8 + -4) = 0x403098;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_004030a0 */

void FUN_004030a0(int param_1,int param_2,byte param_3,undefined4 param_4)

{
  uint *puVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 *puVar5;
  uint uVar6;
  int in_FS_OFFSET;
  char local_1c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar1 = *(uint **)(param_1 + 0xc);
  uVar6 = puVar1[1];
  uVar4 = 0;
  uVar2 = *puVar1;
  do {
    if (7 < uVar4) {
      return;
    }
    uVar3 = uVar6 << 0x18;
    if ((byte)uVar2 == (param_3 & 0x7f)) {
      puVar5 = (undefined4 *)(*(int *)(param_2 + 0x34) * uVar4 + 8 + (int)puVar1);
      if ((*(uint *)(param_2 + 0x3c) & 4) != 0) {
        puVar5 = (undefined4 *)*puVar5;
      }
      (*(code *)**(undefined4 **)(*(int *)(param_2 + 0x20) + 0x10))(param_4,puVar5);
      if (local_1c != '\0') {
        return;
      }
    }
    uVar4 = uVar4 + 1;
    uVar6 = uVar6 >> 8;
    uVar2 = uVar2 >> 8 | uVar3;
  } while( true );
}



/* Function: FUN_004031c0 */

void FUN_004031c0(uint *param_1,int param_2,uint param_3,undefined4 param_4)

{
  uint *puVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int *piVar6;
  int *piVar7;
  int *piVar8;
  int in_FS_OFFSET;
  bool bVar9;
  int *in_stack_ffffffd0;
  undefined4 in_stack_ffffffd4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar1 = (uint *)param_1[3];
  param_3 = param_3 & 0x7f;
  uVar2 = param_3 * 0x1010101 ^ *puVar1;
  uVar5 = param_3 * 0x1010101 ^ puVar1[1];
  uVar3 = ~uVar2 & uVar2 + 0xfefefeff & 0x80808080;
  uVar2 = uVar5 + 0xfefefefe + (uint)(0x1010100 < uVar2) & ~uVar5 & 0x80808080;
  while( true ) {
    if (uVar2 == 0 && uVar3 == 0) {
      uVar2 = *puVar1 & 0x80808080;
      uVar3 = puVar1[1] & 0x80808080;
      if (uVar3 != 0 || uVar2 != 0) {
        uVar5 = 0;
        if (uVar2 != 0) {
          for (; (uVar2 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
          }
        }
        if (uVar2 == 0) {
          iVar4 = 0;
          if (uVar3 != 0) {
            for (; (uVar3 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
            }
          }
          if (uVar3 == 0) {
            iVar4 = 0x20;
          }
          uVar5 = iVar4 + 0x20;
        }
        uVar5 = uVar5 >> 3;
        piVar7 = (int *)(*(int *)(param_2 + 0x34) * uVar5);
        piVar6 = (int *)((int)(piVar7 + 2) + (int)puVar1);
        piVar8 = piVar7;
        if ((*(uint *)(param_2 + 0x3c) & 4) != 0) {
          piVar6 = in_stack_ffffffd0;
          FUN_00468540(*(undefined4 *)(param_2 + 0x20));
          if (DAT_005f5fd0 != 0) {
            FUN_0046ed80();
            *piVar8 = (int)piVar6;
            piVar8[1] = *(int *)((int)(piVar7 + 2) + (int)puVar1);
          }
          *(int **)((int)(piVar7 + 2) + (int)puVar1) = piVar6;
        }
        FUN_004687c0(*(undefined4 *)(param_2 + 0x20),piVar6,param_4);
        piVar7 = (int *)(*(int *)(param_2 + 0x34) * uVar5 + *(int *)(param_2 + 0x38) + 8 +
                        (int)puVar1);
        if ((*(uint *)(param_2 + 0x3c) & 8) != 0) {
          FUN_00468540(*(undefined4 *)(param_2 + 0x24));
          if (DAT_005f5fd0 != 0) {
            FUN_0046ed80();
            *piVar8 = (int)piVar6;
            piVar8[1] = *piVar7;
          }
          *piVar7 = (int)piVar6;
        }
        *(char *)((int)puVar1 + uVar5) = (char)param_3;
        uVar2 = *param_1;
        *param_1 = uVar2 + 1;
        param_1[1] = param_1[1] + (uint)(0xfffffffe < uVar2);
        return;
      }
      FUN_00469970("small map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: functi..." /* TRUNCATED STRING LITERAL */
                   ,0x35);
      return;
    }
    uVar5 = 0;
    if (uVar3 != 0) {
      for (; (uVar3 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
      }
    }
    if (uVar3 == 0) {
      iVar4 = 0;
      if (uVar2 != 0) {
        for (; (uVar2 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
        }
      }
      if (uVar2 == 0) {
        iVar4 = 0x20;
      }
      uVar5 = iVar4 + 0x20;
    }
    piVar6 = (int *)(*(int *)(param_2 + 0x34) * (uVar5 >> 3) + 8 + (int)puVar1);
    if ((*(uint *)(param_2 + 0x3c) & 4) != 0) {
      piVar6 = (int *)*piVar6;
    }
    in_stack_ffffffd0 = piVar6;
    (*(code *)**(undefined4 **)(*(int *)(param_2 + 0x20) + 0x10))(param_4);
    if ((char)in_stack_ffffffd4 != '\0') break;
    bVar9 = uVar3 != 0;
    uVar3 = uVar3 - 1 & uVar3;
    uVar2 = uVar2 & (uVar2 - 1) + (uint)bVar9;
  }
  if ((*(uint *)(param_2 + 0x3c) & 1) != 0) {
    FUN_004687c0(*(undefined4 *)(param_2 + 0x20),piVar6,param_4);
  }
  return;
}



/* Function: FUN_004034a0 */

void FUN_004034a0(int param_1,int param_2)

{
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined4 *local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (undefined4 *)0x403506;
    FUN_0046d980();
  }
  FUN_00468610(*(undefined4 *)(param_2 + 0x28),1);
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = local_4;
    in_EDI[1] = *(undefined4 *)(param_1 + 0xc);
  }
  *(undefined4 **)(param_1 + 0xc) = local_4;
  *local_4 = 0x80808080;
  local_4[1] = 0x80808080;
  return;
}



/* Function: FUN_00403510 */

void FUN_00403510(int param_1,int param_2)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined4 uVar5;
  undefined4 *puVar6;
  uint in_stack_ffffffe4;
  undefined4 local_18;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar5 = 0;
  puVar6 = (undefined4 *)0x0;
  FUN_00403ee0(param_2,0x10,0,0,in_stack_ffffffe4 & 0xffffff00);
  iVar1 = *(int *)(param_1 + 0xc);
  for (uVar2 = 0; uVar2 < 8; uVar2 = uVar2 + 1) {
    if ((*(byte *)(iVar1 + uVar2) & 0x80) == 0) {
      iVar4 = *(int *)(param_2 + 0x34) * uVar2;
      in_EDI = *(undefined4 **)(param_2 + 0x3c);
      puVar6 = (undefined4 *)(iVar4 + 8 + iVar1);
      if (((uint)in_EDI & 4) != 0) {
        puVar6 = *(undefined4 **)(iVar4 + 8 + iVar1);
      }
      iVar4 = iVar4 + *(int *)(param_2 + 0x38);
      iVar3 = iVar4 + 8 + iVar1;
      if (((uint)in_EDI & 8) != 0) {
        iVar3 = *(int *)(iVar4 + 8 + iVar1);
      }
      (*(code *)**(undefined4 **)(param_2 + 0x2c))(puVar6,*(undefined4 *)(param_1 + 8));
      FUN_00404210(local_18,param_2,uVar5,puVar6,iVar3);
    }
  }
  FUN_0046a780(&DAT_004bf100,1,1);
  if (DAT_005f5fd0 != 0) {
    FUN_0046eda0();
    *in_EDI = local_18;
    in_EDI[1] = *puVar6;
    in_EDI[2] = puVar6;
    in_EDI[3] = *(undefined4 *)(param_1 + 0xc);
  }
  *puVar6 = local_18;
  *(undefined4 **)(param_1 + 0xc) = puVar6;
  *(undefined4 *)(param_1 + 0x10) = 1;
  *(undefined1 *)(param_1 + 0x14) = 0;
  *(undefined1 *)(param_1 + 0x15) = 0x20;
  return;
}



/* Function: FUN_00403680 */

void FUN_00403680(uint *param_1,int param_2,uint param_3,int param_4)

{
  uint *puVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar1 = (uint *)param_1[3];
  param_3 = param_3 & 0x7f;
  uVar2 = param_3 * 0x1010101 ^ *puVar1;
  uVar4 = param_3 * 0x1010101 ^ puVar1[1];
  uVar3 = ~uVar2 & uVar2 + 0xfefefeff & 0x80808080;
  uVar2 = uVar4 + 0xfefefefe + (uint)(0x1010100 < uVar2) & ~uVar4 & 0x80808080;
  while( true ) {
    if (uVar2 == 0 && uVar3 == 0) {
      uVar2 = *puVar1 & 0x80808080;
      uVar3 = puVar1[1] & 0x80808080;
      if (uVar3 == 0 && uVar2 == 0) {
        FUN_00469970("small map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: functi..." /* TRUNCATED STRING LITERAL */
                     ,0x35);
      }
      uVar4 = 0;
      if (uVar2 != 0) {
        for (; (uVar2 >> uVar4 & 1) == 0; uVar4 = uVar4 + 1) {
        }
      }
      if (uVar2 == 0) {
        iVar5 = 0;
        if (uVar3 != 0) {
          for (; (uVar3 >> iVar5 & 1) == 0; iVar5 = iVar5 + 1) {
          }
        }
        if (uVar3 == 0) {
          iVar5 = 0x20;
        }
        uVar4 = iVar5 + 0x20;
      }
      *(int *)(*(int *)(param_2 + 0x34) * (uVar4 >> 3) + 8 + (int)puVar1) = param_4;
      *(char *)((int)puVar1 + (uVar4 >> 3)) = (char)param_3;
      uVar2 = *param_1;
      *param_1 = uVar2 + 1;
      param_1[1] = param_1[1] + (uint)(0xfffffffe < uVar2);
      return;
    }
    uVar4 = 0;
    if (uVar3 != 0) {
      for (; (uVar3 >> uVar4 & 1) == 0; uVar4 = uVar4 + 1) {
      }
    }
    if (uVar3 == 0) {
      iVar5 = 0;
      if (uVar2 != 0) {
        for (; (uVar2 >> iVar5 & 1) == 0; iVar5 = iVar5 + 1) {
        }
      }
      if (uVar2 == 0) {
        iVar5 = 0x20;
      }
      uVar4 = iVar5 + 0x20;
    }
    if (*(int *)((uVar4 >> 3) * *(int *)(param_2 + 0x34) + 8 + (int)puVar1) == param_4) break;
    uVar2 = uVar2 & (uVar2 - 1) + (uint)(uVar3 != 0);
    uVar3 = uVar3 - 1 & uVar3;
  }
  return;
}



/* Function: FUN_00403830 */

void FUN_00403830(uint *param_1,int param_2,uint param_3,int param_4,int param_5)

{
  uint *puVar1;
  uint uVar2;
  uint uVar3;
  int *piVar4;
  uint uVar5;
  int iVar6;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar1 = (uint *)param_1[3];
  param_3 = param_3 & 0x7f;
  uVar2 = param_3 * 0x1010101 ^ *puVar1;
  uVar5 = param_3 * 0x1010101 ^ puVar1[1];
  uVar3 = ~uVar2 & uVar2 + 0xfefefeff & 0x80808080;
  uVar2 = uVar5 + 0xfefefefe + (uint)(0x1010100 < uVar2) & ~uVar5 & 0x80808080;
  while( true ) {
    if (uVar2 == 0 && uVar3 == 0) {
      uVar2 = *puVar1 & 0x80808080;
      uVar3 = puVar1[1] & 0x80808080;
      if (uVar2 == 0 && uVar3 == 0) {
        FUN_00469970("small map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: functi..." /* TRUNCATED STRING LITERAL */
                     ,0x35);
      }
      uVar5 = 0;
      if (uVar2 != 0) {
        for (; (uVar2 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
        }
      }
      if (uVar2 == 0) {
        iVar6 = 0;
        if (uVar3 != 0) {
          for (; (uVar3 >> iVar6 & 1) == 0; iVar6 = iVar6 + 1) {
          }
        }
        if (uVar3 == 0) {
          iVar6 = 0x20;
        }
        uVar5 = iVar6 + 0x20;
      }
      piVar4 = (int *)(*(int *)(param_2 + 0x34) * (uVar5 >> 3) + 8 + (int)puVar1);
      *piVar4 = param_4;
      piVar4[1] = param_5;
      *(char *)((int)puVar1 + (uVar5 >> 3)) = (char)param_3;
      uVar2 = *param_1;
      *param_1 = uVar2 + 1;
      param_1[1] = param_1[1] + (uint)(0xfffffffe < uVar2);
      return;
    }
    uVar5 = 0;
    if (uVar3 != 0) {
      for (; (uVar3 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
      }
    }
    if (uVar3 == 0) {
      iVar6 = 0;
      if (uVar2 != 0) {
        for (; (uVar2 >> iVar6 & 1) == 0; iVar6 = iVar6 + 1) {
        }
      }
      if (uVar2 == 0) {
        iVar6 = 0x20;
      }
      uVar5 = iVar6 + 0x20;
    }
    piVar4 = (int *)((uVar5 >> 3) * *(int *)(param_2 + 0x34) + 8 + (int)puVar1);
    if (piVar4[1] == param_5 && *piVar4 == param_4) break;
    uVar2 = uVar2 & (uVar2 - 1) + (uint)(uVar3 != 0);
    uVar3 = uVar3 - 1 & uVar3;
  }
  return;
}



/* Function: FUN_00403a10 */

void FUN_00403a10(int param_1,int param_2,int *param_3,uint param_4,undefined4 param_5)

{
  int iVar1;
  int *piVar2;
  bool bVar3;
  undefined4 *puVar4;
  uint *puVar5;
  uint *puVar6;
  int iVar7;
  uint uVar8;
  char cVar9;
  uint uVar10;
  int in_FS_OFFSET;
  byte bVar11;
  undefined4 in_stack_ffffffc8;
  char local_34;
  int local_28;
  
  while (bVar11 = (byte)in_stack_ffffffc8,
        &stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar5 = *(uint **)(param_1 + 0xc);
  iVar1 = *(int *)(param_2 + 0x34);
  if (0x40 < (int)param_4) {
    uVar8 = puVar5[1];
    uVar10 = *puVar5;
    puVar6 = puVar5 + 2;
    local_28 = 8;
    iVar7 = 0;
    while( true ) {
      if (7 < iVar7) {
        if (local_28 == 8) {
          return;
        }
        puVar4 = (undefined4 *)(local_28 * *(int *)(param_2 + 0x34) + 8 + (int)puVar5);
        if ((puVar4[1] == param_4) && (FUN_00402aa0(param_3,*puVar4,param_4), local_34 != '\0')) {
          return;
        }
        return;
      }
      if ((uVar10 & 0x80) == 0) {
        if (puVar6[1] == param_4) {
          piVar2 = (int *)*puVar6;
          if ((*param_3 == *piVar2) && (param_3[1] == piVar2[1])) {
            if ((*(int *)((param_4 - 8) + (int)param_3) == *(int *)((param_4 - 8) + (int)piVar2)) &&
               (*(int *)((param_4 - 4) + (int)piVar2) == *(int *)((param_4 - 4) + (int)param_3))) {
              bVar3 = true;
            }
            else {
              bVar3 = false;
            }
          }
          else {
            bVar3 = false;
          }
        }
        else {
          bVar3 = false;
        }
      }
      else {
        bVar3 = false;
      }
      if ((bVar3) && (bVar3 = local_28 < 8, local_28 = iVar7, bVar3)) break;
      iVar7 = iVar7 + 1;
      puVar6 = (uint *)((int)puVar6 + iVar1);
      uVar10 = uVar10 >> 8 | uVar8 << 0x18;
      uVar8 = uVar8 >> 8;
    }
  }
  (*(code *)**(undefined4 **)(param_2 + 0x2c))(&param_3,*(undefined4 *)(param_1 + 8));
  uVar8 = *puVar5;
  uVar10 = puVar5[1];
  puVar5 = puVar5 + 2;
  iVar7 = 0;
  do {
    if (7 < iVar7) {
      return;
    }
    if ((byte)uVar8 == (bVar11 & 0x7f)) {
      if (puVar5[1] == param_4) {
        FUN_00402aa0(param_3,*puVar5,param_4);
        cVar9 = local_34;
      }
      else {
        cVar9 = '\0';
      }
      if (cVar9 != '\0') {
        return;
      }
    }
    iVar7 = iVar7 + 1;
    puVar5 = (uint *)((int)puVar5 + iVar1);
    uVar8 = uVar8 >> 8 | uVar10 << 0x18;
    uVar10 = uVar10 >> 8;
  } while( true );
}



/* Function: FUN_00403c90 */

void FUN_00403c90(uint *param_1,int param_2,uint param_3,undefined4 param_4,int param_5)

{
  uint *puVar1;
  uint uVar2;
  undefined4 *puVar3;
  uint uVar4;
  undefined1 uVar5;
  int iVar6;
  uint uVar7;
  undefined4 *puVar8;
  undefined4 *puVar9;
  int in_FS_OFFSET;
  char local_1c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar1 = (uint *)param_1[3];
  param_3 = param_3 & 0x7f;
  uVar2 = param_3 * 0x1010101 ^ *puVar1;
  uVar4 = param_3 * 0x1010101 ^ puVar1[1];
  uVar4 = uVar4 + 0xfefefefe + (uint)(0x1010100 < uVar2) & ~uVar4 & 0x80808080;
  uVar2 = ~uVar2 & uVar2 + 0xfefefeff & 0x80808080;
  while( true ) {
    uVar5 = (undefined1)param_3;
    if (uVar4 == 0 && uVar2 == 0) {
      uVar4 = *puVar1 & 0x80808080;
      uVar2 = puVar1[1] & 0x80808080;
      if (uVar2 == 0 && uVar4 == 0) {
        FUN_00469970("small map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: functi..." /* TRUNCATED STRING LITERAL */
                     ,0x35);
      }
      uVar7 = 0;
      if (uVar4 != 0) {
        for (; (uVar4 >> uVar7 & 1) == 0; uVar7 = uVar7 + 1) {
        }
      }
      if (uVar4 == 0) {
        iVar6 = 0;
        if (uVar2 != 0) {
          for (; (uVar2 >> iVar6 & 1) == 0; iVar6 = iVar6 + 1) {
          }
        }
        if (uVar2 == 0) {
          iVar6 = 0x20;
        }
        uVar7 = iVar6 + 0x20;
      }
      puVar8 = (undefined4 *)(uVar7 >> 3);
      puVar3 = (undefined4 *)(*(int *)(param_2 + 0x34) * (int)puVar8 + 8 + (int)puVar1);
      puVar3[1] = param_5;
      if (DAT_005f5fd0 != 0) {
        puVar9 = puVar8;
        FUN_0046ed80();
        *puVar9 = param_4;
        puVar9[1] = *puVar3;
      }
      *puVar3 = param_4;
      *(undefined1 *)((int)puVar1 + (int)puVar8) = uVar5;
      uVar2 = *param_1;
      *param_1 = uVar2 + 1;
      param_1[1] = param_1[1] + (uint)(0xfffffffe < uVar2);
      return;
    }
    uVar7 = 0;
    if (uVar2 != 0) {
      for (; (uVar2 >> uVar7 & 1) == 0; uVar7 = uVar7 + 1) {
      }
    }
    if (uVar2 == 0) {
      iVar6 = 0;
      if (uVar4 != 0) {
        for (; (uVar4 >> iVar6 & 1) == 0; iVar6 = iVar6 + 1) {
        }
      }
      if (uVar4 == 0) {
        iVar6 = 0x20;
      }
      uVar7 = iVar6 + 0x20;
    }
    puVar8 = (undefined4 *)(uVar7 >> 3);
    puVar3 = (undefined4 *)(*(int *)(param_2 + 0x34) * (int)puVar8 + 8 + (int)puVar1);
    if ((puVar3[1] == param_5) && (FUN_00402aa0(param_4,*puVar3,param_5), local_1c != '\0')) break;
    uVar4 = uVar4 & (uVar4 - 1) + (uint)(uVar2 != 0);
    uVar2 = uVar2 - 1 & uVar2;
  }
  puVar3[1] = param_5;
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *puVar8 = param_4;
    puVar8[1] = *puVar3;
  }
  *puVar3 = param_4;
  return;
}



/* Function: FUN_00403ee0 */

void FUN_00403ee0(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined1 *puVar4;
  uint uVar5;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x18);
      iVar1 = *(int *)((int)register0x00000010 + 0xc);
      uVar2 = *(uint *)((int)register0x00000010 + 8);
      if (uVar2 < 8 && iVar1 == 0) {
        iVar1 = 0;
        uVar2 = 8;
      }
      *(int *)((int)register0x00000010 + -8) = iVar1;
      *(uint *)((int)register0x00000010 + -0xc) = uVar2;
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004bb700;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x403f2d;
      FUN_00411710();
      iVar1 = *(int *)((int)register0x00000010 + -0x14);
      *(undefined4 *)(iVar1 + 8) = *(undefined4 *)((int)register0x00000010 + 0x10);
      *(undefined1 *)(iVar1 + 6) = *(undefined1 *)((int)register0x00000010 + 0x14);
      iVar3 = *(int *)((int)register0x00000010 + -8);
      uVar2 = *(uint *)((int)register0x00000010 + -0xc);
      if ((iVar3 != 0 || uVar2 < 0x401) && iVar3 == 0) {
        uVar5 = uVar2 - 1;
        uVar2 = iVar3 + -1 + (uint)(uVar2 != 0);
        if ((uVar5 < 0x10000 || uVar2 != 0) && uVar2 == 0) {
          iVar3 = 0;
        }
        else {
          uVar5 = uVar5 >> 0x10 | uVar2 * 0x10000;
          uVar2 = uVar2 >> 0x10;
          iVar3 = 0x10;
        }
        if (0xff < uVar5 && uVar2 == 0 || uVar2 != 0) {
          uVar5 = uVar5 >> 8 | uVar2 << 0x18;
          uVar2 = uVar2 >> 8;
          iVar3 = iVar3 + 8;
        }
        if (uVar2 == 0) {
          if (uVar5 < 0x100) {
            uVar2 = (uint)(byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                                [uVar5 + 0x1510] + iVar3;
            uVar5 = iVar3 + -0x20 +
                    (uint)(byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                                [uVar5 + 0x1510];
            uVar2 = -(uint)(uVar2 < 0x20) & 1 << ((byte)uVar2 & 0x1f);
            if (((1U >> ((byte)-uVar5 & 0x1f) & -(uint)(-uVar5 < 0x20)) != 0 ||
                (-(uint)(uVar5 < 0x20) & 1 << ((byte)uVar5 & 0x1f)) != 0) || uVar2 != 0) {
              *(int *)((int)register0x00000010 + -4) = iVar1;
              *(int *)((int)register0x00000010 + -0x18) = iVar1;
              *(undefined4 *)((int)register0x00000010 + -0x14) =
                   *(undefined4 *)((int)register0x00000010 + 4);
              *(short *)((int)register0x00000010 + -0x10) = (short)uVar2;
              *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x404074;
              FUN_004040e0();
              *(undefined4 *)((int)register0x00000010 + 0x18) =
                   *(undefined4 *)((int)register0x00000010 + -4);
              return;
            }
            *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004adee0;
            *(undefined ***)((int)register0x00000010 + -0x14) =
                 &PTR_s_rounded_up_capacity_overflows_ui_00550df8;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x404098;
            FUN_00469650();
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40409d;
            FUN_00438020();
          }
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4040a9;
          FUN_0046ee00();
        }
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4040b7;
        FUN_0046ee90();
      }
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004adee0;
      *(undefined ***)((int)register0x00000010 + -0x14) =
           &PTR_s_initial_table_capacity_too_large_00550df0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4040cf;
      FUN_00469650();
    }
    *(undefined4 *)(puVar4 + -4) = 0x4040d5;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_004040e0 */

void FUN_004040e0(void)

{
  int iVar1;
  undefined4 uVar2;
  ushort uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  undefined1 *puVar7;
  undefined4 *puVar8;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  bool bVar9;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x10);
      *(uint *)((int)register0x00000010 + -4) =
           (uint)(*(ushort *)((int)register0x00000010 + 0xc) >> 3);
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 8) + 0x28);
      *(uint *)((int)register0x00000010 + -0xc) =
           (uint)(*(ushort *)((int)register0x00000010 + 0xc) >> 3);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x404119;
      FUN_00468610();
      uVar2 = *(undefined4 *)((int)register0x00000010 + -8);
      iVar1 = *(int *)((int)register0x00000010 + -4);
      iVar5 = *(int *)((int)register0x00000010 + 4);
      *(int *)(iVar5 + 0x10) = iVar1 + -1;
      *(uint *)(iVar5 + 0x14) = (iVar1 != 0) - 1;
      if (DAT_005f5fd0 != 0) {
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x404145;
        FUN_0046ed80();
        *in_EDI = uVar2;
        in_EDI[1] = *(undefined4 *)(iVar5 + 0xc);
      }
      *(undefined4 *)(iVar5 + 0xc) = uVar2;
      uVar3 = *(ushort *)((int)register0x00000010 + 0xc);
      *(ushort *)(iVar5 + 2) = uVar3;
      if (uVar3 != 0) {
        if (uVar3 < 9) {
          uVar3 = uVar3 - 1;
          goto LAB_0040417c;
        }
        if (uVar3 <= (ushort)(uVar3 * 7)) {
          uVar3 = (ushort)(uVar3 * 7) >> 3;
LAB_0040417c:
          *(ushort *)(iVar5 + 4) = uVar3;
          iVar1 = *(int *)((int)register0x00000010 + 8);
          uVar4 = 0;
          for (uVar6 = 0;
              uVar6 < *(uint *)(iVar5 + 0x14) ||
              uVar6 == *(uint *)(iVar5 + 0x14) && uVar4 <= *(uint *)(iVar5 + 0x10);
              uVar6 = uVar6 + bVar9) {
            puVar8 = (undefined4 *)(*(int *)(iVar1 + 0x30) * uVar4 + *(int *)(iVar5 + 0xc));
            *puVar8 = 0x80808080;
            puVar8[1] = 0x80808080;
            bVar9 = 0xfffffffe < uVar4;
            uVar4 = uVar4 + 1;
          }
          return;
        }
        *(undefined **)((int)register0x00000010 + -0x10) = &DAT_004adee0;
        *(undefined ***)((int)register0x00000010 + -0xc) = &PTR_DAT_00550e08;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4041ec;
        FUN_00469650();
      }
      *(undefined **)((int)register0x00000010 + -0x10) = &DAT_004adee0;
      *(undefined ***)((int)register0x00000010 + -0xc) =
           &PTR_s_table_must_have_positive_capacit_00550e00;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x404204;
      FUN_00469650();
    }
    *(undefined4 *)(puVar7 + -4) = 0x40420a;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_00404210 */

void FUN_00404210(void)

{
  short *psVar1;
  uint *puVar2;
  undefined4 *puVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  undefined4 uVar7;
  uint uVar8;
  undefined1 *puVar9;
  uint uVar10;
  int iVar11;
  undefined4 *puVar12;
  int in_FS_OFFSET;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0x44);
      iVar11 = *(int *)((int)register0x00000010 + 4);
      if (*(short *)(iVar11 + 4) != 0) {
        uVar8 = *(uint *)(iVar11 + 0x10);
        uVar7 = *(undefined4 *)(iVar11 + 0x14);
        uVar10 = *(uint *)((int)register0x00000010 + 0xc) >> 7 & uVar8;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x404256;
        FUN_0046ef4a();
        *(uint *)((int)register0x00000010 + -0x38) = uVar8;
        *(undefined4 *)((int)register0x00000010 + -0x34) = uVar7;
        *(uint *)((int)register0x00000010 + -0x30) = uVar10;
        iVar11 = *(int *)((int)register0x00000010 + 4);
        iVar6 = *(int *)((int)register0x00000010 + 8);
        while( true ) {
          puVar2 = (uint *)(*(int *)((int)register0x00000010 + -0x30) * *(int *)(iVar6 + 0x30) +
                           *(int *)(iVar11 + 0xc));
          *(uint **)((int)register0x00000010 + -4) = puVar2;
          uVar10 = *puVar2 & 0x80808080;
          uVar8 = puVar2[1] & 0x80808080;
          if (uVar8 != 0 || uVar10 != 0) break;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x404279;
          FUN_0046f424();
          uVar8 = *(uint *)((int)register0x00000010 + -0x10);
          iVar11 = *(int *)((int)register0x00000010 + -0xc);
          *(uint *)((int)register0x00000010 + -0x10) = uVar8 + 1;
          *(uint *)((int)register0x00000010 + -0xc) = iVar11 + (uint)(0xfffffffe < uVar8);
          uVar10 = *(uint *)((int)register0x00000010 + -0x18);
          uVar5 = uVar8 + uVar10;
          *(uint *)((int)register0x00000010 + -0x18) =
               uVar5 + 1 & *(uint *)((int)register0x00000010 + -0x20);
          *(uint *)((int)register0x00000010 + -0x14) =
               iVar11 + *(int *)((int)register0x00000010 + -0x14) + (uint)CARRY4(uVar8,uVar10) +
               (uint)(0xfffffffe < uVar5) & *(uint *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4042c2;
          FUN_0046f424();
          iVar11 = *(int *)((int)register0x00000010 + 4);
        }
        iVar11 = *(int *)(iVar6 + 0x34);
        puVar12 = *(undefined4 **)(iVar6 + 0x3c);
        uVar5 = 0;
        if (uVar10 != 0) {
          for (; (uVar10 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
          }
        }
        if (uVar10 == 0) {
          iVar4 = 0;
          if (uVar8 != 0) {
            for (; (uVar8 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
            }
          }
          if (uVar8 == 0) {
            iVar4 = 0x20;
          }
          uVar5 = iVar4 + 0x20;
        }
        uVar5 = uVar5 >> 3;
        *(uint *)((int)register0x00000010 + -8) = uVar5;
        iVar11 = iVar11 * uVar5;
        if (((uint)puVar12 & 4) == 0) {
          *(undefined4 *)((int)register0x00000010 + -0x44) = *(undefined4 *)(iVar6 + 0x20);
          *(int *)((int)register0x00000010 + -0x40) = iVar11 + 8 + (int)puVar2;
          *(undefined4 *)((int)register0x00000010 + -0x3c) =
               *(undefined4 *)((int)register0x00000010 + 0x10);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x40437b;
          FUN_004687c0();
          uVar5 = *(uint *)((int)register0x00000010 + -8);
          iVar6 = *(int *)((int)register0x00000010 + 8);
        }
        else {
          if (DAT_005f5fd0 == 0) {
            uVar7 = *(undefined4 *)((int)register0x00000010 + 0x10);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x404351;
            FUN_0046ed80();
            uVar7 = *(undefined4 *)((int)register0x00000010 + 0x10);
            *puVar12 = uVar7;
            puVar12[1] = *(undefined4 *)(iVar11 + 8 + (int)puVar2);
          }
          *(undefined4 *)(iVar11 + 8 + (int)puVar2) = uVar7;
        }
        puVar3 = (undefined4 *)
                 (*(int *)(iVar6 + 0x34) * uVar5 + *(int *)(iVar6 + 0x38) + 8 +
                 *(int *)((int)register0x00000010 + -4));
        if ((*(uint *)(iVar6 + 0x3c) & 8) == 0) {
          *(undefined4 *)((int)register0x00000010 + -0x44) = *(undefined4 *)(iVar6 + 0x24);
          *(undefined4 **)((int)register0x00000010 + -0x40) = puVar3;
          *(undefined4 *)((int)register0x00000010 + -0x3c) =
               *(undefined4 *)((int)register0x00000010 + 0x14);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4043da;
          FUN_004687c0();
          uVar5 = *(uint *)((int)register0x00000010 + -8);
        }
        else {
          if (DAT_005f5fd0 == 0) {
            uVar7 = *(undefined4 *)((int)register0x00000010 + 0x14);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4043b4;
            FUN_0046ed80();
            uVar7 = *(undefined4 *)((int)register0x00000010 + 0x14);
            *puVar12 = uVar7;
            puVar12[1] = *puVar3;
          }
          *puVar3 = uVar7;
        }
        psVar1 = *(short **)((int)register0x00000010 + 4);
        psVar1[2] = psVar1[2] + -1;
        *psVar1 = *psVar1 + 1;
        *(byte *)(*(int *)((int)register0x00000010 + -4) + uVar5) =
             (byte)*(undefined4 *)((int)register0x00000010 + 0xc) & 0x7f;
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004adee0;
      *(undefined ***)((int)register0x00000010 + -0x40) = &PTR_DAT_00550e10;
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x40441f;
      FUN_00469650();
    }
    *(undefined4 *)(puVar9 + -4) = 0x404425;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
}



/* Function: FUN_00404430 */

void FUN_00404430(int param_1,undefined4 param_2,undefined4 param_3)

{
  ushort uVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar1 = *(short *)(param_1 + 2) * 2;
  if (uVar1 < 0x401) {
    FUN_004046a0(param_1,param_2,param_3,uVar1);
    return;
  }
  FUN_004044a0(param_1,param_2,param_3);
  return;
}



/* Function: FUN_004044a0 */

void FUN_004044a0(int param_1,int param_2,int param_3)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  int in_FS_OFFSET;
  bool bVar9;
  undefined4 uVar10;
  undefined4 local_30;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  cVar1 = *(char *)(param_1 + 6) + '\x01';
  FUN_00403ee0(param_2,0x400,0,0xffffffff,cVar1);
  uVar10 = 0;
  FUN_00403ee0(param_2,0x400,0,0xffffffff,cVar1);
  uVar4 = 0;
  for (uVar6 = 0;
      uVar6 < *(uint *)(param_1 + 0x14) ||
      uVar6 == *(uint *)(param_1 + 0x14) && uVar4 <= *(uint *)(param_1 + 0x10);
      uVar6 = uVar6 + bVar9) {
    iVar7 = *(int *)(param_2 + 0x30) * uVar4 + *(int *)(param_1 + 0xc);
    for (uVar2 = 0; uVar2 < 8; uVar2 = uVar2 + 1) {
      if ((*(byte *)(iVar7 + uVar2) & 0x80) == 0) {
        iVar8 = *(int *)(param_2 + 0x34) * uVar2;
        iVar5 = iVar8 + 8 + iVar7;
        if ((*(uint *)(param_2 + 0x3c) & 4) != 0) {
          iVar5 = *(int *)(iVar8 + 8 + iVar7);
        }
        iVar8 = iVar8 + *(int *)(param_2 + 0x38);
        iVar3 = iVar8 + 8 + iVar7;
        if ((*(uint *)(param_2 + 0x3c) & 8) != 0) {
          iVar3 = *(int *)(iVar8 + 8 + iVar7);
        }
        (*(code *)**(undefined4 **)(param_2 + 0x2c))(iVar5,*(undefined4 *)(param_3 + 8));
        FUN_00404210(local_30,param_2,uVar10,iVar5,iVar3);
      }
    }
    bVar9 = 0xfffffffe < uVar4;
    uVar4 = uVar4 + 1;
  }
  FUN_00402e90(param_3,param_1,local_30,local_30);
  *(undefined4 *)(param_1 + 8) = 0xffffffff;
  return;
}



/* Function: FUN_004046a0 */

void FUN_004046a0(int param_1,int param_2,int param_3,undefined2 param_4)

{
  int iVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int *piVar7;
  int iVar8;
  int iVar9;
  int in_FS_OFFSET;
  bool bVar10;
  undefined4 uVar11;
  int local_20;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar11 = 0;
  FUN_00403ee0(param_2,param_4,0,*(undefined4 *)(param_1 + 8),*(undefined1 *)(param_1 + 6));
  if (*(short *)(param_1 + 2) != 0) {
    uVar3 = 0;
    for (uVar4 = 0;
        uVar4 < *(uint *)(param_1 + 0x14) ||
        uVar4 == *(uint *)(param_1 + 0x14) && uVar3 <= *(uint *)(param_1 + 0x10);
        uVar4 = uVar4 + bVar10) {
      iVar5 = *(int *)(param_2 + 0x30) * uVar3 + *(int *)(param_1 + 0xc);
      for (uVar6 = 0; uVar6 < 8; uVar6 = uVar6 + 1) {
        if ((*(byte *)(iVar5 + uVar6) & 0x80) == 0) {
          iVar8 = *(int *)(param_2 + 0x34) * uVar6;
          iVar1 = iVar8 + 8 + iVar5;
          if ((*(uint *)(param_2 + 0x3c) & 4) != 0) {
            iVar1 = *(int *)(iVar8 + 8 + iVar5);
          }
          iVar8 = *(int *)(param_2 + 0x38) + iVar8;
          iVar9 = iVar8 + 8 + iVar5;
          if ((*(uint *)(param_2 + 0x3c) & 8) != 0) {
            iVar9 = *(int *)(iVar8 + 8 + iVar5);
          }
          (*(code *)**(undefined4 **)(param_2 + 0x2c))(iVar1,*(undefined4 *)(param_3 + 8));
          FUN_00404210(local_20,param_2,uVar11,iVar1,iVar9);
        }
      }
      bVar10 = 0xfffffffe < uVar3;
      uVar3 = uVar3 + 1;
    }
  }
  bVar2 = *(char *)(param_3 + 0x14) - *(char *)(local_20 + 6);
  for (iVar5 = 0; iVar5 < (int)(1 << (bVar2 & 0x1f) & -(uint)(bVar2 < 0x20)); iVar5 = iVar5 + 1) {
    iVar8 = *(int *)(local_20 + 8) + iVar5;
    iVar1 = *(int *)(param_3 + 0xc);
    if (DAT_005f5fd0 != (int *)0x0) {
      piVar7 = DAT_005f5fd0;
      FUN_0046ed80();
      *piVar7 = local_20;
      piVar7[1] = *(int *)(iVar1 + iVar8 * 4);
    }
    *(int *)(iVar1 + iVar8 * 4) = local_20;
  }
  *(undefined4 *)(param_1 + 8) = 0xffffffff;
  return;
}



/* Function: FUN_00404860 */

void FUN_00404860(int param_1,int *param_2,uint param_3)

{
  uint *puVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  int in_FS_OFFSET;
  bool bVar8;
  uint local_50;
  uint local_14;
  uint local_10;
  uint local_c;
  uint local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x404b77;
    FUN_0046d980();
  }
  if ((param_2 == (int *)0x0) || (param_2[1] == 0 && *param_2 == 0)) {
    return;
  }
  if (*(char *)((int)param_2 + 0x16) != '\0') {
    FUN_00469970("concurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Gr..." /* TRUNCATED STRING LITERAL */
                 ,0x21);
    return;
  }
  if (param_2[4] == 0) {
    puVar3 = (uint *)param_2[3];
    puVar1 = puVar3 + 2;
    uVar4 = ~*puVar3 & 0x80808080;
    uVar2 = ~puVar3[1] & 0x80808080;
    while( true ) {
      if (uVar2 == 0 && uVar4 == 0) {
        return;
      }
      if ((*puVar1 == param_3) && ((uVar4 & 0x80) != 0)) break;
      puVar1 = (uint *)((int)puVar1 + *(int *)(param_1 + 0x34));
      uVar4 = uVar4 >> 8 | uVar2 << 0x18;
      uVar2 = uVar2 >> 8;
    }
    return;
  }
  local_14 = param_3;
  (*(code *)**(undefined4 **)(param_1 + 0x2c))(&local_14,param_2[2]);
  if (param_2[4] == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = local_50 >> (*(byte *)((int)param_2 + 0x15) & 0x1f) &
            -(uint)((*(byte *)((int)param_2 + 0x15) & 0x3f) < 0x20);
  }
  local_10 = local_50;
  local_4 = *(int *)(param_2[3] + uVar2 * 4);
  uVar2 = local_50 >> 7 & *(uint *)(local_4 + 0x10);
  FUN_0046ef4a();
  do {
    puVar3 = (uint *)(uVar2 * *(int *)(param_1 + 0x30) + *(int *)(local_4 + 0xc));
    local_8 = puVar3[1];
    local_c = *puVar3;
    uVar4 = (local_50 & 0x7f) * 0x1010101 ^ local_c;
    uVar5 = (local_50 & 0x7f) * 0x1010101 ^ local_8;
    uVar6 = uVar4 + 0xfefefeff & ~uVar4 & 0x80808080;
    for (uVar4 = uVar5 + 0xfefefefe + (uint)(0x1010100 < uVar4) & ~uVar5 & 0x80808080;
        uVar4 != 0 || uVar6 != 0; uVar4 = uVar4 & (uVar4 - 1) + (uint)bVar8) {
      uVar5 = 0;
      if (uVar6 != 0) {
        for (; (uVar6 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
        }
      }
      if (uVar6 == 0) {
        iVar7 = 0;
        if (uVar4 != 0) {
          for (; (uVar4 >> iVar7 & 1) == 0; iVar7 = iVar7 + 1) {
          }
        }
        if (uVar4 == 0) {
          iVar7 = 0x20;
        }
        uVar5 = iVar7 + 0x20;
      }
      if (*(uint *)((uVar5 >> 3) * *(int *)(param_1 + 0x34) + 8 + (int)puVar3) == param_3) {
        return;
      }
      bVar8 = uVar6 != 0;
      uVar6 = uVar6 - 1 & uVar6;
    }
    if ((local_8 & ~(local_8 << 6) & 0x80808080) != 0 ||
        (~(local_c << 6) & local_c & 0x80808080) != 0) {
      return;
    }
    FUN_0046f424();
    FUN_0046f424();
    local_50 = local_10;
  } while( true );
}



/* Function: FUN_00404b80 */

void FUN_00404b80(int param_1,int *param_2,uint param_3)

{
  uint *puVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  int in_FS_OFFSET;
  bool bVar8;
  uint local_50;
  uint local_14;
  uint local_10;
  uint local_c;
  uint local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x404eb5;
    FUN_0046d980();
  }
  if ((param_2 == (int *)0x0) || (param_2[1] == 0 && *param_2 == 0)) {
    return;
  }
  if (*(char *)((int)param_2 + 0x16) != '\0') {
    FUN_00469970("concurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Gr..." /* TRUNCATED STRING LITERAL */
                 ,0x21);
    return;
  }
  if (param_2[4] == 0) {
    puVar3 = (uint *)param_2[3];
    puVar1 = puVar3 + 2;
    uVar2 = ~puVar3[1] & 0x80808080;
    uVar4 = ~*puVar3 & 0x80808080;
    while( true ) {
      if (uVar2 == 0 && uVar4 == 0) {
        return;
      }
      if ((*puVar1 == param_3) && ((uVar4 & 0x80) != 0)) break;
      puVar1 = (uint *)((int)puVar1 + *(int *)(param_1 + 0x34));
      uVar4 = uVar4 >> 8 | uVar2 << 0x18;
      uVar2 = uVar2 >> 8;
    }
    return;
  }
  local_14 = param_3;
  (*(code *)**(undefined4 **)(param_1 + 0x2c))(&local_14,param_2[2]);
  if (param_2[4] == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = local_50 >> (*(byte *)((int)param_2 + 0x15) & 0x1f) &
            -(uint)((*(byte *)((int)param_2 + 0x15) & 0x3f) < 0x20);
  }
  local_10 = local_50;
  local_4 = *(int *)(param_2[3] + uVar2 * 4);
  uVar2 = local_50 >> 7 & *(uint *)(local_4 + 0x10);
  FUN_0046ef4a();
  do {
    puVar3 = (uint *)(uVar2 * *(int *)(param_1 + 0x30) + *(int *)(local_4 + 0xc));
    local_8 = puVar3[1];
    local_c = *puVar3;
    uVar4 = (local_50 & 0x7f) * 0x1010101 ^ local_c;
    uVar5 = (local_50 & 0x7f) * 0x1010101 ^ local_8;
    uVar6 = uVar4 + 0xfefefeff & ~uVar4 & 0x80808080;
    for (uVar4 = uVar5 + 0xfefefefe + (uint)(0x1010100 < uVar4) & ~uVar5 & 0x80808080;
        uVar4 != 0 || uVar6 != 0; uVar4 = uVar4 & (uVar4 - 1) + (uint)bVar8) {
      uVar5 = 0;
      if (uVar6 != 0) {
        for (; (uVar6 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
        }
      }
      if (uVar6 == 0) {
        iVar7 = 0;
        if (uVar4 != 0) {
          for (; (uVar4 >> iVar7 & 1) == 0; iVar7 = iVar7 + 1) {
          }
        }
        if (uVar4 == 0) {
          iVar7 = 0x20;
        }
        uVar5 = iVar7 + 0x20;
      }
      if (*(uint *)((uVar5 >> 3) * *(int *)(param_1 + 0x34) + 8 + (int)puVar3) == param_3) {
        return;
      }
      bVar8 = uVar6 != 0;
      uVar6 = uVar6 - 1 & uVar6;
    }
    if ((local_8 & ~(local_8 << 6) & 0x80808080) != 0 ||
        (~(local_c << 6) & local_c & 0x80808080) != 0) {
      return;
    }
    FUN_0046f424();
    FUN_0046f424();
    local_50 = local_10;
  } while( true );
}



/* Function: FUN_00404ec0 */

void FUN_00404ec0(void)

{
  byte bVar1;
  code *pcVar2;
  int iVar3;
  uint *puVar4;
  int iVar5;
  undefined *puVar6;
  uint uVar7;
  undefined4 uVar8;
  short *psVar9;
  uint uVar10;
  undefined1 *puVar11;
  uint uVar12;
  int iVar13;
  int in_FS_OFFSET;
  bool bVar14;
  
  do {
    puVar11 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar11 = (undefined1 *)((int)register0x00000010 + -0x78);
      iVar5 = *(int *)((int)register0x00000010 + 8);
      if (iVar5 != 0) break;
      puVar6 = PTR_PTR_005cf0f8;
      if (PTR_PTR_005cf0f8 != (undefined *)0x0) {
        puVar6 = *(undefined **)(PTR_PTR_005cf0f8 + 4);
      }
      *(undefined **)((int)register0x00000010 + -0x78) = puVar6;
      *(undefined **)((int)register0x00000010 + -0x74) = PTR_PTR_005cf0fc;
      *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x40534a;
      FUN_00469650();
    }
    *(undefined4 *)(puVar11 + -4) = 0x405350;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar11;
  } while( true );
  if (*(char *)(iVar5 + 0x16) != '\0') {
    *(undefined **)((int)register0x00000010 + -0x78) = &DAT_004c6f09;
    *(undefined4 *)((int)register0x00000010 + -0x74) = 0x15;
    *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x404f04;
    FUN_00469970();
    iVar5 = *(int *)((int)register0x00000010 + 8);
  }
  *(undefined4 *)((int)register0x00000010 + -0x28) = *(undefined4 *)((int)register0x00000010 + 0xc);
  pcVar2 = (code *)**(undefined4 **)(*(int *)((int)register0x00000010 + 4) + 0x2c);
  uVar8 = *(undefined4 *)(iVar5 + 8);
  *(undefined1 **)((int)register0x00000010 + -0x78) =
       (undefined1 *)((int)register0x00000010 + -0x28);
  *(undefined4 *)((int)register0x00000010 + -0x74) = uVar8;
  *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x404f2f;
  (*pcVar2)();
  puVar4 = *(uint **)((int)register0x00000010 + 8);
  bVar1 = *(byte *)((int)puVar4 + 0x16);
  uVar10 = *(uint *)((int)register0x00000010 + -0x70);
  *(uint *)((int)register0x00000010 + -0x24) = uVar10;
  *(byte *)((int)puVar4 + 0x16) = bVar1 ^ 1;
  if (puVar4[3] == 0) {
    *(uint **)((int)register0x00000010 + -0x78) = puVar4;
    *(undefined4 *)((int)register0x00000010 + -0x74) = *(undefined4 *)((int)register0x00000010 + 4);
    *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x404f5f;
    FUN_004034a0();
    puVar4 = *(uint **)((int)register0x00000010 + 8);
    uVar10 = *(uint *)((int)register0x00000010 + -0x24);
  }
  if (puVar4[4] == 0) {
    if (*puVar4 < 8 && puVar4[1] == 0) {
      *(uint **)((int)register0x00000010 + -0x78) = puVar4;
      *(undefined4 *)((int)register0x00000010 + -0x74) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(uint *)((int)register0x00000010 + -0x70) = uVar10;
      *(undefined4 *)((int)register0x00000010 + -0x6c) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x404fc8;
      FUN_00403680();
      iVar5 = *(int *)((int)register0x00000010 + 8);
      uVar8 = *(undefined4 *)((int)register0x00000010 + -0x68);
      if (*(char *)(iVar5 + 0x16) == '\0') {
        *(undefined4 *)((int)register0x00000010 + -4) = uVar8;
        *(undefined **)((int)register0x00000010 + -0x78) = &DAT_004c6f09;
        *(undefined4 *)((int)register0x00000010 + -0x74) = 0x15;
        *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x404ff5;
        FUN_00469970();
        iVar5 = *(int *)((int)register0x00000010 + 8);
        uVar8 = *(undefined4 *)((int)register0x00000010 + -4);
      }
      *(byte *)(iVar5 + 0x16) = *(byte *)(iVar5 + 0x16) ^ 1;
      *(undefined4 *)((int)register0x00000010 + 0x10) = uVar8;
      return;
    }
    *(uint **)((int)register0x00000010 + -0x78) = puVar4;
    *(undefined4 *)((int)register0x00000010 + -0x74) = *(undefined4 *)((int)register0x00000010 + 4);
    *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x404f95;
    FUN_00403510();
    puVar4 = *(uint **)((int)register0x00000010 + 8);
    uVar10 = *(uint *)((int)register0x00000010 + -0x24);
  }
  iVar5 = *(int *)((int)register0x00000010 + 4);
LAB_0040503d:
  if (puVar4[4] == 1) {
    uVar7 = 0;
  }
  else {
    uVar7 = uVar10 >> (*(byte *)((int)puVar4 + 0x15) & 0x1f) &
            -(uint)((*(byte *)((int)puVar4 + 0x15) & 0x3f) < 0x20);
  }
  iVar3 = *(int *)(puVar4[3] + uVar7 * 4);
  *(int *)((int)register0x00000010 + -0x14) = iVar3;
  uVar7 = *(uint *)(iVar3 + 0x10);
  uVar8 = *(undefined4 *)(iVar3 + 0x14);
  uVar10 = uVar10 >> 7 & uVar7;
  *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x40507f;
  FUN_0046ef4a();
  *(uint *)((int)register0x00000010 + -0x58) = uVar7;
  *(undefined4 *)((int)register0x00000010 + -0x54) = uVar8;
  *(uint *)((int)register0x00000010 + -0x50) = uVar10;
  puVar4 = (uint *)0x0;
  uVar8 = 0;
  do {
    *(uint **)((int)register0x00000010 + -8) = puVar4;
    *(undefined4 *)((int)register0x00000010 + -0x18) = uVar8;
    puVar4 = (uint *)(*(int *)((int)register0x00000010 + -0x50) * *(int *)(iVar5 + 0x30) +
                     *(int *)(*(int *)((int)register0x00000010 + -0x14) + 0xc));
    uVar12 = *(uint *)((int)register0x00000010 + -0x24) & 0x7f;
    *(uint *)((int)register0x00000010 + -100) = uVar12;
    *(uint **)((int)register0x00000010 + -0xc) = puVar4;
    uVar10 = puVar4[1];
    *(uint *)((int)register0x00000010 + -0x1c) = uVar10;
    uVar7 = *puVar4;
    *(uint *)((int)register0x00000010 + -0x20) = uVar7;
    uVar7 = uVar12 * 0x1010101 ^ uVar7;
    *(uint *)((int)register0x00000010 + -0x60) = uVar7;
    uVar10 = uVar12 * 0x1010101 ^ uVar10;
    *(uint *)((int)register0x00000010 + -0x5c) = uVar10;
    uVar7 = *(uint *)((int)register0x00000010 + -0x60) + 0xfefefeff & ~uVar7 & 0x80808080;
    iVar3 = *(int *)((int)register0x00000010 + 0xc);
    iVar5 = *(int *)((int)register0x00000010 + 4);
    for (uVar10 = *(int *)((int)register0x00000010 + -0x5c) + -0x1010102 +
                  (uint)(0x1010100 < *(uint *)((int)register0x00000010 + -0x60)) & ~uVar10 &
                  0x80808080; uVar10 != 0 || uVar7 != 0;
        uVar10 = uVar10 & (uVar10 - 1) + (uint)bVar14) {
      uVar12 = 0;
      if (uVar7 != 0) {
        for (; (uVar7 >> uVar12 & 1) == 0; uVar12 = uVar12 + 1) {
        }
      }
      if (uVar7 == 0) {
        iVar13 = 0;
        if (uVar10 != 0) {
          for (; (uVar10 >> iVar13 & 1) == 0; iVar13 = iVar13 + 1) {
          }
        }
        if (uVar10 == 0) {
          iVar13 = 0x20;
        }
        uVar12 = iVar13 + 0x20;
      }
      iVar13 = (uVar12 >> 3) * *(int *)(iVar5 + 0x34);
      if (*(int *)(iVar13 + 8 + (int)puVar4) == iVar3) {
        iVar5 = *(int *)(iVar5 + 0x38) + iVar13 + 8 + (int)puVar4;
        puVar4 = *(uint **)((int)register0x00000010 + 8);
        goto LAB_004052e9;
      }
      bVar14 = uVar7 != 0;
      uVar7 = uVar7 - 1 & uVar7;
    }
    uVar10 = *(uint *)((int)register0x00000010 + -0x20) & 0x80808080;
    uVar7 = *(uint *)((int)register0x00000010 + -0x1c) & 0x80808080;
    if (uVar7 == 0 && uVar10 == 0) {
      uVar12 = *(uint *)((int)register0x00000010 + -0x18);
      puVar4 = *(uint **)((int)register0x00000010 + -8);
    }
    else {
      uVar12 = 0;
      if (uVar10 != 0) {
        for (; (uVar10 >> uVar12 & 1) == 0; uVar12 = uVar12 + 1) {
        }
      }
      if (uVar10 == 0) {
        iVar13 = 0;
        if (uVar7 != 0) {
          for (; (uVar7 >> iVar13 & 1) == 0; iVar13 = iVar13 + 1) {
          }
        }
        if (uVar7 == 0) {
          iVar13 = 0x20;
        }
        uVar12 = iVar13 + 0x20;
      }
      uVar12 = uVar12 >> 3;
      if (*(char *)((int)puVar4 + uVar12) != -2) break;
      if (*(uint **)((int)register0x00000010 + -8) != (uint *)0x0) {
        uVar12 = *(uint *)((int)register0x00000010 + -0x18);
        puVar4 = *(uint **)((int)register0x00000010 + -8);
      }
    }
    *(uint *)((int)register0x00000010 + -0x18) = uVar12;
    *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x4050da;
    FUN_0046f424();
    uVar10 = *(uint *)((int)register0x00000010 + -0x30);
    iVar3 = *(int *)((int)register0x00000010 + -0x2c);
    *(uint *)((int)register0x00000010 + -0x30) = uVar10 + 1;
    *(uint *)((int)register0x00000010 + -0x2c) = iVar3 + (uint)(0xfffffffe < uVar10);
    uVar7 = *(uint *)((int)register0x00000010 + -0x38);
    uVar12 = uVar10 + uVar7;
    *(uint *)((int)register0x00000010 + -0x38) =
         uVar12 + 1 & *(uint *)((int)register0x00000010 + -0x40);
    *(uint *)((int)register0x00000010 + -0x34) =
         iVar3 + *(int *)((int)register0x00000010 + -0x34) + (uint)CARRY4(uVar10,uVar7) +
         (uint)(0xfffffffe < uVar12) & *(uint *)((int)register0x00000010 + -0x3c);
    *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x405123;
    FUN_0046f424();
    uVar8 = *(undefined4 *)((int)register0x00000010 + -0x18);
  } while( true );
  if (*(int *)((int)register0x00000010 + -8) == 0) {
    psVar9 = *(short **)((int)register0x00000010 + -0x14);
  }
  else {
    *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + -8);
    psVar9 = *(short **)((int)register0x00000010 + -0x14);
    psVar9[2] = psVar9[2] + 1;
    uVar12 = *(uint *)((int)register0x00000010 + -0x18);
  }
  if (psVar9[2] != 0) {
    *(int *)(*(int *)(iVar5 + 0x34) * uVar12 + 8 + *(int *)((int)register0x00000010 + -0xc)) = iVar3
    ;
    iVar3 = *(int *)(iVar5 + 0x34);
    iVar13 = *(int *)(iVar5 + 0x38);
    iVar5 = *(int *)((int)register0x00000010 + -0xc);
    *(char *)(iVar5 + uVar12) = (char)*(undefined4 *)((int)register0x00000010 + -100);
    psVar9[2] = psVar9[2] + -1;
    *psVar9 = *psVar9 + 1;
    puVar4 = *(uint **)((int)register0x00000010 + 8);
    uVar10 = *puVar4;
    iVar5 = iVar3 * uVar12 + iVar13 + 8 + iVar5;
    *puVar4 = uVar10 + 1;
    puVar4[1] = puVar4[1] + (uint)(0xfffffffe < uVar10);
LAB_004052e9:
    if (*(char *)((int)puVar4 + 0x16) == '\0') {
      *(int *)((int)register0x00000010 + -0x10) = iVar5;
      *(undefined **)((int)register0x00000010 + -0x78) = &DAT_004c6f09;
      *(undefined4 *)((int)register0x00000010 + -0x74) = 0x15;
      *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x40530b;
      FUN_00469970();
      iVar5 = *(int *)((int)register0x00000010 + -0x10);
      puVar4 = *(uint **)((int)register0x00000010 + 8);
    }
    *(byte *)((int)puVar4 + 0x16) = *(byte *)((int)puVar4 + 0x16) ^ 1;
    *(int *)((int)register0x00000010 + 0x10) = iVar5;
    return;
  }
  *(short **)((int)register0x00000010 + -0x78) = psVar9;
  *(int *)((int)register0x00000010 + -0x74) = iVar5;
  *(undefined4 *)((int)register0x00000010 + -0x70) = *(undefined4 *)((int)register0x00000010 + 8);
  *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x40502c;
  FUN_00404430();
  puVar4 = *(uint **)((int)register0x00000010 + 8);
  uVar10 = *(uint *)((int)register0x00000010 + -0x24);
  iVar5 = *(int *)((int)register0x00000010 + 4);
  goto LAB_0040503d;
}



/* Function: FUN_00405360 */

void FUN_00405360(int param_1,int *param_2,uint param_3,uint param_4)

{
  uint *puVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  int in_FS_OFFSET;
  bool bVar8;
  uint local_5c;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  int local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x4056bd;
    FUN_0046d980();
  }
  if ((param_2 == (int *)0x0) || (param_2[1] == 0 && *param_2 == 0)) {
    return;
  }
  if (*(char *)((int)param_2 + 0x16) != '\0') {
    FUN_00469970("concurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Gr..." /* TRUNCATED STRING LITERAL */
                 ,0x21);
    return;
  }
  if (param_2[4] == 0) {
    puVar3 = (uint *)param_2[3];
    puVar1 = puVar3 + 2;
    uVar2 = ~puVar3[1] & 0x80808080;
    uVar4 = ~*puVar3 & 0x80808080;
    while( true ) {
      if (uVar2 == 0 && uVar4 == 0) {
        return;
      }
      if ((*puVar1 == param_3 && puVar1[1] == param_4) && ((uVar4 & 0x80) != 0)) break;
      puVar1 = (uint *)((int)puVar1 + *(int *)(param_1 + 0x34));
      uVar4 = uVar4 >> 8 | uVar2 << 0x18;
      uVar2 = uVar2 >> 8;
    }
    return;
  }
  local_1c = param_3;
  local_18 = param_4;
  (*(code *)**(undefined4 **)(param_1 + 0x2c))(&local_1c,param_2[2]);
  if (param_2[4] == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = local_5c >> (*(byte *)((int)param_2 + 0x15) & 0x1f) &
            -(uint)((*(byte *)((int)param_2 + 0x15) & 0x3f) < 0x20);
  }
  local_14 = local_5c;
  local_4 = *(int *)(param_2[3] + uVar2 * 4);
  uVar2 = local_5c >> 7 & *(uint *)(local_4 + 0x10);
  FUN_0046ef4a();
  do {
    puVar3 = (uint *)(uVar2 * *(int *)(param_1 + 0x30) + *(int *)(local_4 + 0xc));
    local_c = puVar3[1];
    local_10 = *puVar3;
    uVar4 = (local_5c & 0x7f) * 0x1010101 ^ local_10;
    uVar5 = (local_5c & 0x7f) * 0x1010101 ^ local_c;
    uVar6 = uVar4 + 0xfefefeff & ~uVar4 & 0x80808080;
    for (uVar4 = uVar5 + 0xfefefefe + (uint)(0x1010100 < uVar4) & ~uVar5 & 0x80808080;
        uVar4 != 0 || uVar6 != 0; uVar4 = (uVar4 - 1) + (uint)bVar8 & uVar4) {
      uVar5 = 0;
      if (uVar6 != 0) {
        for (; (uVar6 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
        }
      }
      if (uVar6 == 0) {
        iVar7 = 0;
        if (uVar4 != 0) {
          for (; (uVar4 >> iVar7 & 1) == 0; iVar7 = iVar7 + 1) {
          }
        }
        if (uVar4 == 0) {
          iVar7 = 0x20;
        }
        uVar5 = iVar7 + 0x20;
      }
      local_8 = (uVar5 >> 3) * *(int *)(param_1 + 0x34);
      puVar1 = (uint *)(local_8 + 8 + (int)puVar3);
      if (*puVar1 == param_3 && puVar1[1] == param_4) {
        return;
      }
      bVar8 = uVar6 != 0;
      uVar6 = uVar6 - 1 & uVar6;
    }
    if ((local_c & ~(local_c << 6) & 0x80808080) != 0 ||
        (~(local_10 << 6) & local_10 & 0x80808080) != 0) {
      return;
    }
    FUN_0046f424();
    FUN_0046f424();
    local_5c = local_14;
  } while( true );
}



/* Function: FUN_004056d0 */

void FUN_004056d0(void)

{
  byte bVar1;
  code *pcVar2;
  uint *puVar3;
  int iVar4;
  undefined *puVar5;
  uint uVar6;
  undefined4 uVar7;
  short *psVar8;
  int iVar9;
  uint uVar10;
  int *piVar11;
  undefined1 *puVar12;
  uint uVar13;
  int iVar14;
  int in_FS_OFFSET;
  bool bVar15;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) <
        (undefined1 *)((int)register0x00000010 + -4)) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x84);
      iVar4 = *(int *)((int)register0x00000010 + 8);
      if (iVar4 != 0) break;
      puVar5 = PTR_PTR_005cf0f8;
      if (PTR_PTR_005cf0f8 != (undefined *)0x0) {
        puVar5 = *(undefined **)(PTR_PTR_005cf0f8 + 4);
      }
      *(undefined **)((int)register0x00000010 + -0x84) = puVar5;
      *(undefined **)((int)register0x00000010 + -0x80) = PTR_PTR_005cf0fc;
      *(undefined4 *)((int)register0x00000010 + -0x88) = 0x405bd5;
      FUN_00469650();
    }
    *(undefined4 *)(puVar12 + -4) = 0x405bdb;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
  if (*(char *)(iVar4 + 0x16) != '\0') {
    *(undefined **)((int)register0x00000010 + -0x84) = &DAT_004c6f09;
    *(undefined4 *)((int)register0x00000010 + -0x80) = 0x15;
    *(undefined4 *)((int)register0x00000010 + -0x88) = 0x40571b;
    FUN_00469970();
    iVar4 = *(int *)((int)register0x00000010 + 8);
  }
  *(undefined4 *)((int)register0x00000010 + -0x30) = *(undefined4 *)((int)register0x00000010 + 0xc);
  *(undefined4 *)((int)register0x00000010 + -0x2c) = *(undefined4 *)((int)register0x00000010 + 0x10)
  ;
  pcVar2 = (code *)**(undefined4 **)(*(int *)((int)register0x00000010 + 4) + 0x2c);
  uVar7 = *(undefined4 *)(iVar4 + 8);
  *(undefined1 **)((int)register0x00000010 + -0x84) =
       (undefined1 *)((int)register0x00000010 + -0x30);
  *(undefined4 *)((int)register0x00000010 + -0x80) = uVar7;
  *(undefined4 *)((int)register0x00000010 + -0x88) = 0x405754;
  (*pcVar2)();
  puVar3 = *(uint **)((int)register0x00000010 + 8);
  bVar1 = *(byte *)((int)puVar3 + 0x16);
  uVar10 = *(uint *)((int)register0x00000010 + -0x7c);
  *(uint *)((int)register0x00000010 + -0x28) = uVar10;
  *(byte *)((int)puVar3 + 0x16) = bVar1 ^ 1;
  if (puVar3[3] == 0) {
    *(uint **)((int)register0x00000010 + -0x84) = puVar3;
    *(undefined4 *)((int)register0x00000010 + -0x80) = *(undefined4 *)((int)register0x00000010 + 4);
    *(undefined4 *)((int)register0x00000010 + -0x88) = 0x405787;
    FUN_004034a0();
    puVar3 = *(uint **)((int)register0x00000010 + 8);
    uVar10 = *(uint *)((int)register0x00000010 + -0x28);
  }
  if (puVar3[4] == 0) {
    if (*puVar3 < 8 && puVar3[1] == 0) {
      *(uint **)((int)register0x00000010 + -0x84) = puVar3;
      *(undefined4 *)((int)register0x00000010 + -0x80) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(uint *)((int)register0x00000010 + -0x7c) = uVar10;
      *(undefined4 *)((int)register0x00000010 + -0x78) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x74) =
           *(undefined4 *)((int)register0x00000010 + 0x10);
      *(undefined4 *)((int)register0x00000010 + -0x88) = 0x405804;
      FUN_00403830();
      iVar4 = *(int *)((int)register0x00000010 + 8);
      uVar7 = *(undefined4 *)((int)register0x00000010 + -0x70);
      if (*(char *)(iVar4 + 0x16) == '\0') {
        *(undefined4 *)((int)register0x00000010 + -4) = uVar7;
        *(undefined **)((int)register0x00000010 + -0x84) = &DAT_004c6f09;
        *(undefined4 *)((int)register0x00000010 + -0x80) = 0x15;
        *(undefined4 *)((int)register0x00000010 + -0x88) = 0x405834;
        FUN_00469970();
        iVar4 = *(int *)((int)register0x00000010 + 8);
        uVar7 = *(undefined4 *)((int)register0x00000010 + -4);
      }
      *(byte *)(iVar4 + 0x16) = *(byte *)(iVar4 + 0x16) ^ 1;
      *(undefined4 *)((int)register0x00000010 + 0x14) = uVar7;
      return;
    }
    *(uint **)((int)register0x00000010 + -0x84) = puVar3;
    *(undefined4 *)((int)register0x00000010 + -0x80) = *(undefined4 *)((int)register0x00000010 + 4);
    *(undefined4 *)((int)register0x00000010 + -0x88) = 0x4057c0;
    FUN_00403510();
    puVar3 = *(uint **)((int)register0x00000010 + 8);
    uVar10 = *(uint *)((int)register0x00000010 + -0x28);
  }
  iVar4 = *(int *)((int)register0x00000010 + 4);
LAB_00405885:
  if (puVar3[4] == 1) {
    uVar6 = 0;
  }
  else {
    uVar6 = uVar10 >> (*(byte *)((int)puVar3 + 0x15) & 0x1f) &
            -(uint)((*(byte *)((int)puVar3 + 0x15) & 0x3f) < 0x20);
  }
  iVar9 = *(int *)(puVar3[3] + uVar6 * 4);
  *(int *)((int)register0x00000010 + -0x14) = iVar9;
  uVar6 = *(uint *)(iVar9 + 0x10);
  uVar7 = *(undefined4 *)(iVar9 + 0x14);
  uVar10 = uVar10 >> 7 & uVar6;
  *(undefined4 *)((int)register0x00000010 + -0x88) = 0x4058c7;
  FUN_0046ef4a();
  *(uint *)((int)register0x00000010 + -0x60) = uVar6;
  *(undefined4 *)((int)register0x00000010 + -0x5c) = uVar7;
  *(uint *)((int)register0x00000010 + -0x58) = uVar10;
  puVar3 = (uint *)0x0;
  uVar7 = 0;
  do {
    *(uint **)((int)register0x00000010 + -8) = puVar3;
    *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar7;
    puVar3 = (uint *)(*(int *)((int)register0x00000010 + -0x58) * *(int *)(iVar4 + 0x30) +
                     *(int *)(*(int *)((int)register0x00000010 + -0x14) + 0xc));
    uVar13 = *(uint *)((int)register0x00000010 + -0x28) & 0x7f;
    *(uint *)((int)register0x00000010 + -0x6c) = uVar13;
    *(uint **)((int)register0x00000010 + -0xc) = puVar3;
    uVar10 = puVar3[1];
    *(uint *)((int)register0x00000010 + -0x20) = uVar10;
    uVar6 = *puVar3;
    *(uint *)((int)register0x00000010 + -0x24) = uVar6;
    uVar10 = uVar13 * 0x1010101 ^ uVar10;
    *(uint *)((int)register0x00000010 + -100) = uVar10;
    uVar6 = uVar13 * 0x1010101 ^ uVar6;
    *(uint *)((int)register0x00000010 + -0x68) = uVar6;
    uVar6 = *(uint *)((int)register0x00000010 + -0x68) + 0xfefefeff & ~uVar6 & 0x80808080;
    iVar9 = *(int *)((int)register0x00000010 + 0xc);
    iVar4 = *(int *)((int)register0x00000010 + 4);
    for (uVar10 = *(int *)((int)register0x00000010 + -100) + -0x1010102 +
                  (uint)(0x1010100 < *(uint *)((int)register0x00000010 + -0x68)) & ~uVar10 &
                  0x80808080; uVar10 != 0 || uVar6 != 0;
        uVar10 = uVar10 & (uVar10 - 1) + (uint)bVar15) {
      uVar13 = 0;
      if (uVar6 != 0) {
        for (; (uVar6 >> uVar13 & 1) == 0; uVar13 = uVar13 + 1) {
        }
      }
      if (uVar6 == 0) {
        iVar14 = 0;
        if (uVar10 != 0) {
          for (; (uVar10 >> iVar14 & 1) == 0; iVar14 = iVar14 + 1) {
          }
        }
        if (uVar10 == 0) {
          iVar14 = 0x20;
        }
        uVar13 = iVar14 + 0x20;
      }
      iVar14 = (uVar13 >> 3) * *(int *)(iVar4 + 0x34);
      *(int *)((int)register0x00000010 + -0x18) = iVar14;
      piVar11 = (int *)(iVar14 + 8 + (int)puVar3);
      if (piVar11[1] == *(int *)((int)register0x00000010 + 0x10) && *piVar11 == iVar9) {
        iVar4 = *(int *)(iVar4 + 0x38) + *(int *)((int)register0x00000010 + -0x18) + 8 + (int)puVar3
        ;
        puVar3 = *(uint **)((int)register0x00000010 + 8);
        goto LAB_00405b71;
      }
      bVar15 = uVar6 != 0;
      uVar6 = uVar6 - 1 & uVar6;
      iVar9 = *(int *)((int)register0x00000010 + 0xc);
    }
    uVar10 = *(uint *)((int)register0x00000010 + -0x24) & 0x80808080;
    uVar6 = *(uint *)((int)register0x00000010 + -0x20) & 0x80808080;
    if (uVar6 == 0 && uVar10 == 0) {
      uVar13 = *(uint *)((int)register0x00000010 + -0x1c);
      puVar3 = *(uint **)((int)register0x00000010 + -8);
    }
    else {
      uVar13 = 0;
      if (uVar10 != 0) {
        for (; (uVar10 >> uVar13 & 1) == 0; uVar13 = uVar13 + 1) {
        }
      }
      if (uVar10 == 0) {
        iVar14 = 0;
        if (uVar6 != 0) {
          for (; (uVar6 >> iVar14 & 1) == 0; iVar14 = iVar14 + 1) {
          }
        }
        if (uVar6 == 0) {
          iVar14 = 0x20;
        }
        uVar13 = iVar14 + 0x20;
      }
      uVar13 = uVar13 >> 3;
      if (*(char *)((int)puVar3 + uVar13) != -2) break;
      if (*(uint **)((int)register0x00000010 + -8) != (uint *)0x0) {
        uVar13 = *(uint *)((int)register0x00000010 + -0x1c);
        puVar3 = *(uint **)((int)register0x00000010 + -8);
      }
    }
    *(uint *)((int)register0x00000010 + -0x1c) = uVar13;
    *(undefined4 *)((int)register0x00000010 + -0x88) = 0x405922;
    FUN_0046f424();
    uVar10 = *(uint *)((int)register0x00000010 + -0x38);
    iVar9 = *(int *)((int)register0x00000010 + -0x34);
    *(uint *)((int)register0x00000010 + -0x38) = uVar10 + 1;
    *(uint *)((int)register0x00000010 + -0x34) = iVar9 + (uint)(0xfffffffe < uVar10);
    uVar6 = *(uint *)((int)register0x00000010 + -0x40);
    uVar13 = uVar10 + uVar6;
    *(uint *)((int)register0x00000010 + -0x40) =
         uVar13 + 1 & *(uint *)((int)register0x00000010 + -0x48);
    *(uint *)((int)register0x00000010 + -0x3c) =
         iVar9 + *(int *)((int)register0x00000010 + -0x3c) + (uint)CARRY4(uVar10,uVar6) +
         (uint)(0xfffffffe < uVar13) & *(uint *)((int)register0x00000010 + -0x44);
    *(undefined4 *)((int)register0x00000010 + -0x88) = 0x40596b;
    FUN_0046f424();
    uVar7 = *(undefined4 *)((int)register0x00000010 + -0x1c);
  } while( true );
  if (*(int *)((int)register0x00000010 + -8) == 0) {
    psVar8 = *(short **)((int)register0x00000010 + -0x14);
  }
  else {
    *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + -8);
    psVar8 = *(short **)((int)register0x00000010 + -0x14);
    psVar8[2] = psVar8[2] + 1;
    uVar13 = *(uint *)((int)register0x00000010 + -0x1c);
  }
  if (psVar8[2] != 0) {
    piVar11 = (int *)(*(int *)(iVar4 + 0x34) * uVar13 + 8 + *(int *)((int)register0x00000010 + -0xc)
                     );
    *piVar11 = iVar9;
    piVar11[1] = *(int *)((int)register0x00000010 + 0x10);
    iVar9 = *(int *)(iVar4 + 0x34);
    iVar14 = *(int *)(iVar4 + 0x38);
    iVar4 = *(int *)((int)register0x00000010 + -0xc);
    *(char *)(iVar4 + uVar13) = (char)*(undefined4 *)((int)register0x00000010 + -0x6c);
    psVar8[2] = psVar8[2] + -1;
    *psVar8 = *psVar8 + 1;
    puVar3 = *(uint **)((int)register0x00000010 + 8);
    uVar10 = *puVar3;
    iVar4 = iVar9 * uVar13 + iVar14 + 8 + iVar4;
    *puVar3 = uVar10 + 1;
    puVar3[1] = puVar3[1] + (uint)(0xfffffffe < uVar10);
LAB_00405b71:
    if (*(char *)((int)puVar3 + 0x16) == '\0') {
      *(int *)((int)register0x00000010 + -0x10) = iVar4;
      *(undefined **)((int)register0x00000010 + -0x84) = &DAT_004c6f09;
      *(undefined4 *)((int)register0x00000010 + -0x80) = 0x15;
      *(undefined4 *)((int)register0x00000010 + -0x88) = 0x405b93;
      FUN_00469970();
      iVar4 = *(int *)((int)register0x00000010 + -0x10);
      puVar3 = *(uint **)((int)register0x00000010 + 8);
    }
    *(byte *)((int)puVar3 + 0x16) = *(byte *)((int)puVar3 + 0x16) ^ 1;
    *(int *)((int)register0x00000010 + 0x14) = iVar4;
    return;
  }
  *(short **)((int)register0x00000010 + -0x84) = psVar8;
  *(int *)((int)register0x00000010 + -0x80) = iVar4;
  *(undefined4 *)((int)register0x00000010 + -0x7c) = *(undefined4 *)((int)register0x00000010 + 8);
  *(undefined4 *)((int)register0x00000010 + -0x88) = 0x405871;
  FUN_00404430();
  puVar3 = *(uint **)((int)register0x00000010 + 8);
  uVar10 = *(uint *)((int)register0x00000010 + -0x28);
  iVar4 = *(int *)((int)register0x00000010 + 4);
  goto LAB_00405885;
}



/* Function: FUN_00405be0 */

void FUN_00405be0(int param_1,int *param_2,undefined4 param_3,int param_4)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined4 *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int in_FS_OFFSET;
  bool bVar8;
  uint in_stack_ffffffa4;
  undefined4 in_stack_ffffffa8;
  int local_54;
  undefined4 local_c;
  int local_8;
  uint *local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (uint *)0x405ee9;
    FUN_0046d980();
  }
  if ((param_2 == (int *)0x0) || (param_2[1] == 0 && *param_2 == 0)) {
    return;
  }
  if (*(char *)((int)param_2 + 0x16) != '\0') {
    FUN_00469970("concurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Gr..." /* TRUNCATED STRING LITERAL */
                 ,0x21);
    return;
  }
  if (param_2[4] < 1) {
    FUN_00403a10(param_2,param_1,param_3,param_4);
    if (local_54 == 0) {
      return;
    }
    return;
  }
  local_c = param_3;
  local_8 = param_4;
  (*(code *)**(undefined4 **)(param_1 + 0x2c))(&local_c,param_2[2]);
  if (param_2[4] == 1) {
    uVar6 = 0;
  }
  else {
    uVar6 = in_stack_ffffffa4 >> (*(byte *)((int)param_2 + 0x15) & 0x1f) &
            -(uint)((*(byte *)((int)param_2 + 0x15) & 0x3f) < 0x20);
  }
  iVar1 = *(int *)(param_2[3] + uVar6 * 4);
  uVar6 = in_stack_ffffffa4 >> 7 & *(uint *)(iVar1 + 0x10);
  FUN_0046ef4a();
  do {
    local_4 = (uint *)(uVar6 * *(int *)(param_1 + 0x30) + *(int *)(iVar1 + 0xc));
    uVar2 = (in_stack_ffffffa4 & 0x7f) * 0x1010101 ^ *local_4;
    uVar7 = (in_stack_ffffffa4 & 0x7f) * 0x1010101 ^ local_4[1];
    uVar5 = uVar2 + 0xfefefeff & ~uVar2 & 0x80808080;
    for (uVar2 = uVar7 + 0xfefefefe + (uint)(0x1010100 < uVar2) & ~uVar7 & 0x80808080;
        uVar2 != 0 || uVar5 != 0; uVar2 = uVar2 & (uVar2 - 1) + (uint)bVar8) {
      uVar7 = 0;
      if (uVar5 != 0) {
        for (; (uVar5 >> uVar7 & 1) == 0; uVar7 = uVar7 + 1) {
        }
      }
      if (uVar5 == 0) {
        iVar3 = 0;
        if (uVar2 != 0) {
          for (; (uVar2 >> iVar3 & 1) == 0; iVar3 = iVar3 + 1) {
          }
        }
        if (uVar2 == 0) {
          iVar3 = 0x20;
        }
        uVar7 = iVar3 + 0x20;
      }
      puVar4 = (undefined4 *)((uVar7 >> 3) * *(int *)(param_1 + 0x34) + 8 + (int)local_4);
      if ((puVar4[1] == param_4) &&
         (FUN_00402aa0(param_3,*puVar4,param_4), (char)in_stack_ffffffa8 != '\0')) {
        return;
      }
      bVar8 = uVar5 != 0;
      uVar5 = uVar5 - 1 & uVar5;
    }
    if ((local_4[1] & ~(local_4[1] << 6) & 0x80808080) != 0 ||
        (~(*local_4 << 6) & *local_4 & 0x80808080) != 0) {
      return;
    }
    FUN_0046f424();
    FUN_0046f424();
  } while( true );
}



/* Function: FUN_00405ef0 */

void FUN_00405ef0(int param_1,int *param_2,undefined4 param_3,int param_4)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined4 *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int in_FS_OFFSET;
  bool bVar8;
  uint in_stack_ffffffa4;
  undefined4 in_stack_ffffffa8;
  int local_54;
  undefined4 local_c;
  int local_8;
  uint *local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (uint *)0x406217;
    FUN_0046d980();
  }
  if ((param_2 == (int *)0x0) || (param_2[1] == 0 && *param_2 == 0)) {
    return;
  }
  if (*(char *)((int)param_2 + 0x16) != '\0') {
    FUN_00469970("concurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Gr..." /* TRUNCATED STRING LITERAL */
                 ,0x21);
    return;
  }
  if (param_2[4] < 1) {
    FUN_00403a10(param_2,param_1,param_3,param_4);
    if (local_54 == 0) {
      return;
    }
    return;
  }
  local_c = param_3;
  local_8 = param_4;
  (*(code *)**(undefined4 **)(param_1 + 0x2c))(&local_c,param_2[2]);
  if (param_2[4] == 1) {
    uVar5 = 0;
  }
  else {
    uVar5 = in_stack_ffffffa4 >> (*(byte *)((int)param_2 + 0x15) & 0x1f) &
            -(uint)((*(byte *)((int)param_2 + 0x15) & 0x3f) < 0x20);
  }
  iVar1 = *(int *)(param_2[3] + uVar5 * 4);
  uVar5 = in_stack_ffffffa4 >> 7 & *(uint *)(iVar1 + 0x10);
  FUN_0046ef4a();
  do {
    local_4 = (uint *)(uVar5 * *(int *)(param_1 + 0x30) + *(int *)(iVar1 + 0xc));
    uVar2 = (in_stack_ffffffa4 & 0x7f) * 0x1010101 ^ *local_4;
    uVar6 = (in_stack_ffffffa4 & 0x7f) * 0x1010101 ^ local_4[1];
    uVar7 = uVar2 + 0xfefefeff & ~uVar2 & 0x80808080;
    for (uVar2 = uVar6 + 0xfefefefe + (uint)(0x1010100 < uVar2) & ~uVar6 & 0x80808080;
        uVar2 != 0 || uVar7 != 0; uVar2 = uVar2 & (uVar2 - 1) + (uint)bVar8) {
      uVar6 = 0;
      if (uVar7 != 0) {
        for (; (uVar7 >> uVar6 & 1) == 0; uVar6 = uVar6 + 1) {
        }
      }
      if (uVar7 == 0) {
        iVar3 = 0;
        if (uVar2 != 0) {
          for (; (uVar2 >> iVar3 & 1) == 0; iVar3 = iVar3 + 1) {
          }
        }
        if (uVar2 == 0) {
          iVar3 = 0x20;
        }
        uVar6 = iVar3 + 0x20;
      }
      puVar4 = (undefined4 *)((uVar6 >> 3) * *(int *)(param_1 + 0x34) + 8 + (int)local_4);
      if ((puVar4[1] == param_4) &&
         (FUN_00402aa0(param_3,*puVar4,param_4), (char)in_stack_ffffffa8 != '\0')) {
        return;
      }
      bVar8 = uVar7 != 0;
      uVar7 = uVar7 - 1 & uVar7;
    }
    if ((local_4[1] & ~(local_4[1] << 6) & 0x80808080) != 0 ||
        (~(*local_4 << 6) & *local_4 & 0x80808080) != 0) {
      return;
    }
    FUN_0046f424();
    FUN_0046f424();
  } while( true );
}



/* Function: FUN_00406220 */

void FUN_00406220(void)

{
  byte bVar1;
  code *pcVar2;
  uint *puVar3;
  uint *puVar4;
  uint uVar5;
  int iVar6;
  undefined4 uVar7;
  int iVar8;
  undefined *puVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  short *psVar13;
  undefined1 *puVar14;
  uint uVar15;
  undefined4 *puVar16;
  int iVar17;
  undefined4 *puVar18;
  int in_FS_OFFSET;
  bool bVar19;
  
  do {
    puVar14 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar14 = (undefined1 *)((int)register0x00000010 + -0x80);
      iVar8 = *(int *)((int)register0x00000010 + 8);
      if (iVar8 != 0) break;
      puVar9 = PTR_PTR_005cf0f8;
      if (PTR_PTR_005cf0f8 != (undefined *)0x0) {
        puVar9 = *(undefined **)(PTR_PTR_005cf0f8 + 4);
      }
      *(undefined **)((int)register0x00000010 + -0x80) = puVar9;
      *(undefined **)((int)register0x00000010 + -0x7c) = PTR_PTR_005cf0fc;
      *(undefined4 *)((int)register0x00000010 + -0x84) = 0x406786;
      FUN_00469650();
    }
    *(undefined4 *)(puVar14 + -4) = 0x40678c;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar14;
  } while( true );
  if (*(char *)(iVar8 + 0x16) != '\0') {
    *(undefined **)((int)register0x00000010 + -0x80) = &DAT_004c6f09;
    *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x15;
    *(undefined4 *)((int)register0x00000010 + -0x84) = 0x406264;
    FUN_00469970();
    iVar8 = *(int *)((int)register0x00000010 + 8);
  }
  *(undefined4 *)((int)register0x00000010 + -0x14) = *(undefined4 *)((int)register0x00000010 + 0xc);
  *(undefined4 *)((int)register0x00000010 + -0x10) = *(undefined4 *)((int)register0x00000010 + 0x10)
  ;
  pcVar2 = (code *)**(undefined4 **)(*(int *)((int)register0x00000010 + 4) + 0x2c);
  uVar7 = *(undefined4 *)(iVar8 + 8);
  *(undefined1 **)((int)register0x00000010 + -0x80) =
       (undefined1 *)((int)register0x00000010 + -0x14);
  *(undefined4 *)((int)register0x00000010 + -0x7c) = uVar7;
  *(undefined4 *)((int)register0x00000010 + -0x84) = 0x40629d;
  (*pcVar2)();
  puVar4 = *(uint **)((int)register0x00000010 + 8);
  bVar1 = *(byte *)((int)puVar4 + 0x16);
  uVar12 = *(uint *)((int)register0x00000010 + -0x78);
  *(uint *)((int)register0x00000010 + -0x28) = uVar12;
  *(byte *)((int)puVar4 + 0x16) = bVar1 ^ 1;
  if (puVar4[3] == 0) {
    *(uint **)((int)register0x00000010 + -0x80) = puVar4;
    *(undefined4 *)((int)register0x00000010 + -0x7c) = *(undefined4 *)((int)register0x00000010 + 4);
    *(undefined4 *)((int)register0x00000010 + -0x84) = 0x4062d0;
    FUN_004034a0();
    puVar4 = *(uint **)((int)register0x00000010 + 8);
    uVar12 = *(uint *)((int)register0x00000010 + -0x28);
  }
  if (puVar4[4] == 0) {
    if (*puVar4 < 8 && puVar4[1] == 0) {
      *(uint **)((int)register0x00000010 + -0x80) = puVar4;
      *(undefined4 *)((int)register0x00000010 + -0x7c) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(uint *)((int)register0x00000010 + -0x78) = uVar12;
      *(undefined4 *)((int)register0x00000010 + -0x74) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x70) =
           *(undefined4 *)((int)register0x00000010 + 0x10);
      *(undefined4 *)((int)register0x00000010 + -0x84) = 0x40634d;
      FUN_00403c90();
      iVar8 = *(int *)((int)register0x00000010 + 8);
      uVar7 = *(undefined4 *)((int)register0x00000010 + -0x6c);
      if (*(char *)(iVar8 + 0x16) == '\0') {
        *(undefined4 *)((int)register0x00000010 + -4) = uVar7;
        *(undefined **)((int)register0x00000010 + -0x80) = &DAT_004c6f09;
        *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x15;
        *(undefined4 *)((int)register0x00000010 + -0x84) = 0x40637a;
        FUN_00469970();
        iVar8 = *(int *)((int)register0x00000010 + 8);
        uVar7 = *(undefined4 *)((int)register0x00000010 + -4);
      }
      *(byte *)(iVar8 + 0x16) = *(byte *)(iVar8 + 0x16) ^ 1;
      *(undefined4 *)((int)register0x00000010 + 0x14) = uVar7;
      return;
    }
    *(uint **)((int)register0x00000010 + -0x80) = puVar4;
    *(undefined4 *)((int)register0x00000010 + -0x7c) = *(undefined4 *)((int)register0x00000010 + 4);
    *(undefined4 *)((int)register0x00000010 + -0x84) = 0x406309;
    FUN_00403510();
    puVar4 = *(uint **)((int)register0x00000010 + 8);
    uVar12 = *(uint *)((int)register0x00000010 + -0x28);
  }
  iVar8 = *(int *)((int)register0x00000010 + 4);
LAB_004063c9:
  if (puVar4[4] == 1) {
    uVar10 = 0;
  }
  else {
    uVar10 = uVar12 >> (*(byte *)((int)puVar4 + 0x15) & 0x1f) &
             -(uint)((*(byte *)((int)puVar4 + 0x15) & 0x3f) < 0x20);
  }
  iVar6 = *(int *)(puVar4[3] + uVar10 * 4);
  *(int *)((int)register0x00000010 + -0x1c) = iVar6;
  uVar10 = *(uint *)(iVar6 + 0x10);
  uVar7 = *(undefined4 *)(iVar6 + 0x14);
  uVar12 = uVar12 >> 7 & uVar10;
  *(undefined4 *)((int)register0x00000010 + -0x84) = 0x40640b;
  FUN_0046ef4a();
  *(uint *)((int)register0x00000010 + -0x60) = uVar10;
  *(undefined4 *)((int)register0x00000010 + -0x5c) = uVar7;
  *(uint *)((int)register0x00000010 + -0x58) = uVar12;
  puVar4 = (uint *)0x0;
  uVar12 = 0;
  do {
    *(uint **)((int)register0x00000010 + -8) = puVar4;
    *(uint *)((int)register0x00000010 + -0x24) = uVar12;
    puVar4 = (uint *)(*(int *)((int)register0x00000010 + -0x58) * *(int *)(iVar8 + 0x30) +
                     *(int *)(*(int *)((int)register0x00000010 + -0x1c) + 0xc));
    uVar10 = *(uint *)((int)register0x00000010 + -0x28);
    uVar15 = uVar10 & 0x7f;
    *(uint *)((int)register0x00000010 + -100) = uVar15;
    *(uint **)((int)register0x00000010 + -0xc) = puVar4;
    uVar5 = uVar15 * 0x1010101 ^ *puVar4;
    uVar11 = uVar15 * 0x1010101 ^ puVar4[1];
    uVar15 = uVar5 + 0xfefefeff & ~uVar5 & 0x80808080;
    iVar8 = *(int *)((int)register0x00000010 + 4);
    iVar6 = *(int *)((int)register0x00000010 + 0x10);
    for (uVar5 = uVar11 + 0xfefefefe + (uint)(0x1010100 < uVar5) & ~uVar11 & 0x80808080;
        uVar5 != 0 || uVar15 != 0; uVar5 = uVar5 & (uVar5 - 1) + (uint)bVar19) {
      uVar10 = 0;
      if (uVar15 != 0) {
        for (; (uVar15 >> uVar10 & 1) == 0; uVar10 = uVar10 + 1) {
        }
      }
      if (uVar15 == 0) {
        iVar17 = 0;
        if (uVar5 != 0) {
          for (; (uVar5 >> iVar17 & 1) == 0; iVar17 = iVar17 + 1) {
          }
        }
        if (uVar5 == 0) {
          iVar17 = 0x20;
        }
        uVar10 = iVar17 + 0x20;
      }
      puVar18 = (undefined4 *)(uVar10 >> 3);
      puVar16 = (undefined4 *)
                (*(int *)(iVar8 + 0x34) * (int)puVar18 + 8 +
                *(int *)((int)register0x00000010 + -0xc));
      if (puVar16[1] == iVar6) {
        *(undefined4 **)((int)register0x00000010 + -0x68) = puVar18;
        *(undefined4 **)((int)register0x00000010 + -0x20) = puVar16;
        *(uint *)((int)register0x00000010 + -0x2c) = uVar5;
        *(uint *)((int)register0x00000010 + -0x30) = uVar15;
        uVar7 = *puVar16;
        *(undefined4 *)((int)register0x00000010 + -0x80) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x7c) = uVar7;
        *(int *)((int)register0x00000010 + -0x78) = iVar6;
        *(undefined4 *)((int)register0x00000010 + -0x84) = 0x40661d;
        FUN_00402aa0();
        if (*(char *)((int)register0x00000010 + -0x74) != '\0') {
          puVar16 = *(undefined4 **)((int)register0x00000010 + -0x20);
          puVar16[1] = *(undefined4 *)((int)register0x00000010 + 0x10);
          if (DAT_005f5fd0 == 0) {
            uVar7 = *(undefined4 *)((int)register0x00000010 + 0xc);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x84) = 0x40666b;
            FUN_0046ed80();
            uVar7 = *(undefined4 *)((int)register0x00000010 + 0xc);
            *puVar18 = uVar7;
            puVar18[1] = *puVar16;
          }
          *puVar16 = uVar7;
          iVar8 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x34) *
                  *(int *)((int)register0x00000010 + -0x68) +
                  *(int *)(*(int *)((int)register0x00000010 + 4) + 0x38) + 8 +
                  *(int *)((int)register0x00000010 + -0xc);
          puVar4 = *(uint **)((int)register0x00000010 + 8);
          goto LAB_00406725;
        }
        iVar6 = *(int *)((int)register0x00000010 + 0x10);
        uVar12 = *(uint *)((int)register0x00000010 + -0x24);
        iVar8 = *(int *)((int)register0x00000010 + 4);
        uVar15 = *(uint *)((int)register0x00000010 + -0x30);
        uVar5 = *(uint *)((int)register0x00000010 + -0x2c);
      }
      bVar19 = uVar15 != 0;
      uVar15 = uVar15 - 1 & uVar15;
      uVar10 = *(uint *)((int)register0x00000010 + -0x28);
    }
    puVar3 = *(uint **)((int)register0x00000010 + -0xc);
    uVar15 = *puVar3 & 0x80808080;
    uVar5 = puVar3[1] & 0x80808080;
    puVar16 = (undefined4 *)CONCAT31((int3)(uVar10 >> 8),uVar15 == 0);
    if (uVar5 == 0 && uVar15 == 0) {
      puVar4 = *(uint **)((int)register0x00000010 + -8);
    }
    else {
      uVar10 = 0;
      if (uVar15 != 0) {
        for (; (uVar15 >> uVar10 & 1) == 0; uVar10 = uVar10 + 1) {
        }
      }
      if (uVar15 == 0) {
        iVar6 = 0;
        if (uVar5 != 0) {
          for (; (uVar5 >> iVar6 & 1) == 0; iVar6 = iVar6 + 1) {
          }
        }
        if (uVar5 == 0) {
          iVar6 = 0x20;
        }
        uVar10 = iVar6 + 0x20;
      }
      uVar10 = uVar10 >> 3;
      if (*(char *)((int)puVar3 + uVar10) != -2) break;
      puVar4 = *(uint **)((int)register0x00000010 + -8);
      if (*(uint **)((int)register0x00000010 + -8) == (uint *)0x0) {
        uVar12 = uVar10;
        puVar4 = puVar3;
      }
    }
    *(uint *)((int)register0x00000010 + -0x24) = uVar12;
    *(undefined4 *)((int)register0x00000010 + -0x84) = 0x406464;
    FUN_0046f424();
    uVar12 = *(uint *)((int)register0x00000010 + -0x38);
    iVar6 = *(int *)((int)register0x00000010 + -0x34);
    *(uint *)((int)register0x00000010 + -0x38) = uVar12 + 1;
    *(uint *)((int)register0x00000010 + -0x34) = iVar6 + (uint)(0xfffffffe < uVar12);
    uVar10 = *(uint *)((int)register0x00000010 + -0x40);
    uVar15 = uVar12 + uVar10;
    *(uint *)((int)register0x00000010 + -0x40) =
         uVar15 + 1 & *(uint *)((int)register0x00000010 + -0x48);
    *(uint *)((int)register0x00000010 + -0x3c) =
         iVar6 + *(int *)((int)register0x00000010 + -0x3c) + (uint)CARRY4(uVar12,uVar10) +
         (uint)(0xfffffffe < uVar15) & *(uint *)((int)register0x00000010 + -0x44);
    *(undefined4 *)((int)register0x00000010 + -0x84) = 0x4064ad;
    FUN_0046f424();
    uVar12 = *(uint *)((int)register0x00000010 + -0x24);
  } while( true );
  if (*(int *)((int)register0x00000010 + -8) == 0) {
    psVar13 = *(short **)((int)register0x00000010 + -0x1c);
  }
  else {
    *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + -8);
    psVar13 = *(short **)((int)register0x00000010 + -0x1c);
    psVar13[2] = psVar13[2] + 1;
    uVar10 = uVar12;
  }
  if (psVar13[2] != 0) {
    puVar18 = (undefined4 *)
              (*(int *)(iVar8 + 0x34) * uVar10 + 8 + *(int *)((int)register0x00000010 + -0xc));
    puVar18[1] = *(undefined4 *)((int)register0x00000010 + 0x10);
    if (DAT_005f5fd0 == 0) {
      uVar7 = *(undefined4 *)((int)register0x00000010 + 0xc);
    }
    else {
      *(undefined4 *)((int)register0x00000010 + -0x84) = 0x4066d2;
      FUN_0046ed80();
      uVar7 = *(undefined4 *)((int)register0x00000010 + 0xc);
      *puVar16 = uVar7;
      puVar16[1] = *puVar18;
    }
    *puVar18 = uVar7;
    iVar6 = *(int *)(iVar8 + 0x34);
    iVar17 = *(int *)(iVar8 + 0x38);
    iVar8 = *(int *)((int)register0x00000010 + -0xc);
    *(char *)(iVar8 + uVar10) = (char)*(undefined4 *)((int)register0x00000010 + -100);
    psVar13[2] = psVar13[2] + -1;
    *psVar13 = *psVar13 + 1;
    puVar4 = *(uint **)((int)register0x00000010 + 8);
    uVar12 = *puVar4;
    iVar8 = iVar6 * uVar10 + iVar17 + 8 + iVar8;
    *puVar4 = uVar12 + 1;
    puVar4[1] = puVar4[1] + (uint)(0xfffffffe < uVar12);
LAB_00406725:
    if (*(char *)((int)puVar4 + 0x16) == '\0') {
      *(int *)((int)register0x00000010 + -0x18) = iVar8;
      *(undefined **)((int)register0x00000010 + -0x80) = &DAT_004c6f09;
      *(undefined4 *)((int)register0x00000010 + -0x7c) = 0x15;
      *(undefined4 *)((int)register0x00000010 + -0x84) = 0x406747;
      FUN_00469970();
      iVar8 = *(int *)((int)register0x00000010 + -0x18);
      puVar4 = *(uint **)((int)register0x00000010 + 8);
    }
    *(byte *)((int)puVar4 + 0x16) = *(byte *)((int)puVar4 + 0x16) ^ 1;
    *(int *)((int)register0x00000010 + 0x14) = iVar8;
    return;
  }
  *(short **)((int)register0x00000010 + -0x80) = psVar13;
  *(int *)((int)register0x00000010 + -0x7c) = iVar8;
  *(undefined4 *)((int)register0x00000010 + -0x78) = *(undefined4 *)((int)register0x00000010 + 8);
  *(undefined4 *)((int)register0x00000010 + -0x84) = 0x4063b1;
  FUN_00404430();
  puVar4 = *(uint **)((int)register0x00000010 + 8);
  iVar8 = *(int *)((int)register0x00000010 + 4);
  uVar12 = *(uint *)((int)register0x00000010 + -0x28);
  goto LAB_004063c9;
}



/* Function: FUN_004067a0 */

void FUN_004067a0(int param_1,int *param_2,undefined4 param_3)

{
  uint uVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  undefined4 *puVar6;
  uint in_ESI;
  int in_FS_OFFSET;
  bool bVar7;
  uint local_5c;
  undefined4 local_58;
  char local_4c;
  uint local_40;
  uint local_10;
  int local_8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if ((param_2 == (int *)0x0) || (param_2[1] == 0 && *param_2 == 0)) {
    FUN_00468650(param_1,param_3);
    if (local_5c == 0) {
      return;
    }
    FUN_00469650(*(undefined4 *)(local_5c + 4),local_58);
    goto LAB_00406907;
  }
  if (*(char *)((int)param_2 + 0x16) != '\0') {
    FUN_00469970("concurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Gr..." /* TRUNCATED STRING LITERAL */
                 ,0x21);
  }
  (*(code *)**(undefined4 **)(param_1 + 0x2c))(param_3,param_2[2]);
  if (param_2[4] == 0) {
    FUN_004030a0(param_2,param_1);
    if (local_4c != '\0') {
      return;
    }
    return;
  }
  if (param_2[4] == 1) {
    uVar1 = 0;
  }
  else {
    uVar1 = local_5c >> (*(byte *)((int)param_2 + 0x15) & 0x1f) &
            -(uint)((*(byte *)((int)param_2 + 0x15) & 0x3f) < 0x20);
  }
  local_10 = local_5c;
  local_8 = *(int *)(param_2[3] + uVar1 * 4);
  local_40 = local_5c >> 7 & *(uint *)(local_8 + 0x10);
  in_ESI = local_5c;
  FUN_0046ef4a();
  do {
    puVar2 = (uint *)(local_40 * *(int *)(param_1 + 0x30) + *(int *)(local_8 + 0xc));
    uVar1 = (in_ESI & 0x7f) * 0x1010101 ^ *puVar2;
    uVar4 = (in_ESI & 0x7f) * 0x1010101 ^ puVar2[1];
    uVar3 = uVar1 + 0xfefefeff & ~uVar1 & 0x80808080;
    for (uVar1 = uVar4 + 0xfefefefe + (uint)(0x1010100 < uVar1) & ~uVar4 & 0x80808080;
        uVar1 != 0 || uVar3 != 0; uVar1 = uVar1 & (uVar1 - 1) + (uint)bVar7) {
      uVar4 = 0;
      if (uVar3 != 0) {
        for (; (uVar3 >> uVar4 & 1) == 0; uVar4 = uVar4 + 1) {
        }
      }
      if (uVar3 == 0) {
        iVar5 = 0;
        if (uVar1 != 0) {
          for (; (uVar1 >> iVar5 & 1) == 0; iVar5 = iVar5 + 1) {
          }
        }
        if (uVar1 == 0) {
          iVar5 = 0x20;
        }
        uVar4 = iVar5 + 0x20;
      }
      puVar6 = (undefined4 *)((uVar4 >> 3) * *(int *)(param_1 + 0x34) + 8 + (int)puVar2);
      if ((*(uint *)(param_1 + 0x3c) & 4) != 0) {
        puVar6 = (undefined4 *)*puVar6;
      }
      (*(code *)**(undefined4 **)(*(int *)(param_1 + 0x20) + 0x10))(param_3,puVar6);
      if ((char)local_5c != '\0') {
        return;
      }
      bVar7 = uVar3 != 0;
      uVar3 = uVar3 - 1 & uVar3;
      in_ESI = local_10;
    }
    if ((puVar2[1] & ~(puVar2[1] << 6) & 0x80808080) != 0 ||
        (~(*puVar2 << 6) & *puVar2 & 0x80808080) != 0) {
      return;
    }
LAB_00406907:
    FUN_0046f424();
    FUN_0046f424();
  } while( true );
}



/* Function: FUN_00406ae0 */

void FUN_00406ae0(void)

{
  byte bVar1;
  code *pcVar2;
  short *psVar3;
  undefined4 uVar4;
  int *piVar5;
  int iVar6;
  undefined *puVar7;
  uint uVar8;
  int iVar9;
  int iVar10;
  uint uVar11;
  undefined4 *puVar12;
  uint uVar13;
  uint *puVar14;
  uint uVar15;
  undefined1 *puVar16;
  int *piVar17;
  int in_FS_OFFSET;
  
  do {
    puVar16 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) <
        (undefined1 *)((int)register0x00000010 + -8)) {
      puVar16 = (undefined1 *)((int)register0x00000010 + -0x88);
      iVar6 = *(int *)((int)register0x00000010 + 8);
      if (iVar6 != 0) {
        if (*(char *)(iVar6 + 0x16) != '\0') {
          *(undefined **)((int)register0x00000010 + -0x88) = &DAT_004c6f09;
          *(undefined4 *)((int)register0x00000010 + -0x84) = 0x15;
          *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406b2b;
          FUN_00469970();
          iVar6 = *(int *)((int)register0x00000010 + 8);
        }
        pcVar2 = (code *)**(undefined4 **)(*(int *)((int)register0x00000010 + 4) + 0x2c);
        uVar4 = *(undefined4 *)(iVar6 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x88) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x84) = uVar4;
        *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406b51;
        (*pcVar2)();
        puVar14 = *(uint **)((int)register0x00000010 + 8);
        bVar1 = *(byte *)((int)puVar14 + 0x16);
        uVar13 = *(uint *)((int)register0x00000010 + -0x80);
        *(uint *)((int)register0x00000010 + -0x34) = uVar13;
        *(byte *)((int)puVar14 + 0x16) = bVar1 ^ 1;
        if (puVar14[3] == 0) {
          *(uint **)((int)register0x00000010 + -0x88) = puVar14;
          *(undefined4 *)((int)register0x00000010 + -0x84) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406b84;
          FUN_004034a0();
          puVar14 = *(uint **)((int)register0x00000010 + 8);
          uVar13 = *(uint *)((int)register0x00000010 + -0x34);
        }
        if (puVar14[4] == 0) {
          if (puVar14[1] == 0 && *puVar14 < 8) {
            *(uint **)((int)register0x00000010 + -0x88) = puVar14;
            *(undefined4 *)((int)register0x00000010 + -0x84) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(uint *)((int)register0x00000010 + -0x80) = uVar13;
            *(undefined4 *)((int)register0x00000010 + -0x7c) =
                 *(undefined4 *)((int)register0x00000010 + 0xc);
            *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406bf6;
            FUN_004031c0();
            iVar6 = *(int *)((int)register0x00000010 + 8);
            uVar4 = *(undefined4 *)((int)register0x00000010 + -0x78);
            if (*(char *)(iVar6 + 0x16) == '\0') {
              *(undefined4 *)((int)register0x00000010 + -4) = uVar4;
              *(undefined **)((int)register0x00000010 + -0x88) = &DAT_004c6f09;
              *(undefined4 *)((int)register0x00000010 + -0x84) = 0x15;
              *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406c26;
              FUN_00469970();
              iVar6 = *(int *)((int)register0x00000010 + 8);
              uVar4 = *(undefined4 *)((int)register0x00000010 + -4);
            }
            *(byte *)(iVar6 + 0x16) = *(byte *)(iVar6 + 0x16) ^ 1;
            *(undefined4 *)((int)register0x00000010 + 0x10) = uVar4;
            return;
          }
          *(uint **)((int)register0x00000010 + -0x88) = puVar14;
          *(undefined4 *)((int)register0x00000010 + -0x84) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406bbd;
          FUN_00403510();
          puVar14 = *(uint **)((int)register0x00000010 + 8);
          uVar13 = *(uint *)((int)register0x00000010 + -0x34);
        }
        iVar6 = *(int *)((int)register0x00000010 + 4);
        while( true ) {
          if (puVar14[4] == 1) {
            uVar8 = 0;
          }
          else {
            uVar8 = uVar13 >> (*(byte *)((int)puVar14 + 0x15) & 0x1f) &
                    -(uint)((*(byte *)((int)puVar14 + 0x15) & 0x3f) < 0x20);
          }
          iVar10 = *(int *)(puVar14[3] + uVar8 * 4);
          *(int *)((int)register0x00000010 + -0x18) = iVar10;
          uVar8 = *(uint *)(iVar10 + 0x10);
          uVar4 = *(undefined4 *)(iVar10 + 0x14);
          uVar13 = uVar13 >> 7 & uVar8;
          *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406cba;
          FUN_0046ef4a();
          *(uint *)((int)register0x00000010 + -0x70) = uVar8;
          *(undefined4 *)((int)register0x00000010 + -0x6c) = uVar4;
          *(uint *)((int)register0x00000010 + -0x68) = uVar13;
          uVar4 = 0;
          uVar13 = 0;
          while( true ) {
            *(undefined4 *)((int)register0x00000010 + -8) = uVar4;
            *(uint *)((int)register0x00000010 + -0x28) = uVar13;
            iVar10 = *(int *)((int)register0x00000010 + -0x18);
            puVar14 = (uint *)(*(int *)((int)register0x00000010 + -0x68) * *(int *)(iVar6 + 0x30) +
                              *(int *)(iVar10 + 0xc));
            piVar17 = *(int **)((int)register0x00000010 + -0x34);
            uVar8 = (uint)piVar17 & 0x7f;
            *(uint *)((int)register0x00000010 + -0x74) = uVar8;
            *(uint **)((int)register0x00000010 + -0xc) = puVar14;
            uVar13 = uVar8 * 0x1010101 ^ *puVar14;
            uVar8 = uVar8 * 0x1010101 ^ puVar14[1];
            uVar15 = uVar13 + 0xfefefeff & ~uVar13 & 0x80808080;
            for (uVar13 = uVar8 + 0xfefefefe + (uint)(0x1010100 < uVar13) & ~uVar8 & 0x80808080;
                uVar13 != 0 || uVar15 != 0;
                uVar13 = *(uint *)((int)register0x00000010 + -0x3c) &
                         (*(uint *)((int)register0x00000010 + -0x3c) - 1) + (uint)(uVar13 != 0)) {
              *(uint *)((int)register0x00000010 + -0x40) = uVar15;
              *(uint *)((int)register0x00000010 + -0x3c) = uVar13;
              uVar8 = *(uint *)(iVar6 + 0x3c);
              uVar11 = 0;
              if (uVar15 != 0) {
                for (; (uVar15 >> uVar11 & 1) == 0; uVar11 = uVar11 + 1) {
                }
              }
              if (uVar15 == 0) {
                iVar10 = 0;
                if (uVar13 != 0) {
                  for (; (uVar13 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
                  }
                }
                if (uVar13 == 0) {
                  iVar10 = 0x20;
                }
                uVar11 = iVar10 + 0x20;
              }
              puVar12 = (undefined4 *)
                        ((uVar11 >> 3) * *(int *)(iVar6 + 0x34) + 8 +
                        *(int *)((int)register0x00000010 + -0xc));
              *(undefined4 **)((int)register0x00000010 + -0x1c) = puVar12;
              if ((uVar8 & 4) != 0) {
                puVar12 = (undefined4 *)*puVar12;
              }
              *(undefined4 **)((int)register0x00000010 + -0x14) = puVar12;
              pcVar2 = (code *)**(undefined4 **)(*(int *)(iVar6 + 0x20) + 0x10);
              *(undefined4 *)((int)register0x00000010 + -0x88) =
                   *(undefined4 *)((int)register0x00000010 + 0xc);
              *(undefined4 **)((int)register0x00000010 + -0x84) = puVar12;
              *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406f3e;
              (*pcVar2)();
              if (*(char *)((int)register0x00000010 + -0x80) != '\0') {
                iVar6 = *(int *)((int)register0x00000010 + 4);
                if ((*(uint *)(iVar6 + 0x3c) & 1) != 0) {
                  *(undefined4 *)((int)register0x00000010 + -0x88) = *(undefined4 *)(iVar6 + 0x20);
                  *(undefined4 *)((int)register0x00000010 + -0x84) =
                       *(undefined4 *)((int)register0x00000010 + -0x14);
                  *(undefined4 *)((int)register0x00000010 + -0x80) =
                       *(undefined4 *)((int)register0x00000010 + 0xc);
                  *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406f7b;
                  FUN_004687c0();
                  iVar6 = *(int *)((int)register0x00000010 + 4);
                }
                iVar10 = *(int *)(iVar6 + 0x38) + *(int *)((int)register0x00000010 + -0x1c);
                if ((*(uint *)(iVar6 + 0x3c) & 8) != 0) {
                  iVar10 = *(int *)(*(int *)((int)register0x00000010 + -0x1c) +
                                   *(int *)(iVar6 + 0x38));
                }
                puVar14 = *(uint **)((int)register0x00000010 + 8);
                goto LAB_004070b4;
              }
              uVar13 = *(uint *)((int)register0x00000010 + -0x40);
              uVar15 = uVar13 - 1 & uVar13;
              iVar6 = *(int *)((int)register0x00000010 + 4);
              iVar10 = *(int *)((int)register0x00000010 + -0x18);
              piVar17 = *(int **)((int)register0x00000010 + -0x34);
            }
            puVar14 = *(uint **)((int)register0x00000010 + -0xc);
            uVar13 = *puVar14;
            *(uint *)((int)register0x00000010 + -0x30) = uVar13;
            uVar8 = puVar14[1];
            *(uint *)((int)register0x00000010 + -0x2c) = uVar8;
            uVar15 = ~(uVar13 << 6) & uVar13 & 0x80808080;
            *(uint *)((int)register0x00000010 + -0x40) = uVar15;
            uVar13 = ~(uVar8 << 6) & *(uint *)((int)register0x00000010 + -0x2c) & 0x80808080;
            *(uint *)((int)register0x00000010 + -0x3c) = uVar13;
            if (uVar13 != 0 || uVar15 != 0) break;
            if (*(uint **)((int)register0x00000010 + -8) == (uint *)0x0) {
              uVar8 = *(uint *)((int)register0x00000010 + -0x30) & 0x80808080;
              uVar15 = *(uint *)((int)register0x00000010 + -0x2c) & 0x80808080;
              if (uVar15 == 0 && uVar8 == 0) {
                puVar14 = (uint *)0x0;
                uVar13 = *(uint *)((int)register0x00000010 + -0x28);
              }
              else {
                uVar13 = 0;
                if (uVar8 != 0) {
                  for (; (uVar8 >> uVar13 & 1) == 0; uVar13 = uVar13 + 1) {
                  }
                }
                if (uVar8 == 0) {
                  iVar10 = 0;
                  if (uVar15 != 0) {
                    for (; (uVar15 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
                    }
                  }
                  if (uVar15 == 0) {
                    iVar10 = 0x20;
                  }
                  uVar13 = iVar10 + 0x20;
                }
                uVar13 = uVar13 >> 3;
              }
            }
            else {
              uVar13 = *(uint *)((int)register0x00000010 + -0x28);
              puVar14 = *(uint **)((int)register0x00000010 + -8);
            }
            *(uint **)((int)register0x00000010 + -8) = puVar14;
            *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406d32;
            FUN_0046f424();
            uVar8 = *(uint *)((int)register0x00000010 + -0x48);
            iVar10 = *(int *)((int)register0x00000010 + -0x44);
            *(uint *)((int)register0x00000010 + -0x48) = uVar8 + 1;
            *(uint *)((int)register0x00000010 + -0x44) = iVar10 + (uint)(0xfffffffe < uVar8);
            uVar15 = *(uint *)((int)register0x00000010 + -0x50);
            uVar11 = uVar8 + uVar15;
            *(uint *)((int)register0x00000010 + -0x50) =
                 uVar11 + 1 & *(uint *)((int)register0x00000010 + -0x58);
            *(uint *)((int)register0x00000010 + -0x4c) =
                 iVar10 + *(int *)((int)register0x00000010 + -0x4c) + (uint)CARRY4(uVar8,uVar15) +
                 (uint)(0xfffffffe < uVar11) & *(uint *)((int)register0x00000010 + -0x54);
            *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406d7b;
            FUN_0046f424();
            uVar4 = *(undefined4 *)((int)register0x00000010 + -8);
          }
          if (*(int *)((int)register0x00000010 + -8) == 0) {
            uVar8 = *(uint *)((int)register0x00000010 + -0x40);
            uVar15 = *(uint *)((int)register0x00000010 + -0x3c);
            uVar13 = 0;
            if (uVar8 != 0) {
              for (; (uVar8 >> uVar13 & 1) == 0; uVar13 = uVar13 + 1) {
              }
            }
            if (uVar8 == 0) {
              iVar9 = 0;
              if (uVar15 != 0) {
                for (; (uVar15 >> iVar9 & 1) == 0; iVar9 = iVar9 + 1) {
                }
              }
              if (uVar15 == 0) {
                iVar9 = 0x20;
              }
              uVar13 = iVar9 + 0x20;
            }
            uVar13 = uVar13 >> 3;
          }
          else {
            *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + -8);
            *(short *)(iVar10 + 4) = *(short *)(iVar10 + 4) + 1;
            uVar13 = *(uint *)((int)register0x00000010 + -0x28);
          }
          if (*(short *)(iVar10 + 4) != 0) break;
          *(int *)((int)register0x00000010 + -0x88) = iVar10;
          *(int *)((int)register0x00000010 + -0x84) = iVar6;
          *(undefined4 *)((int)register0x00000010 + -0x80) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406c63;
          FUN_00404430();
          puVar14 = *(uint **)((int)register0x00000010 + 8);
          uVar13 = *(uint *)((int)register0x00000010 + -0x34);
          iVar6 = *(int *)((int)register0x00000010 + 4);
        }
        *(uint *)((int)register0x00000010 + -0x38) = uVar13;
        uVar8 = *(uint *)(iVar6 + 0x3c);
        iVar10 = *(int *)(iVar6 + 0x34) * uVar13 + 8 + *(int *)((int)register0x00000010 + -0xc);
        *(int *)((int)register0x00000010 + -0x20) = iVar10;
        if ((uVar8 & 4) != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x88) = *(undefined4 *)(iVar6 + 0x20);
          *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406fd2;
          FUN_00468540();
          iVar10 = *(int *)((int)register0x00000010 + -0x84);
          if (DAT_005f5fd0 == 0) {
            piVar5 = *(int **)((int)register0x00000010 + -0x20);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x406feb;
            FUN_0046ed80();
            *piVar17 = iVar10;
            piVar5 = *(int **)((int)register0x00000010 + -0x20);
            piVar17[1] = *piVar5;
          }
          *piVar5 = iVar10;
          iVar6 = *(int *)((int)register0x00000010 + 4);
        }
        *(undefined4 *)((int)register0x00000010 + -0x88) = *(undefined4 *)(iVar6 + 0x20);
        *(int *)((int)register0x00000010 + -0x84) = iVar10;
        *(undefined4 *)((int)register0x00000010 + -0x80) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x40701b;
        FUN_004687c0();
        iVar6 = *(int *)((int)register0x00000010 + 4);
        iVar10 = *(int *)(iVar6 + 0x38) + *(int *)((int)register0x00000010 + -0x20);
        if ((*(uint *)(iVar6 + 0x3c) & 8) != 0) {
          *(int *)((int)register0x00000010 + -0x24) = *(int *)(iVar6 + 0x38);
          *(undefined4 *)((int)register0x00000010 + -0x88) = *(undefined4 *)(iVar6 + 0x24);
          *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x407046;
          FUN_00468540();
          iVar10 = *(int *)((int)register0x00000010 + -0x84);
          if (DAT_005f5fd0 == 0) {
            iVar6 = *(int *)((int)register0x00000010 + -0x24);
            iVar9 = *(int *)((int)register0x00000010 + -0x20);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x407063;
            FUN_0046ed80();
            *piVar17 = iVar10;
            iVar6 = *(int *)((int)register0x00000010 + -0x24);
            iVar9 = *(int *)((int)register0x00000010 + -0x20);
            piVar17[1] = *(int *)(iVar9 + iVar6);
          }
          *(int *)(iVar9 + iVar6) = iVar10;
        }
        *(char *)(*(int *)((int)register0x00000010 + -0xc) +
                 *(int *)((int)register0x00000010 + -0x38)) =
             (char)*(undefined4 *)((int)register0x00000010 + -0x74);
        psVar3 = *(short **)((int)register0x00000010 + -0x18);
        psVar3[2] = psVar3[2] + -1;
        *psVar3 = *psVar3 + 1;
        puVar14 = *(uint **)((int)register0x00000010 + 8);
        uVar13 = *puVar14;
        *puVar14 = uVar13 + 1;
        puVar14[1] = puVar14[1] + (uint)(0xfffffffe < uVar13);
LAB_004070b4:
        if (*(char *)((int)puVar14 + 0x16) == '\0') {
          *(int *)((int)register0x00000010 + -0x10) = iVar10;
          *(undefined **)((int)register0x00000010 + -0x88) = &DAT_004c6f09;
          *(undefined4 *)((int)register0x00000010 + -0x84) = 0x15;
          *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x4070d6;
          FUN_00469970();
          puVar14 = *(uint **)((int)register0x00000010 + 8);
          iVar10 = *(int *)((int)register0x00000010 + -0x10);
        }
        *(byte *)((int)puVar14 + 0x16) = *(byte *)((int)puVar14 + 0x16) ^ 1;
        *(int *)((int)register0x00000010 + 0x10) = iVar10;
        return;
      }
      puVar7 = PTR_PTR_005cf0f8;
      if (PTR_PTR_005cf0f8 != (undefined *)0x0) {
        puVar7 = *(undefined **)(PTR_PTR_005cf0f8 + 4);
      }
      *(undefined **)((int)register0x00000010 + -0x88) = puVar7;
      *(undefined **)((int)register0x00000010 + -0x84) = PTR_PTR_005cf0fc;
      *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x407118;
      FUN_00469650();
    }
    *(undefined4 *)(puVar16 + -4) = 0x40711e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar16;
  } while( true );
}



/* Function: FUN_004072f0 */

void FUN_004072f0(int param_1)

{
  int iVar1;
  int iVar2;
  int in_FS_OFFSET;
  undefined *puVar3;
  undefined *puVar4;
  undefined *puVar5;
  undefined *puVar6;
  char local_2c;
  code *local_1c;
  undefined *local_18;
  code *local_14;
  undefined *local_10;
  code **local_c;
  code **local_8;
  undefined **local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (undefined **)0x407497;
    FUN_0046d980();
  }
  local_c = (code **)0x0;
  local_8 = (code **)0x0;
  local_4 = (undefined **)0x0;
  while( true ) {
    puVar3 = &DAT_005f5ebc;
    puVar4 = (undefined *)0x0;
    puVar6 = (undefined *)0x1;
    thunk_FUN_00402540();
    if (local_2c != '\0') break;
    (*(code *)*DAT_005d6e88)();
    puVar5 = puVar4;
    FUN_004027a0(&DAT_005f5f58);
    if (puVar6 == puVar4 && puVar5 == puVar3) {
      (*(code *)*DAT_005d6e8c)(&DAT_004c74e0,0x16);
    }
    (*(code *)*DAT_005d6e84)();
  }
  local_14 = FUN_004074f0;
  local_10 = &DAT_005f5ebc;
  local_c = &local_14;
  (*(code *)*DAT_005d6e88)();
  FUN_004027c0(&DAT_005f5f58,puVar3,puVar4);
  local_1c = FUN_004074a0;
  local_18 = &DAT_005f5f58;
  local_8 = &local_1c;
  local_4 = &PTR_FUN_00536ce8;
  while (DAT_005d7104 != 0) {
    iVar1 = DAT_005d7104 * 8;
    iVar2 = DAT_005d7104 * 8;
    DAT_005d7104 = DAT_005d7104 + -1;
    if ((param_1 == 0) || (*(char *)(DAT_005d7100 + -4 + iVar2) != '\0')) {
      (*(code *)**(undefined4 **)(DAT_005d7100 + -8 + iVar1))();
    }
  }
  FUN_00407540();
  (**local_8)();
  (**local_c)();
  return;
}



/* Function: FUN_004074a0 */

void FUN_004074a0(void)

{
  int *piVar1;
  int in_EDX;
  int in_FS_OFFSET;
  undefined4 local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x4074e0;
    FUN_0046d900();
  }
  piVar1 = *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x10);
  if ((piVar1 != (int *)0x0) && ((undefined1 *)*piVar1 == &stack0x00000004)) {
    *piVar1 = (int)&local_c;
  }
  local_c = *(undefined4 *)(in_EDX + 4);
  local_8 = 0;
  local_4 = 0;
  FUN_004027c0();
  return;
}



/* Function: FUN_004074f0 */

void FUN_004074f0(void)

{
  int *piVar1;
  int in_EDX;
  int in_FS_OFFSET;
  undefined4 local_8;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x407528;
    FUN_0046d900();
  }
  piVar1 = *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x10);
  if ((piVar1 != (int *)0x0) && ((undefined1 *)*piVar1 == &stack0x00000004)) {
    *piVar1 = (int)&local_8;
  }
  local_8 = *(undefined4 *)(in_EDX + 4);
  local_4 = 0;
  thunk_FUN_00402770();
  return;
}



/* Function: FUN_00407540 */

void FUN_00407540(void)

{
  int in_FS_OFFSET;
  int in_stack_fffffff8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00438dc0(&stack0x00000004);
  if (in_stack_fffffff8 != 0) {
    (*(code *)*DAT_005d6e8c)(&DAT_004c7be1,0x17);
  }
  return;
}



/* Function: FUN_00407590 */

void FUN_00407590(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                 undefined4 param_9)

{
  int iVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar1 = param_1;
  FUN_0046f410();
  thunk_FUN_00407b90(param_1 + 0x100,iVar1,0,param_2,param_3,param_4,param_5,param_6,param_7,param_8
                     ,param_9);
  *(undefined4 *)(param_1 + 0x128) = 0;
  *(undefined4 *)(param_1 + 0x120) = 0;
  *(undefined4 *)(param_1 + 0x124) = 0x20;
  return;
}



/* Function: FUN_004077d0 */

void FUN_004077d0(int param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar1 = *(int *)(param_1 + 0x128);
  *(int *)(param_1 + 0x128) = iVar1 + 4;
  if (iVar1 == 0xc) {
    *(undefined4 *)(param_1 + 0x100) = *(undefined4 *)(param_1 + 0xe0);
    *(undefined4 *)(param_1 + 0x104) = *(undefined4 *)(param_1 + 0xe4);
    *(undefined4 *)(param_1 + 0x108) = *(undefined4 *)(param_1 + 0xe8);
    *(undefined4 *)(param_1 + 0x10c) = *(undefined4 *)(param_1 + 0xec);
    *(undefined4 *)(param_1 + 0x110) = *(undefined4 *)(param_1 + 0xf0);
    *(undefined4 *)(param_1 + 0x114) = *(undefined4 *)(param_1 + 0xf4);
    *(undefined4 *)(param_1 + 0x118) = *(undefined4 *)(param_1 + 0xf8);
    *(undefined4 *)(param_1 + 0x11c) = *(undefined4 *)(param_1 + 0xfc);
    *(undefined4 *)(param_1 + 0x128) = 0;
  }
  thunk_FUN_00407b90(param_1 + 0x100,param_1,*(undefined4 *)(param_1 + 0x128));
  *(undefined4 *)(param_1 + 0x120) = 0;
  *(undefined4 *)(param_1 + 0x124) = 0x20;
  if (*(int *)(param_1 + 0x128) == 0xc) {
    *(undefined4 *)(param_1 + 0x124) = 0x1c;
  }
  return;
}



/* Function: FUN_004078c0 */

void FUN_004078c0(int param_1)

{
  undefined4 *puVar1;
  uint uVar2;
  undefined4 uVar3;
  int iVar4;
  int in_FS_OFFSET;
  undefined4 local_28 [8];
  int local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x4079ab;
    FUN_0046d980();
  }
  FUN_0046ef48();
  for (iVar4 = 0; iVar4 < 4; iVar4 = iVar4 + 1) {
    while (local_8 = iVar4, iVar4 = local_8, uVar2 = *(uint *)(param_1 + 0x120),
          *(uint *)(param_1 + 0x124) <= uVar2) {
      FUN_004077d0(param_1);
      iVar4 = local_8;
    }
    *(uint *)(param_1 + 0x120) = uVar2 + 1;
    puVar1 = (undefined4 *)(param_1 + (uVar2 & 0x1f) * 8);
    uVar3 = puVar1[1];
    local_28[local_8 * 2] = *puVar1;
    local_28[iVar4 * 2 + 1] = uVar3;
  }
  local_4 = param_1 + 0x100;
  FUN_0046f410();
  thunk_FUN_00407b90(local_4,param_1,0);
  *(undefined4 *)(param_1 + 0x128) = 0;
  *(undefined4 *)(param_1 + 0x120) = 0;
  *(undefined4 *)(param_1 + 0x124) = 0x20;
  return;
}



/* Function: FUN_004079b0 */

void FUN_004079b0(undefined4 *param_1,undefined4 *param_2,int param_3)

{
  undefined4 uVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  *param_2 = 0x61707865;
  param_2[1] = 0x61707865;
  param_2[2] = 0x61707865;
  param_2[3] = 0x61707865;
  param_2[4] = 0x3320646e;
  param_2[5] = 0x3320646e;
  param_2[6] = 0x3320646e;
  param_2[7] = 0x3320646e;
  param_2[8] = 0x79622d32;
  param_2[9] = 0x79622d32;
  param_2[10] = 0x79622d32;
  param_2[0xb] = 0x79622d32;
  param_2[0xc] = 0x6b206574;
  param_2[0xd] = 0x6b206574;
  param_2[0xe] = 0x6b206574;
  param_2[0xf] = 0x6b206574;
  uVar1 = *param_1;
  param_2[0x10] = uVar1;
  param_2[0x11] = uVar1;
  param_2[0x12] = uVar1;
  param_2[0x13] = uVar1;
  uVar1 = param_1[1];
  param_2[0x14] = uVar1;
  param_2[0x15] = uVar1;
  param_2[0x16] = uVar1;
  param_2[0x17] = uVar1;
  uVar1 = param_1[2];
  param_2[0x18] = uVar1;
  param_2[0x19] = uVar1;
  param_2[0x1a] = uVar1;
  param_2[0x1b] = uVar1;
  uVar1 = param_1[3];
  param_2[0x1c] = uVar1;
  param_2[0x1d] = uVar1;
  param_2[0x1e] = uVar1;
  param_2[0x1f] = uVar1;
  uVar1 = param_1[4];
  param_2[0x20] = uVar1;
  param_2[0x21] = uVar1;
  param_2[0x22] = uVar1;
  param_2[0x23] = uVar1;
  uVar1 = param_1[5];
  param_2[0x24] = uVar1;
  param_2[0x25] = uVar1;
  param_2[0x26] = uVar1;
  param_2[0x27] = uVar1;
  uVar1 = param_1[6];
  param_2[0x28] = uVar1;
  param_2[0x29] = uVar1;
  param_2[0x2a] = uVar1;
  param_2[0x2b] = uVar1;
  uVar1 = param_1[7];
  param_2[0x2c] = uVar1;
  param_2[0x2d] = uVar1;
  param_2[0x2e] = uVar1;
  param_2[0x2f] = uVar1;
  param_2[0x30] = param_3;
  param_2[0x31] = param_3 + 1;
  param_2[0x32] = param_3 + 2;
  param_2[0x33] = param_3 + 3;
  param_2[0x34] = 0;
  param_2[0x35] = 0;
  param_2[0x36] = 0;
  param_2[0x37] = 0;
  param_2[0x38] = 0;
  param_2[0x39] = 0;
  param_2[0x3a] = 0;
  param_2[0x3b] = 0;
  param_2[0x3c] = 0;
  param_2[0x3d] = 0;
  param_2[0x3e] = 0;
  param_2[0x3f] = 0;
  return;
}



/* Function: FUN_00407b90 */

void FUN_00407b90(undefined4 param_1,int param_2,undefined4 param_3)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  int in_FS_OFFSET;
  undefined4 local_50;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004079b0(param_1,param_2,param_3);
  for (iVar5 = 0; iVar5 < 4; iVar5 = iVar5 + 1) {
    local_c = *(uint *)(param_2 + iVar5 * 4);
    uVar8 = *(uint *)(param_2 + 0x10 + iVar5 * 4);
    uVar9 = *(uint *)(param_2 + 0x20 + iVar5 * 4);
    uVar10 = *(uint *)(param_2 + 0x30 + iVar5 * 4);
    uVar3 = *(uint *)(param_2 + 0x40 + iVar5 * 4);
    local_38 = *(uint *)(param_2 + 0x50 + iVar5 * 4);
    local_3c = *(uint *)(param_2 + 0x60 + iVar5 * 4);
    local_40 = *(uint *)(param_2 + 0x70 + iVar5 * 4);
    local_44 = *(uint *)(param_2 + 0x80 + iVar5 * 4);
    local_48 = *(uint *)(param_2 + 0x90 + iVar5 * 4);
    local_14 = *(uint *)(param_2 + 0xa0 + iVar5 * 4);
    local_18 = *(uint *)(param_2 + 0xb0 + iVar5 * 4);
    local_1c = *(uint *)(param_2 + 0xc0 + iVar5 * 4);
    local_20 = *(uint *)(param_2 + 0xd0 + iVar5 * 4);
    uVar6 = *(uint *)(param_2 + 0xe0 + iVar5 * 4);
    uVar4 = *(uint *)(param_2 + 0xf0 + iVar5 * 4);
    for (local_50 = 0; local_50 < 4; local_50 = local_50 + 1) {
      local_1c = local_1c ^ local_c + uVar3;
      uVar2 = local_1c << 0x10 | local_1c >> 0x10;
      local_44 = local_44 + uVar2;
      uVar12 = uVar3 ^ local_44;
      uVar12 = uVar12 << 0xc | uVar12 >> 0x14;
      local_c = local_c + uVar3 + uVar12;
      uVar2 = uVar2 ^ local_c;
      uVar3 = uVar2 << 8 | uVar2 >> 0x18;
      local_44 = local_44 + uVar3;
      uVar12 = uVar12 ^ local_44;
      uVar2 = uVar12 << 7 | uVar12 >> 0x19;
      local_20 = local_20 ^ uVar8 + local_38;
      uVar12 = local_20 << 0x10 | local_20 >> 0x10;
      local_48 = local_48 + uVar12;
      uVar13 = local_38 ^ local_48;
      uVar13 = uVar13 << 0xc | uVar13 >> 0x14;
      uVar8 = uVar8 + local_38 + uVar13;
      uVar12 = uVar12 ^ uVar8;
      uVar11 = uVar12 << 8 | uVar12 >> 0x18;
      local_48 = local_48 + uVar11;
      uVar13 = uVar13 ^ local_48;
      uVar14 = uVar13 << 7 | uVar13 >> 0x19;
      uVar6 = uVar6 ^ uVar9 + local_3c;
      uVar12 = uVar6 << 0x10 | uVar6 >> 0x10;
      local_14 = local_14 + uVar12;
      uVar6 = local_3c ^ local_14;
      uVar6 = uVar6 << 0xc | uVar6 >> 0x14;
      uVar9 = uVar9 + local_3c + uVar6;
      uVar12 = uVar12 ^ uVar9;
      uVar13 = uVar12 << 8 | uVar12 >> 0x18;
      local_14 = local_14 + uVar13;
      uVar6 = uVar6 ^ local_14;
      uVar6 = uVar6 << 7 | uVar6 >> 0x19;
      uVar4 = uVar4 ^ uVar10 + local_40;
      uVar4 = uVar4 << 0x10 | uVar4 >> 0x10;
      local_18 = local_18 + uVar4;
      uVar12 = local_40 ^ local_18;
      uVar12 = uVar12 << 0xc | uVar12 >> 0x14;
      uVar10 = uVar10 + local_40 + uVar12;
      uVar4 = uVar4 ^ uVar10;
      uVar4 = uVar4 << 8 | uVar4 >> 0x18;
      local_18 = local_18 + uVar4;
      uVar12 = uVar12 ^ local_18;
      uVar7 = uVar12 << 7 | uVar12 >> 0x19;
      local_c = local_c + uVar14;
      uVar4 = uVar4 ^ local_c;
      uVar4 = uVar4 << 0x10 | uVar4 >> 0x10;
      local_14 = local_14 + uVar4;
      uVar14 = uVar14 ^ local_14;
      uVar14 = uVar14 << 0xc | uVar14 >> 0x14;
      local_c = local_c + uVar14;
      uVar4 = uVar4 ^ local_c;
      uVar4 = uVar4 << 8 | uVar4 >> 0x18;
      local_14 = local_14 + uVar4;
      uVar14 = uVar14 ^ local_14;
      uVar8 = uVar8 + uVar6;
      uVar3 = uVar3 ^ uVar8;
      uVar3 = uVar3 << 0x10 | uVar3 >> 0x10;
      local_18 = local_18 + uVar3;
      uVar6 = uVar6 ^ local_18;
      uVar12 = uVar6 << 0xc | uVar6 >> 0x14;
      uVar8 = uVar8 + uVar12;
      uVar3 = uVar3 ^ uVar8;
      local_1c = uVar3 << 8 | uVar3 >> 0x18;
      local_18 = local_18 + local_1c;
      uVar12 = uVar12 ^ local_18;
      uVar9 = uVar9 + uVar7;
      uVar11 = uVar11 ^ uVar9;
      uVar3 = uVar11 << 0x10 | uVar11 >> 0x10;
      local_44 = local_44 + uVar3;
      uVar7 = uVar7 ^ local_44;
      uVar7 = uVar7 << 0xc | uVar7 >> 0x14;
      uVar9 = uVar9 + uVar7;
      uVar3 = uVar3 ^ uVar9;
      local_20 = uVar3 << 8 | uVar3 >> 0x18;
      local_44 = local_44 + local_20;
      uVar7 = uVar7 ^ local_44;
      uVar10 = uVar10 + uVar2;
      uVar13 = uVar13 ^ uVar10;
      uVar6 = uVar13 << 0x10 | uVar13 >> 0x10;
      local_48 = local_48 + uVar6;
      uVar2 = uVar2 ^ local_48;
      uVar3 = uVar2 << 0xc | uVar2 >> 0x14;
      uVar10 = uVar10 + uVar3;
      uVar6 = uVar6 ^ uVar10;
      uVar6 = uVar6 << 8 | uVar6 >> 0x18;
      local_48 = local_48 + uVar6;
      uVar3 = uVar3 ^ local_48;
      local_38 = uVar14 << 7 | uVar14 >> 0x19;
      local_3c = uVar12 << 7 | uVar12 >> 0x19;
      local_40 = uVar7 << 7 | uVar7 >> 0x19;
      uVar3 = uVar3 << 7 | uVar3 >> 0x19;
    }
    *(uint *)(param_2 + iVar5 * 4) = local_c;
    *(uint *)(param_2 + 0x10 + iVar5 * 4) = uVar8;
    *(uint *)(param_2 + 0x20 + iVar5 * 4) = uVar9;
    *(uint *)(param_2 + 0x30 + iVar5 * 4) = uVar10;
    piVar1 = (int *)(param_2 + 0x40 + iVar5 * 4);
    *piVar1 = *piVar1 + uVar3;
    piVar1 = (int *)(param_2 + 0x50 + iVar5 * 4);
    *piVar1 = *piVar1 + local_38;
    piVar1 = (int *)(param_2 + 0x60 + iVar5 * 4);
    *piVar1 = *piVar1 + local_3c;
    piVar1 = (int *)(param_2 + 0x70 + iVar5 * 4);
    *piVar1 = *piVar1 + local_40;
    piVar1 = (int *)(param_2 + 0x80 + iVar5 * 4);
    *piVar1 = *piVar1 + local_44;
    piVar1 = (int *)(param_2 + 0x90 + iVar5 * 4);
    *piVar1 = *piVar1 + local_48;
    piVar1 = (int *)(param_2 + 0xa0 + iVar5 * 4);
    *piVar1 = *piVar1 + local_14;
    piVar1 = (int *)(param_2 + 0xb0 + iVar5 * 4);
    *piVar1 = *piVar1 + local_18;
    *(uint *)(param_2 + 0xc0 + iVar5 * 4) = local_1c;
    *(uint *)(param_2 + 0xd0 + iVar5 * 4) = local_20;
    *(uint *)(param_2 + 0xe0 + iVar5 * 4) = uVar6;
    *(uint *)(param_2 + 0xf0 + iVar5 * 4) = uVar4;
  }
  return;
}



/* Function: thunk_FUN_00407b90 */

void thunk_FUN_00407b90(undefined4 param_1,int param_2,undefined4 param_3)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  int in_FS_OFFSET;
  undefined4 uStack_50;
  undefined4 uStack_48;
  undefined4 uStack_44;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined4 uStack_14;
  undefined4 uStack_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004079b0(param_1,param_2,param_3);
  for (iVar5 = 0; iVar5 < 4; iVar5 = iVar5 + 1) {
    uStack_c = *(uint *)(param_2 + iVar5 * 4);
    uVar8 = *(uint *)(param_2 + 0x10 + iVar5 * 4);
    uVar9 = *(uint *)(param_2 + 0x20 + iVar5 * 4);
    uVar10 = *(uint *)(param_2 + 0x30 + iVar5 * 4);
    uVar3 = *(uint *)(param_2 + 0x40 + iVar5 * 4);
    uStack_38 = *(uint *)(param_2 + 0x50 + iVar5 * 4);
    uStack_3c = *(uint *)(param_2 + 0x60 + iVar5 * 4);
    uStack_40 = *(uint *)(param_2 + 0x70 + iVar5 * 4);
    uStack_44 = *(uint *)(param_2 + 0x80 + iVar5 * 4);
    uStack_48 = *(uint *)(param_2 + 0x90 + iVar5 * 4);
    uStack_14 = *(uint *)(param_2 + 0xa0 + iVar5 * 4);
    uStack_18 = *(uint *)(param_2 + 0xb0 + iVar5 * 4);
    uStack_1c = *(uint *)(param_2 + 0xc0 + iVar5 * 4);
    uStack_20 = *(uint *)(param_2 + 0xd0 + iVar5 * 4);
    uVar6 = *(uint *)(param_2 + 0xe0 + iVar5 * 4);
    uVar4 = *(uint *)(param_2 + 0xf0 + iVar5 * 4);
    for (uStack_50 = 0; uStack_50 < 4; uStack_50 = uStack_50 + 1) {
      uStack_1c = uStack_1c ^ uStack_c + uVar3;
      uVar2 = uStack_1c << 0x10 | uStack_1c >> 0x10;
      uStack_44 = uStack_44 + uVar2;
      uVar12 = uVar3 ^ uStack_44;
      uVar12 = uVar12 << 0xc | uVar12 >> 0x14;
      uStack_c = uStack_c + uVar3 + uVar12;
      uVar2 = uVar2 ^ uStack_c;
      uVar3 = uVar2 << 8 | uVar2 >> 0x18;
      uStack_44 = uStack_44 + uVar3;
      uVar12 = uVar12 ^ uStack_44;
      uVar2 = uVar12 << 7 | uVar12 >> 0x19;
      uStack_20 = uStack_20 ^ uVar8 + uStack_38;
      uVar12 = uStack_20 << 0x10 | uStack_20 >> 0x10;
      uStack_48 = uStack_48 + uVar12;
      uVar13 = uStack_38 ^ uStack_48;
      uVar13 = uVar13 << 0xc | uVar13 >> 0x14;
      uVar8 = uVar8 + uStack_38 + uVar13;
      uVar12 = uVar12 ^ uVar8;
      uVar11 = uVar12 << 8 | uVar12 >> 0x18;
      uStack_48 = uStack_48 + uVar11;
      uVar13 = uVar13 ^ uStack_48;
      uVar14 = uVar13 << 7 | uVar13 >> 0x19;
      uVar6 = uVar6 ^ uVar9 + uStack_3c;
      uVar12 = uVar6 << 0x10 | uVar6 >> 0x10;
      uStack_14 = uStack_14 + uVar12;
      uVar6 = uStack_3c ^ uStack_14;
      uVar6 = uVar6 << 0xc | uVar6 >> 0x14;
      uVar9 = uVar9 + uStack_3c + uVar6;
      uVar12 = uVar12 ^ uVar9;
      uVar13 = uVar12 << 8 | uVar12 >> 0x18;
      uStack_14 = uStack_14 + uVar13;
      uVar6 = uVar6 ^ uStack_14;
      uVar6 = uVar6 << 7 | uVar6 >> 0x19;
      uVar4 = uVar4 ^ uVar10 + uStack_40;
      uVar4 = uVar4 << 0x10 | uVar4 >> 0x10;
      uStack_18 = uStack_18 + uVar4;
      uVar12 = uStack_40 ^ uStack_18;
      uVar12 = uVar12 << 0xc | uVar12 >> 0x14;
      uVar10 = uVar10 + uStack_40 + uVar12;
      uVar4 = uVar4 ^ uVar10;
      uVar4 = uVar4 << 8 | uVar4 >> 0x18;
      uStack_18 = uStack_18 + uVar4;
      uVar12 = uVar12 ^ uStack_18;
      uVar7 = uVar12 << 7 | uVar12 >> 0x19;
      uStack_c = uStack_c + uVar14;
      uVar4 = uVar4 ^ uStack_c;
      uVar4 = uVar4 << 0x10 | uVar4 >> 0x10;
      uStack_14 = uStack_14 + uVar4;
      uVar14 = uVar14 ^ uStack_14;
      uVar14 = uVar14 << 0xc | uVar14 >> 0x14;
      uStack_c = uStack_c + uVar14;
      uVar4 = uVar4 ^ uStack_c;
      uVar4 = uVar4 << 8 | uVar4 >> 0x18;
      uStack_14 = uStack_14 + uVar4;
      uVar14 = uVar14 ^ uStack_14;
      uVar8 = uVar8 + uVar6;
      uVar3 = uVar3 ^ uVar8;
      uVar3 = uVar3 << 0x10 | uVar3 >> 0x10;
      uStack_18 = uStack_18 + uVar3;
      uVar6 = uVar6 ^ uStack_18;
      uVar12 = uVar6 << 0xc | uVar6 >> 0x14;
      uVar8 = uVar8 + uVar12;
      uVar3 = uVar3 ^ uVar8;
      uStack_1c = uVar3 << 8 | uVar3 >> 0x18;
      uStack_18 = uStack_18 + uStack_1c;
      uVar12 = uVar12 ^ uStack_18;
      uVar9 = uVar9 + uVar7;
      uVar11 = uVar11 ^ uVar9;
      uVar3 = uVar11 << 0x10 | uVar11 >> 0x10;
      uStack_44 = uStack_44 + uVar3;
      uVar7 = uVar7 ^ uStack_44;
      uVar7 = uVar7 << 0xc | uVar7 >> 0x14;
      uVar9 = uVar9 + uVar7;
      uVar3 = uVar3 ^ uVar9;
      uStack_20 = uVar3 << 8 | uVar3 >> 0x18;
      uStack_44 = uStack_44 + uStack_20;
      uVar7 = uVar7 ^ uStack_44;
      uVar10 = uVar10 + uVar2;
      uVar13 = uVar13 ^ uVar10;
      uVar6 = uVar13 << 0x10 | uVar13 >> 0x10;
      uStack_48 = uStack_48 + uVar6;
      uVar2 = uVar2 ^ uStack_48;
      uVar3 = uVar2 << 0xc | uVar2 >> 0x14;
      uVar10 = uVar10 + uVar3;
      uVar6 = uVar6 ^ uVar10;
      uVar6 = uVar6 << 8 | uVar6 >> 0x18;
      uStack_48 = uStack_48 + uVar6;
      uVar3 = uVar3 ^ uStack_48;
      uStack_38 = uVar14 << 7 | uVar14 >> 0x19;
      uStack_3c = uVar12 << 7 | uVar12 >> 0x19;
      uStack_40 = uVar7 << 7 | uVar7 >> 0x19;
      uVar3 = uVar3 << 7 | uVar3 >> 0x19;
    }
    *(uint *)(param_2 + iVar5 * 4) = uStack_c;
    *(uint *)(param_2 + 0x10 + iVar5 * 4) = uVar8;
    *(uint *)(param_2 + 0x20 + iVar5 * 4) = uVar9;
    *(uint *)(param_2 + 0x30 + iVar5 * 4) = uVar10;
    piVar1 = (int *)(param_2 + 0x40 + iVar5 * 4);
    *piVar1 = *piVar1 + uVar3;
    piVar1 = (int *)(param_2 + 0x50 + iVar5 * 4);
    *piVar1 = *piVar1 + uStack_38;
    piVar1 = (int *)(param_2 + 0x60 + iVar5 * 4);
    *piVar1 = *piVar1 + uStack_3c;
    piVar1 = (int *)(param_2 + 0x70 + iVar5 * 4);
    *piVar1 = *piVar1 + uStack_40;
    piVar1 = (int *)(param_2 + 0x80 + iVar5 * 4);
    *piVar1 = *piVar1 + uStack_44;
    piVar1 = (int *)(param_2 + 0x90 + iVar5 * 4);
    *piVar1 = *piVar1 + uStack_48;
    piVar1 = (int *)(param_2 + 0xa0 + iVar5 * 4);
    *piVar1 = *piVar1 + uStack_14;
    piVar1 = (int *)(param_2 + 0xb0 + iVar5 * 4);
    *piVar1 = *piVar1 + uStack_18;
    *(uint *)(param_2 + 0xc0 + iVar5 * 4) = uStack_1c;
    *(uint *)(param_2 + 0xd0 + iVar5 * 4) = uStack_20;
    *(uint *)(param_2 + 0xe0 + iVar5 * 4) = uVar6;
    *(uint *)(param_2 + 0xf0 + iVar5 * 4) = uVar4;
  }
  return;
}



/* Function: FUN_00408130 */

void FUN_00408130(float *param_1,undefined4 param_2)

{
  float fVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  fVar1 = *param_1;
  if ((fVar1 == 0.0) && (!NAN(fVar1))) {
    return;
  }
  if (NAN(fVar1)) {
    FUN_0046a1a0();
    return;
  }
  FUN_0046ec30(param_1,param_2,4);
  return;
}



/* Function: FUN_004081d0 */

void FUN_004081d0(double *param_1,undefined4 param_2)

{
  double dVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  dVar1 = *param_1;
  if ((dVar1 == 0.0) && (!NAN(dVar1))) {
    return;
  }
  if (NAN(dVar1)) {
    FUN_0046a1a0();
    return;
  }
  FUN_0046ec30(param_1,param_2,8);
  return;
}



/* Function: FUN_00408270 */

void FUN_00408270(int param_1,undefined4 param_2)

{
  int in_FS_OFFSET;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x4082c1;
    FUN_0046d980();
  }
  FUN_00408130(param_1,param_2);
  FUN_00408130(param_1 + 4,local_4);
  return;
}



/* Function: FUN_004082d0 */

void FUN_004082d0(int param_1,undefined4 param_2)

{
  int in_FS_OFFSET;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x408321;
    FUN_0046d980();
  }
  FUN_004081d0(param_1,param_2);
  FUN_004081d0(param_1 + 8,local_4);
  return;
}



/* Function: FUN_00408330 */

void FUN_00408330(void)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x1c);
      piVar1 = *(int **)((int)register0x00000010 + 4);
      if (*piVar1 == 0) {
        *(undefined4 *)((int)register0x00000010 + 0xc) =
             *(undefined4 *)((int)register0x00000010 + 8);
        return;
      }
      iVar2 = *(int *)(*piVar1 + 4);
      if (*(int *)(iVar2 + 0x10) != 0) {
        if ((*(byte *)(iVar2 + 0xf) & 0x20) != 0) {
          *(int *)((int)register0x00000010 + -0x1c) = iVar2;
          *(int **)((int)register0x00000010 + -0x18) = piVar1 + 1;
          *(uint *)((int)register0x00000010 + -0x14) =
               *(uint *)((int)register0x00000010 + 8) ^ 0xaa7f8ea9;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408380;
          FUN_00467a40();
          *(int *)((int)register0x00000010 + 0xc) =
               *(int *)((int)register0x00000010 + -0x10) * -0x3d458933;
          return;
        }
        iVar3 = piVar1[1];
        *(int *)((int)register0x00000010 + -0x1c) = iVar2;
        *(int *)((int)register0x00000010 + -0x18) = iVar3;
        *(uint *)((int)register0x00000010 + -0x14) =
             *(uint *)((int)register0x00000010 + 8) ^ 0xaa7f8ea9;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4083ae;
        FUN_00467a40();
        *(int *)((int)register0x00000010 + 0xc) =
             *(int *)((int)register0x00000010 + -0x10) * -0x3d458933;
        return;
      }
      *(int *)((int)register0x00000010 + -0x1c) = iVar2;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4083d4;
      FUN_00462470();
      uVar4 = *(undefined4 *)((int)register0x00000010 + -0x18);
      uVar5 = *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c7f6f;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x18;
      *(undefined4 *)((int)register0x00000010 + -0x10) = uVar4;
      *(undefined4 *)((int)register0x00000010 + -0xc) = uVar5;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408402;
      FUN_00451db0();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408416;
      FUN_004682f0();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004b3140;
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x40842c;
      FUN_00469650();
    }
    *(undefined4 *)(puVar6 + -4) = 0x408432;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_00408440 */

void FUN_00408440(int param_1,int *param_2)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  byte bVar4;
  uint uVar5;
  undefined4 *puVar6;
  int in_FS_OFFSET;
  int in_stack_ffffffd4;
  int in_stack_ffffffd8;
  undefined4 local_1c;
  undefined4 local_18;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if ((*(byte *)(param_1 + 0xc) & 8) != 0) {
    return;
  }
  bVar4 = *(byte *)(param_1 + 0xf) & 0x1f;
  if (bVar4 < 0x12) {
    if ((byte)(bVar4 - 0xd) < 4) {
      return;
    }
    if (bVar4 == 0x11) {
      uVar5 = 0;
      while( true ) {
        if (*(uint *)(param_1 + 0x28) <= uVar5) {
          return;
        }
        FUN_00408440(*(int **)(param_1 + 0x20),
                     (int *)((int)param_2 + **(int **)(param_1 + 0x20) * uVar5));
        if (in_stack_ffffffd8 != 0) break;
        uVar5 = uVar5 + 1;
        in_stack_ffffffd8 = 0;
      }
      return;
    }
  }
  else {
    if (bVar4 == 0x14) {
      if (*(int *)(param_1 + 0x28) == 0) {
        iVar3 = *param_2;
        if (iVar3 == 0) {
          return;
        }
      }
      else {
        if (*param_2 == 0) {
          return;
        }
        iVar3 = *(int *)(*param_2 + 4);
      }
      if (*(int *)(iVar3 + 0x10) != 0) {
        if ((*(byte *)(iVar3 + 0xf) & 0x20) != 0) {
          FUN_00408440(iVar3,param_2 + 1);
          return;
        }
        FUN_00408440(iVar3,param_2[1]);
        return;
      }
      FUN_00462470(iVar3);
      FUN_00451db0(0,&DAT_004c7f6f,0x18,in_stack_ffffffd4,in_stack_ffffffd8);
      FUN_004682f0(local_1c,local_18);
      return;
    }
    if (bVar4 == 0x18) {
      return;
    }
    if (bVar4 == 0x19) {
      puVar6 = *(undefined4 **)(param_1 + 0x24);
      iVar3 = *(int *)(param_1 + 0x28);
      do {
        if (iVar3 < 1) {
          return;
        }
        uVar1 = puVar6[1];
        iVar2 = puVar6[2];
        FUN_00401200(*puVar6);
        if ((char)in_stack_ffffffd4 == '\0') {
          in_stack_ffffffd4 = iVar2 + (int)param_2;
          FUN_00408440(uVar1);
          if (in_stack_ffffffd8 != 0) {
            return;
          }
        }
        puVar6 = puVar6 + 3;
        iVar3 = iVar3 + -1;
      } while( true );
    }
  }
  FUN_00462470(param_1);
  FUN_00451db0(0,&DAT_004c7f6f,0x18,in_stack_ffffffd4,in_stack_ffffffd8);
  FUN_004682f0(local_1c,local_18);
  return;
}



/* Function: FUN_00408a80 */

void FUN_00408a80(void)

{
  int iVar1;
  code *pcVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x1c);
      iVar1 = *(int *)((int)register0x00000010 + 4);
      if (iVar1 == 0) {
        *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
        return;
      }
      if (*(undefined4 **)(iVar1 + 0x10) != (undefined4 *)0x0) {
        if ((*(byte *)(iVar1 + 0xf) & 0x20) != 0) {
          *(bool *)((int)register0x00000010 + 0x10) =
               *(int *)((int)register0x00000010 + 0xc) == *(int *)((int)register0x00000010 + 8);
          return;
        }
        pcVar2 = (code *)**(undefined4 **)(iVar1 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408ad7;
        (*pcVar2)();
        *(undefined1 *)((int)register0x00000010 + 0x10) =
             *(undefined1 *)((int)register0x00000010 + -0x14);
        return;
      }
      *(int *)((int)register0x00000010 + -0x1c) = iVar1;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408af5;
      FUN_00462470();
      uVar3 = *(undefined4 *)((int)register0x00000010 + -0x18);
      uVar4 = *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
      *(char **)((int)register0x00000010 + -0x18) =
           "comparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x1c;
      *(undefined4 *)((int)register0x00000010 + -0x10) = uVar3;
      *(undefined4 *)((int)register0x00000010 + -0xc) = uVar4;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408b23;
      FUN_00451db0();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408b37;
      FUN_004682f0();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004b3140;
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408b4d;
      FUN_00469650();
    }
    *(undefined4 *)(puVar5 + -4) = 0x408b53;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00408b60 */

void FUN_00408b60(void)

{
  int iVar1;
  code *pcVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x1c);
      if (*(int *)((int)register0x00000010 + 4) == 0) {
        *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
        return;
      }
      iVar1 = *(int *)(*(int *)((int)register0x00000010 + 4) + 4);
      if (*(undefined4 **)(iVar1 + 0x10) != (undefined4 *)0x0) {
        if ((*(byte *)(iVar1 + 0xf) & 0x20) != 0) {
          *(bool *)((int)register0x00000010 + 0x10) =
               *(int *)((int)register0x00000010 + 0xc) == *(int *)((int)register0x00000010 + 8);
          return;
        }
        pcVar2 = (code *)**(undefined4 **)(iVar1 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408bba;
        (*pcVar2)();
        *(undefined1 *)((int)register0x00000010 + 0x10) =
             *(undefined1 *)((int)register0x00000010 + -0x14);
        return;
      }
      *(int *)((int)register0x00000010 + -0x1c) = iVar1;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408bd8;
      FUN_00462470();
      uVar3 = *(undefined4 *)((int)register0x00000010 + -0x18);
      uVar4 = *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
      *(char **)((int)register0x00000010 + -0x18) =
           "comparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x1c;
      *(undefined4 *)((int)register0x00000010 + -0x10) = uVar3;
      *(undefined4 *)((int)register0x00000010 + -0xc) = uVar4;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408c06;
      FUN_00451db0();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408c1a;
      FUN_004682f0();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004b3140;
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x408c30;
      FUN_00469650();
    }
    *(undefined4 *)(puVar5 + -4) = 0x408c36;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00408c40 */

void FUN_00408c40(void)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined4 local_10;
  undefined4 local_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (((DAT_005f6340 != '\0') && (DAT_005f6352 != '\0')) && (DAT_005f6353 != '\0')) {
    DAT_005f5da4 = 1;
    for (iVar1 = 0; iVar1 < 8; iVar1 = iVar1 + 1) {
      FUN_0044ad20();
      *(undefined4 *)(&DAT_005f6120 + iVar1 * 8) = local_10;
      *(undefined4 *)(&DAT_005f6124 + iVar1 * 8) = local_c;
    }
    return;
  }
  for (iVar1 = 0; iVar1 < 4; iVar1 = iVar1 + 1) {
    FUN_0044ad20();
    (&DAT_005f5ff0)[iVar1] = local_10;
  }
  return;
}



/* Function: FUN_00408d50 */

void FUN_00408d50(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x2c);
      iVar1 = *(int *)((int)register0x00000010 + 4);
      if (*(char *)(iVar1 + 0x41) != '\0') {
        if ((*(uint *)(iVar1 + 0x10) & 0x7ffff) == 0x200) {
          *(undefined1 *)((int)register0x00000010 + -0x15) = 1;
          *(undefined1 *)(iVar1 + 0x3e) = *(undefined1 *)((int)register0x00000010 + -0x15);
          iVar2 = *(int *)(iVar1 + 0x10);
          *(undefined4 *)((int)register0x00000010 + -0x2c) = *(undefined4 *)(iVar1 + 0xc);
          *(int *)((int)register0x00000010 + -0x28) = iVar2 << 0xd;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408dab;
          FUN_00414ec0();
          uVar3 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x10);
          *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f6890;
          *(uint *)((int)register0x00000010 + -0x28) = uVar3 * -0x2000;
          *(uint *)((int)register0x00000010 + -0x24) = -(uint)((uVar3 & 0x7ffff) != 0);
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408dd7;
          FUN_00433860();
          uVar4 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x44);
          *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f68b0;
          *(undefined4 *)((int)register0x00000010 + -0x28) = uVar4;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408df8;
          FUN_004026b0();
          *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f7700;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408e06;
          FUN_00433980();
          iVar1 = *(int *)((int)register0x00000010 + -0x28);
          uVar3 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x10);
          *(int *)((int)register0x00000010 + -0x2c) = iVar1;
          *(int *)((int)register0x00000010 + -4) = iVar1 + 0x10;
          *(int *)((int)register0x00000010 + -8) = iVar1 + 0x270;
          *(int *)((int)register0x00000010 + -0xc) = iVar1 + 0x268;
          *(uint *)((int)register0x00000010 + -0x28) = uVar3 * -0x2000;
          *(uint *)((int)register0x00000010 + -0x24) = -(uint)((uVar3 & 0x7ffff) != 0);
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408e4c;
          thunk_FUN_004026b0();
          uVar3 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x10);
          *(undefined4 *)((int)register0x00000010 + -0x2c) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(uint *)((int)register0x00000010 + -0x28) = uVar3 * -0x2000;
          *(uint *)((int)register0x00000010 + -0x24) = -(uint)((uVar3 & 0x7ffff) != 0);
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408e76;
          thunk_FUN_004026b0();
          *(undefined4 *)((int)register0x00000010 + -0x2c) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x28) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408e92;
          FUN_004026b0();
          uVar4 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x44);
          *(undefined4 *)((int)register0x00000010 + -0x2c) =
               *(undefined4 *)((int)register0x00000010 + -0xc);
          *(undefined4 *)((int)register0x00000010 + -0x28) = uVar4;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408eb1;
          FUN_004026b0();
          *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f7700;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408ebf;
          FUN_00433a70();
          iVar1 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x44);
          *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f6780;
          *(int *)((int)register0x00000010 + -0x28) = -iVar1;
          *(uint *)((int)register0x00000010 + -0x24) = -(uint)(iVar1 != 0);
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408ef8;
          FUN_004227a0();
          *(undefined1 **)((int)register0x00000010 + -0x14) = &LAB_00408f60;
          *(undefined4 *)((int)register0x00000010 + -0x10) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined1 **)((int)register0x00000010 + -0x2c) =
               (undefined1 *)((int)register0x00000010 + -0x14);
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408f16;
          FUN_0046d890();
          return;
        }
        *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004cc704;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x2c;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408f30;
        FUN_00469a20();
      }
      *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004cbdc8;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x28;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x408f46;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x408f4c;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00408fc0 */

void FUN_00408fc0(undefined4 param_1,undefined4 param_2)

{
  if ((char)DAT_005f5fd0 != '\0') {
    FUN_00467d40(param_1,param_2);
  }
  FUN_00402760(param_1,param_2);
  return;
}



/* Function: FUN_00409000 */

void FUN_00409000(undefined4 *param_1,uint param_2,char param_3)

{
  uint local_c;
  uint local_8;
  uint *local_4;
  
  if (*(char *)((int)param_1 + 0x8d) == '\0') {
    return;
  }
  local_4 = (uint *)*param_1;
  if (((*local_4 < param_2) && (param_2 <= local_4[1])) && (*(char *)((int)param_1 + 0x95) != '\0'))
  {
    return;
  }
  local_4[1] = param_2 + 0x400;
  *local_4 = param_2 - 0x8000;
  *(undefined1 *)((int)param_1 + 0x95) = 0;
  if ((param_3 == '\0') && (DAT_005d6ecc != 0)) {
    local_c = 0;
    local_8 = 0;
    FUN_0046ea10(DAT_005d6ecc,&local_c);
    if ((local_c != 0) && ((local_c < param_2 && (param_2 <= local_8)))) {
      *local_4 = local_c;
      local_4[1] = local_8;
      *(undefined1 *)((int)param_1 + 0x95) = 1;
    }
  }
  local_4[2] = *local_4 + 0x13a0;
  local_4[3] = *local_4 + 0x13a0;
  return;
}



/* Function: FUN_004090e0 */

void FUN_004090e0(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  undefined1 uVar1;
  int *piVar2;
  int *piVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  code *pcVar10;
  int iVar11;
  int iVar12;
  int in_FS_OFFSET;
  uint in_stack_ffffffc4;
  
  iVar12 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  if (*(int *)(*(int *)(iVar12 + 0x18) + 0x50) != iVar12) {
    FUN_0043a810();
    FUN_0043b060(&DAT_004c9fda,0x1e);
    FUN_0043a870();
    FUN_00435f00(2);
  }
  piVar2 = *(int **)(iVar12 + 0x18);
  piVar3 = (int *)*piVar2;
  iVar4 = piVar3[1];
  iVar5 = *piVar3;
  uVar1 = *(undefined1 *)((int)piVar2 + 0x95);
  FUN_00409000(piVar2,piVar3[7],in_stack_ffffffc4 & 0xffffff00);
  piVar2 = (int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x140);
  *piVar2 = *piVar2 + 1;
  iVar6 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(int *)(*(int *)(iVar6 + 0x18) + 0xb8) = iVar6;
  *(undefined4 *)(iVar6 + 0x88) = *(undefined4 *)(iVar6 + 0x18);
  iVar6 = *(int *)(iVar12 + 0x18);
  iVar11 = iVar12;
  FUN_0046f424();
  uVar7 = *(undefined4 *)(iVar11 + 0x38);
  uVar8 = *(undefined4 *)(iVar11 + 0x40);
  uVar9 = *(undefined4 *)(iVar11 + 0x3c);
  FUN_00469ec0();
  *(undefined1 *)(*(int *)(iVar12 + 0x18) + 0x8c) = 0;
  if (*(char *)(*(int *)(iVar12 + 0x18) + 0x8d) != '\0') {
    *(undefined1 *)(*(int *)(iVar12 + 0x18) + 0x8e) = 0;
  }
  FUN_00402770(*(int *)(iVar12 + 0x18) + 0x328,0);
  if (*(char *)(iVar12 + 0x75) == '\0') {
    FUN_00409320(param_1,param_2,param_3);
    *(undefined1 *)(*(int *)(iVar12 + 0x18) + 0x8c) = 1;
    FUN_00445bf0();
    iVar11 = *(int *)(iVar12 + 0x18);
    if ((*(char *)(iVar11 + 0x8d) != '\0') && (*(int *)(iVar11 + 0xa0) == 0)) {
      *(undefined1 *)(iVar11 + 0x8e) = 1;
    }
    if (*(int *)(iVar12 + 0x18) == iVar6) {
      FUN_00437910(*(int *)(iVar12 + 0x18));
      FUN_00443cc0(uVar9,uVar7,uVar8);
      FUN_0046f424();
      piVar2 = (int *)**(undefined4 **)(iVar12 + 0x18);
      *piVar2 = iVar5;
      piVar2[1] = iVar4;
      *(int *)(**(int **)(iVar12 + 0x18) + 8) = iVar5 + 0x13a0;
      *(undefined4 *)(**(int **)(iVar12 + 0x18) + 0xc) =
           *(undefined4 *)(**(int **)(iVar12 + 0x18) + 8);
      *(undefined1 *)(*(int *)(iVar12 + 0x18) + 0x95) = uVar1;
      return;
    }
    FUN_00469a20("m changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
                 ,0x26);
  }
  FUN_00469650(&DAT_004adee0,&PTR_s_runtime__function_marked_with__c_00550ce0);
  pcVar10 = (code *)swi(3);
  (*pcVar10)();
  return;
}



/* Function: FUN_00409320 */

void FUN_00409320(code *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  int in_FS_OFFSET;
  int in_stack_ffffffb4;
  int local_3c;
  uint local_38;
  uint local_34;
  undefined1 local_2f;
  byte local_2e;
  byte local_2d;
  uint local_2c;
  uint local_28;
  code *local_24;
  int local_20;
  code *local_1c;
  undefined1 *local_18;
  code *local_14;
  undefined **local_10;
  int local_c;
  code **local_8;
  code **local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (code **)0x40955f;
    FUN_0046d980();
  }
  local_8 = (code **)0x0;
  local_4 = (code **)0x0;
  local_2d = 0;
  local_20 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  if ((*(char *)(*(int *)(local_20 + 0x18) + 0x94) != '\0') ||
     (FUN_00402510(&DAT_005f5e78), in_stack_ffffffb4 != 0)) {
    *(undefined1 *)(*(int *)(local_20 + 0x18) + 0x94) = 0;
    FUN_0046d890(&PTR_FUN_00536c24);
  }
  if (param_3 == 0) {
    local_2e = 0;
  }
  else {
    local_28 = *(uint *)(local_20 + 0xd0);
    local_2c = *(int *)(local_20 + 0xcc) + 1;
    iVar1 = *(int *)(local_20 + 200);
    if (local_28 < local_2c) {
      FUN_0046a830(*(int *)(local_20 + 200),local_2c,local_28,1,&DAT_004ae1a0);
      local_28 = local_34;
      local_2c = local_38;
      iVar1 = local_3c;
    }
    *(int *)(iVar1 + -4 + local_2c * 4) = param_3;
    if (local_2c == 0) {
      FUN_0046edf0();
      FUN_00438440();
      return;
    }
    FUN_00408fc0(local_20 + 200,iVar1);
    *(uint *)(local_20 + 0xd0) = local_28;
    *(uint *)(local_20 + 0xcc) = local_2c;
    local_14 = FUN_004095b0;
    local_10 = &PTR_LAB_00536aac;
    local_c = local_20;
    local_8 = &local_14;
    local_2d = 1;
    local_2e = 1;
  }
  if (*(int *)(*(int *)(local_20 + 0x18) + 0xa0) == 0) {
    FUN_0040a470(DAT_005d6dfc,0);
  }
  if (*(int *)(*(int *)(local_20 + 0x18) + 0x84) != DAT_005d8594) {
    FUN_004373c0(DAT_005d8594);
  }
  local_2f = 1;
  local_2e = local_2e | 2;
  local_1c = FUN_00409570;
  local_18 = &local_2f;
  local_4 = &local_1c;
  local_24 = param_1;
  local_2d = local_2e;
  (*param_1)(param_2);
  local_2f = 0;
  if ((local_2e & 2) != 0) {
    local_2e = local_2e & 0xfd;
    local_2d = local_2e;
    (**local_4)();
  }
  if ((local_2e & 1) != 0) {
    local_2d = local_2e & 0xfe;
    (**local_8)();
  }
  return;
}



/* Function: FUN_00409570 */

void FUN_00409570(void)

{
  int *piVar1;
  int in_EDX;
  int in_FS_OFFSET;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x40959e;
    FUN_0046d900();
  }
  piVar1 = *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x10);
  if ((piVar1 != (int *)0x0) && ((undefined1 *)*piVar1 == &stack0x00000004)) {
    *piVar1 = (int)&local_4;
  }
  local_4 = *(undefined4 *)(in_EDX + 4);
  FUN_004095f0();
  return;
}



/* Function: FUN_004095b0 */

void FUN_004095b0(void)

{
  int *piVar1;
  int in_EDX;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d900();
  }
  piVar1 = *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x10);
  if ((piVar1 != (int *)0x0) && ((undefined1 *)*piVar1 == &stack0x00000004)) {
    *piVar1 = (int)register0x00000010;
  }
  piVar1 = (int *)(*(int *)(in_EDX + 8) + 0xcc);
  *piVar1 = *piVar1 + -1;
  return;
}



/* Function: FUN_004095f0 */

void FUN_004095f0(char *param_1)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (*param_1 != '\0') {
    iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
    *piVar1 = *piVar1 + 1;
    piVar1 = *(int **)(iVar2 + 0x18);
    *(undefined4 *)(*piVar1 + 0x1c) = **(undefined4 **)(*piVar1 + 0x1c);
    if (0 < piVar1[0x28]) {
      *(undefined1 *)(piVar1 + 0x23) = 0;
      piVar1[0x28] = piVar1[0x28] + -1;
      FUN_00402770(piVar1 + 0xca,0);
    }
    FUN_00445bf0();
    iVar2 = piVar1[0x1f];
    iVar3 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    piVar1[0x1f] = iVar2 + -1;
    if ((iVar2 == 1) && (*(char *)(iVar3 + 0x69) != '\0')) {
      *(undefined4 *)(iVar3 + 8) = 0xfffffade;
    }
  }
  return;
}



/* Function: FUN_004096b0 */

void FUN_004096b0(void)

{
  uint *puVar1;
  long lVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  undefined4 *puVar6;
  undefined1 *puVar7;
  int *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x1c);
      puVar1 = *(uint **)(*(int *)((int)register0x00000010 + 4) + 0x20);
      if (*puVar1 < 0x10000) {
        if (*(byte *)((int)puVar1 + 0xd) < 9) {
          lVar2 = (ulong)*puVar1 * (ulong)*(uint *)((int)register0x00000010 + 8);
          uVar3 = (uint)lVar2;
          if ((((int)((ulong)lVar2 >> 0x20) == 0) && (uVar3 < 0xffffffc8)) &&
             (-1 < *(int *)((int)register0x00000010 + 8))) {
            *(uint **)((int)register0x00000010 + -8) = puVar1;
            if (uVar3 == 0) {
              *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x38;
              *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
              *(undefined1 *)((int)register0x00000010 + -0x14) = 1;
              *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4097cc;
              FUN_00468370();
              iVar4 = *(int *)((int)register0x00000010 + -0x10);
              iVar5 = iVar4 + 8;
              if (DAT_005f5fd0 != 0) {
                *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4097e4;
                FUN_0046ed80();
                *in_EDI = iVar5;
                in_EDI[1] = *(int *)(iVar4 + 8);
              }
              *(int *)(iVar4 + 8) = iVar5;
            }
            else if (puVar1[1] == 0) {
              *(uint *)((int)register0x00000010 + -0x1c) = uVar3 + 0x38;
              *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
              *(undefined1 *)((int)register0x00000010 + -0x14) = 1;
              *(undefined4 *)((int)register0x00000010 + -0x20) = 0x40978e;
              FUN_00468370();
              iVar4 = *(int *)((int)register0x00000010 + -0x10);
              iVar5 = iVar4 + 0x38;
              if (DAT_005f5fd0 != 0) {
                *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4097a6;
                FUN_0046ed80();
                *in_EDI = iVar5;
                in_EDI[1] = *(int *)(iVar4 + 8);
              }
              *(int *)(iVar4 + 8) = iVar5;
            }
            else {
              *(uint *)((int)register0x00000010 + -0xc) = uVar3;
              *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004bdec0;
              *(undefined4 *)((int)register0x00000010 + -0x20) = 0x40972b;
              FUN_00411710();
              *(undefined4 *)((int)register0x00000010 + -4) =
                   *(undefined4 *)((int)register0x00000010 + -0x18);
              *(undefined4 *)((int)register0x00000010 + -0x1c) =
                   *(undefined4 *)((int)register0x00000010 + -0xc);
              *(undefined4 *)((int)register0x00000010 + -0x18) =
                   *(undefined4 *)((int)register0x00000010 + -8);
              *(undefined1 *)((int)register0x00000010 + -0x14) = 1;
              *(undefined4 *)((int)register0x00000010 + -0x20) = 0x40974c;
              FUN_00468370();
              iVar5 = *(int *)((int)register0x00000010 + -0x10);
              if (DAT_005f5fd0 == 0) {
                iVar4 = *(int *)((int)register0x00000010 + -4);
              }
              else {
                *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409765;
                FUN_0046ed80();
                *in_EDI = iVar5;
                iVar4 = *(int *)((int)register0x00000010 + -4);
                in_EDI[1] = *(int *)(iVar4 + 8);
              }
              *(int *)(iVar4 + 8) = iVar5;
            }
            puVar6 = *(undefined4 **)((int)register0x00000010 + -8);
            *(short *)(iVar4 + 0xc) = (short)*puVar6;
            if (DAT_005f5fd0 != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409808;
              FUN_0046ed80();
              *in_EDI = (int)puVar6;
              in_EDI[1] = *(int *)(iVar4 + 0x18);
            }
            *(undefined4 **)(iVar4 + 0x18) = puVar6;
            *(undefined4 *)(iVar4 + 4) = *(undefined4 *)((int)register0x00000010 + 8);
            if (*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xf0) != 0) {
              *(undefined1 *)(iVar4 + 0xe) = 1;
            }
            *(int *)((int)register0x00000010 + 0xc) = iVar4;
            return;
          }
          *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004b31a0;
          *(undefined ***)((int)register0x00000010 + -0x18) = &PTR_DAT_00550ce8;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409853;
          FUN_00469650();
        }
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c795d;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x17;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409869;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x1c) =
           "makechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x26;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x40987f;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar7 + -4) = 0x409885;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_00409890 */

void FUN_00409890(undefined4 param_1,undefined4 param_2)

{
  FUN_004098c0(param_1,param_2,1);
  return;
}



/* Function: FUN_004098c0 */

void FUN_004098c0(void)

{
  uint *puVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int *piVar5;
  int iVar6;
  undefined1 uVar7;
  int iVar8;
  undefined4 uVar9;
  int iVar10;
  undefined4 uVar11;
  undefined1 *puVar12;
  int *in_EDI;
  int in_FS_OFFSET;
  bool bVar13;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x34);
      piVar5 = *(int **)((int)register0x00000010 + 4);
      if (piVar5 == (int *)0x0) {
        if (*(char *)((int)register0x00000010 + 0xc) == '\0') {
          *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
        *(undefined2 *)((int)register0x00000010 + -0x2c) = 0x104;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 2;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409d4a;
        FUN_00469a60();
        *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004c398e;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0xb;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409d60;
        FUN_00469a20();
LAB_00409d60:
        if (*(int *)(*(int *)((int)register0x00000010 + 4) + 0x10) == 0) {
          *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004c85b1;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x19;
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409d81;
          FUN_00469a20();
        }
        *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004b31a0;
        *(undefined ***)((int)register0x00000010 + -0x30) = &PTR_DAT_00550cf8;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409d99;
        FUN_00469650();
LAB_00409d99:
        *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004c8f1b;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x1b;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409daf;
        FUN_00469a20();
code_r0x00409db1:
        *(undefined4 *)((int)register0x00000010 + -0x34) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409dbd;
        FUN_0040f0e0();
        *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004b31a0;
        *(undefined ***)((int)register0x00000010 + -0x30) = &PTR_DAT_00550cf8;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409dd5;
        FUN_00469650();
      }
      else if ((*(char *)((int)piVar5 + 0xe) == '\0') ||
              (*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xf0) != 0)) {
        if ((*(char *)((int)register0x00000010 + 0xc) == '\0') && (piVar5[4] == 0)) {
          if (piVar5[1] == 0) {
            bVar13 = piVar5[9] == 0;
          }
          else {
            bVar13 = *piVar5 == piVar5[1];
          }
          if (bVar13) {
            *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
            return;
          }
        }
        if (DAT_005f5efc == 0 && DAT_005f5ef8 != 0 || DAT_005f5efc != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x40996a;
          FUN_0046ebf0();
          uVar11 = *(undefined4 *)((int)register0x00000010 + -0x34);
          uVar9 = *(undefined4 *)((int)register0x00000010 + -0x30);
          piVar5 = *(int **)((int)register0x00000010 + 4);
        }
        else {
          uVar9 = 0;
          uVar11 = 0;
        }
        *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar11;
        *(undefined4 *)((int)register0x00000010 + -0x18) = uVar9;
        *(int **)((int)register0x00000010 + -0x10) = piVar5 + 0xd;
        *(int **)((int)register0x00000010 + -0x34) = piVar5 + 0xd;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409991;
        FUN_0040ecf0();
        if (*(int *)(*(int *)((int)register0x00000010 + 4) + 0x10) == 0) {
          *(int *)((int)register0x00000010 + -0x34) = *(int *)((int)register0x00000010 + 4) + 0x24;
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x4099ab;
          FUN_0040ad40();
          if (*(int *)((int)register0x00000010 + -0x30) != 0) {
            *(undefined1 **)((int)register0x00000010 + -8) = &LAB_00409e00;
            *(undefined4 *)((int)register0x00000010 + -4) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x34) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(int *)((int)register0x00000010 + -0x30) = *(int *)((int)register0x00000010 + -0x30);
            *(undefined4 *)((int)register0x00000010 + -0x2c) =
                 *(undefined4 *)((int)register0x00000010 + 8);
            *(undefined1 **)((int)register0x00000010 + -0x28) =
                 (undefined1 *)((int)register0x00000010 + -8);
            *(undefined4 *)((int)register0x00000010 + -0x24) = 3;
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409d0c;
            FUN_00409e30();
            *(undefined1 *)((int)register0x00000010 + 0x14) = 1;
            return;
          }
          puVar1 = *(uint **)((int)register0x00000010 + 4);
          if (*puVar1 < puVar1[1]) {
            uVar4 = puVar1[3];
            uVar2 = puVar1[7];
            uVar3 = puVar1[2];
            *(uint *)((int)register0x00000010 + -0x34) = puVar1[6];
            *(uint *)((int)register0x00000010 + -0x30) = (ushort)uVar4 * uVar2 + uVar3;
            *(undefined4 *)((int)register0x00000010 + -0x2c) =
                 *(undefined4 *)((int)register0x00000010 + 8);
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409ca6;
            FUN_00468750();
            piVar5 = *(int **)((int)register0x00000010 + 4);
            iVar8 = piVar5[7];
            piVar5[7] = iVar8 + 1;
            if (piVar5[1] == iVar8 + 1) {
              piVar5[7] = 0;
            }
            *piVar5 = *piVar5 + 1;
            *(undefined4 *)((int)register0x00000010 + -0x34) =
                 *(undefined4 *)((int)register0x00000010 + -0x10);
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409ccd;
            FUN_0040f0e0();
            *(undefined1 *)((int)register0x00000010 + 0x14) = 1;
            return;
          }
          if (*(char *)((int)register0x00000010 + 0xc) == '\0') {
            *(undefined4 *)((int)register0x00000010 + -0x34) =
                 *(undefined4 *)((int)register0x00000010 + -0x10);
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x4099dd;
            FUN_0040f0e0();
            *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
            return;
          }
          *(undefined4 *)((int)register0x00000010 + -0xc) =
               **(undefined4 **)(in_FS_OFFSET + DAT_005f5ed0);
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x4099fa;
          FUN_0043baa0();
          piVar5 = *(int **)((int)register0x00000010 + -0x34);
          piVar5[6] = 0;
          piVar5[7] = 0;
          if (*(int *)((int)register0x00000010 + -0x18) != 0 ||
              *(int *)((int)register0x00000010 + -0x1c) != 0) {
            piVar5[6] = -1;
            piVar5[7] = -1;
          }
          if (DAT_005f5fd0 == (int *)0x0) {
            iVar8 = *(int *)((int)register0x00000010 + 8);
            iVar6 = *(int *)((int)register0x00000010 + -0xc);
            iVar10 = *(int *)((int)register0x00000010 + 4);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409a52;
            FUN_0046edd0();
            iVar8 = *(int *)((int)register0x00000010 + 8);
            *in_EDI = iVar8;
            in_EDI[1] = piVar5[3];
            in_EDI[2] = piVar5[0xb];
            iVar6 = *(int *)((int)register0x00000010 + -0xc);
            in_EDI[3] = iVar6;
            in_EDI[4] = *piVar5;
            iVar10 = *(int *)((int)register0x00000010 + 4);
            in_EDI[5] = iVar10;
            in_EDI[6] = piVar5[0xd];
          }
          piVar5[3] = iVar8;
          piVar5[0xb] = 0;
          *piVar5 = iVar6;
          *(undefined1 *)(piVar5 + 9) = 0;
          piVar5[0xd] = iVar10;
          if (DAT_005f5fd0 != (int *)0x0) {
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409aa2;
            FUN_0046ed90();
            *in_EDI = (int)piVar5;
            in_EDI[1] = *(int *)(iVar6 + 0xc4);
            in_EDI[2] = *(int *)(iVar6 + 0x48);
          }
          *(int **)(iVar6 + 0xc4) = piVar5;
          *(undefined4 *)(iVar6 + 0x48) = 0;
          if (DAT_005f5fd0 != (int *)0x0) {
            iVar8 = piVar5[1];
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409ad2;
            FUN_0046ed70();
            *in_EDI = iVar8;
          }
          *(int **)((int)register0x00000010 + -0x14) = piVar5;
          piVar5[1] = 0;
          iVar8 = *(int *)(iVar10 + 0x30);
          if (iVar8 == 0) {
            if (DAT_005f5fd0 != (int *)0x0) {
              iVar8 = piVar5[2];
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409b2d;
              FUN_0046eda0();
              *in_EDI = iVar8;
              in_EDI[1] = (int)piVar5;
              in_EDI[2] = *(int *)(iVar10 + 0x2c);
              in_EDI[3] = *(int *)(iVar10 + 0x30);
            }
            piVar5[2] = 0;
            *(int **)(iVar10 + 0x2c) = piVar5;
            *(int **)(iVar10 + 0x30) = piVar5;
          }
          else {
            in_EDI = DAT_005f5fd0;
            if (DAT_005f5fd0 != (int *)0x0) {
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409af5;
              FUN_0046edb0();
              *in_EDI = iVar8;
              in_EDI[1] = piVar5[2];
              in_EDI[2] = (int)piVar5;
              in_EDI[3] = *(int *)(iVar8 + 4);
              in_EDI[4] = *(int *)(iVar10 + 0x30);
            }
            piVar5[2] = iVar8;
            *(int **)(iVar8 + 4) = piVar5;
            *(int **)(iVar10 + 0x30) = piVar5;
          }
          *(int *)((int)register0x00000010 + -0x34) = iVar6 + 0x71;
          *(undefined1 *)((int)register0x00000010 + -0x30) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409b5d;
          FUN_00402810();
          if (*(char *)(*(int *)((int)register0x00000010 + 4) + 0xe) == '\0') {
            uVar7 = 0xf;
          }
          else {
            uVar7 = 0x2a;
          }
          *(undefined ***)((int)register0x00000010 + -0x34) = &PTR_LAB_00536ab0;
          *(undefined4 *)((int)register0x00000010 + -0x30) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined1 *)((int)register0x00000010 + -0x2c) = uVar7;
          *(undefined1 *)((int)register0x00000010 + -0x2b) = 6;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 2;
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409b9c;
          FUN_00469a60();
          iVar6 = *(int *)((int)register0x00000010 + -0x14);
          iVar8 = *(int *)((int)register0x00000010 + -0xc);
          if (*(int *)(iVar8 + 0xc4) == iVar6) {
            if (DAT_005f5fd0 != (int *)0x0) {
              iVar10 = *(int *)(iVar8 + 0xc4);
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409bc5;
              FUN_0046ed70();
              *in_EDI = iVar10;
            }
            *(undefined4 *)(iVar8 + 0xc4) = 0;
            *(undefined1 *)(iVar8 + 0x70) = 0;
            uVar7 = *(undefined1 *)(iVar6 + 0x25);
            if (DAT_005f5fd0 != (int *)0x0) {
              iVar10 = *(int *)(iVar8 + 0x48);
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409beb;
              FUN_0046ed70();
              *in_EDI = iVar10;
            }
            *(undefined1 *)((int)register0x00000010 + -0x1d) = uVar7;
            *(undefined4 *)(iVar8 + 0x48) = 0;
            uVar2 = *(uint *)(iVar6 + 0x18);
            iVar8 = *(int *)(iVar6 + 0x1c);
            in_EDI = (int *)CONCAT31((int3)((uint)in_EDI >> 8),uVar2 != 0);
            if (0 < iVar8 || iVar8 == 0 && uVar2 != 0) {
              *(uint *)((int)register0x00000010 + -0x34) =
                   uVar2 - *(uint *)((int)register0x00000010 + -0x1c);
              *(uint *)((int)register0x00000010 + -0x30) =
                   (iVar8 - *(int *)((int)register0x00000010 + -0x18)) -
                   (uint)(uVar2 < *(uint *)((int)register0x00000010 + -0x1c));
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 2;
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409c41;
              FUN_00468e20();
              iVar6 = *(int *)((int)register0x00000010 + -0x14);
            }
            if (DAT_005f5fd0 != (int *)0x0) {
              iVar8 = *(int *)(iVar6 + 0x34);
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409c5c;
              FUN_0046ed70();
              *in_EDI = iVar8;
            }
            *(undefined4 *)(iVar6 + 0x34) = 0;
            *(int *)((int)register0x00000010 + -0x34) = iVar6;
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409c6d;
            FUN_0043bd80();
            if (*(char *)((int)register0x00000010 + -0x1d) != '\0') {
              *(undefined1 *)((int)register0x00000010 + 0x14) = 1;
              return;
            }
            goto LAB_00409d60;
          }
          goto LAB_00409d99;
        }
        goto code_r0x00409db1;
      }
      *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004b31a0;
      *(undefined ***)((int)register0x00000010 + -0x30) = &PTR_DAT_00550cf0;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x409ded;
      FUN_00469650();
    }
    *(undefined4 *)(puVar12 + -4) = 0x409df3;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
}



/* Function: FUN_00409e30 */

void FUN_00409e30(void)

{
  undefined4 uVar1;
  code *pcVar2;
  int *piVar3;
  int iVar4;
  int iVar5;
  undefined1 *puVar6;
  int *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x1c);
      if (*(char *)(*(int *)((int)register0x00000010 + 4) + 0xe) == '\0') {
        piVar3 = *(int **)((int)register0x00000010 + 8);
LAB_00409e7d:
        if (piVar3[3] != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x1c) =
               *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x18);
          *(int **)((int)register0x00000010 + -0x18) = piVar3;
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)((int)register0x00000010 + 0xc);
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409e9b;
          FUN_0040a080();
          if (DAT_005f5fd0 == 0) {
            piVar3 = *(int **)((int)register0x00000010 + 8);
          }
          else {
            piVar3 = *(int **)((int)register0x00000010 + 8);
            iVar4 = piVar3[3];
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409eb7;
            FUN_0046ed70();
            *in_EDI = iVar4;
          }
          piVar3[3] = 0;
        }
        *(int *)((int)register0x00000010 + -0x10) = *piVar3;
        pcVar2 = (code *)**(undefined4 **)((int)register0x00000010 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409ed0;
        (*pcVar2)();
        iVar4 = *(int *)((int)register0x00000010 + -0x10);
        if (DAT_005f5fd0 == 0) {
          iVar5 = *(int *)((int)register0x00000010 + 8);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409eeb;
          FUN_0046ed80();
          iVar5 = *(int *)((int)register0x00000010 + 8);
          *in_EDI = iVar5;
          in_EDI[1] = *(int *)(iVar4 + 0x48);
        }
        *(int *)(iVar4 + 0x48) = iVar5;
        *(undefined1 *)(iVar5 + 0x25) = 1;
        if (*(int *)(iVar5 + 0x1c) != 0 || *(int *)(iVar5 + 0x18) != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409f19;
          FUN_0046ebf0();
          uVar1 = *(undefined4 *)((int)register0x00000010 + -0x18);
          iVar4 = *(int *)((int)register0x00000010 + 8);
          *(undefined4 *)(iVar4 + 0x18) = *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)(iVar4 + 0x1c) = uVar1;
          iVar4 = *(int *)((int)register0x00000010 + -0x10);
        }
        *(undefined1 **)((int)register0x00000010 + -0xc) = &LAB_00409f80;
        *(int *)((int)register0x00000010 + -8) = iVar4;
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 0x14) + 1;
        *(undefined1 **)((int)register0x00000010 + -0x1c) =
             (undefined1 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409f51;
        FUN_0046d890();
        return;
      }
      piVar3 = *(int **)((int)register0x00000010 + 8);
      if (*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xf0) == *(int *)(*piVar3 + 0xf0))
      goto LAB_00409e7d;
      pcVar2 = (code *)**(undefined4 **)((int)register0x00000010 + 0x10);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409f5d;
      (*pcVar2)();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004b31a0;
      *(undefined ***)((int)register0x00000010 + -0x18) = &PTR_DAT_00550cf0;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x409f75;
      FUN_00469650();
    }
    *(undefined4 *)(puVar6 + -4) = 0x409f7b;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_00409fc0 */

void FUN_00409fc0(int *param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  int in_stack_fffffff4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  thunk_FUN_00402510(param_1);
  if (in_stack_fffffff4 != 0) {
    FUN_0040ecf0(param_1 + 0xd);
    while (*param_1 != 0) {
      FUN_00411ee0(param_1[6],(uint)*(ushort *)(param_1 + 3) * param_1[8] + param_1[2]);
      iVar1 = param_1[8];
      param_1[8] = iVar1 + 1;
      if (param_1[1] == iVar1 + 1) {
        param_1[8] = 0;
      }
      *param_1 = *param_1 + -1;
    }
    FUN_0040f0e0(param_1 + 0xd);
    return;
  }
  return;
}



/* Function: FUN_0040a080 */

void FUN_0040a080(undefined4 *param_1,int param_2,undefined4 param_3)

{
  int in_FS_OFFSET;
  undefined4 uVar1;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar1 = *(undefined4 *)(param_2 + 0xc);
  FUN_00413340(param_1,uVar1,param_3,*param_1,uVar1);
  FUN_0046f640(uVar1,param_3,*param_1);
  return;
}



/* Function: FUN_0040a0f0 */

void FUN_0040a0f0(undefined4 *param_1,int param_2,undefined4 param_3)

{
  int in_FS_OFFSET;
  undefined4 uVar1;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar1 = *(undefined4 *)(param_2 + 0xc);
  FUN_00413340(param_1,param_3,uVar1,*param_1,uVar1);
  FUN_0046f640(param_3,uVar1,*param_1);
  return;
}



/* Function: FUN_0040a160 */

void FUN_0040a160(void)

{
  int iVar1;
  int *piVar2;
  undefined1 *puVar3;
  int *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x24);
      if (*(int *)((int)register0x00000010 + 4) != 0) {
        iVar1 = *(int *)((int)register0x00000010 + 4) + 0x34;
        *(int *)((int)register0x00000010 + -0x10) = iVar1;
        *(int *)((int)register0x00000010 + -0x24) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a193;
        FUN_0040ecf0();
        iVar1 = *(int *)((int)register0x00000010 + 4);
        if (*(int *)(iVar1 + 0x10) == 0) {
          *(undefined4 *)(iVar1 + 0x10) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
          while( true ) {
            *(int *)((int)register0x00000010 + -0x24) = iVar1 + 0x24;
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a1d6;
            FUN_0040ad40();
            piVar2 = *(int **)((int)register0x00000010 + -0x20);
            if (piVar2 == (int *)0x0) break;
            *(int **)((int)register0x00000010 + -0x14) = piVar2;
            iVar1 = piVar2[3];
            if (iVar1 != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x24) =
                   *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x18);
              *(int *)((int)register0x00000010 + -0x20) = iVar1;
              *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a200;
              FUN_00411ee0();
              if (DAT_005f5fd0 == 0) {
                piVar2 = *(int **)((int)register0x00000010 + -0x14);
              }
              else {
                piVar2 = *(int **)((int)register0x00000010 + -0x14);
                iVar1 = piVar2[3];
                *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a21c;
                FUN_0046ed70();
                *in_EDI = iVar1;
              }
              piVar2[3] = 0;
            }
            if (piVar2[7] != 0 || piVar2[6] != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a240;
              FUN_0046ebf0();
              iVar1 = *(int *)((int)register0x00000010 + -0x20);
              piVar2 = *(int **)((int)register0x00000010 + -0x14);
              piVar2[6] = *(int *)((int)register0x00000010 + -0x24);
              piVar2[7] = iVar1;
            }
            iVar1 = *piVar2;
            if (DAT_005f5fd0 != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a26a;
              FUN_0046ed80();
              *in_EDI = (int)piVar2;
              in_EDI[1] = *(int *)(iVar1 + 0x48);
            }
            *(int **)(iVar1 + 0x48) = piVar2;
            *(undefined1 *)((int)piVar2 + 0x25) = 0;
            *(undefined4 *)(iVar1 + 0x5c) = *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(int *)((int)register0x00000010 + -0x1c) = iVar1;
            iVar1 = *(int *)((int)register0x00000010 + 4);
          }
          while( true ) {
            *(int *)((int)register0x00000010 + -0x24) = *(int *)((int)register0x00000010 + 4) + 0x2c
            ;
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a29a;
            FUN_0040ad40();
            piVar2 = *(int **)((int)register0x00000010 + -0x20);
            if (piVar2 == (int *)0x0) break;
            if (DAT_005f5fd0 != 0) {
              iVar1 = piVar2[3];
              *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a2b4;
              FUN_0046ed70();
              *in_EDI = iVar1;
            }
            piVar2[3] = 0;
            if (piVar2[7] != 0 || piVar2[6] != 0) {
              *(int **)((int)register0x00000010 + -0x18) = piVar2;
              *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a2dc;
              FUN_0046ebf0();
              iVar1 = *(int *)((int)register0x00000010 + -0x20);
              piVar2 = *(int **)((int)register0x00000010 + -0x18);
              piVar2[6] = *(int *)((int)register0x00000010 + -0x24);
              piVar2[7] = iVar1;
            }
            iVar1 = *piVar2;
            if (DAT_005f5fd0 != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a306;
              FUN_0046ed80();
              *in_EDI = (int)piVar2;
              in_EDI[1] = *(int *)(iVar1 + 0x48);
            }
            *(int **)(iVar1 + 0x48) = piVar2;
            *(undefined1 *)((int)piVar2 + 0x25) = 0;
            *(undefined4 *)(iVar1 + 0x5c) = *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(int *)((int)register0x00000010 + -0x1c) = iVar1;
          }
          *(undefined4 *)((int)register0x00000010 + -0x24) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a321;
          FUN_0040f0e0();
          while (iVar1 = *(int *)((int)register0x00000010 + -0x1c), iVar1 != 0) {
            if (iVar1 != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x1c) = *(undefined4 *)(iVar1 + 0x5c);
            }
            *(undefined4 *)(iVar1 + 0x5c) = 0;
            *(undefined1 **)((int)register0x00000010 + -0xc) = &LAB_0040a3c0;
            *(int *)((int)register0x00000010 + -8) = iVar1;
            *(undefined4 *)((int)register0x00000010 + -4) = 3;
            *(undefined1 **)((int)register0x00000010 + -0x24) =
                 (undefined1 *)((int)register0x00000010 + -0xc);
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a34d;
            FUN_0046d890();
          }
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x24) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a376;
        FUN_0040f0e0();
        *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004b31a0;
        *(undefined ***)((int)register0x00000010 + -0x20) = &PTR_DAT_00550d08;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a38e;
        FUN_00469650();
      }
      *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004b31a0;
      *(undefined ***)((int)register0x00000010 + -0x20) = &PTR_DAT_00550d00;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40a3a6;
      FUN_00469650();
    }
    *(undefined4 *)(puVar3 + -4) = 0x40a3ac;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_0040a400 */

void FUN_0040a400(int param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (*(int *)(param_1 + 4) != 0) {
    if (*(int *)(param_1 + 0x14) != 0) {
      FUN_004577c0(*(int *)(param_1 + 0x14));
    }
    thunk_FUN_00402510(param_1);
    return;
  }
  FUN_00402520(param_1 + 0x2c);
  return;
}



/* Function: FUN_0040a470 */

void FUN_0040a470(undefined4 param_1,undefined4 param_2)

{
  FUN_0040a490(param_1,param_2,1);
  return;
}



/* Function: FUN_0040a490 */

void FUN_0040a490(void)

{
  uint uVar1;
  int *piVar2;
  undefined1 uVar3;
  int iVar4;
  int iVar5;
  char cVar6;
  undefined4 uVar7;
  int iVar8;
  undefined4 uVar9;
  undefined4 *puVar10;
  undefined1 *puVar11;
  int *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar11 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar11 = (undefined1 *)((int)register0x00000010 + -0x38);
      iVar4 = *(int *)((int)register0x00000010 + 4);
      if (iVar4 == 0) {
        if (*(char *)((int)register0x00000010 + 0xc) == '\0') {
          *(undefined1 *)((int)register0x00000010 + 0x10) = 0;
          *(undefined1 *)((int)register0x00000010 + 0x11) = 0;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
        *(undefined2 *)((int)register0x00000010 + -0x30) = 0x103;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 2;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40aa0b;
        FUN_00469a60();
        *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c398e;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0xb;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40aa21;
        FUN_00469a20();
LAB_0040aa21:
        *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c8f1b;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x1b;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40aa37;
        FUN_00469a20();
      }
      else if ((*(char *)(iVar4 + 0xe) == '\0') ||
              (*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xf0) != 0)) {
        if (*(int *)(iVar4 + 0x14) != 0) {
          *(int *)((int)register0x00000010 + -0x38) = *(int *)(iVar4 + 0x14);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a4e3;
          FUN_004577c0();
          iVar4 = *(int *)((int)register0x00000010 + 4);
        }
        if (*(char *)((int)register0x00000010 + 0xc) == '\0') {
          *(int *)((int)register0x00000010 + -0x38) = iVar4;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a4fc;
          FUN_0040a400();
          cVar6 = *(char *)((int)register0x00000010 + -0x34);
          iVar4 = *(int *)((int)register0x00000010 + 4);
        }
        else {
          cVar6 = '\0';
        }
        if (cVar6 != '\0') {
          *(int *)((int)register0x00000010 + -0x38) = iVar4 + 0x10;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a51b;
          FUN_00402510();
          if (*(int *)((int)register0x00000010 + -0x34) == 0) {
            *(undefined1 *)((int)register0x00000010 + 0x10) = 0;
            *(undefined1 *)((int)register0x00000010 + 0x11) = 0;
            return;
          }
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a533;
          FUN_0040a400();
          if (*(char *)((int)register0x00000010 + -0x34) != '\0') {
            if (*(int *)((int)register0x00000010 + 8) != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x38) =
                   *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x18);
              *(int *)((int)register0x00000010 + -0x34) = *(int *)((int)register0x00000010 + 8);
              *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a557;
              FUN_00411ee0();
            }
            *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
            *(undefined1 *)((int)register0x00000010 + 0x11) = 0;
            return;
          }
          iVar4 = *(int *)((int)register0x00000010 + 4);
        }
        if (DAT_005f5efc == 0 && DAT_005f5ef8 != 0 || DAT_005f5efc != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a59e;
          FUN_0046ebf0();
          uVar9 = *(undefined4 *)((int)register0x00000010 + -0x38);
          uVar7 = *(undefined4 *)((int)register0x00000010 + -0x34);
          iVar4 = *(int *)((int)register0x00000010 + 4);
        }
        else {
          uVar7 = 0;
          uVar9 = 0;
        }
        *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar7;
        *(undefined4 *)((int)register0x00000010 + -0x20) = uVar9;
        *(int *)((int)register0x00000010 + -0x10) = iVar4 + 0x34;
        *(int *)((int)register0x00000010 + -0x38) = iVar4 + 0x34;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a5c5;
        FUN_0040ecf0();
        piVar2 = *(int **)((int)register0x00000010 + 4);
        if (piVar2[4] == 0) {
          *(int **)((int)register0x00000010 + -0x38) = piVar2 + 0xb;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a618;
          FUN_0040ad40();
          if (*(int *)((int)register0x00000010 + -0x34) != 0) {
            *(undefined1 **)((int)register0x00000010 + -8) = &LAB_0040aa60;
            *(undefined4 *)((int)register0x00000010 + -4) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x38) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(int *)((int)register0x00000010 + -0x34) = *(int *)((int)register0x00000010 + -0x34);
            *(undefined4 *)((int)register0x00000010 + -0x30) =
                 *(undefined4 *)((int)register0x00000010 + 8);
            *(undefined1 **)((int)register0x00000010 + -0x2c) =
                 (undefined1 *)((int)register0x00000010 + -8);
            *(undefined4 *)((int)register0x00000010 + -0x28) = 3;
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a9b5;
            FUN_0040aa90();
            *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
            *(undefined1 *)((int)register0x00000010 + 0x11) = 1;
            return;
          }
          piVar2 = *(int **)((int)register0x00000010 + 4);
        }
        else if (*piVar2 == 0) {
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a5e4;
          FUN_0040f0e0();
          if (*(int *)((int)register0x00000010 + 8) != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x38) =
                 *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x18);
            *(int *)((int)register0x00000010 + -0x34) = *(int *)((int)register0x00000010 + 8);
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a5ff;
            FUN_00411ee0();
          }
          *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
          *(undefined1 *)((int)register0x00000010 + 0x11) = 0;
          return;
        }
        if (*piVar2 != 0) {
          iVar4 = (uint)*(ushort *)(piVar2 + 3) * piVar2[8] + piVar2[2];
          if (*(int *)((int)register0x00000010 + 8) != 0) {
            *(int *)((int)register0x00000010 + -0x18) = iVar4;
            *(int *)((int)register0x00000010 + -0x38) = piVar2[6];
            *(int *)((int)register0x00000010 + -0x34) = *(int *)((int)register0x00000010 + 8);
            *(int *)((int)register0x00000010 + -0x30) = iVar4;
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a659;
            FUN_00468750();
            piVar2 = *(int **)((int)register0x00000010 + 4);
            iVar4 = *(int *)((int)register0x00000010 + -0x18);
          }
          *(int *)((int)register0x00000010 + -0x38) = piVar2[6];
          *(int *)((int)register0x00000010 + -0x34) = iVar4;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a670;
          FUN_00411ee0();
          piVar2 = *(int **)((int)register0x00000010 + 4);
          iVar4 = piVar2[8];
          piVar2[8] = iVar4 + 1;
          if (piVar2[1] == iVar4 + 1) {
            piVar2[8] = 0;
          }
          *piVar2 = *piVar2 + -1;
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a697;
          FUN_0040f0e0();
          *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
          *(undefined1 *)((int)register0x00000010 + 0x11) = 1;
          return;
        }
        if (*(char *)((int)register0x00000010 + 0xc) == '\0') {
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a6bc;
          FUN_0040f0e0();
          *(undefined1 *)((int)register0x00000010 + 0x10) = 0;
          *(undefined1 *)((int)register0x00000010 + 0x11) = 0;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             **(undefined4 **)(in_FS_OFFSET + DAT_005f5ed0);
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a6de;
        FUN_0043baa0();
        piVar2 = *(int **)((int)register0x00000010 + -0x38);
        piVar2[6] = 0;
        piVar2[7] = 0;
        if (*(int *)((int)register0x00000010 + -0x1c) != 0 ||
            *(int *)((int)register0x00000010 + -0x20) != 0) {
          piVar2[6] = -1;
          piVar2[7] = -1;
        }
        if (DAT_005f5fd0 == (int *)0x0) {
          iVar4 = *(int *)((int)register0x00000010 + 8);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a72e;
          FUN_0046ed90();
          iVar4 = *(int *)((int)register0x00000010 + 8);
          *in_EDI = iVar4;
          in_EDI[1] = piVar2[3];
          in_EDI[2] = piVar2[0xb];
        }
        piVar2[3] = iVar4;
        piVar2[0xb] = 0;
        iVar4 = *(int *)((int)register0x00000010 + -0xc);
        if (DAT_005f5fd0 == (int *)0x0) {
          iVar5 = *(int *)((int)register0x00000010 + 4);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a765;
          FUN_0046edd0();
          *in_EDI = (int)piVar2;
          in_EDI[1] = *(int *)(iVar4 + 0xc4);
          in_EDI[2] = iVar4;
          in_EDI[3] = *piVar2;
          iVar5 = *(int *)((int)register0x00000010 + 4);
          in_EDI[4] = iVar5;
          in_EDI[5] = piVar2[0xd];
          in_EDI[6] = *(int *)(iVar4 + 0x48);
        }
        *(int **)(iVar4 + 0xc4) = piVar2;
        *piVar2 = iVar4;
        *(undefined1 *)(piVar2 + 9) = 0;
        piVar2[0xd] = iVar5;
        *(undefined4 *)(iVar4 + 0x48) = 0;
        if (DAT_005f5fd0 != (int *)0x0) {
          iVar8 = piVar2[1];
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a7b3;
          FUN_0046ed70();
          *in_EDI = iVar8;
        }
        piVar2[1] = 0;
        iVar8 = *(int *)(iVar5 + 0x28);
        if (iVar8 == 0) {
          if (DAT_005f5fd0 != (int *)0x0) {
            iVar8 = piVar2[2];
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a80a;
            FUN_0046eda0();
            *in_EDI = iVar8;
            in_EDI[1] = (int)piVar2;
            in_EDI[2] = *(int *)(iVar5 + 0x24);
            in_EDI[3] = *(int *)(iVar5 + 0x28);
          }
          piVar2[2] = 0;
          *(int **)(iVar5 + 0x24) = piVar2;
          *(int **)(iVar5 + 0x28) = piVar2;
        }
        else {
          in_EDI = DAT_005f5fd0;
          if (DAT_005f5fd0 != (int *)0x0) {
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a7d2;
            FUN_0046edb0();
            *in_EDI = iVar8;
            in_EDI[1] = piVar2[2];
            in_EDI[2] = (int)piVar2;
            in_EDI[3] = *(int *)(iVar8 + 4);
            in_EDI[4] = *(int *)(iVar5 + 0x28);
          }
          piVar2[2] = iVar8;
          *(int **)(iVar8 + 4) = piVar2;
          *(int **)(iVar5 + 0x28) = piVar2;
        }
        *(int **)((int)register0x00000010 + -0x14) = piVar2;
        if (*(int *)(iVar5 + 0x14) != 0) {
          *(int *)((int)register0x00000010 + -0x38) = iVar5;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a83b;
          FUN_00457970();
          iVar4 = *(int *)((int)register0x00000010 + -0xc);
        }
        *(int *)((int)register0x00000010 + -0x38) = iVar4 + 0x71;
        *(undefined1 *)((int)register0x00000010 + -0x34) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a851;
        FUN_00402810();
        if (*(char *)(*(int *)((int)register0x00000010 + 4) + 0xe) == '\0') {
          uVar3 = 0xe;
        }
        else {
          uVar3 = 0x29;
        }
        *(undefined ***)((int)register0x00000010 + -0x38) = &PTR_LAB_00536ab0;
        *(undefined4 *)((int)register0x00000010 + -0x34) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined1 *)((int)register0x00000010 + -0x30) = uVar3;
        *(undefined1 *)((int)register0x00000010 + -0x2f) = 7;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 2;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a890;
        FUN_00469a60();
        iVar4 = *(int *)((int)register0x00000010 + -0x14);
        iVar5 = *(int *)((int)register0x00000010 + -0xc);
        if (*(int *)(iVar5 + 0xc4) == iVar4) {
          if (*(int *)(*(int *)((int)register0x00000010 + 4) + 0x14) != 0) {
            *(int *)((int)register0x00000010 + -0x38) = *(int *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a8b7;
            FUN_00457aa0();
            iVar4 = *(int *)((int)register0x00000010 + -0x14);
            iVar5 = *(int *)((int)register0x00000010 + -0xc);
          }
          if (DAT_005f5fd0 != (int *)0x0) {
            iVar8 = *(int *)(iVar5 + 0xc4);
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a8d4;
            FUN_0046ed70();
            *in_EDI = iVar8;
          }
          *(undefined4 *)(iVar5 + 0xc4) = 0;
          *(undefined1 *)(iVar5 + 0x70) = 0;
          uVar1 = *(uint *)(iVar4 + 0x18);
          iVar8 = *(int *)(iVar4 + 0x1c);
          puVar10 = (undefined4 *)CONCAT31((int3)((uint)in_EDI >> 8),uVar1 != 0);
          if (0 < iVar8 || iVar8 == 0 && uVar1 != 0) {
            *(uint *)((int)register0x00000010 + -0x38) =
                 uVar1 - *(uint *)((int)register0x00000010 + -0x20);
            *(uint *)((int)register0x00000010 + -0x34) =
                 (iVar8 - *(int *)((int)register0x00000010 + -0x1c)) -
                 (uint)(uVar1 < *(uint *)((int)register0x00000010 + -0x20));
            *(undefined4 *)((int)register0x00000010 + -0x30) = 2;
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a92d;
            FUN_00468e20();
            iVar4 = *(int *)((int)register0x00000010 + -0x14);
            iVar5 = *(int *)((int)register0x00000010 + -0xc);
          }
          *(undefined1 *)((int)register0x00000010 + -0x21) = *(undefined1 *)(iVar4 + 0x25);
          if (DAT_005f5fd0 != (int *)0x0) {
            uVar9 = *(undefined4 *)(iVar5 + 0x48);
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a94f;
            FUN_0046ed80();
            *puVar10 = uVar9;
            puVar10[1] = *(undefined4 *)(iVar4 + 0x34);
          }
          *(undefined4 *)(iVar5 + 0x48) = 0;
          *(undefined4 *)(iVar4 + 0x34) = 0;
          *(int *)((int)register0x00000010 + -0x38) = iVar4;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40a96d;
          FUN_0043bd80();
          *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
          *(undefined1 *)((int)register0x00000010 + 0x11) =
               *(undefined1 *)((int)register0x00000010 + -0x21);
          return;
        }
        goto LAB_0040aa21;
      }
      *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004b31a0;
      *(undefined ***)((int)register0x00000010 + -0x34) = &PTR_DAT_00550d10;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x40aa4f;
      FUN_00469650();
    }
    *(undefined4 *)(puVar11 + -4) = 0x40aa55;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar11;
  } while( true );
}



/* Function: FUN_0040aa90 */

void FUN_0040aa90(void)

{
  int iVar1;
  undefined4 uVar2;
  code *pcVar3;
  int iVar4;
  int *piVar5;
  int iVar6;
  undefined1 *puVar7;
  int *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x20);
      iVar4 = *(int *)((int)register0x00000010 + 4);
      if (*(char *)(iVar4 + 0xe) == '\0') {
        piVar5 = *(int **)((int)register0x00000010 + 8);
LAB_0040aadd:
        if (*(int *)(iVar4 + 4) == 0) {
          if (*(int *)((int)register0x00000010 + 0xc) != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x20) = *(undefined4 *)(iVar4 + 0x18);
            *(int **)((int)register0x00000010 + -0x1c) = piVar5;
            *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + 0xc);
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40ab03;
            FUN_0040a0f0();
            piVar5 = *(int **)((int)register0x00000010 + 8);
          }
        }
        else {
          iVar6 = (uint)*(ushort *)(iVar4 + 0xc) * *(int *)(iVar4 + 0x20) + *(int *)(iVar4 + 8);
          if (*(int *)((int)register0x00000010 + 0xc) != 0) {
            *(int *)((int)register0x00000010 + -0x14) = iVar6;
            *(undefined4 *)((int)register0x00000010 + -0x20) = *(undefined4 *)(iVar4 + 0x18);
            *(int *)((int)register0x00000010 + -0x1c) = *(int *)((int)register0x00000010 + 0xc);
            *(int *)((int)register0x00000010 + -0x18) = iVar6;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40ab34;
            FUN_00468750();
            iVar4 = *(int *)((int)register0x00000010 + 4);
            piVar5 = *(int **)((int)register0x00000010 + 8);
            iVar6 = *(int *)((int)register0x00000010 + -0x14);
          }
          iVar1 = piVar5[3];
          *(undefined4 *)((int)register0x00000010 + -0x20) = *(undefined4 *)(iVar4 + 0x18);
          *(int *)((int)register0x00000010 + -0x1c) = iVar6;
          *(int *)((int)register0x00000010 + -0x18) = iVar1;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40ab56;
          FUN_00468750();
          iVar4 = *(int *)((int)register0x00000010 + 4);
          iVar6 = *(int *)(iVar4 + 0x20) + 1;
          *(int *)(iVar4 + 0x20) = iVar6;
          if (*(int *)(iVar4 + 4) == iVar6) {
            *(undefined4 *)(iVar4 + 0x20) = 0;
          }
          *(undefined4 *)(iVar4 + 0x1c) = *(undefined4 *)(iVar4 + 0x20);
          piVar5 = *(int **)((int)register0x00000010 + 8);
        }
        if (DAT_005f5fd0 != 0) {
          iVar4 = piVar5[3];
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40ab8b;
          FUN_0046ed70();
          *in_EDI = iVar4;
        }
        piVar5[3] = 0;
        *(int *)((int)register0x00000010 + -0x10) = *piVar5;
        pcVar3 = (code *)**(undefined4 **)((int)register0x00000010 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40aba2;
        (*pcVar3)();
        iVar4 = *(int *)((int)register0x00000010 + -0x10);
        if (DAT_005f5fd0 == 0) {
          iVar6 = *(int *)((int)register0x00000010 + 8);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40abbd;
          FUN_0046ed80();
          iVar6 = *(int *)((int)register0x00000010 + 8);
          *in_EDI = iVar6;
          in_EDI[1] = *(int *)(iVar4 + 0x48);
        }
        *(int *)(iVar4 + 0x48) = iVar6;
        *(undefined1 *)(iVar6 + 0x25) = 1;
        if (*(int *)(iVar6 + 0x1c) != 0 || *(int *)(iVar6 + 0x18) != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40abeb;
          FUN_0046ebf0();
          uVar2 = *(undefined4 *)((int)register0x00000010 + -0x1c);
          iVar4 = *(int *)((int)register0x00000010 + 8);
          *(undefined4 *)(iVar4 + 0x18) = *(undefined4 *)((int)register0x00000010 + -0x20);
          *(undefined4 *)(iVar4 + 0x1c) = uVar2;
          iVar4 = *(int *)((int)register0x00000010 + -0x10);
        }
        *(undefined1 **)((int)register0x00000010 + -0xc) = &LAB_0040ac60;
        *(int *)((int)register0x00000010 + -8) = iVar4;
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 0x14) + 1;
        *(undefined1 **)((int)register0x00000010 + -0x20) =
             (undefined1 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40ac23;
        FUN_0046d890();
        return;
      }
      piVar5 = *(int **)((int)register0x00000010 + 8);
      if (*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xf0) == *(int *)(*piVar5 + 0xf0))
      goto LAB_0040aadd;
      pcVar3 = (code *)**(undefined4 **)((int)register0x00000010 + 0x10);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40ac2f;
      (*pcVar3)();
      *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004b31a0;
      *(undefined ***)((int)register0x00000010 + -0x1c) = &PTR_DAT_00550d10;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40ac47;
      FUN_00469650();
    }
    *(undefined4 *)(puVar7 + -4) = 0x40ac4d;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_0040acf0 */

void FUN_0040acf0(undefined4 param_1,undefined4 param_2)

{
  int in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004098c0(param_1,param_2,0,unaff_retaddr);
  return;
}



/* Function: FUN_0040ad40 */

void FUN_0040ad40(int *param_1)

{
  int *piVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  int *in_EDI;
  int in_FS_OFFSET;
  char local_8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  do {
    piVar2 = (int *)*param_1;
    if (piVar2 == (int *)0x0) {
      return;
    }
    iVar3 = piVar2[1];
    if (iVar3 == 0) {
      piVar1 = param_1;
      if (DAT_005f5fd0 != 0) {
        iVar3 = *param_1;
        FUN_0046ed80();
        *in_EDI = iVar3;
        in_EDI[1] = piVar1[1];
      }
      *piVar1 = 0;
      piVar1[1] = 0;
    }
    else {
      piVar1 = param_1;
      if (DAT_005f5fd0 != 0) {
        iVar4 = *(int *)(iVar3 + 8);
        FUN_0046eda0();
        *in_EDI = iVar4;
        in_EDI[1] = iVar3;
        in_EDI[2] = *piVar1;
        in_EDI[3] = piVar2[1];
      }
      *(undefined4 *)(iVar3 + 8) = 0;
      *piVar1 = iVar3;
      piVar2[1] = 0;
    }
  } while (((char)piVar2[9] != '\0') && (FUN_00402540(*piVar2 + 0xe4,0,1), local_8 == '\0'));
  return;
}



/* Function: FUN_0040ae30 */

void FUN_0040ae30(int param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040ecf0(&DAT_005d84f8);
  iVar1 = DAT_005f5e88;
  FUN_0040f0e0(&DAT_005d84f8);
  if ((0 < param_1) && (param_1 != iVar1)) {
    FUN_0043ded0(9);
    FUN_0046f41a();
    DAT_005f5e90 = param_1;
    FUN_0046f41a();
    FUN_0043df60();
    return;
  }
  return;
}



/* Function: FUN_0040aee0 */

void FUN_0040aee0(void)

{
  int in_FS_OFFSET;
  int local_10;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004027a0(&DAT_005f5ee8);
  FUN_00402520(&DAT_005d6e18);
  for (; local_10 != 0; local_10 = *(int *)(local_10 + 0xb0)) {
  }
  return;
}



/* Function: FUN_0040af60 */

void FUN_0040af60(void)

{
  int in_FS_OFFSET;
  int local_24;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  thunk_FUN_004027a0(&DAT_005d8ac8);
  thunk_FUN_004027a0(&DAT_005d9f10);
  FUN_00402520(&DAT_005d6e18);
  for (; local_24 != 0; local_24 = *(int *)(local_24 + 0xb0)) {
    thunk_FUN_004027a0(local_24 + 0x148);
  }
  return;
}



/* Function: FUN_0040b030 */

void FUN_0040b030(void)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  char cVar5;
  int iVar6;
  char cVar7;
  int iVar8;
  undefined1 *puVar9;
  uint uVar10;
  int in_FS_OFFSET;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0x18);
      if (DAT_005d7000 != 0) {
        *(int *)((int)register0x00000010 + -4) = DAT_005d7000;
        *(int *)((int)register0x00000010 + -0x10) = DAT_005d7004;
        uVar2 = *(uint *)((int)register0x00000010 + 8);
        iVar4 = 0;
        iVar6 = DAT_005d7000;
        iVar8 = DAT_005d7004;
LAB_0040b070:
        if (iVar8 <= iVar4) {
          *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
          *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
          return;
        }
        piVar1 = (int *)(iVar6 + iVar4 * 8);
        iVar3 = piVar1[1];
        if ((int)uVar2 < iVar3) {
          *(int *)((int)register0x00000010 + -0xc) = iVar3;
          iVar3 = *piVar1;
          if (*(char *)(iVar3 + uVar2) == '=') {
            *(int *)((int)register0x00000010 + -8) = iVar4;
            uVar10 = 0;
            do {
              if ((int)uVar2 <= (int)uVar10) {
                *(uint *)((int)register0x00000010 + 0xc) =
                     iVar3 + (uVar2 + 1 &
                             (int)-((*(int *)((int)register0x00000010 + -0xc) - uVar2) + -1) >> 0x1f
                             );
                *(uint *)((int)register0x00000010 + 0x10) =
                     (*(int *)((int)register0x00000010 + -0xc) - uVar2) + -1;
                return;
              }
              cVar5 = *(char *)(iVar3 + uVar10);
              if (uVar2 <= uVar10) {
                *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40b11c;
                FUN_0046edf0();
                goto LAB_0040b11c;
              }
              cVar7 = *(char *)(*(int *)((int)register0x00000010 + 4) + uVar10);
              if (cVar7 != cVar5) {
                if ((byte)(cVar5 + 0xbfU) < 0x1a) {
                  cVar5 = cVar5 + ' ';
                }
                if ((byte)(cVar7 + 0xbfU) < 0x1a) {
                  cVar7 = cVar7 + ' ';
                }
                if (cVar5 != cVar7) goto LAB_0040b0e4;
              }
              uVar10 = uVar10 + 1;
            } while( true );
          }
        }
        goto LAB_0040b06f;
      }
LAB_0040b11c:
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c72e6;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x16;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40b132;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar9 + -4) = 0x40b138;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
LAB_0040b0e4:
  iVar4 = *(int *)((int)register0x00000010 + -8);
  iVar6 = *(int *)((int)register0x00000010 + -4);
  iVar8 = *(int *)((int)register0x00000010 + -0x10);
LAB_0040b06f:
  iVar4 = iVar4 + 1;
  goto LAB_0040b070;
}



/* Function: FUN_0040bf40 */

void FUN_0040bf40(undefined *param_1,float *param_2)

{
  undefined8 uVar1;
  undefined8 uVar2;
  undefined1 uVar3;
  char cVar4;
  short sVar5;
  undefined2 uVar6;
  uint uVar7;
  float fVar8;
  float fVar9;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_1 != (undefined *)0x0) {
    uVar7 = *(uint *)(param_1 + 8);
    if (uVar7 < 0x66db77fa) {
      if (uVar7 < 0x2fbedfce) {
        if (uVar7 < 0x111ed2a0) {
          if (uVar7 == 0x294554e) {
            if (param_1 == &DAT_004ae060) {
              fVar8 = *param_2;
              FUN_0043a810();
              FUN_0043ad50(fVar8,0);
              FUN_0043a870();
              return;
            }
          }
          else if ((uVar7 == 0x111ed29f) && (param_1 == &DAT_004ae2a0)) {
            uVar1 = *(undefined8 *)param_2;
            FUN_0043a810();
            FUN_0043aab0(uVar1);
            FUN_0043a870();
            return;
          }
        }
        else if (uVar7 == 0x13b6cc10) {
          if (param_1 == &DAT_004ae020) {
            fVar8 = *param_2;
            FUN_0043a810();
            FUN_0043ae80(fVar8,(int)fVar8 >> 0x1f);
            FUN_0043a870();
            return;
          }
        }
        else if ((uVar7 == 0x2fbedfcd) && (param_1 == &DAT_004ae220)) {
          uVar1 = *(undefined8 *)param_2;
          uVar2 = *(undefined8 *)(param_2 + 2);
          FUN_0043a810();
          FUN_0043acd0(uVar1,uVar2);
          FUN_0043a870();
          return;
        }
      }
      else if (uVar7 < 0x625f5c88) {
        if (uVar7 == 0x4d160681) {
          if (param_1 == &DAT_004ae0e0) {
            fVar8 = *param_2;
            fVar9 = param_2[1];
            FUN_0043a810();
            FUN_0043ad50(fVar8,fVar9);
            FUN_0043a870();
            return;
          }
        }
        else if ((uVar7 == 0x625f5c87) && (param_1 == &DAT_004ae0a0)) {
          fVar8 = *param_2;
          fVar9 = param_2[1];
          FUN_0043a810();
          FUN_0043ae80(fVar8,fVar9);
          FUN_0043a870();
          return;
        }
      }
      else if (uVar7 == 0x651d6272) {
        if (param_1 == &DAT_004adf60) {
          uVar3 = *(undefined1 *)param_2;
          FUN_0043a810();
          FUN_0043ad50(uVar3,0);
          FUN_0043a870();
          return;
        }
      }
      else if ((uVar7 == 0x66db77f9) && (param_1 == &DAT_004ae120)) {
        fVar8 = *param_2;
        FUN_0043a810();
        FUN_0043ae80(fVar8,(int)fVar8 >> 0x1f);
        FUN_0043a870();
        return;
      }
    }
    else if (uVar7 < 0x9097a864) {
      if (uVar7 < 0x71b4a375) {
        if (uVar7 == 0x68f35f3f) {
          if (param_1 == &DAT_004ae1a0) {
            fVar8 = *param_2;
            FUN_0043a810();
            FUN_0043ad50(fVar8,0);
            FUN_0043a870();
            return;
          }
        }
        else if ((uVar7 == 0x71b4a374) && (param_1 == &DAT_004ae2e0)) {
          uVar3 = *(undefined1 *)param_2;
          FUN_0043a810();
          FUN_0043aa50(uVar3);
          FUN_0043a870();
          return;
        }
      }
      else if (uVar7 == 0x87106456) {
        if (param_1 == &DAT_004adfa0) {
          sVar5 = *(short *)param_2;
          FUN_0043a810();
          FUN_0043ae80((int)sVar5,(int)sVar5 >> 0x1f);
          FUN_0043a870();
          return;
        }
      }
      else if ((uVar7 == 0x9097a863) && (param_1 == &DAT_004adee0)) {
        FUN_0040cd00(*param_2,param_2[1]);
        return;
      }
    }
    else if (uVar7 < 0xa1718dd5) {
      if (uVar7 == 0xa08ba67d) {
        if (param_1 == &DAT_004adfe0) {
          uVar6 = *(undefined2 *)param_2;
          FUN_0043a810();
          FUN_0043ad50(uVar6,0);
          FUN_0043a870();
          return;
        }
      }
      else if ((uVar7 == 0xa1718dd4) && (param_1 == &DAT_004ae260)) {
        fVar8 = *param_2;
        FUN_0043a810();
        FUN_0043aab0((double)fVar8);
        FUN_0043a870();
        return;
      }
    }
    else if (uVar7 == 0xb6882940) {
      if (param_1 == &DAT_004ae1e0) {
        fVar8 = *param_2;
        fVar9 = param_2[1];
        FUN_0043a810();
        FUN_0043acd0((double)fVar8,(double)fVar9);
        FUN_0043a870();
        return;
      }
    }
    else if (uVar7 == 0xdf136f9a) {
      if (param_1 == &DAT_004ae160) {
        fVar8 = *param_2;
        FUN_0043a810();
        FUN_0043ad50(fVar8,0);
        FUN_0043a870();
        return;
      }
    }
    else if ((uVar7 == 0xe12fc403) && (param_1 == &DAT_004adf20)) {
      cVar4 = *(char *)param_2;
      FUN_0043a810();
      FUN_0043ae80((int)cVar4,(int)cVar4 >> 0x1f);
      FUN_0043a870();
      return;
    }
    FUN_0040c4b0(param_1,param_2);
    return;
  }
  FUN_0043a810();
  FUN_0043b060(&DAT_004c2a14,3);
  FUN_0043a870();
  return;
}



/* Function: FUN_0040c4b0 */

void FUN_0040c4b0(int param_1,float *param_2)

{
  undefined8 uVar1;
  undefined8 uVar2;
  byte bVar3;
  undefined1 uVar4;
  char cVar5;
  short sVar6;
  undefined2 uVar7;
  float fVar8;
  float fVar9;
  int in_FS_OFFSET;
  undefined8 in_stack_ffffffb4;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined8 in_stack_ffffffbc;
  
  while (uVar11 = (undefined4)in_stack_ffffffbc,
        &stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar10 = (undefined4)((ulong)in_stack_ffffffb4 >> 0x20);
  FUN_00462470(param_1);
  bVar3 = *(byte *)(param_1 + 0xf);
  if (bVar3 < 9) {
    if (4 < bVar3) {
      if (6 < bVar3) {
        if (bVar3 == 7) {
          fVar8 = *param_2;
          FUN_0043a810();
          FUN_0043b060(uVar10,uVar11);
          FUN_0043b060(&DAT_004c2928,1);
          FUN_0043ad50(fVar8,0);
          FUN_0043b060(&DAT_004c2926,1);
          FUN_0043a870();
          return;
        }
        uVar4 = *(undefined1 *)param_2;
        FUN_0043a810();
        FUN_0043b060(uVar10,uVar11);
        FUN_0043b060(&DAT_004c2928,1);
        FUN_0043ad50(uVar4,0);
        FUN_0043b060(&DAT_004c2926,1);
        FUN_0043a870();
        return;
      }
      if (bVar3 == 5) {
        fVar8 = *param_2;
        FUN_0043a810();
        FUN_0043b060(uVar10,uVar11);
        FUN_0043b060(&DAT_004c2928,1);
        FUN_0043ae80(fVar8,(int)fVar8 >> 0x1f);
        FUN_0043b060(&DAT_004c2926,1);
        FUN_0043a870();
        return;
      }
      fVar8 = *param_2;
      fVar9 = param_2[1];
      FUN_0043a810();
      FUN_0043b060(uVar10,uVar11);
      FUN_0043b060(&DAT_004c2928,1);
      FUN_0043ae80(fVar8,fVar9);
      FUN_0043b060(&DAT_004c2926,1);
      FUN_0043a870();
      return;
    }
    if (2 < bVar3) {
      if (bVar3 == 3) {
        cVar5 = *(char *)param_2;
        FUN_0043a810();
        FUN_0043b060(uVar10,uVar11);
        FUN_0043b060(&DAT_004c2928,1);
        FUN_0043ae80((int)cVar5,(int)cVar5 >> 0x1f);
        FUN_0043b060(&DAT_004c2926,1);
        FUN_0043a870();
        return;
      }
      sVar6 = *(short *)param_2;
      FUN_0043a810();
      FUN_0043b060(uVar10,uVar11);
      FUN_0043b060(&DAT_004c2928,1);
      FUN_0043ae80((int)sVar6,(int)sVar6 >> 0x1f);
      FUN_0043b060(&DAT_004c2926,1);
      FUN_0043a870();
      return;
    }
    if (bVar3 == 1) {
      uVar4 = *(undefined1 *)param_2;
      FUN_0043a810();
      FUN_0043b060(uVar10,uVar11);
      FUN_0043b060(&DAT_004c2928,1);
      FUN_0043aa50(uVar4);
      FUN_0043b060(&DAT_004c2926,1);
      FUN_0043a870();
      return;
    }
    if (bVar3 == 2) {
      fVar8 = *param_2;
      FUN_0043a810();
      FUN_0043b060(uVar10,uVar11);
      FUN_0043b060(&DAT_004c2928,1);
      FUN_0043ae80(fVar8,(int)fVar8 >> 0x1f);
      FUN_0043b060(&DAT_004c2926,1);
      FUN_0043a870();
      return;
    }
  }
  else {
    if (bVar3 < 0xd) {
      if (10 < bVar3) {
        if (bVar3 == 0xb) {
          fVar8 = *param_2;
          fVar9 = param_2[1];
          FUN_0043a810();
          FUN_0043b060(uVar10,uVar11);
          FUN_0043b060(&DAT_004c2928,1);
          FUN_0043ad50(fVar8,fVar9);
          FUN_0043b060(&DAT_004c2926,1);
          FUN_0043a870();
          return;
        }
        fVar8 = *param_2;
        FUN_0043a810();
        FUN_0043b060(uVar10,uVar11);
        FUN_0043b060(&DAT_004c2928,1);
        FUN_0043ad50(fVar8,0);
        FUN_0043b060(&DAT_004c2926,1);
        FUN_0043a870();
        return;
      }
      if (bVar3 == 9) {
        uVar7 = *(undefined2 *)param_2;
        FUN_0043a810();
        FUN_0043b060(uVar10,uVar11);
        FUN_0043b060(&DAT_004c2928,1);
        FUN_0043ad50(uVar7,0);
        FUN_0043b060(&DAT_004c2926,1);
        FUN_0043a870();
        return;
      }
      fVar8 = *param_2;
      FUN_0043a810();
      FUN_0043b060(uVar10,uVar11);
      FUN_0043b060(&DAT_004c2928,1);
      FUN_0043ad50(fVar8,0);
      FUN_0043b060(&DAT_004c2926,1);
      FUN_0043a870();
      return;
    }
    if (bVar3 < 0xf) {
      if (bVar3 == 0xd) {
        fVar8 = *param_2;
        FUN_0043a810();
        FUN_0043b060(uVar10,uVar11);
        FUN_0043b060(&DAT_004c2928,1);
        FUN_0043aab0((double)fVar8);
        FUN_0043b060(&DAT_004c2926,1);
        FUN_0043a870();
        return;
      }
      uVar1 = *(undefined8 *)param_2;
      FUN_0043a810();
      FUN_0043b060(uVar10,uVar11);
      FUN_0043b060(&DAT_004c2928,1);
      FUN_0043aab0(uVar1);
      FUN_0043b060(&DAT_004c2926,1);
      FUN_0043a870();
      return;
    }
    if (bVar3 == 0xf) {
      fVar8 = *param_2;
      fVar9 = param_2[1];
      FUN_0043a810();
      FUN_0043b060(uVar10,uVar11);
      FUN_0043acd0((double)fVar8,(double)fVar9);
      FUN_0043a870();
      return;
    }
    if (bVar3 == 0x10) {
      uVar1 = *(undefined8 *)param_2;
      uVar2 = *(undefined8 *)(param_2 + 2);
      FUN_0043a810();
      FUN_0043b060(uVar10,uVar11);
      FUN_0043acd0(uVar1,uVar2);
      FUN_0043a870();
      return;
    }
    if (bVar3 == 0x18) {
      FUN_0043a810();
      FUN_0043b060(uVar10,uVar11);
      FUN_0043b060(&DAT_004c2940,2);
      FUN_0043a870();
      FUN_0040cd00(*param_2,param_2[1]);
      FUN_0043a810();
      FUN_0043b060(&DAT_004c2942,2);
      FUN_0043a870();
      return;
    }
  }
  FUN_0043a810();
  FUN_0043b060(&DAT_004c2928,1);
  FUN_0043b060(uVar10,uVar11);
  FUN_0043b060(&DAT_004c2944,2);
  FUN_0043afe0(param_2);
  FUN_0043a870();
  return;
}



/* Function: FUN_0040cd00 */

void FUN_0040cd00(void)

{
  int iVar1;
  int iVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x20);
      iVar1 = *(int *)((int)register0x00000010 + 8);
      iVar2 = *(int *)((int)register0x00000010 + 4);
      while( true ) {
        *(int *)((int)register0x00000010 + -4) = iVar2;
        *(int *)((int)register0x00000010 + -8) = iVar1;
        *(int *)((int)register0x00000010 + -0x20) = iVar2;
        *(int *)((int)register0x00000010 + -0x1c) = iVar1;
        *(undefined1 *)((int)register0x00000010 + -0x18) = 10;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cd9e;
        FUN_00402ae0();
        iVar1 = *(int *)((int)register0x00000010 + -0x14);
        if (iVar1 < 0) {
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cdbc;
          FUN_0043a810();
          *(undefined4 *)((int)register0x00000010 + -0x20) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x1c) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cdd0;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cdd5;
          FUN_0043a870();
          return;
        }
        if (*(uint *)((int)register0x00000010 + -8) < iVar1 + 1U) break;
        *(int *)((int)register0x00000010 + -0x10) = iVar1;
        *(uint *)((int)register0x00000010 + -0xc) = iVar1 + 1U;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cd2e;
        FUN_0043a810();
        *(undefined4 *)((int)register0x00000010 + -0x20) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cd42;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cd47;
        FUN_0043a870();
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cd4c;
        FUN_0043a810();
        *(undefined **)((int)register0x00000010 + -0x20) = &DAT_0055044c;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cd62;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cd67;
        FUN_0043a870();
        iVar1 = (*(int *)((int)register0x00000010 + -8) - *(int *)((int)register0x00000010 + -0x10))
                + -1;
        iVar2 = *(int *)((int)register0x00000010 + -4) +
                (*(uint *)((int)register0x00000010 + -0xc) & -iVar1 >> 0x1f);
      }
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40cdde;
      FUN_0046ee10();
    }
    *(undefined4 *)(puVar3 + -4) = 0x40cde4;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_0040cdf0 */

void FUN_0040cdf0(void)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  undefined4 uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  int in_FS_OFFSET;
  undefined1 uVar10;
  undefined1 uVar11;
  undefined4 unaff_retaddr;
  uint in_stack_ffffff1c;
  undefined4 in_stack_ffffff20;
  uint in_stack_ffffff24;
  uint in_stack_ffffff28;
  uint uVar12;
  uint local_d4;
  uint local_d0;
  uint local_cc;
  uint local_c8;
  undefined1 local_c4 [32];
  undefined1 local_a4 [32];
  undefined1 local_84 [28];
  undefined1 local_68 [4];
  uint local_64;
  uint local_60;
  uint local_5c;
  int local_58;
  uint local_54;
  int local_50;
  int local_4c;
  char *local_48;
  undefined4 local_44;
  uint local_40;
  uint local_3c;
  undefined *local_38;
  undefined4 local_34;
  int local_30;
  undefined *local_28;
  undefined4 local_24;
  int local_20;
  int local_1c;
  undefined *local_18;
  undefined4 local_14;
  int local_10;
  undefined *local_8;
  undefined4 local_4;
  
  while (local_68 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x40d1f6;
    FUN_0046d980();
  }
  FUN_0046b840(unaff_retaddr);
  uVar4 = in_stack_ffffff20;
  local_54 = in_stack_ffffff24;
  if (in_stack_ffffff1c != 0) goto LAB_0040d1d1;
  local_54 = 0;
  uVar4 = 0;
  do {
    in_stack_ffffff1c = local_d0;
    uVar12 = local_d4;
    FUN_00459e90(uVar4,local_54);
    local_d4 = local_d0;
    local_d0 = local_cc;
    FUN_00451e50(local_84,in_stack_ffffff20,in_stack_ffffff24,in_stack_ffffff28,uVar12);
    local_54 = local_cc;
    local_64 = local_c8;
    FUN_00402ae0(local_cc,local_c8,0x28);
    if (-1 < (int)in_stack_ffffff28) {
      uVar5 = in_stack_ffffff28 - 1;
      if (uVar5 <= local_64) {
        uVar7 = in_stack_ffffff28 + 2;
        uVar10 = local_64 < uVar7;
        uVar6 = local_64;
        uVar3 = in_stack_ffffff28;
        if ((int)uVar7 < (int)local_64) goto LAB_0040cf02;
        do {
          uVar3 = local_54;
          uVar12 = uVar6;
          FUN_00451db0(0,
                       "panicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid..." /* TRUNCATED STRING LITERAL */
                       ,0x31,local_54,uVar6);
          in_stack_ffffff28 = in_stack_ffffff1c;
          uVar5 = local_cc;
          FUN_00469a20(in_stack_ffffff1c,local_cc);
LAB_0040cf02:
          if ((bool)uVar10) goto LAB_0040d17d;
          if (uVar7 < uVar5) goto LAB_0040d174;
          uVar2 = *(ushort *)((in_stack_ffffff28 - 1) + local_54);
          uVar10 = uVar2 < 0x282e;
        } while ((uVar2 != 0x282e) ||
                (bVar1 = *(byte *)(in_stack_ffffff28 + 1 + local_54), uVar10 = bVar1 < 0x2a,
                bVar1 != 0x2a));
        local_58 = uVar6 - in_stack_ffffff28;
        local_5c = local_58 - 2;
        local_50 = ((int)-local_5c >> 0x1f & uVar7) + local_54;
        local_60 = uVar5;
        FUN_00402ae0(local_50,local_5c,0x29);
        if (-1 < (int)uVar3) {
          uVar5 = uVar3 + 2;
          uVar10 = uVar5 < local_5c;
          uVar11 = uVar5 == local_5c;
          uVar7 = local_5c;
          if ((int)uVar5 < (int)local_5c) goto LAB_0040cfc3;
          do {
            uVar12 = uVar7;
            FUN_00451db0(0,&DAT_004ccad8,0x2e,local_50,uVar7);
            uVar3 = in_stack_ffffff1c;
            uVar5 = local_cc;
            FUN_00469a20(in_stack_ffffff1c,local_cc);
LAB_0040cfc3:
            if (!(bool)uVar10 && !(bool)uVar11) goto LAB_0040d127;
            if (uVar5 < uVar3) goto LAB_0040d122;
            uVar10 = *(ushort *)(local_50 + uVar3) < 0x2e29;
            uVar11 = *(ushort *)(local_50 + uVar3) == 0x2e29;
          } while (!(bool)uVar11);
          iVar8 = (local_58 - uVar3) + -4;
          local_4c = local_50 + (-iVar8 >> 0x1f & uVar5);
          iVar9 = local_50;
          FUN_0046ef3e();
          local_44 = 0xd;
          local_48 = 
          "value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
          ;
          local_3c = local_60;
          local_40 = local_54;
          local_34 = 1;
          local_38 = &DAT_00550430;
          local_24 = 1;
          local_28 = &DAT_00550430;
          local_20 = local_4c;
          local_14 = 0x13;
          local_18 = &DAT_004c6131;
          local_4 = 8;
          local_8 = &DAT_004c3122;
          uVar4 = 9;
          local_30 = iVar9;
          local_1c = iVar8;
          local_10 = iVar9;
          FUN_00451be0(0,&local_48,9,9);
          FUN_004682f0(uVar12,in_stack_ffffff1c);
          FUN_00469650(&DAT_004b31a0,uVar4);
LAB_0040d122:
          FUN_0046ee50();
LAB_0040d127:
          FUN_0046ee10();
        }
        FUN_00451db0(local_c4,&DAT_004c611e,0x13,local_50,local_5c);
        FUN_00469a20(in_stack_ffffff1c,local_cc);
LAB_0040d174:
        FUN_0046ee50();
LAB_0040d17d:
        FUN_0046ee10();
      }
      FUN_0046ee10();
    }
    uVar4 = 0x13;
    FUN_00451db0(local_a4,&DAT_004c610b);
    FUN_00469a20(in_stack_ffffff1c,local_cc);
    in_stack_ffffff28 = local_64;
LAB_0040d1d1:
    FUN_00453940(uVar4,*(undefined4 *)(in_stack_ffffff1c + 4));
    in_stack_ffffff20 = uVar4;
    in_stack_ffffff24 = local_54;
  } while( true );
}



/* Function: FUN_0040d2c0 */

void FUN_0040d2c0(undefined4 param_1,undefined4 param_2,uint param_3)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_3 != 0) {
    for (; 8 < param_3; param_3 = param_3 - 8) {
    }
    return;
  }
  return;
}



/* Function: FUN_0040d390 */

void FUN_0040d390(int param_1,uint param_2,uint param_3)

{
  uint uVar1;
  code *pcVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  
  if ((int)param_3 < 0) {
    FUN_004026b0(param_1 + 0x500,1,0);
    return;
  }
  if (param_3 == 0) {
    iVar4 = 0;
    uVar3 = param_2;
  }
  else {
    iVar4 = 0x20;
    uVar3 = param_3;
  }
  if (0xffff < uVar3) {
    uVar3 = uVar3 >> 0x10;
    iVar4 = iVar4 + 0x10;
  }
  if (0xff < uVar3) {
    uVar3 = uVar3 >> 8;
    iVar4 = iVar4 + 8;
  }
  if (0xff < uVar3) {
    FUN_0046ee00();
    FUN_0046ee90();
    pcVar2 = (code *)swi(3);
    (*pcVar2)();
    return;
  }
  uVar5 = (uint)(byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                      [uVar3 + 0x1510] + iVar4;
  if (uVar5 < 9) {
    uVar3 = 0;
    uVar5 = 9;
  }
  else {
    uVar3 = ((byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                   [uVar3 + 0x1510] - 8) + iVar4;
  }
  if (uVar3 < 0x28) {
    uVar1 = uVar5 - 0x23;
    uVar5 = uVar5 - 3;
    FUN_004026b0(param_1 + ((((-(uint)(uVar5 >> 5 == 0) ^ 0xffffffff) &
                              (int)param_3 >> ((~-(uVar1 < 0x20) | (byte)uVar1) & 0x1f) |
                             param_3 << ((byte)-uVar1 & 0x1f) & -(uint)(-uVar1 < 0x20) |
                             param_2 >> ((byte)uVar5 & 0x1f) & -(uint)(uVar5 < 0x20)) & 3) +
                           uVar3 * 4) * 8,1,0);
    return;
  }
  FUN_004026b0(param_1 + 0x508,1,0);
  return;
}



/* Function: FUN_0040d560 */

void FUN_0040d560(void)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  int *piVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  undefined1 *puVar8;
  int *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x2c);
      *(int *)((int)register0x00000010 + -4) = DAT_005d6fc0;
      *(int *)((int)register0x00000010 + -0x18) = DAT_005d6fc4;
      *(undefined4 *)((int)register0x00000010 + -0x14) = DAT_005d6fc8;
      piVar4 = *(int **)((int)register0x00000010 + 8);
      if ((*piVar4 != 3) ||
         (iVar5 = piVar4[3], iVar2 = DAT_005d6fc0, iVar3 = DAT_005d6fc4, uVar7 = DAT_005d6fc8,
         iVar5 == 0)) {
        *piVar4 = 3;
        *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004b5040;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d5b9;
        FUN_00411710();
        iVar5 = *(int *)((int)register0x00000010 + -0x28);
        if (DAT_005f5fd0 == 0) {
          iVar3 = *(int *)((int)register0x00000010 + 8);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d5d2;
          FUN_0046ed80();
          *in_EDI = iVar5;
          iVar3 = *(int *)((int)register0x00000010 + 8);
          in_EDI[1] = *(int *)(iVar3 + 0xc);
        }
        *(int *)(iVar3 + 0xc) = iVar5;
        iVar2 = *(int *)((int)register0x00000010 + -4);
        uVar7 = *(undefined4 *)((int)register0x00000010 + -0x14);
        iVar3 = *(int *)((int)register0x00000010 + -0x18);
      }
      *(int *)(iVar5 + 0x10) = iVar3;
      *(undefined4 *)(iVar5 + 0x14) = uVar7;
      if (DAT_005f5fd0 != 0) {
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d604;
        FUN_0046ed80();
        *in_EDI = iVar2;
        in_EDI[1] = *(int *)(iVar5 + 0xc);
      }
      *(int *)((int)register0x00000010 + -8) = iVar5;
      *(int *)(iVar5 + 0xc) = iVar2;
      iVar3 = iVar3 + -1;
      if (*(int *)(iVar5 + 4) != iVar3) {
        *(int *)((int)register0x00000010 + -0xc) = iVar3;
        *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004ae0e0;
        *(int *)((int)register0x00000010 + -0x28) = iVar3;
        *(int *)((int)register0x00000010 + -0x24) = iVar3;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d635;
        FUN_0046a780();
        iVar3 = *(int *)((int)register0x00000010 + -0x20);
        iVar5 = *(int *)((int)register0x00000010 + -0xc);
        piVar4 = *(int **)((int)register0x00000010 + -8);
        piVar4[1] = iVar5;
        piVar4[2] = iVar5;
        if (DAT_005f5fd0 != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d656;
          FUN_0046ed80();
          *in_EDI = iVar3;
          in_EDI[1] = *piVar4;
        }
        *piVar4 = iVar3;
      }
      *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 4) + 0x500;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d672;
      FUN_004027a0();
      piVar4 = *(int **)((int)register0x00000010 + -8);
      if (piVar4[1] != 0) {
        puVar1 = (undefined4 *)*piVar4;
        uVar7 = *(undefined4 *)((int)register0x00000010 + -0x24);
        *puVar1 = *(undefined4 *)((int)register0x00000010 + -0x28);
        puVar1[1] = uVar7;
        uVar6 = 0;
        while ((int)uVar6 < 0xa0) {
          *(uint *)((int)register0x00000010 + -0x1c) = uVar6;
          *(uint *)((int)register0x00000010 + -0xc) = uVar6 + 1;
          *(uint *)((int)register0x00000010 + -0x2c) =
               *(int *)((int)register0x00000010 + 4) + uVar6 * 8;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d6cf;
          FUN_004027a0();
          piVar4 = *(int **)((int)register0x00000010 + -8);
          uVar6 = *(uint *)((int)register0x00000010 + -0xc);
          if ((uint)piVar4[1] <= uVar6) goto LAB_0040d72e;
          puVar1 = (undefined4 *)(*piVar4 + 8 + *(int *)((int)register0x00000010 + -0x1c) * 8);
          uVar7 = *(undefined4 *)((int)register0x00000010 + -0x24);
          *puVar1 = *(undefined4 *)((int)register0x00000010 + -0x28);
          puVar1[1] = uVar7;
        }
        iVar3 = piVar4[1];
        *(int *)((int)register0x00000010 + -0xc) = iVar3;
        *(int *)((int)register0x00000010 + -0x10) = iVar3 + -1;
        *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 4) + 0x508;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d6fd;
        FUN_004027a0();
        if (*(uint *)((int)register0x00000010 + -0x10) <
            (uint)(*(int **)((int)register0x00000010 + -8))[1]) {
          puVar1 = (undefined4 *)
                   (**(int **)((int)register0x00000010 + -8) + -8 +
                   *(int *)((int)register0x00000010 + -0xc) * 8);
          uVar7 = *(undefined4 *)((int)register0x00000010 + -0x24);
          *puVar1 = *(undefined4 *)((int)register0x00000010 + -0x28);
          puVar1[1] = uVar7;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d72e;
        FUN_0046edf0();
LAB_0040d72e:
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d735;
        FUN_0046edf0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x40d73e;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar8 + -4) = 0x40d744;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_0040d750 */

void FUN_0040d750(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  byte bVar4;
  uint uVar5;
  int iVar6;
  int in_FS_OFFSET;
  undefined8 *puStack_4c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0046a780(&DAT_004ae2a0,0xa3);
  *puStack_4c = 0xfff0000000000000;
  for (uVar5 = 0; (int)uVar5 < 4; uVar5 = uVar5 + 1) {
    FUN_00464b10(uVar5 << 6,uVar5 >> 0x1a | ((int)uVar5 >> 0x1f) << 6);
    puStack_4c[uVar5 + 1] = (double)CONCAT44(puStack_4c,0xa3) / DAT_00550be4;
  }
  for (iVar6 = 9; iVar6 < 0x30; iVar6 = iVar6 + 1) {
    for (uVar5 = 0; (int)uVar5 < 4; uVar5 = uVar5 + 1) {
      uVar1 = iVar6 - 0x21;
      uVar2 = iVar6 - 0x23;
      bVar4 = (byte)(iVar6 - 3U);
      uVar3 = -(uint)(iVar6 - 3U < 0x20);
      FUN_00464b10(1 << ((byte)(iVar6 - 1U) & 0x1f) & -(uint)(iVar6 - 1U < 0x20) |
                   uVar5 << (bVar4 & 0x1f) & uVar3,
                   1 << ((byte)uVar1 & 0x1f) & -(uint)(uVar1 < 0x20) |
                   1U >> ((byte)-uVar1 & 0x1f) & -(uint)(-uVar1 < 0x20) |
                   uVar5 << ((byte)uVar2 & 0x1f) & -(uint)(uVar2 < 0x20) |
                   ((int)uVar5 >> 0x1f) << (bVar4 & 0x1f) & uVar3 |
                   uVar5 >> ((byte)-uVar2 & 0x1f) & -(uint)(-uVar2 < 0x20));
      puStack_4c[(uVar5 - 0x1f) + iVar6 * 4] = (double)CONCAT44(puStack_4c,0xa3) / DAT_00550be4;
    }
  }
  puStack_4c[0xa1] = DAT_00550ca8;
  puStack_4c[0xa2] = 0x7ff0000000000000;
  return;
}



/* Function: FUN_0040d980 */

void FUN_0040d980(int *param_1,int param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int in_FS_OFFSET;
  int *local_10;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar1 = *param_1;
  uVar2 = *(uint *)(param_2 + 8) ^ *(uint *)(param_3 + 8);
  iVar3 = 1;
  while( true ) {
    uVar2 = uVar2 & iVar1 - 1U;
    FUN_00402520(param_1 + uVar2 + 2);
    if (local_10 == (int *)0x0) {
      return;
    }
    if ((*local_10 == param_2) && (local_10[1] == param_3)) break;
    uVar2 = uVar2 + iVar3;
    iVar3 = iVar3 + 1;
  }
  return;
}



/* Function: FUN_0040da30 */

void FUN_0040da30(void)

{
  uint uVar1;
  int *piVar2;
  int *piVar3;
  uint *puVar4;
  uint uVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x28);
      if (*(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x6c) == 0) {
        uVar5 = *(uint *)PTR_DAT_005cef04;
        if (*(uint *)(PTR_DAT_005cef04 + 4) < (uVar5 >> 2) * 3) goto LAB_0040dac6;
        *(undefined **)((int)register0x00000010 + -0x10) = PTR_DAT_005cef04;
        *(uint *)((int)register0x00000010 + -0x28) = (uVar5 * 2 + 2) * 4;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
        *(undefined1 *)((int)register0x00000010 + -0x20) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40da98;
        FUN_00468370();
        piVar2 = *(int **)((int)register0x00000010 + -0x1c);
        *(int **)((int)register0x00000010 + -0xc) = piVar2;
        piVar3 = *(int **)((int)register0x00000010 + -0x10);
        *piVar2 = *piVar3 << 1;
        *(code **)((int)register0x00000010 + -8) = FUN_004725f0;
        *(int **)((int)register0x00000010 + -4) = piVar2;
        *(undefined **)((int)register0x00000010 + -0x14) = PTR_DAT_005cef04;
        puVar4 = (uint *)PTR_DAT_005cef04;
        for (uVar5 = 0; uVar5 < *puVar4; uVar5 = uVar5 + 1) {
          uVar1 = puVar4[uVar5 + 2];
          if (uVar1 != 0) {
            *(uint *)((int)register0x00000010 + -0x18) = uVar5;
            *(uint *)((int)register0x00000010 + -0x28) = uVar1;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40daf8;
            (**(code **)((int)register0x00000010 + -8))();
            piVar2 = *(int **)((int)register0x00000010 + -0xc);
            piVar3 = *(int **)((int)register0x00000010 + -0x10);
            puVar4 = *(uint **)((int)register0x00000010 + -0x14);
            uVar5 = *(uint *)((int)register0x00000010 + -0x18);
          }
        }
        if (piVar3[1] == piVar2[1]) {
          *(undefined ***)((int)register0x00000010 + -0x28) = &PTR_DAT_005cef04;
          *(int **)((int)register0x00000010 + -0x24) = piVar2;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40db24;
          FUN_00408fc0();
LAB_0040dac6:
          *(undefined **)((int)register0x00000010 + -0x28) = PTR_DAT_005cef04;
          *(undefined4 *)((int)register0x00000010 + -0x24) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40dad6;
          FUN_0040db70();
          return;
        }
        *(char **)((int)register0x00000010 + -0x28) =
             "mismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x27;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40db42;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x28) =
           "malloc deadlockruntime error: scan missed a gmisaligned maskruntime: min = runtime: inUse=runtime: max = requested skip=bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0xf;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40db58;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x40db5e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_0040db70 */

void FUN_0040db70(int *param_1,int *param_2)

{
  uint uVar1;
  int iVar2;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar1 = *(uint *)(*param_2 + 8) ^ *(uint *)(param_2[1] + 8);
  iVar2 = 1;
  while( true ) {
    uVar1 = uVar1 & *param_1 - 1U;
    if (param_2 == (int *)param_1[uVar1 + 2]) {
      return;
    }
    if ((int *)param_1[uVar1 + 2] == (int *)0x0) break;
    uVar1 = uVar1 + iVar2;
    iVar2 = iVar2 + 1;
  }
  FUN_00402760(param_1 + uVar1 + 2,param_2);
  param_1[1] = param_1[1] + 1;
  return;
}



/* Function: FUN_0040dbe0 */

void FUN_0040dbe0(void)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  undefined4 uVar5;
  char cVar6;
  uint uVar7;
  undefined1 *puVar8;
  int *piVar9;
  uint uVar10;
  byte bVar11;
  int iVar12;
  undefined4 *puVar13;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x5c);
      piVar9 = *(int **)((int)register0x00000010 + 4);
      iVar4 = piVar9[1];
      if ((*(byte *)(iVar4 + 0xc) & 1) == 0) {
        iVar12 = 0;
      }
      else {
        bVar11 = *(byte *)(iVar4 + 0xf) & 0x1f;
        if (bVar11 < 0x15) {
          if (bVar11 < 0x13) {
            if (bVar11 == 0x11) {
              iVar12 = iVar4 + 0x2c;
            }
            else if (bVar11 == 0x12) {
              iVar12 = iVar4 + 0x28;
            }
            else {
LAB_0040dc7b:
              iVar12 = iVar4 + 0x20;
            }
          }
          else if (bVar11 == 0x13) {
            iVar12 = iVar4 + 0x24;
          }
          else {
            iVar12 = iVar4 + 0x30;
          }
        }
        else if (bVar11 < 0x17) {
          if (bVar11 == 0x15) {
            iVar12 = iVar4 + 0x40;
          }
          else {
            iVar12 = iVar4 + 0x24;
          }
        }
        else if (bVar11 == 0x17) {
          iVar12 = iVar4 + 0x24;
        }
        else {
          if (bVar11 != 0x19) goto LAB_0040dc7b;
          iVar12 = iVar4 + 0x30;
        }
      }
      iVar1 = *piVar9;
      uVar7 = *(uint *)(iVar1 + 0x28);
      iVar2 = *(int *)(iVar12 + 8);
      if (uVar7 < 0x10001) {
        *(int *)((int)register0x00000010 + -0x14) = iVar1;
        *(int *)((int)register0x00000010 + -0x1c) = iVar4;
        *(int *)((int)register0x00000010 + -0x20) = iVar12;
        *(int *)((int)register0x00000010 + -0x24) = iVar2 + iVar12;
        *(uint *)((int)register0x00000010 + -0x4c) = uVar7;
        *(uint *)((int)register0x00000010 + -0x2c) = (uint)*(ushort *)(iVar12 + 4);
        *(int *)((int)register0x00000010 + -0x38) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
        iVar4 = *(int *)((int)register0x00000010 + -0x38);
LAB_0040dcfd:
        puVar13 = *(undefined4 **)((int)register0x00000010 + -0x48);
        if ((int)uVar7 <= (int)puVar13) {
          if (*(char *)((int)register0x00000010 + 8) != '\0') {
            piVar9[3] = *(int *)((int)register0x00000010 + -0xc);
          }
          *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
          *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
          return;
        }
        if (puVar13 < *(undefined4 **)(iVar4 + 0x28)) {
          uVar5 = *(undefined4 *)(*(int *)(iVar4 + 0x24) + 4 + (int)puVar13 * 8);
          *(int *)((int)register0x00000010 + -4) = *(int *)(iVar4 + 0x24) + (int)puVar13 * 8;
          *(int *)((int)register0x00000010 + -0x5c) = iVar4;
          *(undefined4 *)((int)register0x00000010 + -0x58) = uVar5;
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40dd30;
          FUN_00462c50();
          uVar5 = **(undefined4 **)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x28) =
               *(undefined4 *)((int)register0x00000010 + -0x54);
          *(undefined4 *)((int)register0x00000010 + -0x5c) =
               *(undefined4 *)((int)register0x00000010 + -0x14);
          *(undefined4 *)((int)register0x00000010 + -0x58) = uVar5;
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40dd4e;
          FUN_004629a0();
          *(undefined4 *)((int)register0x00000010 + -8) =
               *(undefined4 *)((int)register0x00000010 + -0x54);
          *(undefined4 *)((int)register0x00000010 + -0x5c) =
               *(undefined4 *)((int)register0x00000010 + -0x54);
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40dd5e;
          FUN_00401280();
          *(undefined4 *)((int)register0x00000010 + -0x10) =
               *(undefined4 *)((int)register0x00000010 + -0x58);
          *(undefined4 *)((int)register0x00000010 + -0x3c) =
               *(undefined4 *)((int)register0x00000010 + -0x54);
          *(undefined4 *)((int)register0x00000010 + -0x5c) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40dd7a;
          FUN_00463150();
          iVar4 = *(int *)((int)register0x00000010 + -0x54);
          uVar5 = *(undefined4 *)((int)register0x00000010 + -0x58);
          if (iVar4 == 0) {
            *(undefined4 *)((int)register0x00000010 + -0x5c) =
                 *(undefined4 *)(*(int *)((int)register0x00000010 + -0x14) + 0x20);
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40dd95;
            FUN_00401280();
            uVar5 = *(undefined4 *)((int)register0x00000010 + -0x58);
            iVar4 = *(int *)((int)register0x00000010 + -0x54);
          }
          *(int *)((int)register0x00000010 + -0x40) = iVar4;
          *(undefined4 *)((int)register0x00000010 + -0x18) = uVar5;
          uVar5 = *(undefined4 *)((int)register0x00000010 + -0x1c);
          iVar4 = *(int *)((int)register0x00000010 + -0x24);
          uVar10 = *(uint *)((int)register0x00000010 + -0x2c);
          uVar7 = *(uint *)((int)register0x00000010 + -0x44);
          do {
            if ((int)uVar10 <= (int)uVar7) {
              *(undefined4 *)((int)register0x00000010 + 0xc) =
                   *(undefined4 *)((int)register0x00000010 + -0x10);
              *(undefined4 *)((int)register0x00000010 + 0x10) =
                   *(undefined4 *)((int)register0x00000010 + -0x3c);
              return;
            }
            if (uVar10 <= uVar7) {
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40dfbc;
              FUN_0046edf0();
              break;
            }
            *(uint *)((int)register0x00000010 + -0x44) = uVar7;
            *(uint *)((int)register0x00000010 + -0x30) = uVar7 * 0x10;
            uVar3 = *(undefined4 *)(iVar4 + uVar7 * 0x10);
            *(undefined4 *)((int)register0x00000010 + -0x5c) = uVar5;
            *(undefined4 *)((int)register0x00000010 + -0x58) = uVar3;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40de95;
            FUN_004629a0();
            uVar5 = *(undefined4 *)
                     (*(int *)((int)register0x00000010 + -0x24) + 4 +
                     *(int *)((int)register0x00000010 + -0x30));
            *(undefined4 *)((int)register0x00000010 + -8) =
                 *(undefined4 *)((int)register0x00000010 + -0x54);
            *(undefined4 *)((int)register0x00000010 + -0x5c) =
                 *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(undefined4 *)((int)register0x00000010 + -0x58) = uVar5;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40deb9;
            FUN_00462c50();
            if (*(int *)((int)register0x00000010 + -0x54) ==
                *(int *)((int)register0x00000010 + -0x28)) {
              *(undefined4 *)((int)register0x00000010 + -0x5c) =
                   *(undefined4 *)((int)register0x00000010 + -8);
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40ded3;
              FUN_00401280();
              if (*(int *)((int)register0x00000010 + -0x54) ==
                  *(int *)((int)register0x00000010 + -0x3c)) {
                *(undefined4 *)((int)register0x00000010 + -0x5c) =
                     *(undefined4 *)((int)register0x00000010 + -0x58);
                *(undefined4 *)((int)register0x00000010 + -0x58) =
                     *(undefined4 *)((int)register0x00000010 + -0x10);
                *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40def5;
                FUN_00402aa0();
                cVar6 = *(char *)((int)register0x00000010 + -0x50);
              }
              else {
                cVar6 = '\0';
              }
            }
            else {
              cVar6 = '\0';
            }
            if (cVar6 != '\0') {
              *(undefined4 *)((int)register0x00000010 + -0x5c) =
                   *(undefined4 *)((int)register0x00000010 + -8);
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40df18;
              FUN_00463150();
              iVar4 = *(int *)((int)register0x00000010 + -0x54);
              uVar5 = *(undefined4 *)((int)register0x00000010 + -0x58);
              if (iVar4 == 0) {
                uVar5 = **(undefined4 **)((int)register0x00000010 + -0x20);
                *(undefined4 *)((int)register0x00000010 + -0x5c) =
                     *(undefined4 *)((int)register0x00000010 + -0x1c);
                *(undefined4 *)((int)register0x00000010 + -0x58) = uVar5;
                *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40df3a;
                FUN_004629a0();
                *(undefined4 *)((int)register0x00000010 + -0x5c) =
                     *(undefined4 *)((int)register0x00000010 + -0x54);
                *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40df46;
                FUN_00401280();
                uVar5 = *(undefined4 *)((int)register0x00000010 + -0x58);
                iVar4 = *(int *)((int)register0x00000010 + -0x54);
              }
              if ((**(byte **)((int)register0x00000010 + -8) & 1) == 0) {
                if (*(int *)((int)register0x00000010 + -0x40) == iVar4) {
                  *(undefined4 *)((int)register0x00000010 + -0x5c) = uVar5;
                  *(undefined4 *)((int)register0x00000010 + -0x58) =
                       *(undefined4 *)((int)register0x00000010 + -0x18);
                  *(int *)((int)register0x00000010 + -0x54) = iVar4;
                  *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40df85;
                  FUN_00402aa0();
                  cVar6 = *(char *)((int)register0x00000010 + -0x50);
                }
                else {
                  cVar6 = '\0';
                }
              }
              else {
                cVar6 = '\x01';
              }
              if (cVar6 != '\0') goto LAB_0040ddba;
            }
            puVar13 = *(undefined4 **)((int)register0x00000010 + -0x44);
            uVar7 = (int)puVar13 + 1;
            uVar5 = *(undefined4 *)((int)register0x00000010 + -0x1c);
            iVar4 = *(int *)((int)register0x00000010 + -0x24);
            uVar10 = *(uint *)((int)register0x00000010 + -0x2c);
          } while( true );
        }
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40dfc5;
        FUN_0046edf0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40dfcf;
      FUN_0046ee70();
    }
    *(undefined4 *)(puVar8 + -4) = 0x40dfd5;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
LAB_0040ddba:
  uVar5 = *(undefined4 *)
           (*(int *)((int)register0x00000010 + -0x24) + 8 +
           *(int *)((int)register0x00000010 + -0x30));
  *(undefined4 *)((int)register0x00000010 + -0x5c) =
       *(undefined4 *)((int)register0x00000010 + -0x1c);
  *(undefined4 *)((int)register0x00000010 + -0x58) = uVar5;
  *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40ddd6;
  FUN_00462f40();
  uVar5 = *(undefined4 *)((int)register0x00000010 + -0x54);
  iVar4 = *(int *)((int)register0x00000010 + -0x48);
  if (iVar4 != 0) {
    if (*(char *)((int)register0x00000010 + 8) != '\0') {
      if (DAT_005f5fd0 == 0) {
        iVar12 = *(int *)((int)register0x00000010 + 4);
      }
      else {
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x40de0e;
        FUN_0046ed80();
        *puVar13 = uVar5;
        iVar12 = *(int *)((int)register0x00000010 + 4);
        puVar13[1] = *(undefined4 *)(iVar12 + 0xc + iVar4 * 4);
      }
      *(undefined4 *)(iVar12 + 0xc + iVar4 * 4) = uVar5;
    }
    uVar5 = *(undefined4 *)((int)register0x00000010 + -0xc);
  }
  uVar7 = *(uint *)((int)register0x00000010 + -0x4c);
  piVar9 = *(int **)((int)register0x00000010 + 4);
  *(int *)((int)register0x00000010 + -0x48) = iVar4 + 1;
  *(undefined4 *)((int)register0x00000010 + -0xc) = uVar5;
  iVar4 = *(int *)((int)register0x00000010 + -0x14);
  goto LAB_0040dcfd;
}



/* Function: FUN_0040dfe0 */

void FUN_0040dfe0(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int in_FS_OFFSET;
  int *local_1c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040ecf0(&DAT_005f5ddc);
  FUN_00402520(&DAT_005d6e1c);
  if (local_1c == (int *)0x0) {
    iVar3 = 0;
    iVar4 = 0;
  }
  else {
    iVar4 = *local_1c;
    iVar3 = local_1c[1];
  }
  for (iVar5 = 0; iVar5 < iVar3; iVar5 = iVar5 + 1) {
    iVar6 = *(int *)(iVar4 + iVar5 * 4);
    iVar1 = *(int *)(iVar6 + 0xbc);
    iVar2 = *(int *)(iVar6 + 0xc0);
    for (iVar6 = 0; iVar6 < iVar2; iVar6 = iVar6 + 1) {
      FUN_0040da30(*(undefined4 *)(iVar1 + iVar6 * 4));
    }
  }
  FUN_0040f0e0(&DAT_005f5ddc);
  return;
}



/* Function: FUN_0040e0b0 */

void FUN_0040e0b0(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined4 *in_stack_fffffffc;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    in_stack_fffffffc = (undefined4 *)0x40e133;
    FUN_0046d980();
  }
  FUN_00411710(&DAT_004b85c0);
  if (DAT_005f5fd0 != 0) goto LAB_0040e113;
  do {
    *in_stack_fffffffc = param_3;
    in_stack_fffffffc[1] = param_1;
    in_stack_fffffffc[2] = param_2;
    in_stack_fffffffc[4] = 0;
    in_stack_fffffffc[3] = 0;
    FUN_00469650(&DAT_004b3cc0,in_stack_fffffffc);
LAB_0040e113:
    FUN_0046ed90();
    *in_EDI = param_3;
    in_EDI[1] = param_1;
    in_EDI[2] = param_2;
  } while( true );
}



/* Function: FUN_0040e140 */

void FUN_0040e140(int param_1,undefined4 param_2,undefined4 param_3)

{
  undefined4 uVar1;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined4 *in_stack_fffffff8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined4 *)(param_1 + 4);
  }
  FUN_00411710(&DAT_004b85c0);
  if (DAT_005f5fd0 != 0) goto LAB_0040e1b6;
  do {
    *in_stack_fffffff8 = param_3;
    in_stack_fffffff8[1] = uVar1;
    in_stack_fffffff8[2] = param_2;
    in_stack_fffffff8[4] = 0;
    in_stack_fffffff8[3] = 0;
    FUN_00469650(&DAT_004b3cc0,in_stack_fffffff8);
LAB_0040e1b6:
    FUN_0046ed90();
    *in_EDI = param_3;
    in_EDI[1] = uVar1;
    in_EDI[2] = param_2;
  } while( true );
}



/* Function: FUN_0040e1e0 */

void FUN_0040e1e0(undefined4 *param_1,undefined4 param_2)

{
  int in_FS_OFFSET;
  undefined4 local_8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00468370(*param_1,param_1,1);
  FUN_00468750(param_1,local_8,param_2);
  return;
}



/* Function: FUN_0040e240 */

void FUN_0040e240(undefined4 *param_1,undefined4 param_2)

{
  int in_FS_OFFSET;
  uint in_stack_fffffff4;
  undefined4 local_8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00468370(*param_1,param_1,in_stack_fffffff4 & 0xffffff00);
  FUN_0046f640(local_8,param_2,*param_1);
  return;
}



/* Function: FUN_0040e2a0 */

void FUN_0040e2a0(uint param_1)

{
  int in_FS_OFFSET;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (uint *)0x40e2fb;
    FUN_0046d980();
  }
  if (0xff < param_1) {
    FUN_00468370(4,DAT_005d6da4,0);
    *local_4 = param_1;
  }
  return;
}



/* Function: FUN_0040e3c0 */

void FUN_0040e3c0(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x18);
      iVar3 = *(int *)((int)register0x00000010 + 4);
      uVar1 = *(uint *)(iVar3 + 4);
      if (-1 < (int)uVar1) {
        *(uint *)((int)register0x00000010 + -8) = uVar1;
        if (((int)((ulong)uVar1 * 4 >> 0x20) == 0) &&
           ((uint)((ulong)uVar1 * 4) <= (uint)-(iVar3 + 8))) break;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e44f;
        FUN_00464550();
      }
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e454;
      FUN_00464550();
    }
    *(undefined4 *)(puVar6 + -4) = 0x40e45a;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
  iVar2 = 0;
  iVar4 = 0;
  do {
    iVar5 = *(int *)((int)register0x00000010 + -8);
    if (iVar5 <= iVar2) {
LAB_0040e43e:
      *(int *)((int)register0x00000010 + 0xc) = iVar5;
      *(int *)((int)register0x00000010 + 0x10) = iVar4;
      return;
    }
    *(int *)((int)register0x00000010 + -4) = iVar2;
    *(undefined4 *)((int)register0x00000010 + -0x18) = *(undefined4 *)(iVar3 + 8 + iVar2 * 4);
    *(undefined4 *)((int)register0x00000010 + -0x14) = *(undefined4 *)((int)register0x00000010 + 8);
    *(undefined1 *)((int)register0x00000010 + -0x10) = 1;
    *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e430;
    FUN_00468020();
    iVar4 = *(int *)((int)register0x00000010 + -0xc);
    if (iVar4 != 0) {
      iVar5 = *(int *)((int)register0x00000010 + -4);
      goto LAB_0040e43e;
    }
    iVar2 = *(int *)((int)register0x00000010 + -4) + 1;
    iVar3 = *(int *)((int)register0x00000010 + 4);
  } while( true );
}



/* Function: FUN_0040e4a0 */

void FUN_0040e4a0(undefined4 param_1,undefined4 *param_2)

{
  int in_FS_OFFSET;
  undefined4 local_1c;
  undefined4 local_18;
  char local_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  param_2[2] = param_2[2] + 1;
  do {
    FUN_004027a0(param_1);
    *param_2 = local_1c;
    param_2[1] = local_18;
    FUN_00402640(param_1);
  } while (local_c == '\0');
  return;
}



/* Function: FUN_0040e520 */

void FUN_0040e520(undefined4 param_1)

{
  int in_FS_OFFSET;
  int in_stack_ffffffe0;
  int iVar1;
  int in_stack_ffffffe4;
  int iVar2;
  undefined1 local_10;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  do {
    FUN_004027a0(param_1);
    if (in_stack_ffffffe4 == 0 && in_stack_ffffffe0 == 0) {
      return;
    }
    iVar1 = in_stack_ffffffe0;
    iVar2 = in_stack_ffffffe4;
    FUN_004027a0(in_stack_ffffffe4);
    FUN_00402640(param_1,in_stack_ffffffe0,in_stack_ffffffe4,iVar1,iVar2);
  } while (local_10 == '\0');
  return;
}



/* Function: FUN_0040e5d0 */

void FUN_0040e5d0(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x18);
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e5ff;
      FUN_004688e0();
      if (*(int *)((int)register0x00000010 + -0xc) == 0) {
        return;
      }
      *(char **)((int)register0x00000010 + -0x18) =
           "lfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x24;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e621;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x40e627;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_0040e630 */

void FUN_0040e630(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x14);
      do {
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x40e651;
        thunk_FUN_00402510();
        *(undefined4 *)((int)register0x00000010 + -4) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0xc) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x40e66d;
        thunk_FUN_00402540();
      } while (*(char *)((int)register0x00000010 + -8) == '\0');
      iVar1 = *(int *)((int)register0x00000010 + -4);
      if (iVar1 == 0) {
        return;
      }
      if (iVar1 != 1) {
        *(int *)((int)register0x00000010 + -0x14) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x40e68b;
        FUN_00436640();
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c8bca;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x1a;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x40e6a5;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x40e6ab;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_0040e6b0 */

void FUN_0040e6b0(void)

{
  int iVar1;
  int *piVar2;
  undefined4 uVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x18);
      iVar1 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      piVar2 = *(int **)(iVar1 + 0x18);
      if (*piVar2 == iVar1) {
        *(int *)((int)register0x00000010 + -8) = iVar1;
        *(int **)((int)register0x00000010 + -0x18) = piVar2;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e6e9;
        FUN_00436680();
        uVar3 = *(undefined4 *)(*(int *)((int)register0x00000010 + -8) + 0x18);
        *(undefined4 *)((int)register0x00000010 + -4) = uVar3;
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x10) = uVar3;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e70e;
        thunk_FUN_00402540();
        if (*(char *)((int)register0x00000010 + -0xc) == '\0') {
          if (**(int **)((int)register0x00000010 + 4) == 1) {
            return;
          }
          *(char **)((int)register0x00000010 + -0x18) =
               "notesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
          ;
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0x1d;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e76a;
          FUN_00469a20();
        }
        else {
          *(undefined1 *)(*(int *)(*(int *)((int)register0x00000010 + -8) + 0x18) + 0x89) = 1;
          if (*(int *)PTR_DAT_005cef00 == 0) {
            *(undefined4 *)((int)register0x00000010 + -0x18) = 0xffffffff;
            *(undefined4 *)((int)register0x00000010 + -0x14) = 0xffffffff;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e745;
            FUN_004362f0();
          }
          else {
            while( true ) {
              *(undefined4 *)((int)register0x00000010 + -0x18) =
                   *(undefined4 *)((int)register0x00000010 + 4);
              *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e7b4;
              thunk_FUN_00402510();
              if (*(int *)((int)register0x00000010 + -0x14) != 0) break;
              *(undefined4 *)((int)register0x00000010 + -0x18) = 10000000;
              *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e790;
              FUN_004362f0();
              *(undefined4 *)((int)register0x00000010 + -0x18) = *(undefined4 *)PTR_DAT_005cef00;
              *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e7a8;
              FUN_0046ea10();
            }
          }
        }
        *(undefined1 *)(*(int *)(*(int *)((int)register0x00000010 + -8) + 0x18) + 0x89) = 0;
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c6157;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40e7d4;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x40e7da;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_0040e7e0 */

void FUN_0040e7e0(int *param_1,uint param_2,undefined *param_3)

{
  int iVar1;
  uint in_EDX;
  int in_FS_OFFSET;
  int *piVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  undefined *puVar6;
  int local_18;
  char local_14;
  undefined *local_10;
  uint local_c;
  
  iVar1 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  local_18 = *(int *)(iVar1 + 0x18);
  iVar5 = 0;
  piVar2 = param_1;
  thunk_FUN_00402540();
  if (local_14 == '\0') {
    if (*param_1 == 1) {
      return;
    }
    param_3 = &DAT_004ca016;
    FUN_00469a20(&DAT_004ca016,0x1e);
    param_2 = in_EDX;
  }
  else {
    if ((int)param_3 < 0) {
      *(undefined1 *)(*(int *)(iVar1 + 0x18) + 0x89) = 1;
      if (*(int *)PTR_DAT_005cef00 == 0) {
        FUN_004362f0(0xffffffff,0xffffffff);
      }
      else {
        while (FUN_004362f0(10000000,0), local_18 < 0) {
          FUN_0046ea10(*(undefined4 *)PTR_DAT_005cef00,0);
        }
      }
      goto LAB_0040ea31;
    }
    FUN_0046fa70();
    local_c = (int)piVar2 + param_2;
    local_10 = param_3 + (uint)CARRY4((uint)piVar2,param_2) + iVar5;
  }
  do {
    *(undefined1 *)(*(int *)(iVar1 + 0x18) + 0x89) = 1;
    if ((*(int *)PTR_DAT_005cef00 != 0) &&
       (10000000 < param_2 && param_3 == (undefined *)0x0 || 0 < (int)param_3)) {
      param_3 = (undefined *)0x0;
      param_2 = 10000000;
    }
    FUN_004362f0();
    if (-1 < local_18) {
      *(undefined1 *)(*(int *)(iVar1 + 0x18) + 0x89) = 0;
      return;
    }
    uVar3 = *(uint *)PTR_DAT_005cef00;
    uVar4 = param_2;
    puVar6 = param_3;
    if (uVar3 != 0) {
      puVar6 = (undefined *)0x0;
      FUN_0046ea10();
      uVar4 = uVar3;
    }
    *(undefined1 *)(*(int *)(iVar1 + 0x18) + 0x89) = 0;
    FUN_0046fa70();
    param_2 = local_c - uVar4;
    param_3 = local_10 + (-(uint)(local_c < uVar4) - (int)puVar6);
  } while ((param_3 != (undefined *)0x0 || param_2 != 0) && -1 < (int)param_3);
  while( true ) {
    thunk_FUN_00402510(param_1);
    if (*(undefined **)(iVar1 + 0x18) != puVar6) break;
    local_18 = 0;
    thunk_FUN_00402540(param_1);
    if (local_14 != '\0') {
      return;
    }
  }
  if (puVar6 == (undefined *)0x1) {
    (*(undefined **)(iVar1 + 0x18))[0x89] = 1;
    FUN_004362f0(0xffffffff,0xffffffff);
    if (-1 < local_18) {
      *(undefined1 *)(*(int *)(iVar1 + 0x18) + 0x89) = 0;
      return;
    }
    FUN_00469a20("runtime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside boot..." /* TRUNCATED STRING LITERAL */
                 ,0x32);
  }
  FUN_00469a20("runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top ..." /* TRUNCATED STRING LITERAL */
               ,0x31);
LAB_0040ea31:
  *(undefined1 *)(*(int *)(iVar1 + 0x18) + 0x89) = 0;
  return;
}



/* Function: FUN_0040ea80 */

void FUN_0040ea80(void)

{
  int *piVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x1c);
      piVar1 = *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
      if (*piVar1 == **(int **)(in_FS_OFFSET + DAT_005f5ed0)) {
        *(int **)((int)register0x00000010 + -0x1c) = piVar1;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x40eaad;
        FUN_00436680();
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
        *(undefined4 *)((int)register0x00000010 + -8) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x40eae1;
        FUN_0040e7e0();
        *(undefined1 *)((int)register0x00000010 + 0x10) =
             *(undefined1 *)((int)register0x00000010 + -4);
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c67ac;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x40eb04;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x40eb0a;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_0040eb10 */

void FUN_0040eb10(void)

{
  int *piVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x20);
      piVar1 = *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
      if (*piVar1 != **(int **)(in_FS_OFFSET + DAT_005f5ed0)) {
        *(int **)((int)register0x00000010 + -0x20) = piVar1;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40eb41;
        FUN_00436680();
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40eb46;
        FUN_00469d40();
        *(undefined4 *)((int)register0x00000010 + -0x20) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40eb7a;
        FUN_0040e7e0();
        *(undefined1 *)((int)register0x00000010 + -1) =
             *(undefined1 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40eb88;
        FUN_00469ec0();
        *(undefined1 *)((int)register0x00000010 + 0x10) =
             *(undefined1 *)((int)register0x00000010 + -1);
        return;
      }
      *(char **)((int)register0x00000010 + -0x20) =
           "notetsleepg on g0bad TinySizeClassruntime: pointer g already scannedmark - bad statusscanobject n == 0swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x11;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40ebab;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x40ebb1;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_0040ebc0 */

void FUN_0040ebc0(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0xc);
      if ((byte)s__________________________________005cc9a0[7] < 0x44) {
        if (((&DAT_005cc900)[(byte)s__________________________________005cc9a0[7]] & 0x3ff) == 0) {
          return;
        }
        *(uint *)((int)register0x00000010 + -4) =
             (uint)(ushort)(&DAT_005cc900)[(byte)s__________________________________005cc9a0[7]];
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ec06;
        FUN_0043a810();
        *(undefined **)((int)register0x00000010 + -0xc) = &DAT_004c8f36;
        *(undefined4 *)((int)register0x00000010 + -8) = 0x1b;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ec1c;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -8) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ec30;
        FUN_0043ad50();
        *(undefined **)((int)register0x00000010 + -0xc) = &DAT_004c2924;
        *(undefined4 *)((int)register0x00000010 + -8) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ec46;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -8) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ec5a;
        FUN_0043aef0();
        *(undefined **)((int)register0x00000010 + -0xc) = &DAT_004cc234;
        *(undefined4 *)((int)register0x00000010 + -8) = 0x2a;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ec70;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x3ff;
        *(undefined4 *)((int)register0x00000010 + -8) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ec84;
        FUN_0043aef0();
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ec89;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ec8e;
        FUN_0043a870();
        *(char **)((int)register0x00000010 + -0xc) =
             "runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Gorun..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -8) = 0x36;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40eca4;
        FUN_00469a20();
      }
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x40ecae;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar1 + -4) = 0x40ecb4;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_0040ecc0 */

void FUN_0040ecc0(undefined4 param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040ecf0(param_1);
  return;
}



/* Function: FUN_0040ecf0 */

void FUN_0040ecf0(void)

{
  undefined4 uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  undefined1 uVar5;
  undefined *puVar6;
  char cVar7;
  undefined1 *puVar8;
  char cVar9;
  int iVar10;
  uint uVar11;
  int in_FS_OFFSET;
  undefined1 uVar12;
  
code_r0x0040ecf0:
  puVar8 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar8 = (undefined1 *)((int)register0x00000010 + -0x48);
    iVar10 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
    iVar4 = *(int *)(iVar10 + 0x7c);
    if (-1 < iVar4) {
      *(int *)((int)register0x00000010 + -0x20) = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      *(int *)(iVar10 + 0x7c) = iVar4 + 1;
      *(undefined4 *)((int)register0x00000010 + -0x48) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined1 *)((int)register0x00000010 + -0x44) = 1;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ed3d;
      FUN_004026f0();
      if ((*(byte *)((int)register0x00000010 + -0x40) & 1) == 0) {
        if ((*(byte *)((int)register0x00000010 + -0x40) & 2) != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x48) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined1 *)((int)register0x00000010 + -0x44) = 2;
          *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40edc1;
          FUN_004027f0();
        }
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x48) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + -0x20) + 0x18);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ed56;
      FUN_00436680();
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ed61;
      FUN_0046ef49();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined1 **)((int)register0x00000010 + -0x48) =
           (undefined1 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ed75;
      FUN_00431870();
      if (DAT_005f5e8c < 2) {
        uVar1 = 0;
      }
      else {
        uVar1 = 4;
      }
      *(undefined4 *)((int)register0x00000010 + -0x2c) = uVar1;
      *(undefined4 *)((int)register0x00000010 + -0x48) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ed97;
      thunk_FUN_00402510();
      uVar2 = *(uint *)((int)register0x00000010 + -0x44);
      iVar4 = *(int *)((int)register0x00000010 + -0x2c);
      puVar6 = *(undefined **)((int)register0x00000010 + 4);
      cVar7 = '\0';
      cVar9 = '\0';
      iVar10 = 0;
      do {
        *(int *)((int)register0x00000010 + -0x28) = iVar10;
        *(char *)((int)register0x00000010 + -0x35) = cVar9;
        *(char *)((int)register0x00000010 + -0x36) = cVar7;
        if ((uVar2 & 1) == 0) {
          if (cVar7 == '\0') {
            *(undefined **)((int)register0x00000010 + -0x48) = puVar6;
            *(undefined1 *)((int)register0x00000010 + -0x44) = 3;
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40f020;
            FUN_004026f0();
            if ((*(byte *)((int)register0x00000010 + -0x40) & 1) == 0) {
              *(undefined1 **)((int)register0x00000010 + -0x48) =
                   (undefined1 *)((int)register0x00000010 + -0x1c);
              *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40f069;
              FUN_00431a50();
              return;
            }
          }
          else {
            uVar3 = uVar2 & 0xfffffeff | 3;
            if ((uVar2 & 0xfffffc00) == 0) {
              uVar3 = uVar3 & 0xfffffffd;
            }
            *(undefined **)((int)register0x00000010 + -0x48) = puVar6;
            *(uint *)((int)register0x00000010 + -0x44) = uVar2;
            *(uint *)((int)register0x00000010 + -0x40) = uVar3;
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40f008;
            thunk_FUN_00402540();
            if (*(char *)((int)register0x00000010 + -0x3c) != '\0') {
              *(undefined1 **)((int)register0x00000010 + -0x48) =
                   (undefined1 *)((int)register0x00000010 + -0x1c);
              *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40f059;
              FUN_00431a50();
              return;
            }
          }
          *(undefined4 *)((int)register0x00000010 + -0x48) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40f036;
          thunk_FUN_00402510();
          uVar2 = *(uint *)((int)register0x00000010 + -0x44);
          iVar10 = *(int *)((int)register0x00000010 + -0x28);
          cVar7 = *(char *)((int)register0x00000010 + -0x36);
          cVar9 = *(char *)((int)register0x00000010 + -0x35);
        }
        else {
          if ((cVar7 == '\0') && ((uVar2 & 0x100) == 0)) {
            *(uint *)((int)register0x00000010 + -0x30) = uVar2;
            *(undefined **)((int)register0x00000010 + -0x48) = puVar6;
            *(uint *)((int)register0x00000010 + -0x44) = uVar2;
            *(uint *)((int)register0x00000010 + -0x24) = uVar2 | 0x100;
            *(uint *)((int)register0x00000010 + -0x40) = uVar2 | 0x100;
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ee17;
            thunk_FUN_00402540();
            if (*(char *)((int)register0x00000010 + -0x3c) == '\0') {
              iVar4 = *(int *)((int)register0x00000010 + -0x2c);
              puVar6 = *(undefined **)((int)register0x00000010 + 4);
              cVar9 = *(char *)((int)register0x00000010 + -0x35);
              iVar10 = *(int *)((int)register0x00000010 + -0x28);
              cVar7 = *(char *)((int)register0x00000010 + -0x36);
              uVar2 = *(uint *)((int)register0x00000010 + -0x30);
            }
            else {
              iVar4 = *(int *)((int)register0x00000010 + -0x2c);
              puVar6 = *(undefined **)((int)register0x00000010 + 4);
              cVar9 = *(char *)((int)register0x00000010 + -0x35);
              iVar10 = *(int *)((int)register0x00000010 + -0x28);
              cVar7 = '\x01';
              uVar2 = *(uint *)((int)register0x00000010 + -0x24);
            }
          }
          *(char *)((int)register0x00000010 + -0x36) = cVar7;
          if (((cVar7 == '\0') && (cVar9 == '\0')) && (puVar6 != &DAT_005d84f8)) {
LAB_0040eeda:
            if ((uVar2 & 1) == 0) goto LAB_0040f06d;
            uVar3 = uVar2 & 0xfffffc00;
            if (uVar3 == 0) {
              iVar10 = 0;
            }
            else {
              *(undefined4 **)((int)register0x00000010 + -0x34) = &DAT_005d7d60;
              if (uVar3 == 0x5d7c00) {
                iVar10 = *(int *)((int)register0x00000010 + -0x34);
              }
              else {
                iVar10 = uVar3 + 8;
              }
            }
            iVar4 = *(int *)((int)register0x00000010 + -0x20);
            *(int *)(*(int *)(iVar4 + 0x18) + 0x144) = iVar10;
            uVar3 = *(uint *)(iVar4 + 0x18);
            uVar11 = uVar2 & 0x3ff;
            if (cVar7 != '\0') {
              uVar11 = uVar2 & 0x2ff;
            }
            *(undefined **)((int)register0x00000010 + -0x48) = puVar6;
            *(uint *)((int)register0x00000010 + -0x44) = uVar2;
            *(uint *)((int)register0x00000010 + -0x40) = uVar11 | uVar3 & 0xfffffc00 | 2;
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ef57;
            thunk_FUN_00402540();
            if (*(char *)((int)register0x00000010 + -0x3c) == '\0') {
              iVar10 = *(int *)((int)register0x00000010 + -0x20);
              uVar1 = *(undefined4 *)((int)register0x00000010 + -0x28);
              uVar5 = *(undefined1 *)((int)register0x00000010 + -0x36);
              uVar12 = *(undefined1 *)((int)register0x00000010 + -0x35);
            }
            else {
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0xffffffff;
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0xffffffff;
              *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ef88;
              FUN_004362f0();
              iVar10 = *(int *)((int)register0x00000010 + -0x20);
              uVar12 = *(int *)(*(int *)(iVar10 + 0x18) + 0x144) == 0;
              uVar1 = 0;
              uVar5 = 0;
            }
            *(undefined1 *)((int)register0x00000010 + -0x35) = uVar12;
            *(undefined1 *)((int)register0x00000010 + -0x36) = uVar5;
            *(undefined4 *)((int)register0x00000010 + -0x28) = uVar1;
            *(undefined4 *)(*(int *)(iVar10 + 0x18) + 0x144) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x48) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40efc9;
            thunk_FUN_00402510();
            uVar2 = *(uint *)((int)register0x00000010 + -0x44);
            iVar10 = *(int *)((int)register0x00000010 + -0x28);
            cVar7 = *(char *)((int)register0x00000010 + -0x36);
            cVar9 = *(char *)((int)register0x00000010 + -0x35);
          }
          else if (iVar10 < iVar4) {
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x1e;
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40eeb7;
            FUN_0046e9f0();
            *(undefined4 *)((int)register0x00000010 + -0x48) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40eec3;
            thunk_FUN_00402510();
            uVar2 = *(uint *)((int)register0x00000010 + -0x44);
            iVar10 = *(int *)((int)register0x00000010 + -0x28);
            cVar7 = *(char *)((int)register0x00000010 + -0x36);
            cVar9 = *(char *)((int)register0x00000010 + -0x35);
          }
          else {
            if (iVar4 + 1 <= iVar10) goto LAB_0040eeda;
            *(undefined ***)((int)register0x00000010 + -0x48) = &PTR_LAB_00536c0c;
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ee88;
            FUN_0046d890();
            *(undefined4 *)((int)register0x00000010 + -0x48) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40ee94;
            thunk_FUN_00402510();
            uVar2 = *(uint *)((int)register0x00000010 + -0x44);
            iVar10 = *(int *)((int)register0x00000010 + -0x28);
            cVar7 = *(char *)((int)register0x00000010 + -0x36);
            cVar9 = *(char *)((int)register0x00000010 + -0x35);
          }
        }
        iVar10 = iVar10 + 1;
        iVar4 = *(int *)((int)register0x00000010 + -0x2c);
        puVar6 = *(undefined **)((int)register0x00000010 + 4);
      } while( true );
    }
    goto LAB_0040f083;
  }
  goto LAB_0040f09a;
LAB_0040f06d:
  *(undefined **)((int)register0x00000010 + -0x48) = &DAT_004ccdea;
  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x2f;
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40f083;
  FUN_00469a20();
LAB_0040f083:
  *(undefined **)((int)register0x00000010 + -0x48) = &DAT_004c85ca;
  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x19;
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x40f099;
  FUN_00469a20();
LAB_0040f09a:
  *(undefined4 *)(puVar8 + -4) = 0x40f09f;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar8;
  goto code_r0x0040ecf0;
}



/* Function: FUN_0040f0b0 */

void FUN_0040f0b0(undefined4 param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040f0e0(param_1);
  return;
}



/* Function: FUN_0040f0e0 */

void FUN_0040f0e0(void)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -4) = **(undefined4 **)(in_FS_OFFSET + DAT_005f5ed0)
      ;
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined1 *)((int)register0x00000010 + -0xc) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x40f119;
      FUN_004026f0();
      if ((*(byte *)((int)register0x00000010 + -8) & 1) != 0) {
        if ((*(byte *)((int)register0x00000010 + -8) & 2) != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x10) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0x40f134;
          FUN_0040f1c0();
        }
        *(int *)((int)register0x00000010 + -0x10) =
             *(int *)(*(int *)((int)register0x00000010 + -4) + 0x18) + 0x148;
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x40f152;
        FUN_00431ce0();
        iVar2 = *(int *)((int)register0x00000010 + -4);
        piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
        *piVar1 = *piVar1 + -1;
        iVar3 = *(int *)(*(int *)(iVar2 + 0x18) + 0x7c);
        if (-1 < iVar3) {
          if ((iVar3 == 0) && (*(char *)(iVar2 + 0x69) != '\0')) {
            *(undefined4 *)(iVar2 + 8) = 0xfffffade;
          }
          return;
        }
        *(undefined **)((int)register0x00000010 + -0x10) = &DAT_004c8f51;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x1b;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x40f191;
        FUN_00469a20();
      }
      *(undefined **)((int)register0x00000010 + -0x10) = &DAT_004c798b;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x17;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x40f1a7;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x40f1ad;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_0040f1c0 */

void FUN_0040f1c0(undefined *param_1)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  uint uVar6;
  uint uVar7;
  undefined4 *puVar8;
  undefined4 *puVar9;
  int in_FS_OFFSET;
  uint in_stack_ffffffd8;
  char local_20;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  thunk_FUN_00402510(param_1);
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  uVar7 = *(uint *)(iVar1 + 0x45c);
  uVar3 = *(uint *)(iVar1 + 0x458) << 0x11 ^ *(uint *)(iVar1 + 0x458);
  uVar6 = uVar7 >> 0x10 ^ uVar3 >> 7 ^ uVar7 ^ uVar3;
  uVar3 = uVar7 + uVar6 >> 0x1c;
  *(uint *)(iVar1 + 0x458) = uVar7;
  *(uint *)(iVar1 + 0x45c) = uVar6;
  if (((uVar3 != 0) && ((in_stack_ffffffd8 & 0x100) != 0)) && (param_1 != &DAT_005d84f8)) {
    return;
  }
  while (((in_stack_ffffffd8 & 0xfffffc00) != 0 && ((in_stack_ffffffd8 & 0x200) == 0))) {
    uVar7 = in_stack_ffffffd8;
    thunk_FUN_00402540(param_1,in_stack_ffffffd8,in_stack_ffffffd8 | 0x200);
    if (local_20 != '\0') {
      puVar4 = (undefined4 *)0x0;
      while( true ) {
        uVar7 = in_stack_ffffffd8 & 0xfffffc00;
        if (uVar7 == 0) {
          puVar8 = (undefined4 *)0x0;
        }
        else {
          puVar8 = &DAT_005d7d60;
          if (uVar7 != 0x5d7c00) {
            puVar8 = (undefined4 *)(uVar7 + 8);
          }
        }
        puVar5 = puVar4;
        if (puVar4 == (undefined4 *)0x0) {
          puVar4 = puVar8;
          if (((in_stack_ffffffd8 & 0x100) != 0) && (param_1 != &DAT_005d84f8)) {
            puVar4 = (undefined4 *)0x0;
          }
          puVar5 = puVar8;
          puVar2 = puVar8;
          if (uVar3 == 0) {
            do {
              puVar9 = puVar2;
              puVar4 = puVar5;
              puVar5 = (undefined4 *)puVar4[0x51];
              puVar2 = puVar4;
            } while ((undefined4 *)puVar4[0x51] != (undefined4 *)0x0);
            if (puVar8 == puVar4) {
              puVar5 = (undefined4 *)0x0;
            }
            else {
              puVar9[0x51] = 0;
              puVar5 = puVar4;
            }
          }
          else {
            puVar5 = (undefined4 *)0x0;
          }
        }
        if (puVar8 == puVar4) {
          uVar7 = puVar8[0x51] & 0xfffffc00;
        }
        thunk_FUN_00402540(param_1,in_stack_ffffffd8,uVar7 | in_stack_ffffffd8 & 0x1ff);
        if (local_20 != '\0') break;
        thunk_FUN_00402510(param_1);
        puVar4 = puVar5;
      }
      if (puVar4 != (undefined4 *)0x0) {
        FUN_00436640(puVar4);
      }
      return;
    }
    in_stack_ffffffd8 = uVar7;
    thunk_FUN_00402510(param_1);
  }
  return;
}



/* Function: FUN_0040f470 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_0040f470(void)

{
  undefined4 uVar1;
  uint uVar2;
  undefined4 *puVar3;
  int iVar4;
  uint uVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x28);
      if (DAT_005cc904 == 0x10) {
        if (DAT_005f5de0 != 0) {
          if (DAT_005f5de0 < 0x80001) {
            if (0xfff < DAT_005f5de0) {
              if ((DAT_005f5de0 - 1 & DAT_005f5de0) == 0) {
                if ((DAT_005f5de4 - 1 & DAT_005f5de4) == 0) break;
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f71d;
                FUN_0043a810();
                *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c79b9;
                *(undefined4 *)((int)register0x00000010 + -0x24) = 0x17;
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f733;
                FUN_0043b060();
                *(uint *)((int)register0x00000010 + -0x28) = DAT_005f5de4;
                *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f749;
                FUN_0043ad50();
                *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c79a2;
                *(undefined4 *)((int)register0x00000010 + -0x24) = 0x17;
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f75f;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f764;
                FUN_0043a870();
                *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c85e3;
                *(undefined4 *)((int)register0x00000010 + -0x24) = 0x19;
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f77a;
                FUN_00469a20();
              }
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f77f;
              FUN_0043a810();
              *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c5bb6;
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x12;
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f795;
              FUN_0043b060();
              *(uint *)((int)register0x00000010 + -0x28) = DAT_005f5de0;
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f7ab;
              FUN_0043ad50();
              *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c79a2;
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x17;
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f7c1;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f7c6;
              FUN_0043a870();
              *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c67c0;
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x14;
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f7dc;
              FUN_00469a20();
            }
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f7e1;
            FUN_0043a810();
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c5bb6;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x12;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f7f7;
            FUN_0043b060();
            *(uint *)((int)register0x00000010 + -0x28) = DAT_005f5de0;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f80d;
            FUN_0043ad50();
            *(char **)((int)register0x00000010 + -0x28) =
                 ") is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
            ;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x25;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f823;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0x1000;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f837;
            FUN_0043ae80();
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c2946;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 2;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f84d;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f852;
            FUN_0043a870();
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c67c0;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x14;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f868;
            FUN_00469a20();
          }
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f86d;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c5bb6;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x12;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f883;
          FUN_0043b060();
          *(uint *)((int)register0x00000010 + -0x28) = DAT_005f5de0;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f899;
          FUN_0043ad50();
          *(char **)((int)register0x00000010 + -0x28) =
               ") is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched coun..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x24;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f8af;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x80000;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f8c3;
          FUN_0043ae80();
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c2946;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 2;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f8d9;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f8de;
          FUN_0043a870();
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c67c0;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x14;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f8f4;
          FUN_00469a20();
        }
        *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004ca034;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x1e;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f90a;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x28) =
           "bad TinySizeClassruntime: pointer g already scannedmark - bad statusscanobject n == 0swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x11;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f920;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x40f926;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
  if (0x400000 < DAT_005f5de4) {
    DAT_005f5de4 = 0;
  }
  if (DAT_005f5de4 != 0) goto LAB_0040f6f7;
LAB_0040f4f4:
  iVar4 = 0;
  uVar5 = 1;
  while( true ) {
    if (0x43 < iVar4) goto LAB_0040f6d8;
    if (1 < (byte)(&DAT_005cc6a0)[iVar4]) {
      uVar5 = 0;
    }
    if ((&DAT_005cc900)[iVar4] == 0x80) break;
    iVar4 = iVar4 + 1;
  }
  if ((char)uVar5 == '\0') {
    *(char **)((int)register0x00000010 + -0x28) =
         "expected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
    ;
    *(undefined4 *)((int)register0x00000010 + -0x24) = 0x53;
    *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f6d8;
    FUN_00469a20();
    goto LAB_0040f6d8;
  }
  *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005ddde0;
  *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f53f;
  FUN_00429380();
  *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f544;
  FUN_00413b30();
  DAT_005f5e64 = *(undefined4 *)((int)register0x00000010 + -0x28);
  for (iVar4 = 0; iVar4 < 3; iVar4 = iVar4 + 1) {
  }
  *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x232000;
  *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f56c;
  FUN_00415340();
  uVar5 = *(uint *)((int)register0x00000010 + -0x20);
  if (uVar5 != 0) {
    if (uVar5 + 0x232000 < uVar5) {
      iVar4 = 0x231fff;
    }
    else {
      iVar4 = 0x232000;
    }
    DAT_005ddf24 = uVar5 + iVar4;
    DAT_005ddf28 = 1;
    DAT_005ddf1c = uVar5;
    _DAT_005ddf20 = uVar5;
  }
  if ((DAT_005cce68 < DAT_005ddf1c) || (uVar5 = DAT_005ddf24, DAT_005ddf24 <= DAT_005cce68)) {
    uVar5 = DAT_005cce68;
  }
  *(undefined4 *)((int)register0x00000010 + -0xc) = 0x20000000;
  *(undefined4 *)((int)register0x00000010 + -8) = 0x10000000;
  *(undefined4 *)((int)register0x00000010 + -4) = 0x8000000;
  uVar5 = uVar5 + 0x43ffff & 0xffc00000;
  *(uint *)((int)register0x00000010 + -0x14) = uVar5;
  iVar4 = 0;
  do {
    if (2 < iVar4) {
LAB_0040f64d:
      *(uint *)((int)register0x00000010 + -0x14) = uVar5;
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005e24b4;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f65f;
      FUN_00418000();
      puVar3 = *(undefined4 **)((int)register0x00000010 + -0x24);
      *puVar3 = *(undefined4 *)((int)register0x00000010 + -0x14);
      puVar3[2] = DAT_005ddf2c;
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005e24b4;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f686;
      DAT_005ddf2c = puVar3;
      FUN_00418000();
      puVar3 = *(undefined4 **)((int)register0x00000010 + -0x24);
      *puVar3 = *(undefined4 *)((int)register0x00000010 + -0x14);
      puVar3[2] = DAT_005e24dc;
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f6788;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0xffffffff;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x7fffffff;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f6be;
      DAT_005e24dc = puVar3;
      thunk_FUN_004027c0();
      return;
    }
    *(int *)((int)register0x00000010 + -0x10) = iVar4;
    uVar1 = *(undefined4 *)((int)register0x00000010 + iVar4 * 4 + -0xc);
    *(uint *)((int)register0x00000010 + -0x28) = uVar5;
    *(undefined4 *)((int)register0x00000010 + -0x24) = uVar1;
    *(undefined4 *)((int)register0x00000010 + -0x20) = 0x400000;
    *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f617;
    FUN_0040fef0();
    uVar2 = *(uint *)((int)register0x00000010 + -0x1c);
    if (uVar2 != 0) {
      iVar4 = *(int *)((int)register0x00000010 + -0x18);
      if (iVar4 + uVar2 < uVar2) {
        iVar4 = iVar4 + -1;
      }
      uVar5 = iVar4 + uVar2;
      DAT_005ddf3c = 0;
      _DAT_005ddf30 = uVar2;
      _DAT_005ddf34 = uVar2;
      DAT_005ddf38 = uVar5;
      goto LAB_0040f64d;
    }
    iVar4 = *(int *)((int)register0x00000010 + -0x10) + 1;
    uVar5 = *(uint *)((int)register0x00000010 + -0x14);
  } while( true );
LAB_0040f6d8:
  *(char **)((int)register0x00000010 + -0x28) =
       "min size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocat..." /* TRUNCATED STRING LITERAL */
  ;
  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x36;
  *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x40f6ee;
  FUN_00469a20();
  DAT_005f5de8 = uVar5;
  do {
    DAT_005f5de8 = DAT_005f5de8 + 1;
LAB_0040f6f7:
  } while (DAT_005f5de4 != (1 << ((byte)DAT_005f5de8 & 0x1f) & -(uint)(DAT_005f5de8 < 0x20)));
  goto LAB_0040f4f4;
}



/* Function: FUN_0040f930 */

/* WARNING: Type propagation algorithm not settling */

void FUN_0040f930(void)

{
  uint *puVar1;
  undefined4 *puVar2;
  char *pcVar3;
  uint uVar4;
  uint uVar5;
  char *pcVar6;
  int iVar7;
  uint *puVar8;
  uint *puVar9;
  undefined1 *puVar10;
  char *pcVar11;
  uint *puVar12;
  int iVar13;
  char *in_EDI;
  uint uVar14;
  int in_FS_OFFSET;
  
  while (puVar10 = (undefined1 *)register0x00000010,
        register0x00000010 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
LAB_0040fee0:
    *(undefined4 *)(puVar10 + -4) = 0x40fee5;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar10;
  }
  puVar10 = (undefined1 *)((int)register0x00000010 + -0x50);
  puVar8 = *(uint **)((int)register0x00000010 + 4);
  pcVar11 = (char *)(*(int *)((int)register0x00000010 + 8) + 0x3fffffU & 0xffc00000);
  *(char **)((int)register0x00000010 + -0x38) = pcVar11;
  puVar12 = *(uint **)((int)register0x00000010 + 0xc);
  if (puVar12 == puVar8 + 0x53) {
    *(uint **)((int)register0x00000010 + -0x50) = puVar8 + 0x54;
    *(char **)((int)register0x00000010 + -0x4c) = pcVar11;
    *(undefined4 *)((int)register0x00000010 + -0x48) = 0x400000;
    *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f6898;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40f99b;
    FUN_00411d30();
    pcVar3 = *(char **)((int)register0x00000010 + -0x40);
    if (pcVar3 != (char *)0x0) {
      pcVar6 = *(char **)((int)register0x00000010 + -0x38);
      goto LAB_0040f9b8;
    }
    puVar8 = *(uint **)((int)register0x00000010 + 4);
    pcVar11 = *(char **)((int)register0x00000010 + -0x38);
    puVar12 = *(uint **)((int)register0x00000010 + 0xc);
  }
  else {
    pcVar3 = (char *)0x0;
  }
LAB_0040fc8c:
  puVar9 = (uint *)*puVar12;
  if (puVar9 == (uint *)0x0) {
    pcVar6 = (char *)0x0;
LAB_0040fd37:
    if (pcVar6 == (char *)0x0) {
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0;
      *(char **)((int)register0x00000010 + -0x4c) = pcVar11;
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x400000;
      *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fd57;
      FUN_0040fef0();
      if (*(int *)((int)register0x00000010 + -0x44) == 0) {
        *(undefined4 *)((int)register0x00000010 + 0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x18) = 0;
        return;
      }
      *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + -0x44);
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + -0x40);
      *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + 4) + 0x46d4;
      *(int *)((int)register0x00000010 + -0x50) = *(int *)((int)register0x00000010 + 4) + 0x46d4;
      *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fd84;
      FUN_00418000();
      puVar2 = *(undefined4 **)((int)register0x00000010 + -0x4c);
      *puVar2 = *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined1 *)(puVar2 + 1) = 1;
      puVar2[2] = DAT_005ddf2c;
      *(undefined4 *)((int)register0x00000010 + -0x50) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fdad;
      DAT_005ddf2c = puVar2;
      FUN_00418000();
      puVar2 = *(undefined4 **)((int)register0x00000010 + -0x4c);
      pcVar6 = *(char **)((int)register0x00000010 + -0x18);
      *puVar2 = pcVar6 + *(int *)((int)register0x00000010 + -4);
      puVar2[2] = DAT_005ddf2c;
      pcVar3 = *(char **)((int)register0x00000010 + -4);
      DAT_005ddf2c = puVar2;
    }
    pcVar11 = pcVar6 + (int)pcVar3;
    if (pcVar11 < pcVar3) {
      iVar13 = 0x1c;
      in_EDI = 
      "region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
    }
    else {
      iVar13 = 0;
      in_EDI = (char *)0x0;
    }
    if (iVar13 == 0) {
      if (((uint)pcVar3 & 0x3fffff) == 0) {
        puVar12 = (uint *)0x0;
LAB_0040f9b8:
        *(char **)((int)register0x00000010 + -4) = pcVar3;
        *(char **)((int)register0x00000010 + -0x18) = pcVar6;
        uVar4 = (uint)pcVar3 >> 0x16;
        puVar9 = *(uint **)((int)register0x00000010 + 4);
        do {
          if ((uint)(pcVar6 + -1 + (int)pcVar3) >> 0x16 < uVar4) {
            *(char **)((int)register0x00000010 + 0x14) = pcVar3;
            *(char **)((int)register0x00000010 + 0x18) = pcVar6;
            return;
          }
          *(uint *)((int)register0x00000010 + -0x24) = uVar4;
          puVar8 = (uint *)puVar9[0x4d];
          pcVar6 = pcVar3;
          if (puVar8 == (uint *)0x0) {
            *(code **)((int)register0x00000010 + -0x50) = VirtualAlloc_exref;
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x1000;
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x3000;
            *(undefined4 *)((int)register0x00000010 + -0x40) = 4;
            *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fa47;
            FUN_00437120();
            iVar13 = *(int *)((int)register0x00000010 + -0x3c);
            pcVar3 = in_EDI;
            if (iVar13 == 0) goto LAB_0040fc4e;
            *(int *)((int)register0x00000010 + -8) = iVar13;
            *(int *)((int)register0x00000010 + -0x50) =
                 *(int *)((int)register0x00000010 + 4) + 0x134;
            *(int *)((int)register0x00000010 + -0x4c) = iVar13;
            *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fa6d;
            FUN_00402760();
            uVar4 = *(uint *)((int)register0x00000010 + -0x24);
            puVar9 = *(uint **)((int)register0x00000010 + 4);
            pcVar6 = *(char **)((int)register0x00000010 + -4);
            puVar8 = *(uint **)((int)register0x00000010 + -8);
          }
          if (0x3ff < uVar4) goto LAB_0040fc44;
          puVar12 = (uint *)puVar8[uVar4];
          if (puVar12 != (uint *)0x0) goto LAB_0040fc2e;
          *(uint **)((int)register0x00000010 + -0x14) = puVar8;
          *(uint **)((int)register0x00000010 + -0x50) = puVar9 + 0x4f;
          *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x8c8;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 4;
          *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f84f0;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fac5;
          FUN_00411d30();
          iVar13 = *(int *)((int)register0x00000010 + -0x40);
          if (iVar13 == 0) {
            *(undefined4 *)((int)register0x00000010 + -0x50) = 0x8c8;
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 4;
            *(undefined **)((int)register0x00000010 + -0x48) = &DAT_005f84f0;
            *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40faeb;
            FUN_004119f0();
            iVar13 = *(int *)((int)register0x00000010 + -0x44);
            if (iVar13 == 0) goto LAB_0040fc18;
          }
          puVar9 = (uint *)(uint)*(byte *)((int)register0x00000010 + 0x10);
          if (*(byte *)((int)register0x00000010 + 0x10) == 0) {
            iVar7 = *(int *)((int)register0x00000010 + -0x24);
          }
          else {
            pcVar6 = *(char **)((int)register0x00000010 + 4);
            iVar7 = *(int *)(pcVar6 + 0x168);
            if (*(int *)(pcVar6 + 0x164) == iVar7) {
              *(int *)((int)register0x00000010 + -0x30) = iVar13;
              puVar12 = (uint *)(iVar7 << 3);
              if (puVar12 == (uint *)0x0) {
                puVar12 = DAT_005f5de0;
              }
              *(uint **)((int)register0x00000010 + -0x34) = puVar12;
              *(uint **)((int)register0x00000010 + -0x50) = puVar12;
              *(undefined4 *)((int)register0x00000010 + -0x4c) = 4;
              *(undefined **)((int)register0x00000010 + -0x48) = &DAT_005f84f0;
              *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fb49;
              FUN_004119f0();
              if (*(int *)((int)register0x00000010 + -0x44) == 0) goto LAB_0040fc02;
              iVar13 = *(int *)((int)register0x00000010 + 4);
              uVar4 = *(uint *)((int)register0x00000010 + -0x34);
              in_EDI = *(char **)(iVar13 + 0x160);
              *(int *)(iVar13 + 0x160) = *(int *)((int)register0x00000010 + -0x44);
              *(uint *)(iVar13 + 0x168) = uVar4 >> 2;
              iVar7 = *(int *)(iVar13 + 0x164);
              if (*(int *)(iVar13 + 0x164) <= *(int *)(iVar13 + 0x164)) {
                iVar7 = *(int *)(iVar13 + 0x164);
              }
              if (*(char **)(iVar13 + 0x160) != in_EDI) {
                *(char **)((int)register0x00000010 + -0x50) = *(char **)(iVar13 + 0x160);
                *(char **)((int)register0x00000010 + -0x4c) = in_EDI;
                *(int *)((int)register0x00000010 + -0x48) = iVar7 << 2;
                *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fba1;
                FUN_0046f640();
              }
              iVar13 = *(int *)((int)register0x00000010 + -0x30);
              puVar9 = (uint *)(uint)*(byte *)((int)register0x00000010 + 0x10);
              pcVar6 = *(char **)((int)register0x00000010 + 4);
            }
            puVar12 = *(uint **)(pcVar6 + 0x164);
            puVar8 = *(uint **)(pcVar6 + 0x168);
            puVar1 = (uint *)((int)puVar12 + 1);
            if (puVar8 < puVar1) goto LAB_0040fbfd;
            *(uint **)(pcVar6 + 0x164) = puVar1;
            if (puVar1 <= puVar12) goto LAB_0040fbf6;
            iVar7 = *(int *)((int)register0x00000010 + -0x24);
            *(int *)(*(int *)(pcVar6 + 0x160) + (int)puVar12 * 4) = iVar7;
          }
          *(int *)((int)register0x00000010 + -0x50) =
               *(int *)((int)register0x00000010 + -0x14) + iVar7 * 4;
          *(int *)((int)register0x00000010 + -0x4c) = iVar13;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40f9de;
          FUN_00402760();
          uVar4 = *(int *)((int)register0x00000010 + -0x24) + 1;
          pcVar6 = *(char **)((int)register0x00000010 + -0x18);
          pcVar3 = *(char **)((int)register0x00000010 + -4);
          puVar9 = *(uint **)((int)register0x00000010 + 4);
        } while( true );
      }
      pcVar3 = 
      "misrounded allocation in sysAllocruntime: failed to decommit pages/cpu/classes/gc/pause:cpu-seconds/cpu/classes/gc/total:cpu-seconds/gc/limiter/last-enabled:gc-cycle/memory/classes/heap/stacks:bytes/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createeven..." /* TRUNCATED STRING LITERAL */
      ;
      *(char **)((int)register0x00000010 + -0x50) =
           "misrounded allocation in sysAllocruntime: failed to decommit pages/cpu/classes/gc/pause:cpu-seconds/cpu/classes/gc/total:cpu-seconds/gc/limiter/last-enabled:gc-cycle/memory/classes/heap/stacks:bytes/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createeven..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x21;
      *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fe2c;
      FUN_00469a20();
    }
    *(int *)((int)register0x00000010 + -0x20) = iVar13;
    *(char **)((int)register0x00000010 + -0x2c) = pcVar3;
    *(char **)((int)register0x00000010 + -0x18) = pcVar11;
    *(char **)((int)register0x00000010 + -0x10) = in_EDI;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fe41;
    FUN_0043a810();
    *(char **)((int)register0x00000010 + -0x50) =
         "runtime: memory allocated by OS [misrounded allocation in sysAllocruntime: failed to decommit pages/cpu/classes/gc/pause:cpu-seconds/cpu/classes/gc/total:cpu-seconds/gc/limiter/last-enabled:gc-cycle/memory/classes/heap/stacks:bytes/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unw..." /* TRUNCATED STRING LITERAL */
    ;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x21;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fe57;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0x50) =
         *(undefined4 *)((int)register0x00000010 + -0x2c);
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fe6b;
    FUN_0043aef0();
    *(undefined **)((int)register0x00000010 + -0x50) = &DAT_004c293a;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 2;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fe81;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0x50) =
         *(undefined4 *)((int)register0x00000010 + -0x18);
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fe95;
    FUN_0043aef0();
    *(undefined **)((int)register0x00000010 + -0x50) = &DAT_004ca3fe;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x1f;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40feab;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0x50) =
         *(undefined4 *)((int)register0x00000010 + -0x10);
    *(undefined4 *)((int)register0x00000010 + -0x4c) =
         *(undefined4 *)((int)register0x00000010 + -0x20);
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40febf;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fec4;
    FUN_0043aa10();
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fec9;
    FUN_0043a870();
    *(undefined **)((int)register0x00000010 + -0x50) = &DAT_004ccb06;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x2e;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fedf;
    FUN_00469a20();
    goto LAB_0040fee0;
  }
  uVar4 = *puVar9;
  if ((char)puVar9[1] != '\0') {
    uVar4 = uVar4 - (int)pcVar11;
  }
  *(uint **)((int)register0x00000010 + -0x1c) = puVar9;
  uVar14 = uVar4 + (int)pcVar11;
  if (uVar14 < uVar4) {
    uVar5 = 0;
    pcVar6 = pcVar11;
  }
  else {
    *(uint *)((int)register0x00000010 + -0x28) = uVar4;
    *(uint *)((int)register0x00000010 + -0x18) = uVar14;
    *(uint *)((int)register0x00000010 + -0x50) = uVar4;
    *(char **)((int)register0x00000010 + -0x4c) = pcVar11;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fcc8;
    FUN_00415340();
    uVar5 = *(uint *)((int)register0x00000010 + -0x48);
    uVar4 = *(uint *)((int)register0x00000010 + -0x28);
    puVar9 = *(uint **)((int)register0x00000010 + -0x1c);
    pcVar6 = *(char **)((int)register0x00000010 + -0x38);
    puVar12 = *(uint **)((int)register0x00000010 + 0xc);
    uVar14 = *(uint *)((int)register0x00000010 + -0x18);
    puVar8 = *(uint **)((int)register0x00000010 + 4);
  }
  *(uint *)((int)register0x00000010 + -4) = uVar5;
  if (uVar5 == uVar4) {
    if ((char)puVar9[1] == '\0') {
      uVar4 = uVar14;
    }
    *puVar9 = uVar4;
    pcVar3 = *(char **)((int)register0x00000010 + -4);
    pcVar11 = pcVar6;
    goto LAB_0040fd37;
  }
  pcVar3 = *(char **)((int)register0x00000010 + -4);
  if (pcVar3 != (char *)0x0) {
    *(char **)((int)register0x00000010 + -0x50) = pcVar3;
    *(char **)((int)register0x00000010 + -0x4c) = pcVar6;
    *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fd06;
    FUN_00415280();
    puVar8 = *(uint **)((int)register0x00000010 + 4);
    puVar9 = *(uint **)((int)register0x00000010 + -0x1c);
    pcVar6 = *(char **)((int)register0x00000010 + -0x38);
    puVar12 = *(uint **)((int)register0x00000010 + 0xc);
    pcVar3 = *(char **)((int)register0x00000010 + -4);
  }
  goto LAB_0040fc64;
LAB_0040fbf6:
  *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fbfd;
  FUN_0046edf0();
LAB_0040fbfd:
  *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fc02;
  FUN_0046ee30();
LAB_0040fc02:
  *(char **)((int)register0x00000010 + -0x50) =
       "out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of ran..." /* TRUNCATED STRING LITERAL */
  ;
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x22;
  *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fc18;
  FUN_00469a20();
LAB_0040fc18:
  *(undefined **)((int)register0x00000010 + -0x50) = &DAT_004cc75c;
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x2c;
  *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fc2e;
  FUN_00469a20();
LAB_0040fc2e:
  *(undefined **)((int)register0x00000010 + -0x50) = &DAT_004c85fc;
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x19;
  *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fc44;
  FUN_00469a20();
LAB_0040fc44:
  *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fc4e;
  FUN_0046ee00();
  pcVar3 = in_EDI;
LAB_0040fc4e:
  *(char **)((int)register0x00000010 + -0x50) =
       "out of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
  ;
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x27;
  *(undefined4 *)((int)register0x00000010 + -0x54) = 0x40fc64;
  FUN_00469a20();
LAB_0040fc64:
  *puVar12 = puVar9[2];
  puVar8[0x11bc] = puVar8[0x11bc] - puVar8[0x11b5];
  *puVar9 = puVar8[0x11b8];
  puVar8[0x11b8] = (uint)puVar9;
  pcVar11 = pcVar6;
  goto LAB_0040fc8c;
}



/* Function: FUN_0040fef0 */

void FUN_0040fef0(void)

{
  int iVar1;
  uint uVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x18);
      iVar1 = 0;
      while( true ) {
        *(int *)((int)register0x00000010 + -0xc) = iVar1;
        *(int *)((int)register0x00000010 + -4) =
             *(int *)((int)register0x00000010 + 8) + *(int *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(int *)((int)register0x00000010 + -0x14) =
             *(int *)((int)register0x00000010 + 8) + *(int *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40ff2e;
        FUN_00415340();
        uVar2 = *(uint *)((int)register0x00000010 + -0x10);
        if (uVar2 == 0) {
          *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
          *(undefined4 *)((int)register0x00000010 + 0x14) = 0;
          return;
        }
        if ((uVar2 & *(int *)((int)register0x00000010 + 0xc) - 1U) == 0) {
          *(uint *)((int)register0x00000010 + 0x10) = uVar2;
          *(undefined4 *)((int)register0x00000010 + 0x14) =
               *(undefined4 *)((int)register0x00000010 + -4);
          return;
        }
        *(uint *)((int)register0x00000010 + -8) = uVar2;
        *(uint *)((int)register0x00000010 + -0x18) = uVar2;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40ff5b;
        FUN_00415280();
        uVar2 = -*(int *)((int)register0x00000010 + 0xc) &
                *(int *)((int)register0x00000010 + 0xc) + -1 +
                *(int *)((int)register0x00000010 + -8);
        *(uint *)((int)register0x00000010 + -8) = uVar2;
        *(uint *)((int)register0x00000010 + -0x18) = uVar2;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40ff81;
        FUN_00415340();
        iVar1 = *(int *)((int)register0x00000010 + -0x10);
        if (iVar1 == *(int *)((int)register0x00000010 + -8)) {
          *(int *)((int)register0x00000010 + 0x10) = iVar1;
          *(undefined4 *)((int)register0x00000010 + 0x14) =
               *(undefined4 *)((int)register0x00000010 + 8);
          return;
        }
        *(int *)((int)register0x00000010 + -0x18) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40ff9f;
        FUN_00415280();
        if (*(int *)((int)register0x00000010 + -0xc) == 99) break;
        iVar1 = *(int *)((int)register0x00000010 + -0xc) + 1;
      }
      *(char **)((int)register0x00000010 + -0x18) =
           "failed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x38;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x40fff8;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x40fffe;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00410010 */

void FUN_00410010(int param_1)

{
  bool bVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc)) {
    FUN_0046afb0();
  }
  FUN_0042cad0(param_1 + 8);
  FUN_0040ecf0(param_1);
  if (*(char *)(param_1 + 0x138) == '\0') {
    *(undefined1 *)(param_1 + 0x138) = 1;
    FUN_0040f0e0(param_1);
    bVar1 = false;
    while (!bVar1) {
      FUN_00402520(param_1 + 0x134);
      bVar1 = true;
    }
    return;
  }
  FUN_0040f0e0(param_1);
  return;
}



/* Function: FUN_004100b0 */

void FUN_004100b0(void)

{
  ushort uVar1;
  undefined4 uVar2;
  ushort uVar3;
  uint uVar4;
  int iVar5;
  ushort uVar6;
  ushort uVar7;
  undefined1 *puVar8;
  ushort uVar9;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x1c);
      uVar4 = (uint)*(byte *)((int)register0x00000010 + 8);
      if (uVar4 < 0x88) {
        *(uint *)((int)register0x00000010 + -4) = uVar4;
        uVar2 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x1c + uVar4 * 4);
        *(undefined4 *)((int)register0x00000010 + -8) = uVar2;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar2;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4100f4;
        FUN_00412dd0();
        uVar3 = *(ushort *)((int)register0x00000010 + -0x18);
        iVar5 = *(int *)((int)register0x00000010 + -8);
        uVar6 = *(ushort *)(iVar5 + 0x1a);
        uVar7 = uVar3;
        if (uVar6 == uVar3) {
          *(ushort *)((int)register0x00000010 + -0xe) = uVar6;
          uVar7 = *(ushort *)(iVar5 + 0x3c);
          if (uVar7 == uVar6) {
            *(ushort *)((int)register0x00000010 + -0x12) = uVar3;
            *(undefined4 *)((int)register0x00000010 + -0x1c) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined1 *)((int)register0x00000010 + -0x18) =
                 *(undefined1 *)((int)register0x00000010 + 8);
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x410132;
            FUN_00413c60();
            uVar2 = *(undefined4 *)
                     (*(int *)((int)register0x00000010 + 4) + 0x1c +
                     *(int *)((int)register0x00000010 + -4) * 4);
            *(undefined4 *)((int)register0x00000010 + -8) = uVar2;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar2;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41014a;
            FUN_00412dd0();
            uVar3 = *(ushort *)((int)register0x00000010 + -0x18);
            uVar6 = *(ushort *)((int)register0x00000010 + -0xe);
            iVar5 = *(int *)((int)register0x00000010 + -8);
            uVar7 = *(ushort *)((int)register0x00000010 + -0x12);
            goto LAB_00410161;
          }
        }
        else {
LAB_00410161:
          if (uVar3 < *(ushort *)(iVar5 + 0x1a)) {
            uVar9 = *(short *)(iVar5 + 0x3c) + 1;
            *(ushort *)(iVar5 + 0x3c) = uVar9;
            uVar1 = *(ushort *)(iVar5 + 0x1a);
            if (uVar9 <= uVar1) {
              *(uint *)((int)register0x00000010 + 0xc) =
                   (uint)uVar3 * *(int *)(iVar5 + 0x44) + *(int *)(iVar5 + 0xc);
              *(int *)((int)register0x00000010 + 0x10) = iVar5;
              *(bool *)((int)register0x00000010 + 0x14) = uVar6 == uVar7;
              return;
            }
            *(ushort *)((int)register0x00000010 + -0xe) = uVar9;
            *(ushort *)((int)register0x00000010 + -0x10) = uVar1;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4101ac;
            FUN_0043a810();
            *(char **)((int)register0x00000010 + -0x1c) =
                 "s.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
            ;
            *(undefined4 *)((int)register0x00000010 + -0x18) = 0xe;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4101c2;
            FUN_0043b060();
            *(uint *)((int)register0x00000010 + -0xc) =
                 (uint)*(ushort *)((int)register0x00000010 + -0x10);
            *(uint *)((int)register0x00000010 + -0x1c) =
                 (uint)*(ushort *)((int)register0x00000010 + -0xe);
            *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4101e6;
            FUN_0043ad50();
            *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c3a33;
            *(undefined4 *)((int)register0x00000010 + -0x18) = 0xb;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4101fc;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x1c) =
                 *(undefined4 *)((int)register0x00000010 + -0xc);
            *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x410210;
            FUN_0043ad50();
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x410215;
            FUN_0043aa10();
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41021a;
            FUN_0043a870();
            *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c79e7;
            *(undefined4 *)((int)register0x00000010 + -0x18) = 0x17;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x410230;
            FUN_00469a20();
          }
          uVar7 = (ushort)iVar5;
          *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c7312;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x16;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x410246;
          FUN_00469a20();
        }
        *(ushort *)((int)register0x00000010 + -0x10) = uVar7;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x410250;
        FUN_0043a810();
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c79d0;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x17;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x410266;
        FUN_0043b060();
        *(uint *)((int)register0x00000010 + -0xc) =
             (uint)*(ushort *)((int)register0x00000010 + -0xe);
        *(uint *)((int)register0x00000010 + -0x1c) =
             (uint)*(ushort *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41028a;
        FUN_0043ad50();
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c3a33;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0xb;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4102a0;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4102b4;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4102b9;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4102be;
        FUN_0043a870();
        *(char **)((int)register0x00000010 + -0x1c) =
             "s.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not ..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x31;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4102d4;
        FUN_00469a20();
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4102de;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar8 + -4) = 0x4102e4;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_004102f0 */

void FUN_004102f0(uint param_1)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  ushort uVar8;
  byte bVar9;
  int iVar10;
  undefined4 *puVar11;
  uint *puVar12;
  uint uVar13;
  uint uVar14;
  char cVar15;
  int in_FS_OFFSET;
  undefined4 *in_stack_ffffffd0;
  uint in_stack_ffffffd4;
  char local_28;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  piVar1 = (int *)(*(int *)(iVar4 + 0x18) + 0x7c);
  *piVar1 = *piVar1 + 1;
  iVar4 = *(int *)(iVar4 + 0x18);
  *(undefined4 *)(iVar4 + 0x6c) = 1;
  puVar12 = DAT_005f5e64;
  if (*(int *)(iVar4 + 0x58) != 0) {
    puVar12 = *(uint **)(*(int *)(iVar4 + 0x58) + 0x30);
  }
  uVar14 = puVar12[5];
  if ((param_1 & 7) == 0) {
    uVar14 = uVar14 + 7 & 0xfffffff8;
  }
  else if (param_1 == 0xc) {
    uVar14 = uVar14 + 7 & 0xfffffff8;
  }
  else if ((param_1 & 3) == 0) {
    uVar14 = uVar14 + 3 & 0xfffffffc;
  }
  else if ((param_1 & 1) == 0) {
    uVar14 = uVar14 + 1 & 0xfffffffe;
  }
  if ((uVar14 + param_1 < 0x11) && (puVar12[4] != 0)) {
    puVar12[5] = uVar14 + param_1;
    puVar12[6] = puVar12[6] + 1;
    *(undefined4 *)(iVar4 + 0x6c) = 0;
    iVar10 = *(int *)(iVar4 + 0x7c);
    iVar5 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    *(int *)(iVar4 + 0x7c) = iVar10 + -1;
    if ((iVar10 == 1) && (*(char *)(iVar5 + 0x69) != '\0')) {
      *(undefined4 *)(iVar5 + 8) = 0xfffffade;
    }
    return;
  }
  uVar14 = puVar12[0xc];
  uVar13 = *(uint *)(uVar14 + 0x24);
  uVar6 = *(uint *)(uVar14 + 0x20);
  iVar10 = 0;
  if (uVar6 != 0) {
    for (; (uVar6 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
    }
  }
  if (uVar6 == 0) {
    iVar10 = 0;
    if (uVar13 != 0) {
      for (; (uVar13 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
      }
    }
    if (uVar13 == 0) {
      iVar10 = 0x20;
    }
    iVar10 = iVar10 + 0x20;
  }
  if (iVar10 < 0x40) {
    uVar2 = iVar10 + (uint)*(ushort *)(uVar14 + 0x18);
    if ((ushort)uVar2 < *(ushort *)(uVar14 + 0x1a)) {
      uVar3 = iVar10 + 1 + (uint)*(ushort *)(uVar14 + 0x18);
      uVar8 = (ushort)uVar3;
      if (((uVar3 & 0x3f) == 0) && (*(ushort *)(uVar14 + 0x1a) != uVar8)) {
        puVar11 = (undefined4 *)0x0;
      }
      else {
        uVar3 = iVar10 - 0x1f;
        bVar9 = (byte)(iVar10 + 1U);
        uVar7 = -(uint)(iVar10 + 1U < 0x20);
        *(uint *)(uVar14 + 0x20) =
             uVar13 >> ((byte)uVar3 & 0x1f) & -(uint)(uVar3 < 0x20) |
             uVar6 >> (bVar9 & 0x1f) & uVar7 |
             uVar13 << ((byte)-uVar3 & 0x1f) & -(uint)(-uVar3 < 0x20);
        *(uint *)(uVar14 + 0x24) = uVar13 >> (bVar9 & 0x1f) & uVar7;
        *(ushort *)(uVar14 + 0x18) = uVar8;
        *(short *)(uVar14 + 0x3c) = *(short *)(uVar14 + 0x3c) + 1;
        puVar11 = (undefined4 *)
                  ((uVar2 & 0xffff) * *(int *)(uVar14 + 0x44) + *(int *)(uVar14 + 0xc));
      }
      goto LAB_004104d0;
    }
  }
  puVar11 = (undefined4 *)0x0;
LAB_004104d0:
  if (puVar11 == (undefined4 *)0x0) {
    puVar11 = in_stack_ffffffd0;
    uVar14 = in_stack_ffffffd4;
    FUN_004100b0(puVar12,5);
    cVar15 = local_28;
  }
  else {
    cVar15 = '\0';
  }
  *puVar11 = 0;
  puVar11[1] = 0;
  puVar11[2] = 0;
  puVar11[3] = 0;
  if ((param_1 < puVar12[5]) || (puVar12[4] == 0)) {
    puVar12[4] = (uint)puVar11;
    puVar12[5] = param_1;
  }
  FUN_0046ea00();
  *(undefined2 *)(uVar14 + 0x1c) = *(undefined2 *)(uVar14 + 0x18);
  if ((char)DAT_005f5fd0 != '\0') {
    FUN_00420a30(uVar14,puVar11);
  }
  uVar13 = *puVar12;
  uVar6 = *(uint *)(uVar14 + 0x44);
  *puVar12 = uVar13 - uVar6;
  uVar13 = puVar12[1] - (uint)(uVar13 < uVar6);
  puVar12[1] = uVar13;
  if (((int)uVar13 < 0) || (puVar12[2] != DAT_005cc27c)) {
    FUN_00411750(iVar4,puVar11,*(undefined4 *)(uVar14 + 0x44));
  }
  *(undefined4 *)(iVar4 + 0x6c) = 0;
  iVar10 = *(int *)(iVar4 + 0x7c);
  iVar5 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(int *)(iVar4 + 0x7c) = iVar10 + -1;
  if ((iVar10 == 1) && (*(char *)(iVar5 + 0x69) != '\0')) {
    *(undefined4 *)(iVar5 + 8) = 0xfffffade;
  }
  if ((cVar15 != '\0') && (FUN_00418440(0,0,0,0), local_28 != '\0')) {
    FUN_004185b0(0,0,0,0);
  }
  return;
}



/* Function: FUN_00410660 */

void FUN_00410660(void)

{
  int *piVar1;
  uint uVar2;
  ushort uVar3;
  uint uVar4;
  uint *puVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  undefined1 uVar9;
  int iVar10;
  int iVar11;
  undefined1 *puVar12;
  byte bVar13;
  ushort uVar14;
  uint uVar15;
  int in_FS_OFFSET;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x40);
      iVar8 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      piVar1 = (int *)(*(int *)(iVar8 + 0x18) + 0x7c);
      *piVar1 = *piVar1 + 1;
      iVar8 = *(int *)(iVar8 + 0x18);
      *(undefined4 *)(iVar8 + 0x6c) = 1;
      iVar11 = DAT_005f5e64;
      if (*(int *)(iVar8 + 0x58) != 0) {
        iVar11 = *(int *)(*(int *)(iVar8 + 0x58) + 0x30);
      }
      uVar7 = *(uint *)((int)register0x00000010 + 4);
      if (uVar7 < 0x3f9) {
        uVar7 = uVar7 + 7 >> 3;
        if (uVar7 < 0x81) {
          bVar13 = (&DAT_005cc860)[uVar7];
LAB_004106ed:
          uVar7 = (uint)bVar13;
          if (uVar7 < 0x44) {
            uVar15 = (uint)(ushort)(&DAT_005cc900)[uVar7];
            *(undefined1 *)((int)register0x00000010 + -0x28) = 1;
            bVar13 = (byte)(uVar7 << 1) | *(byte *)((int)register0x00000010 + -0x28);
            uVar7 = uVar7 << 1 & 0xff | (uint)*(byte *)((int)register0x00000010 + -0x28);
            if (uVar7 < 0x88) break;
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4109af;
            FUN_0046edf0();
          }
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4109b9;
          FUN_0046edf0();
          goto LAB_004109b9;
        }
      }
      else {
        uVar7 = uVar7 - 0x381 >> 7;
        if (uVar7 < 0xf9) {
          bVar13 = s__________________________________005cc9a0[uVar7];
          goto LAB_004106ed;
        }
LAB_004109b9:
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4109c3;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4109cd;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar12 + -4) = 0x4109d3;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
  *(int *)((int)register0x00000010 + -8) = iVar8;
  *(int *)((int)register0x00000010 + -0x20) = iVar11;
  *(uint *)((int)register0x00000010 + -0xc) = uVar15;
  iVar8 = *(int *)(iVar11 + 0x1c + uVar7 * 4);
  uVar7 = *(uint *)(iVar8 + 0x24);
  uVar4 = *(uint *)(iVar8 + 0x20);
  iVar10 = 0;
  if (uVar4 != 0) {
    for (; (uVar4 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
    }
  }
  if (uVar4 == 0) {
    iVar10 = 0;
    if (uVar7 != 0) {
      for (; (uVar7 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
      }
    }
    if (uVar7 == 0) {
      iVar10 = 0x20;
    }
    iVar10 = iVar10 + 0x20;
  }
  if (iVar10 < 0x40) {
    *(byte *)((int)register0x00000010 + -0x29) = bVar13;
    uVar14 = *(ushort *)(iVar8 + 0x18);
    uVar15 = iVar10 + (uint)uVar14;
    uVar3 = *(ushort *)(iVar8 + 0x1a);
    if ((ushort)uVar15 < uVar3) {
      *(int *)((int)register0x00000010 + -0x24) = iVar8;
      uVar2 = iVar10 + 1 + (uint)uVar14;
      uVar14 = (ushort)uVar2;
      if (((uVar2 & 0x3f) == 0) && (uVar3 != uVar14)) {
        iVar11 = *(int *)((int)register0x00000010 + -0x20);
        bVar13 = *(byte *)((int)register0x00000010 + -0x29);
        uVar15 = *(uint *)((int)register0x00000010 + -0xc);
        iVar10 = 0;
      }
      else {
        *(uint *)((int)register0x00000010 + -0x10) = uVar4;
        *(ushort *)((int)register0x00000010 + -0x26) = uVar14;
        *(uint *)((int)register0x00000010 + -0x14) = uVar7;
        uVar4 = iVar10 - 0x1f;
        *(uint *)((int)register0x00000010 + -0x18) = -uVar4;
        *(int *)((int)register0x00000010 + -0x1c) =
             *(int *)((int)register0x00000010 + -0x14) << ((byte)-uVar4 & 0x1f);
        uVar2 = *(uint *)((int)register0x00000010 + -0x14);
        bVar13 = (byte)(iVar10 + 1U);
        uVar6 = -(uint)(iVar10 + 1U < 0x20);
        iVar8 = *(int *)((int)register0x00000010 + -0x24);
        *(uint *)(iVar8 + 0x20) =
             *(uint *)((int)register0x00000010 + -0x1c) &
             -(uint)(*(uint *)((int)register0x00000010 + -0x18) < 0x20) |
             *(uint *)((int)register0x00000010 + -0x10) >> (bVar13 & 0x1f) & uVar6 |
             uVar7 >> ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20);
        *(uint *)(iVar8 + 0x24) = uVar2 >> (bVar13 & 0x1f) & uVar6;
        *(undefined2 *)(iVar8 + 0x18) = *(undefined2 *)((int)register0x00000010 + -0x26);
        *(short *)(iVar8 + 0x3c) = *(short *)(iVar8 + 0x3c) + 1;
        iVar10 = (uVar15 & 0xffff) * *(int *)(iVar8 + 0x44) + *(int *)(iVar8 + 0xc);
        iVar11 = *(int *)((int)register0x00000010 + -0x20);
        uVar15 = *(uint *)((int)register0x00000010 + -0xc);
        bVar13 = *(byte *)((int)register0x00000010 + -0x29);
      }
      goto LAB_0041083b;
    }
    iVar11 = *(int *)((int)register0x00000010 + -0x20);
    bVar13 = *(byte *)((int)register0x00000010 + -0x29);
    uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  }
  iVar10 = 0;
LAB_0041083b:
  if (iVar10 == 0) {
    *(int *)((int)register0x00000010 + -0x40) = iVar11;
    *(byte *)((int)register0x00000010 + -0x3c) = bVar13;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410851;
    FUN_004100b0();
    iVar10 = *(int *)((int)register0x00000010 + -0x38);
    iVar8 = *(int *)((int)register0x00000010 + -0x34);
    uVar9 = *(undefined1 *)((int)register0x00000010 + -0x30);
    uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  }
  else {
    uVar9 = 0;
  }
  *(undefined1 *)((int)register0x00000010 + -0x27) = uVar9;
  *(int *)((int)register0x00000010 + -0x24) = iVar8;
  *(int *)((int)register0x00000010 + -4) = iVar10;
  if ((*(char *)((int)register0x00000010 + 0xc) != '\0') && (*(char *)(iVar8 + 0x40) != '\0')) {
    *(int *)((int)register0x00000010 + -0x40) = iVar10;
    *(uint *)((int)register0x00000010 + -0x3c) = uVar15;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410893;
    FUN_0046f470();
  }
  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410898;
  FUN_0046ea00();
  iVar8 = *(int *)((int)register0x00000010 + -0x24);
  *(undefined2 *)(iVar8 + 0x1c) = *(undefined2 *)(iVar8 + 0x18);
  if ((char)DAT_005f5fd0 != '\0') {
    *(int *)((int)register0x00000010 + -0x40) = iVar8;
    *(undefined4 *)((int)register0x00000010 + -0x3c) = *(undefined4 *)((int)register0x00000010 + -4)
    ;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4108bf;
    FUN_00420a30();
  }
  puVar5 = *(uint **)((int)register0x00000010 + -0x20);
  uVar7 = *puVar5;
  uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  *puVar5 = uVar7 - uVar15;
  uVar7 = puVar5[1] - (uint)(uVar7 < uVar15);
  puVar5[1] = uVar7;
  if (((int)uVar7 < 0) || (puVar5[2] != DAT_005cc27c)) {
    *(undefined4 *)((int)register0x00000010 + -0x40) = *(undefined4 *)((int)register0x00000010 + -8)
    ;
    *(undefined4 *)((int)register0x00000010 + -0x3c) = *(undefined4 *)((int)register0x00000010 + -4)
    ;
    *(uint *)((int)register0x00000010 + -0x38) = uVar15;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4108fd;
    FUN_00411750();
    uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  }
  iVar8 = *(int *)((int)register0x00000010 + -8);
  *(undefined4 *)(iVar8 + 0x6c) = 0;
  iVar11 = *(int *)(iVar8 + 0x7c);
  iVar10 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(int *)(iVar8 + 0x7c) = iVar11 + -1;
  if ((iVar11 == 1) && (*(char *)(iVar10 + 0x69) != '\0')) {
    *(undefined4 *)(iVar10 + 8) = 0xfffffade;
  }
  if (*(char *)((int)register0x00000010 + -0x27) != '\0') {
    *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410964;
    FUN_00418440();
    if (*(char *)((int)register0x00000010 + -0x30) != '\0') {
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410991;
      FUN_004185b0();
    }
    uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  }
  *(undefined4 *)((int)register0x00000010 + 0x10) = *(undefined4 *)((int)register0x00000010 + -4);
  *(uint *)((int)register0x00000010 + 0x14) = uVar15;
  return;
}



/* Function: FUN_004109e0 */

void FUN_004109e0(void)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  ushort uVar4;
  uint *puVar5;
  uint uVar6;
  int iVar7;
  byte bVar8;
  undefined1 uVar9;
  ushort uVar10;
  int iVar11;
  uint uVar12;
  undefined1 *puVar13;
  int iVar14;
  byte bVar15;
  int iVar16;
  int in_FS_OFFSET;
  
  do {
    puVar13 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar13 = (undefined1 *)((int)register0x00000010 + -0x40);
      iVar7 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      piVar1 = (int *)(*(int *)(iVar7 + 0x18) + 0x7c);
      *piVar1 = *piVar1 + 1;
      iVar7 = *(int *)(iVar7 + 0x18);
      *(undefined4 *)(iVar7 + 0x6c) = 1;
      iVar11 = DAT_005f5e64;
      if (*(int *)(iVar7 + 0x58) != 0) {
        iVar11 = *(int *)(*(int *)(iVar7 + 0x58) + 0x30);
      }
      iVar14 = *(int *)((int)register0x00000010 + 4);
      uVar6 = iVar14 + 7U >> 3;
      if (uVar6 < 0x81) {
        bVar8 = (&DAT_005cc860)[uVar6];
        *(undefined1 *)((int)register0x00000010 + -0x29) = 0;
        bVar15 = bVar8 << 1 | *(byte *)((int)register0x00000010 + -0x29);
        if (bVar15 < 0x88) {
          *(int *)((int)register0x00000010 + -8) = iVar7;
          *(int *)((int)register0x00000010 + -0x20) = iVar11;
          *(byte *)((int)register0x00000010 + -0x27) = bVar8;
          *(byte *)((int)register0x00000010 + -0x2a) = bVar15;
          iVar7 = *(int *)(iVar11 + 0x1c + (uint)bVar15 * 4);
          uVar6 = *(uint *)(iVar7 + 0x24);
          uVar12 = *(uint *)(iVar7 + 0x20);
          iVar16 = 0;
          if (uVar12 != 0) {
            for (; (uVar12 >> iVar16 & 1) == 0; iVar16 = iVar16 + 1) {
            }
          }
          if (uVar12 == 0) {
            iVar16 = 0;
            if (uVar6 != 0) {
              for (; (uVar6 >> iVar16 & 1) == 0; iVar16 = iVar16 + 1) {
              }
            }
            if (uVar6 == 0) {
              iVar16 = 0x20;
            }
            iVar16 = iVar16 + 0x20;
          }
          if (iVar16 < 0x40) {
            uVar10 = *(ushort *)(iVar7 + 0x18);
            uVar2 = iVar16 + (uint)uVar10;
            uVar4 = *(ushort *)(iVar7 + 0x1a);
            if (uVar4 <= (ushort)uVar2) {
              iVar11 = *(int *)((int)register0x00000010 + -0x20);
              iVar14 = *(int *)((int)register0x00000010 + 4);
              bVar8 = *(byte *)((int)register0x00000010 + -0x27);
              goto LAB_00410b7e;
            }
            *(int *)((int)register0x00000010 + -0x24) = iVar7;
            uVar3 = iVar16 + 1 + (uint)uVar10;
            uVar10 = (ushort)uVar3;
            if (((uVar3 & 0x3f) == 0) && (uVar4 != uVar10)) {
              iVar11 = *(int *)((int)register0x00000010 + -0x20);
              iVar14 = *(int *)((int)register0x00000010 + 4);
              bVar8 = *(byte *)((int)register0x00000010 + -0x27);
              iVar16 = 0;
            }
            else {
              *(ushort *)((int)register0x00000010 + -0x26) = uVar10;
              *(uint *)((int)register0x00000010 + -0xc) = uVar6;
              uVar6 = iVar16 - 0x1f;
              *(uint *)((int)register0x00000010 + -0x10) =
                   *(uint *)((int)register0x00000010 + -0xc) >> ((byte)uVar6 & 0x1f);
              *(uint *)((int)register0x00000010 + -0x14) = -uVar6;
              bVar8 = (byte)(iVar16 + 1U);
              uVar3 = *(uint *)((int)register0x00000010 + -0xc);
              *(uint *)((int)register0x00000010 + -0x18) = uVar2 & 0xffff;
              uVar2 = -(uint)(iVar16 + 1U < 0x20);
              iVar7 = *(int *)((int)register0x00000010 + -0x24);
              *(uint *)(iVar7 + 0x20) =
                   *(int *)((int)register0x00000010 + -0xc) << ((byte)-uVar6 & 0x1f) &
                   -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20) |
                   uVar12 >> (bVar8 & 0x1f) & uVar2 |
                   *(uint *)((int)register0x00000010 + -0x10) & -(uint)(uVar6 < 0x20);
              *(uint *)(iVar7 + 0x24) = uVar3 >> (bVar8 & 0x1f) & uVar2;
              *(undefined2 *)(iVar7 + 0x18) = *(undefined2 *)((int)register0x00000010 + -0x26);
              *(short *)(iVar7 + 0x3c) = *(short *)(iVar7 + 0x3c) + 1;
              iVar16 = *(int *)((int)register0x00000010 + -0x18) * *(int *)(iVar7 + 0x44) +
                       *(int *)(iVar7 + 0xc);
              iVar11 = *(int *)((int)register0x00000010 + -0x20);
              iVar14 = *(int *)((int)register0x00000010 + 4);
              bVar8 = *(byte *)((int)register0x00000010 + -0x27);
            }
          }
          else {
LAB_00410b7e:
            iVar16 = 0;
          }
          if (iVar16 == 0) {
            *(int *)((int)register0x00000010 + -0x40) = iVar11;
            *(undefined1 *)((int)register0x00000010 + -0x3c) =
                 *(undefined1 *)((int)register0x00000010 + -0x2a);
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410b99;
            FUN_004100b0();
            iVar16 = *(int *)((int)register0x00000010 + -0x38);
            iVar7 = *(int *)((int)register0x00000010 + -0x34);
            uVar9 = *(undefined1 *)((int)register0x00000010 + -0x30);
            iVar14 = *(int *)((int)register0x00000010 + 4);
            bVar8 = *(byte *)((int)register0x00000010 + -0x27);
          }
          else {
            uVar9 = 0;
          }
          *(undefined1 *)((int)register0x00000010 + -0x28) = uVar9;
          *(int *)((int)register0x00000010 + -0x24) = iVar7;
          *(int *)((int)register0x00000010 + -4) = iVar16;
          if ((*(char *)((int)register0x00000010 + 0xc) != '\0') &&
             (*(char *)(iVar7 + 0x40) != '\0')) {
            *(int *)((int)register0x00000010 + -0x40) = iVar16;
            *(int *)((int)register0x00000010 + -0x3c) = iVar14;
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410be0;
            FUN_0046f470();
            iVar7 = *(int *)((int)register0x00000010 + -0x24);
            iVar16 = *(int *)((int)register0x00000010 + -4);
            iVar14 = *(int *)((int)register0x00000010 + 4);
            bVar8 = *(byte *)((int)register0x00000010 + -0x27);
          }
          *(uint *)((int)register0x00000010 + -0x1c) = (uint)bVar8;
          *(int *)((int)register0x00000010 + -0x40) = iVar7;
          *(int *)((int)register0x00000010 + -0x3c) = iVar16;
          *(int *)((int)register0x00000010 + -0x38) = iVar14;
          *(undefined4 *)((int)register0x00000010 + -0x34) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410c12;
          FUN_00412bd0();
          *(int *)(*(int *)((int)register0x00000010 + -0x20) + 0xc) =
               *(int *)(*(int *)((int)register0x00000010 + -0x20) + 0xc) +
               *(int *)((int)register0x00000010 + -0x30);
          if (*(uint *)((int)register0x00000010 + -0x1c) < 0x44) {
            *(uint *)((int)register0x00000010 + -0x18) =
                 (uint)(ushort)(&DAT_005cc900)[*(uint *)((int)register0x00000010 + -0x1c)];
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410c3d;
            FUN_0046ea00();
            iVar7 = *(int *)((int)register0x00000010 + -0x24);
            *(undefined2 *)(iVar7 + 0x1c) = *(undefined2 *)(iVar7 + 0x18);
            if ((char)DAT_005f5fd0 != '\0') {
              *(int *)((int)register0x00000010 + -0x40) = iVar7;
              *(undefined4 *)((int)register0x00000010 + -0x3c) =
                   *(undefined4 *)((int)register0x00000010 + -4);
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410c64;
              FUN_00420a30();
            }
            puVar5 = *(uint **)((int)register0x00000010 + -0x20);
            uVar6 = *puVar5;
            uVar12 = *(uint *)((int)register0x00000010 + -0x18);
            *puVar5 = uVar6 - uVar12;
            uVar6 = puVar5[1] - (uint)(uVar6 < uVar12);
            puVar5[1] = uVar6;
            if (((int)uVar6 < 0) || (puVar5[2] != DAT_005cc27c)) {
              *(undefined4 *)((int)register0x00000010 + -0x40) =
                   *(undefined4 *)((int)register0x00000010 + -8);
              *(undefined4 *)((int)register0x00000010 + -0x3c) =
                   *(undefined4 *)((int)register0x00000010 + -4);
              *(uint *)((int)register0x00000010 + -0x38) = uVar12;
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410ca2;
              FUN_00411750();
              uVar12 = *(uint *)((int)register0x00000010 + -0x18);
            }
            iVar7 = *(int *)((int)register0x00000010 + -8);
            *(undefined4 *)(iVar7 + 0x6c) = 0;
            iVar11 = *(int *)(iVar7 + 0x7c);
            iVar14 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
            *(int *)(iVar7 + 0x7c) = iVar11 + -1;
            if ((iVar11 == 1) && (*(char *)(iVar14 + 0x69) != '\0')) {
              *(undefined4 *)(iVar14 + 8) = 0xfffffade;
            }
            if (*(char *)((int)register0x00000010 + -0x28) != '\0') {
              *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410d09;
              FUN_00418440();
              if (*(char *)((int)register0x00000010 + -0x30) != '\0') {
                *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
                *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
                *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
                *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410d36;
                FUN_004185b0();
              }
              uVar12 = *(uint *)((int)register0x00000010 + -0x18);
            }
            *(undefined4 *)((int)register0x00000010 + 0x10) =
                 *(undefined4 *)((int)register0x00000010 + -4);
            *(uint *)((int)register0x00000010 + 0x14) = uVar12;
            return;
          }
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410d54;
          FUN_0046edf0();
        }
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410d5e;
        FUN_0046edf0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410d68;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar13 + -4) = 0x410d6e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar13;
  } while( true );
}



/* Function: FUN_00410d80 */

void FUN_00410d80(void)

{
  int *piVar1;
  uint uVar2;
  ushort uVar3;
  uint *puVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  undefined4 *puVar8;
  undefined1 uVar9;
  int iVar10;
  int iVar11;
  undefined1 *puVar12;
  byte bVar13;
  ushort uVar14;
  uint uVar15;
  undefined4 *puVar16;
  int in_FS_OFFSET;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x40);
      iVar7 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      piVar1 = (int *)(*(int *)(iVar7 + 0x18) + 0x7c);
      *piVar1 = *piVar1 + 1;
      iVar7 = *(int *)(iVar7 + 0x18);
      *(undefined4 *)(iVar7 + 0x6c) = 1;
      iVar11 = DAT_005f5e64;
      if (*(int *)(iVar7 + 0x58) != 0) {
        iVar11 = *(int *)(*(int *)(iVar7 + 0x58) + 0x30);
      }
      iVar10 = *(int *)((int)register0x00000010 + 4);
      if (iVar10 + 8U < 0x3f9) {
        uVar6 = iVar10 + 0xfU >> 3;
        if (uVar6 < 0x81) {
          bVar13 = (&DAT_005cc860)[uVar6];
LAB_00410e10:
          uVar6 = (uint)bVar13;
          if (uVar6 < 0x44) {
            uVar15 = (uint)(ushort)(&DAT_005cc900)[uVar6];
            *(undefined1 *)((int)register0x00000010 + -0x28) = 0;
            bVar13 = (byte)(uVar6 << 1) | *(byte *)((int)register0x00000010 + -0x28);
            uVar6 = uVar6 << 1 & 0xff | (uint)*(byte *)((int)register0x00000010 + -0x28);
            if (uVar6 < 0x88) break;
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x41111c;
            FUN_0046edf0();
          }
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x411126;
          FUN_0046edf0();
          goto LAB_00411126;
        }
      }
      else {
        uVar6 = iVar10 - 0x379U >> 7;
        if (uVar6 < 0xf9) {
          bVar13 = s__________________________________005cc9a0[uVar6];
          goto LAB_00410e10;
        }
LAB_00411126:
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x411130;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x41113a;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar12 + -4) = 0x411140;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
  *(int *)((int)register0x00000010 + -8) = iVar7;
  *(int *)((int)register0x00000010 + -0x20) = iVar11;
  *(uint *)((int)register0x00000010 + -0xc) = uVar15;
  iVar7 = *(int *)(iVar11 + 0x1c + uVar6 * 4);
  puVar16 = *(undefined4 **)(iVar7 + 0x24);
  uVar6 = *(uint *)(iVar7 + 0x20);
  iVar10 = 0;
  if (uVar6 != 0) {
    for (; (uVar6 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
    }
  }
  if (uVar6 == 0) {
    iVar10 = 0;
    if (puVar16 != (undefined4 *)0x0) {
      for (; ((uint)puVar16 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
      }
    }
    if (puVar16 == (undefined4 *)0x0) {
      iVar10 = 0x20;
    }
    iVar10 = iVar10 + 0x20;
  }
  if (iVar10 < 0x40) {
    *(byte *)((int)register0x00000010 + -0x29) = bVar13;
    uVar14 = *(ushort *)(iVar7 + 0x18);
    uVar15 = iVar10 + (uint)uVar14;
    uVar3 = *(ushort *)(iVar7 + 0x1a);
    if ((ushort)uVar15 < uVar3) {
      *(int *)((int)register0x00000010 + -0x24) = iVar7;
      uVar2 = iVar10 + 1 + (uint)uVar14;
      uVar14 = (ushort)uVar2;
      if (((uVar2 & 0x3f) == 0) && (uVar3 != uVar14)) {
        iVar11 = *(int *)((int)register0x00000010 + -0x20);
        bVar13 = *(byte *)((int)register0x00000010 + -0x29);
        uVar15 = *(uint *)((int)register0x00000010 + -0xc);
        puVar8 = (undefined4 *)0x0;
      }
      else {
        *(ushort *)((int)register0x00000010 + -0x26) = uVar14;
        *(uint *)((int)register0x00000010 + -0x10) = uVar6;
        *(undefined4 **)((int)register0x00000010 + -0x14) = puVar16;
        uVar6 = iVar10 - 0x1f;
        *(uint *)((int)register0x00000010 + -0x18) = -uVar6;
        *(int *)((int)register0x00000010 + -0x1c) =
             *(int *)((int)register0x00000010 + -0x14) << ((byte)-uVar6 & 0x1f);
        uVar2 = *(uint *)((int)register0x00000010 + -0x14);
        bVar13 = (byte)(iVar10 + 1U);
        puVar16 = (undefined4 *)((uint)puVar16 >> ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20));
        uVar6 = -(uint)(iVar10 + 1U < 0x20);
        iVar7 = *(int *)((int)register0x00000010 + -0x24);
        *(uint *)(iVar7 + 0x20) =
             *(uint *)((int)register0x00000010 + -0x1c) &
             -(uint)(*(uint *)((int)register0x00000010 + -0x18) < 0x20) |
             *(uint *)((int)register0x00000010 + -0x10) >> (bVar13 & 0x1f) & uVar6 | (uint)puVar16;
        *(uint *)(iVar7 + 0x24) = uVar2 >> (bVar13 & 0x1f) & uVar6;
        *(undefined2 *)(iVar7 + 0x18) = *(undefined2 *)((int)register0x00000010 + -0x26);
        *(short *)(iVar7 + 0x3c) = *(short *)(iVar7 + 0x3c) + 1;
        puVar8 = (undefined4 *)((uVar15 & 0xffff) * *(int *)(iVar7 + 0x44) + *(int *)(iVar7 + 0xc));
        iVar11 = *(int *)((int)register0x00000010 + -0x20);
        uVar15 = *(uint *)((int)register0x00000010 + -0xc);
        bVar13 = *(byte *)((int)register0x00000010 + -0x29);
      }
      goto LAB_00410f5e;
    }
    iVar11 = *(int *)((int)register0x00000010 + -0x20);
    bVar13 = *(byte *)((int)register0x00000010 + -0x29);
    uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  }
  puVar8 = (undefined4 *)0x0;
LAB_00410f5e:
  if (puVar8 == (undefined4 *)0x0) {
    *(int *)((int)register0x00000010 + -0x40) = iVar11;
    *(byte *)((int)register0x00000010 + -0x3c) = bVar13;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410f74;
    FUN_004100b0();
    puVar8 = *(undefined4 **)((int)register0x00000010 + -0x38);
    iVar7 = *(int *)((int)register0x00000010 + -0x34);
    uVar9 = *(undefined1 *)((int)register0x00000010 + -0x30);
    iVar11 = *(int *)((int)register0x00000010 + -0x20);
    uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  }
  else {
    uVar9 = 0;
  }
  *(undefined1 *)((int)register0x00000010 + -0x27) = uVar9;
  *(int *)((int)register0x00000010 + -0x24) = iVar7;
  *(undefined4 **)((int)register0x00000010 + -4) = puVar8;
  if ((*(char *)((int)register0x00000010 + 0xc) != '\0') && (*(char *)(iVar7 + 0x40) != '\0')) {
    *(undefined4 **)((int)register0x00000010 + -0x40) = puVar8;
    *(uint *)((int)register0x00000010 + -0x3c) = uVar15;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410fb6;
    FUN_0046f470();
    iVar7 = *(int *)((int)register0x00000010 + -0x24);
    puVar8 = *(undefined4 **)((int)register0x00000010 + -4);
    iVar11 = *(int *)((int)register0x00000010 + -0x20);
  }
  if (DAT_005f5fd0 != 0) {
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410fdd;
    FUN_0046ed80();
    *puVar16 = *(undefined4 *)((int)register0x00000010 + 8);
    puVar16[1] = *puVar8;
  }
  *puVar8 = *(undefined4 *)((int)register0x00000010 + 8);
  *(int *)(iVar11 + 0xc) = *(int *)(iVar11 + 0xc) + *(int *)(iVar7 + 0x44);
  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x410ffc;
  FUN_0046ea00();
  iVar7 = *(int *)((int)register0x00000010 + -0x24);
  *(undefined2 *)(iVar7 + 0x1c) = *(undefined2 *)(iVar7 + 0x18);
  iVar11 = *(int *)((int)register0x00000010 + -4) + 8;
  *(int *)((int)register0x00000010 + -4) = iVar11;
  if ((char)DAT_005f5fd0 != '\0') {
    *(int *)((int)register0x00000010 + -0x40) = iVar7;
    *(int *)((int)register0x00000010 + -0x3c) = iVar11;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x41102a;
    FUN_00420a30();
    iVar11 = *(int *)((int)register0x00000010 + -4);
  }
  puVar4 = *(uint **)((int)register0x00000010 + -0x20);
  uVar6 = *puVar4;
  uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  *puVar4 = uVar6 - uVar15;
  uVar6 = puVar4[1] - (uint)(uVar6 < uVar15);
  puVar4[1] = uVar6;
  if (((int)uVar6 < 0) || (puVar4[2] != DAT_005cc27c)) {
    *(undefined4 *)((int)register0x00000010 + -0x40) = *(undefined4 *)((int)register0x00000010 + -8)
    ;
    *(int *)((int)register0x00000010 + -0x3c) = iVar11;
    *(uint *)((int)register0x00000010 + -0x38) = uVar15;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x411068;
    FUN_00411750();
    iVar11 = *(int *)((int)register0x00000010 + -4);
    uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  }
  iVar7 = *(int *)((int)register0x00000010 + -8);
  *(undefined4 *)(iVar7 + 0x6c) = 0;
  iVar10 = *(int *)(iVar7 + 0x7c);
  iVar5 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(int *)(iVar7 + 0x7c) = iVar10 + -1;
  if ((iVar10 == 1) && (*(char *)(iVar5 + 0x69) != '\0')) {
    *(undefined4 *)(iVar5 + 8) = 0xfffffade;
  }
  if (*(char *)((int)register0x00000010 + -0x27) != '\0') {
    *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4110d1;
    FUN_00418440();
    if (*(char *)((int)register0x00000010 + -0x30) != '\0') {
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4110fe;
      FUN_004185b0();
    }
    iVar11 = *(int *)((int)register0x00000010 + -4);
    uVar15 = *(uint *)((int)register0x00000010 + -0xc);
  }
  *(int *)((int)register0x00000010 + 0x10) = iVar11;
  *(uint *)((int)register0x00000010 + 0x14) = uVar15;
  return;
}



/* Function: FUN_00411150 */

void FUN_00411150(undefined4 param_1,int param_2,char param_3)

{
  int *piVar1;
  int iVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  uint *puVar7;
  uint uVar8;
  int *in_EDI;
  int in_FS_OFFSET;
  bool bVar9;
  int in_stack_ffffffdc;
  char local_20;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
  *piVar1 = *piVar1 + 1;
  iVar2 = *(int *)(iVar2 + 0x18);
  *(undefined4 *)(iVar2 + 0x6c) = 1;
  puVar7 = DAT_005f5e64;
  if (*(int *)(iVar2 + 0x58) != 0) {
    puVar7 = *(uint **)(*(int *)(iVar2 + 0x58) + 0x30);
  }
  if (param_2 == 0) {
    bVar9 = true;
  }
  else {
    bVar9 = *(int *)(param_2 + 4) == 0;
  }
  FUN_00413ee0(puVar7,param_1,bVar9);
  *(undefined2 *)(in_stack_ffffffdc + 0x18) = 1;
  *(undefined2 *)(in_stack_ffffffdc + 0x3c) = 1;
  if (DAT_005f5fd0 != 0) {
    iVar6 = *(int *)(in_stack_ffffffdc + 0x5c);
    FUN_0046ed70();
    *in_EDI = iVar6;
  }
  *(undefined4 *)(in_stack_ffffffdc + 0x5c) = 0;
  uVar3 = *(undefined4 *)(in_stack_ffffffdc + 0xc);
  uVar4 = *(uint *)(in_stack_ffffffdc + 0x44);
  FUN_0046ea00();
  *(undefined2 *)(in_stack_ffffffdc + 0x1c) = *(undefined2 *)(in_stack_ffffffdc + 0x18);
  if ((char)DAT_005f5fd0 != '\0') {
    FUN_00420a30(in_stack_ffffffdc,uVar3);
  }
  uVar8 = *puVar7;
  *puVar7 = uVar8 - uVar4;
  uVar8 = puVar7[1] - (uint)(uVar8 < uVar4);
  puVar7[1] = uVar8;
  if (((int)uVar8 < 0) || (puVar7[2] != DAT_005cc27c)) {
    FUN_00411750(iVar2,uVar3,uVar4);
  }
  *(undefined4 *)(iVar2 + 0x6c) = 0;
  iVar6 = *(int *)(iVar2 + 0x7c);
  iVar5 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(int *)(iVar2 + 0x7c) = iVar6 + -1;
  if ((iVar6 == 1) && (*(char *)(iVar5 + 0x69) != '\0')) {
    *(undefined4 *)(iVar5 + 8) = 0xfffffade;
  }
  FUN_00418440(0,0,0,0);
  if (local_20 != '\0') {
    FUN_004185b0(0,0,0,0);
  }
  if (param_2 == 0) {
    bVar9 = true;
  }
  else {
    bVar9 = *(int *)(param_2 + 4) == 0;
  }
  if ((!bVar9) || ((param_3 != '\0' && (*(char *)(in_stack_ffffffdc + 0x40) != '\0')))) {
    FUN_00411680(uVar4,uVar3);
    iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
    *piVar1 = *piVar1 + 1;
    iVar2 = *(int *)(iVar2 + 0x18);
    if (!bVar9) {
      puVar7 = DAT_005f5e64;
      if (*(int *)(iVar2 + 0x58) != 0) {
        puVar7 = *(uint **)(*(int *)(iVar2 + 0x58) + 0x30);
      }
      if (DAT_005f5fd0 != 0) {
        FUN_0046ed80();
        *in_EDI = param_2;
        in_EDI[1] = *(int *)(in_stack_ffffffdc + 0x5c);
      }
      *(int *)(in_stack_ffffffdc + 0x5c) = param_2;
      puVar7[3] = puVar7[3] + *(int *)(in_stack_ffffffdc + 0x44);
    }
    FUN_0046ea00();
    iVar6 = *(int *)(iVar2 + 0x7c);
    iVar5 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    *(int *)(iVar2 + 0x7c) = iVar6 + -1;
    if ((iVar6 == 1) && (*(char *)(iVar5 + 0x69) != '\0')) {
      *(undefined4 *)(iVar5 + 8) = 0xfffffade;
    }
  }
  return;
}



/* Function: FUN_00411420 */

void FUN_00411420(uint param_1,int param_2)

{
  undefined4 uVar1;
  int in_FS_OFFSET;
  bool bVar2;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (DAT_005f626c != 0) {
    if (param_2 == 0) {
      uVar1 = 0x10;
    }
    else if ((param_1 & 7) == 0) {
      uVar1 = 8;
    }
    else if ((param_1 & 3) == 0) {
      uVar1 = 4;
    }
    else if ((param_1 & 1) == 0) {
      uVar1 = 2;
    }
    else {
      uVar1 = 1;
    }
    FUN_004119f0(param_1,uVar1,&DAT_005f84f8);
    return;
  }
  if ((DAT_005f6080 != '\0') &&
     (DAT_005f6088 == *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x58) &&
      DAT_005f6084 == *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x54))) {
    bVar2 = 0xfffffffe < DAT_005f608c;
    DAT_005f608c = DAT_005f608c + 1;
    DAT_005f6090 = DAT_005f6090 + (uint)bVar2;
  }
  return;
}



/* Function: FUN_00411520 */

void FUN_00411520(undefined4 param_1,uint param_2,undefined4 param_3)

{
  int in_FS_OFFSET;
  bool bVar1;
  undefined4 in_stack_ffffffe8;
  int in_stack_ffffffec;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if ((DAT_005f6080 != '\0') &&
     (DAT_005f6088 == *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x58) &&
      *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x54) == DAT_005f6084)) {
    bVar1 = CARRY4(DAT_005f6094,param_2);
    DAT_005f6094 = DAT_005f6094 + param_2;
    DAT_005f6098 = DAT_005f6098 + (uint)bVar1;
  }
  if (DAT_005d7d31 != '\0') {
    if (DAT_005d7d30 == '\0') {
      in_stack_ffffffec = 0;
      in_stack_ffffffe8 = 0;
    }
    else {
      FUN_0045e520();
    }
    if (in_stack_ffffffec != 0) {
      FUN_00458780(in_stack_ffffffe8,in_stack_ffffffec,param_1,param_3,in_stack_ffffffec,
                   in_stack_ffffffe8);
      FUN_0045e630(in_stack_ffffffe8,in_stack_ffffffec);
    }
  }
  return;
}



/* Function: FUN_00411610 */

void FUN_00411610(uint param_1)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar2 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x50);
  if (iVar2 == 0) {
    iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  }
  uVar1 = *(uint *)(iVar2 + 0x110);
  *(uint *)(iVar2 + 0x110) = uVar1 - param_1;
  iVar3 = *(int *)(iVar2 + 0x114) - (uint)(uVar1 < param_1);
  *(int *)(iVar2 + 0x114) = iVar3;
  if (iVar3 < 0) {
    FUN_0041db60(iVar2);
  }
  return;
}



/* Function: FUN_00411680 */

void FUN_00411680(int param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar1 = param_1 + param_2;
  for (; param_2 < uVar1; param_2 = param_2 + 0x40000) {
    if (*(char *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x69) != '\0') {
      FUN_0046d830(&PTR_LAB_00536b18);
    }
    uVar2 = uVar1 - param_2;
    if (0x40000 < uVar2) {
      uVar2 = 0x40000;
    }
    FUN_0046f470(param_2,uVar2);
  }
  return;
}



/* Function: FUN_00411710 */

void FUN_00411710(undefined4 *param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00468370(*param_1,param_1,1);
  return;
}



/* Function: FUN_00411750 */

void FUN_00411750(void)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x10);
      iVar1 = *(int *)((int)register0x00000010 + 4);
      piVar2 = DAT_005f5e64;
      if (*(int *)(iVar1 + 0x58) != 0) {
        piVar2 = *(int **)(*(int *)(iVar1 + 0x58) + 0x30);
      }
      if (piVar2 != (int *)0x0) {
        piVar2[2] = DAT_005cc27c;
        if (DAT_005cc27c == 0) {
          iVar3 = 0x7fffffff;
          iVar4 = -1;
        }
        else if (DAT_005cc27c == 1) {
          iVar3 = 0;
          iVar4 = 0;
        }
        else {
          *(int **)((int)register0x00000010 + -4) = piVar2;
          *(int *)((int)register0x00000010 + -0x10) = DAT_005cc27c;
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4117b7;
          FUN_00411810();
          iVar4 = *(int *)((int)register0x00000010 + -0xc);
          iVar3 = iVar4 >> 0x1f;
          iVar1 = *(int *)((int)register0x00000010 + 4);
          piVar2 = *(int **)((int)register0x00000010 + -4);
        }
        *piVar2 = iVar4;
        piVar2[1] = iVar3;
        *(int *)((int)register0x00000010 + -0x10) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -8) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4117e9;
        FUN_00431440();
        return;
      }
      *(char **)((int)register0x00000010 + -0x10) =
           "profilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to m..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x38;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x411803;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x411809;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00411810 */

void FUN_00411810(void)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  double dVar7;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x38);
      iVar2 = *(int *)((int)register0x00000010 + 4);
      if (iVar2 < 0x7000001) {
        if (iVar2 == 0) {
          *(undefined4 *)((int)register0x00000010 + 8) = 0;
          return;
        }
      }
      else {
        iVar2 = 0x7000000;
      }
      *(int *)((int)register0x00000010 + -4) = iVar2;
      iVar2 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
      uVar1 = *(uint *)(iVar2 + 0x45c);
      uVar3 = *(uint *)(iVar2 + 0x458) << 0x11 ^ *(uint *)(iVar2 + 0x458);
      uVar3 = uVar1 >> 0x10 ^ uVar3 >> 7 ^ uVar1 ^ uVar3;
      *(uint *)(iVar2 + 0x458) = uVar1;
      *(uint *)(iVar2 + 0x45c) = uVar3;
      *(uint *)((int)register0x00000010 + -0x38) = (uVar3 + uVar1 >> 6) + 1;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x411891;
      FUN_0046ed20();
      *(undefined8 *)((int)register0x00000010 + -0x14) =
           *(undefined8 *)((int)register0x00000010 + -0x34);
      uVar1 = *(uint *)((int)register0x00000010 + -0x10);
      uVar3 = uVar1 >> 0x14 & 0x7ff;
      uVar4 = uVar1 >> 0xf & 0x1f;
      uVar5 = uVar4 + 1;
      if (uVar4 != 0xffffffff) {
        if (uVar5 < 0x21) {
          *(undefined8 *)((int)register0x00000010 + -0x24) =
               *(undefined8 *)(&DAT_005ccba0 + (uVar1 >> 0xc & 0xf8));
          *(uint *)((int)register0x00000010 + -0x28) =
               *(uint *)((int)register0x00000010 + -0x14) >> 0x1b | (uVar1 & 0x7fff) << 5;
          *(undefined8 *)((int)register0x00000010 + -0x1c) =
               *(undefined8 *)(&DAT_005ccba0 + uVar5 * 8);
          *(uint *)((int)register0x00000010 + -0x38) = uVar3 - 0x3ff;
          *(uint *)((int)register0x00000010 + -0x34) = (0x3fe < uVar3) - 1;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41192f;
          FUN_00464a40();
          *(undefined8 *)((int)register0x00000010 + -0xc) =
               *(undefined8 *)((int)register0x00000010 + -0x30);
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + -0x28);
          *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41194f;
          FUN_00464b10();
          dVar7 = (*(double *)((int)register0x00000010 + -0xc) +
                   *(double *)((int)register0x00000010 + -0x24) +
                  DAT_00550c30 *
                  *(double *)((int)register0x00000010 + -0x30) *
                  (*(double *)((int)register0x00000010 + -0x1c) -
                  *(double *)((int)register0x00000010 + -0x24))) - DAT_00550c90;
          if (0.0 < dVar7) {
            dVar7 = 0.0;
          }
          *(int *)((int)register0x00000010 + 8) =
               (int)(dVar7 * (double)*(int *)((int)register0x00000010 + -4) * DAT_00550cd0) + 1;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4119d8;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4119e4;
      FUN_0046ee90();
    }
    *(undefined4 *)(puVar6 + -4) = 0x4119ea;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_004119f0 */

void FUN_004119f0(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  undefined4 local_18;
  undefined1 *local_14;
  undefined4 *local_10;
  undefined4 local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  local_18 = 0;
  local_14 = &LAB_00411a40;
  local_10 = &local_18;
  local_c = param_1;
  local_8 = param_2;
  local_4 = param_3;
  FUN_0046d890(&local_14);
  return;
}



/* Function: FUN_00411a90 */

void FUN_00411a90(void)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  int *piVar7;
  undefined1 *puVar8;
  uint uVar9;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x28);
      uVar4 = *(uint *)((int)register0x00000010 + 4);
      if (uVar4 != 0) {
        uVar9 = *(uint *)((int)register0x00000010 + 8);
        if (uVar9 == 0) {
          uVar9 = 8;
LAB_00411ad8:
          if (0xffff < uVar4) {
            *(uint *)((int)register0x00000010 + -0x28) = uVar4;
            *(undefined4 *)((int)register0x00000010 + -0x24) =
                 *(undefined4 *)((int)register0x00000010 + 0xc);
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411b9b;
            FUN_00414d10();
            *(undefined4 *)((int)register0x00000010 + 0x10) =
                 *(undefined4 *)((int)register0x00000010 + -0x20);
            return;
          }
          *(uint *)((int)register0x00000010 + -0x18) = uVar9;
          iVar6 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
          piVar7 = (int *)(*(int *)(iVar6 + 0x18) + 0x7c);
          *piVar7 = *piVar7 + 1;
          iVar6 = *(int *)(iVar6 + 0x18);
          *(int *)((int)register0x00000010 + -0x10) = iVar6;
          if ((iVar6 == 0) || (*(int *)(iVar6 + 0x58) == 0)) {
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f5f90;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411b25;
            FUN_0040ecf0();
            uVar4 = *(uint *)((int)register0x00000010 + 4);
            uVar9 = *(uint *)((int)register0x00000010 + -0x18);
            iVar6 = *(int *)((int)register0x00000010 + -0x10);
            piVar7 = &DAT_005f5f94;
          }
          else {
            piVar7 = (int *)(*(int *)(iVar6 + 0x58) + 0x940);
          }
          *(int **)((int)register0x00000010 + -0xc) = piVar7;
          iVar1 = piVar7[1];
          *(uint *)((int)register0x00000010 + -0x14) = -uVar9;
          uVar9 = (uVar9 - 1) + iVar1 & -uVar9;
          piVar7[1] = uVar9;
          if ((0x40000 < uVar4 + uVar9) || (*piVar7 == 0)) {
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0x40000;
            *(undefined **)((int)register0x00000010 + -0x24) = &DAT_005f84f8;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411b78;
            FUN_00414d10();
            iVar6 = *(int *)((int)register0x00000010 + -0x20);
            piVar7 = *(int **)((int)register0x00000010 + -0xc);
            *piVar7 = iVar6;
            if (iVar6 == 0) {
              if (piVar7 == &DAT_005f5f94) goto code_r0x00411ccc;
              do {
                *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004ca41d;
                *(undefined4 *)((int)register0x00000010 + -0x24) = 0x1f;
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411cca;
                FUN_00469a20();
code_r0x00411ccc:
                *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f5f90;
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411cda;
                FUN_0040f0e0();
              } while( true );
            }
            while( true ) {
              uVar3 = DAT_005f5dec;
              *(undefined4 *)*piVar7 = DAT_005f5dec;
              iVar6 = *piVar7;
              *(int *)((int)register0x00000010 + -4) = iVar6;
              *(undefined4 **)((int)register0x00000010 + -0x28) = &DAT_005f5dec;
              *(undefined4 *)((int)register0x00000010 + -0x24) = uVar3;
              *(int *)((int)register0x00000010 + -0x20) = iVar6;
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411bd1;
              thunk_FUN_00402540();
              if (*(char *)((int)register0x00000010 + -0x1c) != '\0') break;
              piVar7 = *(int **)((int)register0x00000010 + -0xc);
            }
            piVar7 = *(int **)((int)register0x00000010 + -0xc);
            piVar7[1] = *(int *)((int)register0x00000010 + -0x18) + 3U &
                        *(uint *)((int)register0x00000010 + -0x14);
            uVar4 = *(uint *)((int)register0x00000010 + 4);
            iVar6 = *(int *)((int)register0x00000010 + -0x10);
          }
          iVar5 = piVar7[1];
          piVar7[1] = uVar4 + iVar5;
          iVar1 = *(int *)(iVar6 + 0x7c);
          iVar5 = *piVar7 + iVar5;
          iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
          *(int *)(iVar6 + 0x7c) = iVar1 + -1;
          if ((iVar1 == 1) && (*(char *)(iVar2 + 0x69) != '\0')) {
            *(undefined4 *)(iVar2 + 8) = 0xfffffade;
          }
          *(int *)((int)register0x00000010 + -8) = iVar5;
          if (piVar7 == &DAT_005f5f94) {
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f5f90;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411c4e;
            FUN_0040f0e0();
            uVar4 = *(uint *)((int)register0x00000010 + 4);
            iVar5 = *(int *)((int)register0x00000010 + -8);
          }
          if (*(undefined **)((int)register0x00000010 + 0xc) != &DAT_005f84f8) {
            *(undefined **)((int)register0x00000010 + -0x28) =
                 *(undefined **)((int)register0x00000010 + 0xc);
            *(uint *)((int)register0x00000010 + -0x24) = uVar4;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411c78;
            FUN_00433860();
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f84f8;
            *(int *)((int)register0x00000010 + -0x24) = -*(int *)((int)register0x00000010 + 4);
            *(uint *)((int)register0x00000010 + -0x20) =
                 -(uint)(*(int *)((int)register0x00000010 + 4) != 0);
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411c9e;
            FUN_00433860();
            iVar5 = *(int *)((int)register0x00000010 + -8);
          }
          *(int *)((int)register0x00000010 + 0x10) = iVar5;
          return;
        }
        if ((uVar9 & uVar9 - 1) == 0) {
          if (uVar9 < 0x2001) goto LAB_00411ad8;
          *(char **)((int)register0x00000010 + -0x28) =
               "persistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] wi..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x23;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411cf2;
          FUN_00469a20();
        }
        *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004cc25e;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x2a;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411d08;
        FUN_00469a20();
      }
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c8be4;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x1a;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x411d1e;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x411d24;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_00411d30 */

void FUN_00411d30(uint *param_1,int param_2,int param_3,undefined4 param_4)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar1 = param_3 + -1 + *param_1 & -param_3;
  uVar2 = param_2 + uVar1;
  if (uVar2 <= param_1[2]) {
    *param_1 = uVar2;
    uVar2 = (uVar2 - 2) + DAT_005f5de0 & -DAT_005f5de0;
    if (param_1[1] < uVar2) {
      if ((char)param_1[3] != '\0') {
        iVar3 = uVar2 - param_1[1];
        FUN_00433860(param_4,iVar3,0,uVar2,uVar1,iVar3);
        FUN_00414df0(param_1[1],iVar3,iVar3);
      }
      param_1[1] = uVar2;
    }
    return;
  }
  return;
}



/* Function: FUN_00411e00 */

void FUN_00411e00(int param_1,undefined4 param_2)

{
  FUN_00412520(param_2,0,*(undefined4 *)(param_1 + 4),param_1);
  return;
}



/* Function: FUN_00411e30 */

void FUN_00411e30(int param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_00412520(param_2,param_3,*(undefined4 *)(param_1 + 4),param_1);
  return;
}



/* Function: FUN_00411e60 */

void FUN_00411e60(int param_1,undefined4 param_2,undefined4 param_3,uint param_4)

{
  if (((((char)DAT_005f5fd0 != '\0') && (param_1 != 0)) && (*(int *)(param_1 + 4) != 0)) &&
     (3 < param_4)) {
    FUN_00412520(param_2,param_3,param_4,0);
  }
  FUN_0046f640(param_2,param_3,param_4);
  return;
}



/* Function: FUN_00411ee0 */

void FUN_00411ee0(undefined4 *param_1,undefined4 param_2)

{
  if (((char)DAT_005f5fd0 != '\0') && (param_1[1] != 0)) {
    FUN_00412520(param_2,0,param_1[1],param_1);
  }
  FUN_0046f470(param_2,*param_1);
  return;
}



/* Function: FUN_00411f40 */

void FUN_00411f40(int param_1,int param_2,int param_3)

{
  int iVar1;
  undefined4 in_stack_ffffffdc;
  int in_stack_ffffffe0;
  undefined4 in_stack_ffffffe4;
  undefined4 in_stack_ffffffe8;
  
  iVar1 = (int)((ulong)(uint)(param_2 - *(int *)(param_1 + 0xc)) * (ulong)*(uint *)(param_1 + 0x38)
               >> 0x20) * *(int *)(param_1 + 0x44) + *(int *)(param_1 + 0xc);
  FUN_00412000(param_1,iVar1);
  if ((param_2 == iVar1) && (*(int *)(param_1 + 0x44) == param_3)) {
    return;
  }
  FUN_004122e0(in_stack_ffffffdc,in_stack_ffffffe0,in_stack_ffffffe4,in_stack_ffffffe8,
               param_2 - in_stack_ffffffe0,param_3 + param_2);
  return;
}



/* Function: FUN_00412000 */

void FUN_00412000(int param_1,int *param_2)

{
  int iVar1;
  
  if ((*(byte *)(param_1 + 0x3e) & 1) != 0) {
    return;
  }
  if (*(uint *)(param_1 + 0x44) < 0x81) {
    FUN_00412b40(param_1,param_2);
    return;
  }
  if (*(byte *)(param_1 + 0x3e) >> 1 == 0) {
    iVar1 = *(int *)(param_1 + 0x5c);
    if (iVar1 == 0) {
      return;
    }
  }
  else {
    iVar1 = *param_2;
  }
  if ((*(byte *)(iVar1 + 0xc) & 0x10) != 0) {
    FUN_00462630(iVar1);
  }
  return;
}



/* Function: FUN_00412100 */

void FUN_00412100(int param_1,int param_2)

{
  if ((*(byte *)(param_1 + 0x3e) & 1) != 0) {
    return;
  }
  if ((*(byte *)(param_2 + 0xc) & 0x10) != 0) {
    FUN_00462630(param_2);
  }
  return;
}



/* Function: FUN_00412170 */

void FUN_00412170(uint param_1,uint param_2,uint param_3,int *param_4,uint param_5)

{
  int iVar1;
  uint uVar2;
  int local_c;
  
  while( true ) {
    if (param_3 != 0) {
      iVar1 = 0;
      if (param_3 != 0) {
        for (; (param_3 >> iVar1 & 1) == 0; iVar1 = iVar1 + 1) {
        }
      }
      return;
    }
    if (param_4 == (int *)0x0) break;
    param_2 = param_2 + 0x80;
    if (param_4[1] + param_1 <= param_2) {
      param_1 = param_1 + *param_4;
      param_2 = param_1;
    }
    if (param_5 <= param_2) {
      return;
    }
    if ((*(byte *)(param_4 + 3) & 0x10) == 0) {
      iVar1 = param_4[5];
    }
    else {
      FUN_00462630(param_4);
      iVar1 = local_c;
    }
    param_3 = *(uint *)(iVar1 + (param_2 - param_1 >> 5));
    if (param_5 < param_2 + 0x80) {
      uVar2 = (param_2 - param_5) + 0x80 >> 2;
      param_3 = param_3 & ~((1 << ((byte)uVar2 & 0x1f) & -(uint)(uVar2 < 0x20)) - 1 <<
                            ((byte)-(uVar2 - 0x20) & 0x1f) & -(uint)(-(uVar2 - 0x20) < 0x20));
    }
  }
  return;
}



/* Function: FUN_004122e0 */

void FUN_004122e0(int param_1,int param_2,undefined4 param_3,uint *param_4,uint param_5,uint param_6
                 )

{
  uint uVar1;
  code *pcVar2;
  int iVar3;
  
  if (param_6 <= param_2 + param_5) {
    return;
  }
  if (param_4 != (uint *)0x0) {
    uVar1 = *param_4;
    if (param_5 < uVar1) {
      param_2 = param_2 + (param_5 & 0xffffff80);
    }
    else {
      if (uVar1 == 0) {
        FUN_00438080();
        pcVar2 = (code *)swi(3);
        (*pcVar2)();
        return;
      }
      iVar3 = (((param_2 - param_1) + param_5) / uVar1) * uVar1;
      param_1 = param_1 + iVar3;
      param_2 = param_1 + (param_5 - iVar3 & 0xffffff80);
    }
    if ((uint)(param_2 - param_1) < param_4[1]) {
      if ((param_4[3] & 0x10) != 0) {
        FUN_00462630(param_4);
      }
    }
    else {
      if ((param_4[3] & 0x10) != 0) {
        FUN_00462630(param_4);
      }
      if (param_6 <= param_1 + uVar1) {
        return;
      }
    }
    return;
  }
  return;
}



/* Function: FUN_00412520 */

void FUN_00412520(uint param_1,uint param_2,uint param_3,int param_4)

{
  undefined4 *puVar1;
  int iVar2;
  code *pcVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  int iVar7;
  undefined4 uVar8;
  int in_FS_OFFSET;
  int *in_stack_ffffffb8;
  undefined4 in_stack_ffffffc0;
  undefined4 in_stack_ffffffc4;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 *local_28;
  
  if (((param_2 | param_1 | param_3) & 3) != 0) {
    FUN_00469a20(&DAT_004cbdf0,0x28);
    pcVar3 = (code *)swi(3);
    (*pcVar3)();
    return;
  }
  if ((char)DAT_005f5fd0 == '\0') {
    return;
  }
  iVar5 = *(int *)(DAT_005ddf14 + (param_1 >> 0x16) * 4);
  if (iVar5 == 0) {
    iVar5 = 0;
  }
  else {
    iVar5 = *(int *)(iVar5 + (param_1 >> 0xb & 0x7fc));
  }
  if (iVar5 != 0) {
    FUN_00402470(iVar5 + 0x3f);
    if ((((char)in_stack_ffffffb8 == '\x01') && (*(uint *)(iVar5 + 0xc) <= param_1)) &&
       (param_1 < *(uint *)(iVar5 + 0x48))) {
      iVar4 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
      if (param_4 == 0) {
        FUN_00411f40(iVar5,param_1,param_3);
      }
      else {
        FUN_00412100(iVar5,param_4,param_1);
      }
      uVar6 = local_38;
      uVar8 = local_34;
      if (param_2 == 0) {
        while (FUN_00412170(in_stack_ffffffc0,in_stack_ffffffc4,uVar6,uVar8,param_1 + param_3),
              local_28 != (undefined4 *)0x0) {
          if (*(uint *)(iVar4 + 0x98c) < *(int *)(iVar4 + 0x988) + 4U) {
            FUN_00433e10();
          }
          puVar1 = *(undefined4 **)(iVar4 + 0x988);
          *(undefined4 **)(iVar4 + 0x988) = puVar1 + 1;
          *puVar1 = *local_28;
          in_stack_ffffffc0 = local_38;
          in_stack_ffffffc4 = local_34;
          uVar6 = local_30;
          uVar8 = local_2c;
        }
      }
      else {
        while (FUN_00412170(in_stack_ffffffc0,in_stack_ffffffc4,uVar6,uVar8,param_1 + param_3),
              local_28 != (undefined4 *)0x0) {
          if (*(uint *)(iVar4 + 0x98c) < *(int *)(iVar4 + 0x988) + 8U) {
            FUN_00433e10();
          }
          puVar1 = *(undefined4 **)(iVar4 + 0x988);
          *(undefined4 **)(iVar4 + 0x988) = puVar1 + 2;
          *puVar1 = *local_28;
          puVar1[1] = *(undefined4 *)((int)local_28 + (param_2 - param_1));
          in_stack_ffffffc0 = local_38;
          in_stack_ffffffc4 = local_34;
          uVar6 = local_30;
          uVar8 = local_2c;
        }
      }
      return;
    }
    return;
  }
  FUN_00402520(&DAT_005d6e1c);
  if (in_stack_ffffffb8 == (int *)0x0) {
    iVar4 = 0;
    iVar5 = 0;
  }
  else {
    iVar5 = *in_stack_ffffffb8;
    iVar4 = in_stack_ffffffb8[1];
  }
  iVar7 = 0;
  while( true ) {
    if (iVar4 <= iVar7) {
      FUN_00402520(&DAT_005d6e1c);
      if (in_stack_ffffffb8 == (int *)0x0) {
        iVar4 = 0;
        iVar5 = 0;
      }
      else {
        iVar5 = *in_stack_ffffffb8;
        iVar4 = in_stack_ffffffb8[1];
      }
      iVar7 = 0;
      while( true ) {
        if (iVar4 <= iVar7) {
          return;
        }
        iVar2 = *(int *)(iVar5 + iVar7 * 4);
        if ((*(uint *)(iVar2 + 0x70) <= param_1) && (param_1 < *(uint *)(iVar2 + 0x74))) break;
        iVar7 = iVar7 + 1;
      }
      FUN_004131e0(param_1,param_2,param_3,param_1 - *(uint *)(iVar2 + 0x70),
                   *(undefined4 *)(iVar2 + 0x118));
      return;
    }
    iVar2 = *(int *)(iVar5 + iVar7 * 4);
    if ((*(uint *)(iVar2 + 0x68) <= param_1) && (param_1 < *(uint *)(iVar2 + 0x6c))) break;
    iVar7 = iVar7 + 1;
  }
  FUN_004131e0(param_1,param_2,param_3,param_1 - *(uint *)(iVar2 + 0x68),
               *(undefined4 *)(iVar2 + 0x110));
  return;
}



/* Function: FUN_00412890 */

void FUN_00412890(uint param_1,uint param_2,uint param_3,int param_4)

{
  int iVar1;
  int iVar2;
  undefined4 *puVar3;
  code *pcVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  int in_FS_OFFSET;
  undefined4 in_stack_ffffffc8;
  undefined4 in_stack_ffffffcc;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  if (((param_2 | param_1 | param_3) & 3) != 0) {
    FUN_00469a20(&DAT_004cbdf0,0x28);
    pcVar4 = (code *)swi(3);
    (*pcVar4)();
    return;
  }
  if ((char)DAT_005f5fd0 != '\0') {
    iVar1 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
    iVar2 = *(int *)(DAT_005ddf14 + (param_1 >> 0x16) * 4);
    if (iVar2 == 0) {
      uVar5 = 0;
    }
    else {
      uVar5 = *(undefined4 *)(iVar2 + (param_1 >> 0xb & 0x7fc));
    }
    uVar6 = local_30;
    uVar7 = local_2c;
    if (param_4 == 0) {
      FUN_00411f40(uVar5,param_1,param_3);
    }
    else {
      FUN_00412100(uVar5,param_4,param_1);
    }
    while( true ) {
      FUN_00412170(in_stack_ffffffc8,in_stack_ffffffcc,uVar6,uVar7,param_1 + param_3);
      if (local_20 == 0) break;
      if (*(uint *)(iVar1 + 0x98c) < *(int *)(iVar1 + 0x988) + 4U) {
        FUN_00433e10();
      }
      puVar3 = *(undefined4 **)(iVar1 + 0x988);
      *(undefined4 **)(iVar1 + 0x988) = puVar3 + 1;
      *puVar3 = *(undefined4 *)((local_20 - param_1) + param_2);
      in_stack_ffffffc8 = local_30;
      in_stack_ffffffcc = local_2c;
      uVar6 = local_28;
      uVar7 = local_24;
    }
    return;
  }
  return;
}



/* Function: FUN_00412a30 */

void FUN_00412a30(int param_1)

{
  int in_FS_OFFSET;
  undefined4 in_stack_fffffff4;
  undefined4 local_8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if ((((*(byte *)(param_1 + 0x3e) & 1) == 0) && (*(uint *)(param_1 + 0x44) < 0x81)) ||
     (*(char *)(param_1 + 0x41) != '\0')) {
    FUN_00412a90(param_1);
    if (local_8 != 0) {
      FUN_0046f470(in_stack_fffffff4,local_8 << 2);
    }
  }
  return;
}



/* Function: FUN_00412a90 */

void FUN_00412a90(int param_1)

{
  if (*(int *)(param_1 + 0x10) == 1) {
    return;
  }
  return;
}



/* Function: FUN_00412b40 */

void FUN_00412b40(void)

{
  return;
}



/* Function: FUN_00412bd0 */

void FUN_00412bd0(int param_1,int param_2,uint param_3,uint *param_4)

{
  uint *puVar1;
  uint *puVar2;
  int iVar3;
  byte bVar4;
  byte bVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint *local_20;
  
  if ((param_4[3] & 0x10) == 0) {
    local_20 = (uint *)param_4[5];
  }
  else {
    FUN_00462630(param_4);
  }
  uVar6 = *param_4;
  if (uVar6 == 4) {
    uVar7 = (1 << ((byte)(param_3 >> 2) & 0x1f) & -(uint)(param_3 >> 2 < 0x20)) - 1;
  }
  else {
    uVar7 = *local_20;
    for (uVar8 = uVar6; uVar8 < param_3; uVar8 = uVar8 + uVar6) {
      uVar7 = uVar7 | *local_20 << ((byte)(uVar8 >> 2) & 0x1f) & -(uint)(uVar8 >> 2 < 0x20);
    }
  }
  uVar6 = *(uint *)(param_1 + 0x44) >> 2;
  iVar3 = *(int *)(param_1 + 0xc);
  uVar8 = (uint)(param_2 - iVar3) >> 2;
  uVar9 = uVar8 & 0x1f;
  uVar10 = (uint)(param_2 - iVar3) >> 7;
  bVar4 = (byte)uVar8;
  if (uVar9 + uVar6 < 0x21) {
    puVar1 = (uint *)(iVar3 + 0x1f00 + uVar10 * 4);
    *puVar1 = ~((1 << ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20)) - 1 << (bVar4 & 0x1f)) & *puVar1
              | uVar7 << (bVar4 & 0x1f);
  }
  else {
    uVar6 = (uVar6 - 0x20) + uVar9;
    bVar5 = (byte)-(uVar9 - 0x20);
    puVar1 = (uint *)(iVar3 + 0x1f00 + uVar10 * 4);
    puVar2 = (uint *)(iVar3 + 0x1f04 + uVar10 * 4);
    uVar8 = -(uint)(-(uVar9 - 0x20) < 0x20);
    *puVar1 = 0xffffffffU >> (bVar5 & 0x1f) & uVar8 & *puVar1 | uVar7 << (bVar4 & 0x1f);
    *puVar2 = -(1 << ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20)) & *puVar2 |
              uVar7 >> (bVar5 & 0x1f) & uVar8;
  }
  return;
}



/* Function: FUN_00412d40 */

void FUN_00412d40(int param_1,ushort param_2)

{
  undefined1 uVar1;
  undefined1 uVar2;
  undefined1 uVar3;
  undefined1 uVar4;
  int iVar5;
  uint uVar6;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar5 = *(int *)(param_1 + 0x28);
  uVar6 = (uint)param_2;
  uVar1 = *(undefined1 *)(iVar5 + 4 + uVar6);
  uVar2 = *(undefined1 *)(iVar5 + 5 + uVar6);
  uVar3 = *(undefined1 *)(iVar5 + 6 + uVar6);
  uVar4 = *(undefined1 *)(iVar5 + 7 + uVar6);
  *(uint *)(param_1 + 0x20) =
       ~CONCAT13(*(undefined1 *)(iVar5 + 3 + uVar6),
                 CONCAT12(*(undefined1 *)(iVar5 + 2 + uVar6),
                          CONCAT11(*(undefined1 *)(iVar5 + 1 + uVar6),*(undefined1 *)(iVar5 + uVar6)
                                  )));
  *(uint *)(param_1 + 0x24) = ~CONCAT13(uVar4,CONCAT12(uVar3,CONCAT11(uVar2,uVar1)));
  return;
}



/* Function: FUN_00412dd0 */

void FUN_00412dd0(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  byte bVar5;
  ushort uVar6;
  ushort uVar7;
  undefined1 *puVar8;
  ushort uVar9;
  int iVar10;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x24);
      iVar4 = *(int *)((int)register0x00000010 + 4);
      uVar6 = *(ushort *)(iVar4 + 0x18);
      uVar7 = *(ushort *)(iVar4 + 0x1a);
      if (uVar7 == uVar6) {
        *(ushort *)((int)register0x00000010 + 8) = uVar6;
        return;
      }
      if (uVar6 <= uVar7) {
        *(ushort *)((int)register0x00000010 + -0x1a) = uVar7;
        uVar1 = *(uint *)(iVar4 + 0x20);
        uVar2 = *(uint *)(iVar4 + 0x24);
        iVar10 = 0;
        if (uVar1 != 0) {
          for (; (uVar1 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
          }
        }
        if (uVar1 == 0) {
          iVar10 = 0;
          if (uVar2 != 0) {
            for (; (uVar2 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
            }
          }
          if (uVar2 == 0) {
            iVar10 = 0x20;
          }
          iVar10 = iVar10 + 0x20;
        }
        while( true ) {
          if (iVar10 != 0x40) {
            uVar9 = uVar6 + (short)iVar10;
            if (uVar7 <= uVar9) {
              *(ushort *)(iVar4 + 0x18) = uVar7;
              *(ushort *)((int)register0x00000010 + 8) = uVar7;
              return;
            }
            *(ushort *)((int)register0x00000010 + -0x16) = uVar9;
            uVar1 = *(uint *)(iVar4 + 0x24);
            *(uint *)((int)register0x00000010 + -4) = uVar1;
            *(undefined4 *)((int)register0x00000010 + -8) = *(undefined4 *)(iVar4 + 0x20);
            iVar4 = iVar10 + -0x1f;
            *(int *)((int)register0x00000010 + -0xc) = iVar4;
            *(uint *)((int)register0x00000010 + -0x10) = uVar1 >> ((byte)iVar4 & 0x1f);
            *(int *)((int)register0x00000010 + -0x14) = -iVar4;
            bVar5 = (byte)(iVar10 + 1U);
            uVar2 = *(uint *)((int)register0x00000010 + -4);
            uVar1 = uVar6 + 1 + iVar10;
            uVar7 = (ushort)uVar1;
            uVar3 = -(uint)(iVar10 + 1U < 0x20);
            iVar10 = *(int *)((int)register0x00000010 + 4);
            *(uint *)(iVar10 + 0x20) =
                 *(int *)((int)register0x00000010 + -4) << ((byte)-iVar4 & 0x1f) &
                 -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20) |
                 *(uint *)((int)register0x00000010 + -8) >> (bVar5 & 0x1f) & uVar3 |
                 *(uint *)((int)register0x00000010 + -0x10) &
                 -(uint)(*(uint *)((int)register0x00000010 + -0xc) < 0x20);
            *(uint *)(iVar10 + 0x24) = uVar2 >> (bVar5 & 0x1f) & uVar3;
            if (((uVar1 & 0x3f) == 0) && (*(ushort *)((int)register0x00000010 + -0x1a) != uVar7)) {
              *(ushort *)((int)register0x00000010 + -0x18) = uVar7;
              *(int *)((int)register0x00000010 + -0x24) = iVar10;
              *(ushort *)((int)register0x00000010 + -0x20) = uVar7 >> 3;
              *(undefined4 *)((int)register0x00000010 + -0x28) = 0x412f28;
              FUN_00412d40();
              iVar10 = *(int *)((int)register0x00000010 + 4);
              uVar7 = *(ushort *)((int)register0x00000010 + -0x18);
            }
            *(ushort *)(iVar10 + 0x18) = uVar7;
            *(undefined2 *)((int)register0x00000010 + 8) =
                 *(undefined2 *)((int)register0x00000010 + -0x16);
            return;
          }
          uVar6 = uVar6 + 0x40 & 0xffc0;
          if (uVar7 <= uVar6) break;
          *(ushort *)((int)register0x00000010 + -0x18) = uVar6;
          *(int *)((int)register0x00000010 + -0x24) = iVar4;
          *(ushort *)((int)register0x00000010 + -0x20) = uVar6 >> 3;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x412e3c;
          FUN_00412d40();
          iVar4 = *(int *)((int)register0x00000010 + 4);
          uVar1 = *(uint *)(iVar4 + 0x20);
          uVar2 = *(uint *)(iVar4 + 0x24);
          iVar10 = 0;
          if (uVar1 != 0) {
            for (; (uVar1 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
            }
          }
          if (uVar1 == 0) {
            iVar10 = 0;
            if (uVar2 != 0) {
              for (; (uVar2 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
              }
            }
            if (uVar2 == 0) {
              iVar10 = 0x20;
            }
            iVar10 = iVar10 + 0x20;
          }
          uVar7 = *(ushort *)((int)register0x00000010 + -0x1a);
          uVar6 = *(ushort *)((int)register0x00000010 + -0x18);
        }
        *(ushort *)(iVar4 + 0x18) = uVar7;
        *(ushort *)((int)register0x00000010 + 8) = uVar7;
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c7328;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x16;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x412f66;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x412f6c;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_00412f80 */

void FUN_00412f80(int param_1,undefined4 param_2,int param_3,undefined4 param_4)

{
  undefined4 uVar1;
  undefined4 uVar2;
  int in_FS_OFFSET;
  uint uVar3;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0043a810();
  FUN_0043a810();
  FUN_0043b060("runtime: pointer g already scannedmark - bad statusscanobject n == 0swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
               ,0x11);
  uVar3 = 0;
  FUN_0043aef0(param_2);
  FUN_0043a870();
  if (param_1 != 0) {
    FUN_00402470(param_1 + 0x3f);
    if ((char)uVar3 == '\x01') {
      FUN_0043a810();
      FUN_0043b060(&DAT_004c8615,0x19);
      FUN_0043a870();
    }
    else {
      FUN_0043a810();
      FUN_0043b060(&DAT_004c67d4,0x14);
      FUN_0043a870();
    }
    uVar1 = *(undefined4 *)(param_1 + 0x48);
    uVar2 = *(undefined4 *)(param_1 + 0xc);
    FUN_0043a810();
    FUN_0043b060(" span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                 ,0xd);
    FUN_0043aef0(uVar2,0);
    FUN_0043b060(&DAT_004c3eef,0xc);
    FUN_0043aef0(uVar1,0);
    FUN_0043b060(&DAT_004c3efb,0xc);
    FUN_0043ad50(uVar3 & 0xff,0);
    FUN_0043a870();
  }
  FUN_0043a810();
  FUN_0043aa10();
  FUN_0043a870();
  if (param_3 != 0) goto LAB_0041301e;
  do {
    *(undefined1 *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x96) = 2;
    FUN_00469a20("found bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
                 ,0x3e);
LAB_0041301e:
    FUN_0043a810();
    FUN_0043b060(&DAT_004ca052,0x1e);
    FUN_0043aef0(param_3,0);
    FUN_0043b060(&DAT_004c2927,1);
    FUN_0043aef0(param_4,0);
    FUN_0043b060(&DAT_004c2946,2);
    FUN_0043a870();
    FUN_00420630(&DAT_004c2d50,6,param_3,param_4);
  } while( true );
}



/* Function: FUN_004131e0 */

void FUN_004131e0(int param_1,int param_2,uint param_3,uint param_4,int param_5)

{
  byte *pbVar1;
  int iVar2;
  undefined4 *puVar3;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;
  int in_FS_OFFSET;
  
  iVar2 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
  uVar6 = 1 << ((byte)(param_4 >> 2) & 7);
  pbVar4 = (byte *)(param_5 + (param_4 >> 5));
  uVar5 = 0;
  do {
    if (param_3 <= uVar5) {
      return;
    }
    if ((char)uVar6 == '\0') {
      pbVar1 = pbVar4 + 1;
      pbVar4 = pbVar4 + 1;
      if (*pbVar1 != 0) {
        uVar6 = 1;
        goto LAB_0041325a;
      }
      uVar5 = uVar5 + 0x1c;
    }
    else {
LAB_0041325a:
      if ((*pbVar4 & (byte)uVar6) != 0) {
        if (param_2 == 0) {
          if (*(uint *)(iVar2 + 0x98c) < *(int *)(iVar2 + 0x988) + 4U) {
            FUN_00433e10();
            uVar6 = uVar6 & 0xff;
          }
          puVar3 = *(undefined4 **)(iVar2 + 0x988);
          *(undefined4 **)(iVar2 + 0x988) = puVar3 + 1;
          *puVar3 = *(undefined4 *)(uVar5 + param_1);
        }
        else {
          if (*(uint *)(iVar2 + 0x98c) < *(int *)(iVar2 + 0x988) + 8U) {
            FUN_00433e10();
            uVar6 = uVar6 & 0xff;
          }
          puVar3 = *(undefined4 **)(iVar2 + 0x988);
          *(undefined4 **)(iVar2 + 0x988) = puVar3 + 2;
          *puVar3 = *(undefined4 *)(uVar5 + param_1);
          puVar3[1] = *(undefined4 *)(param_2 + uVar5);
        }
      }
      uVar6 = uVar6 << 1;
    }
    uVar5 = uVar5 + 4;
  } while( true );
}



/* Function: FUN_00413340 */

void FUN_00413340(int *param_1,int param_2,int param_3,int param_4)

{
  int iVar1;
  undefined4 *puVar2;
  code *pcVar3;
  uint uVar4;
  uint uVar5;
  int in_FS_OFFSET;
  byte *in_stack_ffffffd4;
  undefined4 local_28;
  
  if (param_1 != (int *)0x0) {
    if (*param_1 == param_4) {
      if ((char)DAT_005f5fd0 != '\0') {
        if ((*(byte *)(param_1 + 3) & 0x10) == 0) {
          in_stack_ffffffd4 = (byte *)param_1[5];
        }
        else {
          FUN_00462630(param_1);
        }
        iVar1 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
        uVar5 = 0;
        for (uVar4 = 0; uVar4 < (uint)param_1[1]; uVar4 = uVar4 + 4) {
          if ((uVar4 & 0x1f) == 0) {
            uVar5 = (uint)*in_stack_ffffffd4;
            in_stack_ffffffd4 = in_stack_ffffffd4 + 1;
          }
          else {
            uVar5 = uVar5 >> 1;
          }
          if ((uVar5 & 1) != 0) {
            if (*(uint *)(iVar1 + 0x98c) < *(int *)(iVar1 + 0x988) + 8U) {
              FUN_00433e10();
            }
            puVar2 = *(undefined4 **)(iVar1 + 0x988);
            *(undefined4 **)(iVar1 + 0x988) = puVar2 + 2;
            *puVar2 = *(undefined4 *)(param_2 + uVar4);
            puVar2[1] = *(undefined4 *)(param_3 + uVar4);
          }
        }
        return;
      }
      return;
    }
    FUN_00462470(param_1);
    iVar1 = *param_1;
    FUN_0043a810();
    FUN_0043b060(&DAT_004cbe18,0x28);
    FUN_0043b060(in_stack_ffffffd4,local_28);
    FUN_0043b060(&DAT_004c3a3e,0xb);
    FUN_0043ad50(iVar1,0);
    FUN_0043b060(&DAT_004c5bc8,0x12);
    FUN_0043ad50(param_4,0);
    FUN_0043aa10();
    FUN_0043a870();
    FUN_00469a20("runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memor..." /* TRUNCATED STRING LITERAL */
                 ,0x24);
  }
  FUN_00469a20(&DAT_004cc048,0x29);
  pcVar3 = (code *)swi(3);
  (*pcVar3)();
  return;
}



/* Function: FUN_00413530 */

void FUN_00413530(int param_1)

{
  uint uVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  for (uVar1 = 0; uVar1 < *(ushort *)(param_1 + 0x1a) + 7 >> 3; uVar1 = uVar1 + 8) {
  }
  return;
}



/* Function: FUN_00413680 */

void FUN_00413680(void)

{
  uint uVar1;
  int iVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x1c);
      uVar1 = (*(uint *)((int)register0x00000010 + 8) >> 2) + 7 >> 3;
      *(uint *)((int)register0x00000010 + -0xc) = uVar1;
      iVar2 = uVar1 + 1;
      *(int *)((int)register0x00000010 + -8) = iVar2;
      *(int *)((int)register0x00000010 + -0x1c) = iVar2;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 1;
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005f84e8;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4136c7;
      FUN_004119f0();
      if (*(uint *)((int)register0x00000010 + -8) < 0x40000001) {
        if (*(uint *)((int)register0x00000010 + -0xc) < *(uint *)((int)register0x00000010 + -8)) {
          iVar2 = *(int *)((int)register0x00000010 + -0x10);
          *(int *)((int)register0x00000010 + -4) = iVar2;
          *(undefined1 *)(*(uint *)((int)register0x00000010 + -0xc) + iVar2) = 0xa1;
          *(undefined4 *)((int)register0x00000010 + -0x1c) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(int *)((int)register0x00000010 + -0x18) = iVar2;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4136f9;
          FUN_00413750();
          if (*(char *)(*(int *)((int)register0x00000010 + -0xc) +
                       *(int *)((int)register0x00000010 + -4)) == -0x5f) {
            *(undefined4 *)((int)register0x00000010 + 0xc) =
                 *(undefined4 *)((int)register0x00000010 + -0x14);
            *(int *)((int)register0x00000010 + 0x10) = *(int *)((int)register0x00000010 + -4);
            return;
          }
          *(char **)((int)register0x00000010 + -0x1c) =
               "progToPointerMask: overflow/gc/cycles/forced:gc-cycles/memory/classes/other:bytes/memory/classes/total:bytesfailed to set sweep barrierwork.nwait was > work.nproc not in stack roots range [allocated pages below zero?address not a stack addressmspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for misma..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x1b;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41372e;
          FUN_00469a20();
        }
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x413733;
        FUN_0046edf0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41373d;
      FUN_0046ee20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x413743;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00413750 */

void FUN_00413750(byte *param_1,byte *param_2)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  byte *pbVar10;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar6 = 0;
  uVar3 = 0;
LAB_00413885:
  do {
    while( true ) {
      for (; 7 < uVar3; uVar3 = uVar3 - 8) {
        *param_2 = (byte)uVar6;
        uVar6 = uVar6 >> 8;
        param_2 = param_2 + 1;
      }
      bVar1 = *param_1;
      uVar7 = bVar1 & 0x7f;
      param_1 = param_1 + 1;
      if ((bVar1 & 0x80) != 0) break;
      if ((bVar1 & 0x7f) == 0) {
        for (iVar2 = (-uVar3 & 7) + uVar3; iVar2 != 0; iVar2 = iVar2 + -8) {
          *param_2 = (byte)uVar6;
          uVar6 = uVar6 >> 8;
          param_2 = param_2 + 1;
        }
        return;
      }
      for (uVar4 = 0; uVar4 < uVar7 >> 3; uVar4 = uVar4 + 1) {
        uVar6 = uVar6 | (uint)*param_1 << ((byte)uVar3 & 0x1f);
        *param_2 = (byte)uVar6;
        uVar6 = uVar6 >> 8;
        param_1 = param_1 + 1;
        param_2 = param_2 + 1;
      }
      if ((bVar1 & 7) != 0) {
        uVar6 = uVar6 | (uint)*param_1 << ((byte)uVar3 & 0x1f);
        uVar3 = uVar3 + (bVar1 & 7);
        param_1 = param_1 + 1;
      }
    }
    uVar4 = uVar3;
    if ((bVar1 & 0x7f) != 0) goto LAB_004137be;
    uVar7 = 0;
    uVar8 = 0;
LAB_00413a90:
    bVar1 = *param_1;
    param_1 = param_1 + 1;
    uVar7 = uVar7 | -(uint)(uVar8 < 0x20) & (bVar1 & 0x7f) << ((byte)uVar8 & 0x1f);
    uVar4 = uVar3;
    if ((bVar1 & 0x80) != 0) {
LAB_00413a87:
      uVar8 = uVar8 + 7;
      goto LAB_00413a90;
    }
LAB_004137be:
    uVar5 = 0;
    uVar3 = 0;
    while( true ) {
      bVar1 = *param_1;
      param_1 = param_1 + 1;
      uVar5 = uVar5 | -(uint)(uVar3 < 0x20) & (bVar1 & 0x7f) << ((byte)uVar3 & 0x1f);
      if ((bVar1 & 0x80) == 0) break;
      uVar3 = uVar3 + 7;
    }
    uVar5 = uVar5 * uVar7;
    uVar3 = uVar4;
    uVar8 = uVar6;
    pbVar10 = param_2;
    if (uVar7 < 0x1a) {
      for (; uVar3 < uVar7; uVar3 = uVar3 + 8) {
        uVar8 = uVar8 << 8 | (uint)pbVar10[-1];
        pbVar10 = pbVar10 + -1;
      }
      if (uVar7 < uVar3) {
        uVar8 = -(uint)(uVar3 - uVar7 < 0x20) & uVar8 >> ((byte)(uVar3 - uVar7) & 0x1f);
        uVar3 = uVar7;
      }
      if (uVar3 == 1) {
        uVar3 = uVar5;
        if (uVar8 == 1) {
          uVar8 = 0x1ffffff;
          uVar3 = 0x19;
        }
        goto LAB_004139aa;
      }
      uVar7 = uVar3 * 2;
      uVar9 = uVar3;
      if (0x19 < uVar7) goto LAB_004139aa;
      for (; uVar9 < 0x21; uVar9 = uVar9 * 2) {
        uVar8 = uVar8 | -(uint)(uVar9 < 0x20) & uVar8 << ((byte)uVar9 & 0x1f);
        uVar7 = uVar8;
      }
      if (uVar3 != 0) break;
      FUN_00438080();
      goto LAB_00413a87;
    }
    uVar3 = uVar7 - uVar4 & 7;
    pbVar10 = param_2 + -((uVar7 - uVar4) + 7 >> 3);
    if (uVar3 != 0) {
      bVar1 = *pbVar10;
      pbVar10 = pbVar10 + 1;
      uVar6 = uVar6 | (uint)(bVar1 >> (-((char)uVar3 + -8) & 0x1fU)) << ((byte)uVar4 & 0x1f);
      uVar4 = uVar4 + uVar3;
      uVar5 = uVar5 - uVar3;
    }
    for (uVar3 = uVar5 >> 3; uVar3 != 0; uVar3 = uVar3 - 1) {
      bVar1 = *pbVar10;
      pbVar10 = pbVar10 + 1;
      uVar6 = uVar6 | (uint)bVar1 << ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20);
      *param_2 = (byte)uVar6;
      uVar6 = uVar6 >> 8;
      param_2 = param_2 + 1;
    }
    uVar5 = uVar5 & 7;
    uVar3 = uVar4;
    if (uVar5 != 0) {
      uVar6 = uVar6 | ((1 << (sbyte)uVar5) - 1U & (uint)*pbVar10) << ((byte)uVar4 & 0x1f) &
                      -(uint)(uVar4 < 0x20);
      uVar3 = uVar5 + uVar4;
    }
  } while( true );
  uVar3 = uVar3 * (int)(0x19 / (ulong)uVar3);
  uVar8 = uVar8 & (1 << ((byte)uVar3 & 0x1f) & -(uint)(uVar3 < 0x20)) - 1;
LAB_004139aa:
  while (uVar3 <= uVar5) {
    uVar6 = uVar6 | uVar8 << ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20);
    for (uVar4 = uVar3 + uVar4; 7 < uVar4; uVar4 = uVar4 - 8) {
      *param_2 = (byte)uVar6;
      uVar6 = uVar6 >> 8;
      param_2 = param_2 + 1;
    }
    uVar5 = uVar5 - uVar3;
  }
  uVar3 = uVar4;
  if (uVar5 != 0) {
    uVar3 = uVar4 + uVar5;
    uVar6 = uVar6 | (uVar8 & (1 << ((byte)uVar5 & 0x1f) & -(uint)(uVar5 < 0x20)) - 1) <<
                    ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20);
  }
  goto LAB_00413885;
}



/* Function: FUN_00413b30 */

void FUN_00413b30(void)

{
  int iVar1;
  int in_FS_OFFSET;
  int local_10;
  int *local_c;
  undefined1 *local_8;
  int **local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (int **)0x413bd5;
    FUN_0046d980();
  }
  local_c = (int *)0x0;
  local_8 = &LAB_00413be0;
  local_4 = &local_c;
  FUN_0046d890(&local_8);
  for (iVar1 = 0; iVar1 < 0x88; iVar1 = iVar1 + 1) {
    local_c[iVar1 + 7] = (int)&DAT_005d7280;
  }
  if (DAT_005cc27c == 0) {
    iVar1 = 0x7fffffff;
    local_10 = -1;
  }
  else if (DAT_005cc27c == 1) {
    iVar1 = 0;
    local_10 = 0;
  }
  else {
    FUN_00411810(DAT_005cc27c);
    iVar1 = local_10 >> 0x1f;
  }
  *local_c = local_10;
  local_c[1] = iVar1;
  return;
}



/* Function: FUN_00413c60 */

void FUN_00413c60(void)

{
  undefined *puVar1;
  undefined4 uVar2;
  long lVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  undefined1 *puVar8;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x28);
      uVar5 = (uint)*(byte *)((int)register0x00000010 + 8);
      if (uVar5 < 0x88) {
        puVar1 = *(undefined **)(*(int *)((int)register0x00000010 + 4) + 0x1c + uVar5 * 4);
        if (*(short *)(puVar1 + 0x1a) == *(short *)(puVar1 + 0x3c)) {
          *(uint *)((int)register0x00000010 + -8) = uVar5;
          if (puVar1 == &DAT_005d7280) {
LAB_00413dc5:
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005ddf70 + uVar5 * 0x80;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413dd8;
            FUN_00414420();
            iVar6 = *(int *)((int)register0x00000010 + -0x24);
            if (iVar6 != 0) {
              if (*(short *)(iVar6 + 0x1a) != *(short *)(iVar6 + 0x3c)) {
                *(int *)((int)register0x00000010 + -0xc) = iVar6;
                *(int *)(iVar6 + 0x34) = DAT_005dde90 + 3;
                *(undefined2 *)(iVar6 + 0x42) = *(undefined2 *)(iVar6 + 0x3c);
                uVar7 = (uint)*(ushort *)(iVar6 + 0x3c) * *(int *)(iVar6 + 0x44);
                uVar5 = *(int *)(iVar6 + 0x10) * 0x2000;
                uVar2 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0xc);
                *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f6780;
                *(uint *)((int)register0x00000010 + -0x24) = uVar5 - uVar7;
                *(uint *)((int)register0x00000010 + -0x20) = -(uint)(uVar5 < uVar7);
                *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar2;
                *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413e47;
                FUN_004227a0();
                iVar6 = *(int *)((int)register0x00000010 + 4);
                *(undefined4 *)(iVar6 + 0xc) = 0;
                *(undefined4 *)(iVar6 + 0x1c + *(int *)((int)register0x00000010 + -8) * 4) =
                     *(undefined4 *)((int)register0x00000010 + -0xc);
                return;
              }
              *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c7354;
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x16;
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413e78;
              FUN_00469a20();
            }
            *(char **)((int)register0x00000010 + -0x28) =
                 "out of memory is nil, not value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
            ;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0xd;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413e8e;
            FUN_00469a20();
LAB_00413e8e:
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413e9a;
            FUN_0046edf0();
          }
          else if (*(int *)(puVar1 + 0x34) == DAT_005dde90 + 3) {
            *(undefined **)((int)register0x00000010 + -0xc) = puVar1;
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005ddf70 + uVar5 * 0x80;
            *(undefined **)((int)register0x00000010 + -0x24) = puVar1;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413ce1;
            FUN_00414840();
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f7700;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413cef;
            FUN_00433980();
            uVar5 = (uint)*(ushort *)(*(int *)((int)register0x00000010 + -0xc) + 0x3c);
            uVar7 = (uint)*(ushort *)(*(int *)((int)register0x00000010 + -0xc) + 0x42);
            iVar6 = uVar5 - uVar7;
            if ((uint)(int)(char)(*(byte *)((int)register0x00000010 + 8) >> 1) < 0x44) {
              *(int *)((int)register0x00000010 + -0x14) = iVar6;
              *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + -0x24);
              iVar4 = -(uint)(uVar5 < uVar7);
              *(int *)((int)register0x00000010 + -0x10) = iVar4;
              *(int *)((int)register0x00000010 + -0x28) =
                   *(int *)((int)register0x00000010 + -0x24) + 0x48 +
                   (char)(*(byte *)((int)register0x00000010 + 8) >> 1) * 8;
              *(int *)((int)register0x00000010 + -0x24) = iVar6;
              *(int *)((int)register0x00000010 + -0x20) = iVar4;
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413d42;
              FUN_004026b0();
              if (*(char *)((int)register0x00000010 + 8) == '\x05') {
                uVar2 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x18);
                *(int *)((int)register0x00000010 + -0x28) =
                     *(int *)((int)register0x00000010 + -4) + 0x30;
                *(undefined4 *)((int)register0x00000010 + -0x24) = uVar2;
                *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
                *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413d6e;
                FUN_004026b0();
                *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x18) = 0;
              }
              *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f7700;
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413d87;
              FUN_00433a70();
              uVar5 = *(uint *)(*(int *)((int)register0x00000010 + -0xc) + 0x44);
              lVar3 = (ulong)*(uint *)((int)register0x00000010 + -0x14) * (ulong)uVar5;
              *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f68a8;
              *(int *)((int)register0x00000010 + -0x24) = (int)lVar3;
              *(uint *)((int)register0x00000010 + -0x20) =
                   *(int *)((int)register0x00000010 + -0x10) * uVar5 + (int)((ulong)lVar3 >> 0x20);
              *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413db7;
              FUN_004026b0();
              *(undefined2 *)(*(int *)((int)register0x00000010 + -0xc) + 0x42) = 0;
              uVar5 = *(uint *)((int)register0x00000010 + -8);
              goto LAB_00413dc5;
            }
            goto LAB_00413e8e;
          }
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c733e;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x16;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413eb0;
          FUN_00469a20();
        }
        *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004cbe40;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x28;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413ec6;
        FUN_00469a20();
      }
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413ed0;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar8 + -4) = 0x413ed6;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_00413ee0 */

void FUN_00413ee0(void)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x28);
      uVar1 = *(uint *)((int)register0x00000010 + 8);
      if (uVar1 <= uVar1 + 0x2000) {
        uVar3 = uVar1 >> 0xd;
        if ((uVar1 & 0x1fff) != 0) {
          uVar3 = uVar3 + 1;
        }
        *(uint *)((int)register0x00000010 + -0x10) = uVar3;
        *(uint *)((int)register0x00000010 + -8) = uVar3 << 0xd;
        *(uint *)((int)register0x00000010 + -0x28) = uVar3 << 0xd;
        *(uint *)((int)register0x00000010 + -0x24) = uVar3;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413f30;
        FUN_00428250();
        *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005ddde0;
        *(undefined4 *)((int)register0x00000010 + -0x24) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined1 *)((int)register0x00000010 + -0x20) =
             *(undefined1 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413f51;
        FUN_00429c40();
        if (*(int *)((int)register0x00000010 + -0x1c) != 0) {
          *(int *)((int)register0x00000010 + -0x14) = *(int *)((int)register0x00000010 + -0x1c);
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f7700;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413f6f;
          FUN_00433980();
          *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + -0x24);
          *(int *)((int)register0x00000010 + -0x28) =
               *(int *)((int)register0x00000010 + -0x24) + 0x38;
          *(undefined4 *)((int)register0x00000010 + -0x24) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413f94;
          FUN_004026b0();
          *(int *)((int)register0x00000010 + -0x28) = *(int *)((int)register0x00000010 + -4) + 0x40;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413fb3;
          FUN_004026b0();
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f7700;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413fc1;
          FUN_00433a70();
          *(uint *)((int)register0x00000010 + -0xc) = (uint)*(byte *)((int)register0x00000010 + 0xc)
          ;
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f68a8;
          *(undefined4 *)((int)register0x00000010 + -0x24) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x413fef;
          FUN_004026b0();
          iVar2 = *(int *)(*(int *)((int)register0x00000010 + -0x14) + 0x10);
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f6780;
          *(int *)((int)register0x00000010 + -0x24) = iVar2 << 0xd;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x414023;
          FUN_004227a0();
          if (*(uint *)((int)register0x00000010 + -0xc) < 0x88) {
            *(undefined **)((int)register0x00000010 + -0x28) =
                 &DAT_005ddfa8 +
                 (DAT_005dde90 >> 1 & 1) * 0x18 + *(uint *)((int)register0x00000010 + -0xc) * 0x80;
            *(undefined4 *)((int)register0x00000010 + -0x24) =
                 *(undefined4 *)((int)register0x00000010 + -0x14);
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41405c;
            FUN_004330d0();
            iVar2 = *(int *)((int)register0x00000010 + -0x14);
            *(int *)(iVar2 + 0x48) = *(int *)(iVar2 + 0xc) + *(int *)((int)register0x00000010 + 8);
            *(int *)((int)register0x00000010 + -0x28) = iVar2;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x414074;
            FUN_00412a30();
            *(undefined4 *)((int)register0x00000010 + 0x10) =
                 *(undefined4 *)((int)register0x00000010 + -0x14);
            return;
          }
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41408a;
          FUN_0046edf0();
        }
        *(char **)((int)register0x00000010 + -0x28) =
             "out of memory is nil, not value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0xd;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4140a0;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x28) =
           "out of memory is nil, not value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0xd;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4140b6;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x4140bc;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_004140d0 */

void FUN_004140d0(void)

{
  undefined *puVar1;
  long lVar2;
  uint uVar3;
  int iVar4;
  undefined1 *puVar5;
  undefined4 uVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  int in_FS_OFFSET;
  
code_r0x004140d0:
  puVar5 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar5 = (undefined1 *)((int)register0x00000010 + -0x3c);
    iVar7 = *(int *)((int)register0x00000010 + 4);
    *(undefined4 *)((int)register0x00000010 + -4) = *(undefined4 *)(iVar7 + 0xc);
    *(undefined4 *)(iVar7 + 0xc) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x20) = DAT_005dde90;
    iVar4 = 0;
    uVar6 = 0;
    uVar8 = 0;
    do {
      *(undefined4 *)((int)register0x00000010 + -0x14) = uVar8;
      *(undefined4 *)((int)register0x00000010 + -0x10) = uVar6;
      if (0x87 < iVar4) {
        *(undefined4 *)(iVar7 + 0x10) = 0;
        *(undefined4 *)(iVar7 + 0x14) = 0;
        *(undefined **)((int)register0x00000010 + -0x3c) = &DAT_005f7700;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x41428b;
        FUN_00433980();
        uVar6 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x18);
        *(int *)((int)register0x00000010 + -0x3c) = *(int *)((int)register0x00000010 + -0x38) + 0x30
        ;
        *(undefined4 *)((int)register0x00000010 + -0x38) = uVar6;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x4142af;
        FUN_004026b0();
        *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x18) = 0;
        *(undefined **)((int)register0x00000010 + -0x3c) = &DAT_005f7700;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x4142c8;
        FUN_00433a70();
        *(undefined **)((int)register0x00000010 + -0x3c) = &DAT_005f6780;
        *(undefined4 *)((int)register0x00000010 + -0x38) =
             *(undefined4 *)((int)register0x00000010 + -0x14);
        *(undefined4 *)((int)register0x00000010 + -0x34) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x30) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x4142f6;
        FUN_004227a0();
        return;
      }
      puVar1 = *(undefined **)(iVar7 + 0x1c + iVar4 * 4);
      if (puVar1 != &DAT_005d7280) {
        *(int *)((int)register0x00000010 + -0x18) = iVar4;
        *(undefined **)((int)register0x00000010 + -0x1c) = puVar1;
        *(uint *)((int)register0x00000010 + -8) = (uint)*(ushort *)(puVar1 + 0x3c);
        *(uint *)((int)register0x00000010 + -0xc) = (uint)*(ushort *)(puVar1 + 0x42);
        *(undefined2 *)(puVar1 + 0x42) = 0;
        *(undefined **)((int)register0x00000010 + -0x3c) = &DAT_005f7700;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x41415e;
        FUN_00433980();
        uVar3 = (uint)(char)((byte)(*(uint *)((int)register0x00000010 + -0x18) >> 1) & 0x7f);
        iVar4 = *(uint *)((int)register0x00000010 + -8) - *(uint *)((int)register0x00000010 + -0xc);
        if (0x43 < uVar3) goto LAB_004142fa;
        *(int *)((int)register0x00000010 + -0x28) = iVar4;
        iVar7 = -(uint)(*(uint *)((int)register0x00000010 + -8) <
                       *(uint *)((int)register0x00000010 + -0xc));
        *(int *)((int)register0x00000010 + -0x24) = iVar7;
        *(uint *)((int)register0x00000010 + -0x3c) =
             *(int *)((int)register0x00000010 + -0x38) + 0x48 + uVar3 * 8;
        *(int *)((int)register0x00000010 + -0x38) = iVar4;
        *(int *)((int)register0x00000010 + -0x34) = iVar7;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x4141a8;
        FUN_004026b0();
        *(undefined **)((int)register0x00000010 + -0x3c) = &DAT_005f7700;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x4141b6;
        FUN_00433a70();
        uVar3 = *(uint *)(*(int *)((int)register0x00000010 + -0x1c) + 0x44);
        lVar2 = (ulong)*(uint *)((int)register0x00000010 + -0x28) * (ulong)uVar3;
        *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + -0x20) + 1;
        *(undefined **)((int)register0x00000010 + -0x3c) = &DAT_005f68a8;
        *(int *)((int)register0x00000010 + -0x38) = (int)lVar2;
        *(uint *)((int)register0x00000010 + -0x34) =
             *(int *)((int)register0x00000010 + -0x24) * uVar3 + (int)((ulong)lVar2 >> 0x20);
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x4141ee;
        FUN_004026b0();
        iVar4 = *(int *)((int)register0x00000010 + -0x1c);
        if (*(int *)(iVar4 + 0x34) == *(int *)((int)register0x00000010 + -8)) {
          iVar7 = *(int *)((int)register0x00000010 + -0x10);
          iVar9 = *(int *)((int)register0x00000010 + -0x14);
        }
        else {
          lVar2 = (ulong)((uint)*(ushort *)(iVar4 + 0x1a) - (uint)*(ushort *)(iVar4 + 0x3c) & 0xffff
                         ) * (ulong)*(uint *)(iVar4 + 0x44);
          uVar3 = (uint)lVar2;
          iVar9 = *(uint *)((int)register0x00000010 + -0x14) - uVar3;
          iVar7 = (*(int *)((int)register0x00000010 + -0x10) - (int)((ulong)lVar2 >> 0x20)) -
                  (uint)(*(uint *)((int)register0x00000010 + -0x14) < uVar3);
        }
        *(int *)((int)register0x00000010 + -0x14) = iVar9;
        *(int *)((int)register0x00000010 + -0x10) = iVar7;
        *(undefined **)((int)register0x00000010 + -0x3c) =
             &DAT_005ddf70 + *(int *)((int)register0x00000010 + -0x18) * 0x80;
        *(int *)((int)register0x00000010 + -0x38) = iVar4;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x414246;
        FUN_00414840();
        iVar4 = *(int *)((int)register0x00000010 + -0x18);
        *(undefined **)(*(int *)((int)register0x00000010 + 4) + 0x1c + iVar4 * 4) = &DAT_005d7280;
        uVar6 = *(undefined4 *)((int)register0x00000010 + -0x10);
        uVar8 = *(undefined4 *)((int)register0x00000010 + -0x14);
        iVar7 = *(int *)((int)register0x00000010 + 4);
      }
      iVar4 = iVar4 + 1;
    } while( true );
  }
  goto LAB_00414305;
LAB_004142fa:
  *(undefined4 *)((int)register0x00000010 + -0x40) = 0x414304;
  FUN_0046edf0();
LAB_00414305:
  *(undefined4 *)(puVar5 + -4) = 0x41430a;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar5;
  goto code_r0x004140d0;
}



/* Function: FUN_00414310 */

void FUN_00414310(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -8) = DAT_005dde90;
      *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0x254;
      *(int *)((int)register0x00000010 + -0x14) = *(int *)((int)register0x00000010 + 4) + 0x254;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x414348;
      FUN_00402510();
      iVar1 = *(int *)((int)register0x00000010 + -0x10);
      if (iVar1 == *(int *)((int)register0x00000010 + -8)) {
        return;
      }
      if (iVar1 == *(int *)((int)register0x00000010 + -8) + -2) {
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x414367;
        FUN_004140d0();
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x414373;
        FUN_0044edd0();
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x10) = DAT_005dde90;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x414389;
        FUN_00402770();
        return;
      }
      *(int *)((int)register0x00000010 + -0xc) = iVar1;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x41439a;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x14) =
           "bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0xd;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4143b0;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4143c4;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004ca070;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x1e;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4143da;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4143ee;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4143f3;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4143f8;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c3f07;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0xc;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x41440e;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x414414;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00414420 */

void FUN_00414420(void)

{
  ushort uVar1;
  undefined4 uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  ushort uVar6;
  undefined1 *puVar7;
  int in_FS_OFFSET;
  bool bVar8;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x48);
      if ((uint)(int)(char)(**(byte **)((int)register0x00000010 + 4) >> 1) < 0x44) break;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414826;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar7 + -4) = 0x41482c;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
  *(uint *)((int)register0x00000010 + -0x48) =
       (uint)(byte)(&DAT_005cc6a0)[(char)(**(byte **)((int)register0x00000010 + 4) >> 1)] << 0xd;
  *(undefined4 *)((int)register0x00000010 + -0x44) = 0;
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414469;
  FUN_00428250();
  if (DAT_005d7d30 == '\0') {
    iVar4 = 0;
    uVar2 = 0;
  }
  else {
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x41447f;
    FUN_0045e520();
    uVar2 = *(undefined4 *)((int)register0x00000010 + -0x48);
    iVar4 = *(int *)((int)register0x00000010 + -0x44);
  }
  if (iVar4 != 0) {
    *(undefined4 *)((int)register0x00000010 + -8) = uVar2;
    *(int *)((int)register0x00000010 + -0x34) = iVar4;
    *(undefined4 *)((int)register0x00000010 + -0x48) = uVar2;
    *(int *)((int)register0x00000010 + -0x44) = iVar4;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x41449e;
    FUN_0045ece0();
    *(undefined4 *)((int)register0x00000010 + -0x48) = *(undefined4 *)((int)register0x00000010 + -8)
    ;
    *(undefined4 *)((int)register0x00000010 + -0x44) =
         *(undefined4 *)((int)register0x00000010 + -0x34);
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4144b2;
    FUN_0045e630();
  }
  *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
  *(undefined1 *)((int)register0x00000010 + -0x24) = 0;
  uVar3 = DAT_005dde90 >> 1 & 1;
  *(uint *)((int)register0x00000010 + -0x10) = uVar3;
  *(uint *)((int)register0x00000010 + -0x14) = uVar3 * 3;
  *(uint *)((int)register0x00000010 + -0x48) =
       *(int *)((int)register0x00000010 + 4) + 8 + uVar3 * 0x18;
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4144e5;
  FUN_004332d0();
  iVar4 = *(int *)((int)register0x00000010 + -0x44);
  if (iVar4 == 0) {
    *(undefined **)((int)register0x00000010 + -0x48) = &DAT_005d716c;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414502;
    FUN_004265a0();
    *(undefined4 *)((int)register0x00000010 + -0x28) =
         *(undefined4 *)((int)register0x00000010 + -0x44);
    *(char *)((int)register0x00000010 + -0x24) = *(char *)((int)register0x00000010 + -0x40);
    if (*(char *)((int)register0x00000010 + -0x40) == '\0') goto LAB_00414521;
    iVar4 = 100;
    goto LAB_00414697;
  }
  bVar8 = false;
LAB_00414595:
  do {
    *(int *)((int)register0x00000010 + -0x18) = iVar4;
    if (!bVar8) {
      if (DAT_005d7d30 == '\0') {
        iVar5 = 0;
        uVar2 = 0;
      }
      else {
        *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4145b3;
        FUN_0045e520();
        uVar2 = *(undefined4 *)((int)register0x00000010 + -0x48);
        iVar5 = *(int *)((int)register0x00000010 + -0x44);
        iVar4 = *(int *)((int)register0x00000010 + -0x18);
      }
      if (iVar5 != 0) {
        *(undefined4 *)((int)register0x00000010 + -0xc) = uVar2;
        *(int *)((int)register0x00000010 + -0x38) = iVar5;
        *(undefined4 *)((int)register0x00000010 + -0x48) = uVar2;
        *(int *)((int)register0x00000010 + -0x44) = iVar5;
        *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4145d8;
        FUN_0045ee40();
        *(undefined4 *)((int)register0x00000010 + -0x48) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0x38);
        *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4145ec;
        FUN_0045e630();
        iVar4 = *(int *)((int)register0x00000010 + -0x18);
      }
    }
    if ((*(ushort *)(iVar4 + 0x3c) != *(ushort *)(iVar4 + 0x1a)) &&
       (uVar1 = *(ushort *)(iVar4 + 0x18), uVar1 != *(ushort *)(iVar4 + 0x1a))) {
      *(int *)((int)register0x00000010 + -0x48) = iVar4;
      *(ushort *)((int)register0x00000010 + -0x44) = (uVar1 & 0xffc0) >> 3;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x41461c;
      FUN_00412d40();
      iVar4 = *(int *)((int)register0x00000010 + -0x18);
      uVar3 = *(uint *)(iVar4 + 0x24);
      *(uint *)((int)register0x00000010 + -0x10) = uVar3;
      uVar6 = *(ushort *)(iVar4 + 0x18) & 0x3f;
      uVar1 = uVar6 - 0x20;
      iVar5 = *(int *)((int)register0x00000010 + -0x18);
      *(uint *)(iVar5 + 0x20) =
           *(int *)((int)register0x00000010 + -0x10) << ((byte)-uVar1 & 0x1f) &
           -(uint)((ushort)-uVar1 < 0x20) |
           *(uint *)(iVar4 + 0x20) >> ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20) |
           -(uint)(uVar1 < 0x20) & uVar3 >> ((byte)uVar1 & 0x1f);
      *(uint *)(iVar5 + 0x24) = uVar3 >> ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20);
      *(int *)((int)register0x00000010 + 8) = iVar5;
      return;
    }
    *(undefined **)((int)register0x00000010 + -0x48) = &DAT_004c7f87;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x18;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414690;
    FUN_00469a20();
    do {
      iVar4 = *(int *)((int)register0x00000010 + -0x2c) + -1;
LAB_00414697:
      if (iVar4 < 0) goto LAB_0041472e;
      *(int *)((int)register0x00000010 + -0x2c) = iVar4;
      *(int *)((int)register0x00000010 + -0x48) =
           *(int *)((int)register0x00000010 + 4) + 8 +
           (*(int *)((int)register0x00000010 + -0x10) + -1) * -0x18;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4146bd;
      FUN_004332d0();
      if (*(int *)((int)register0x00000010 + -0x44) == 0) {
        iVar4 = *(int *)((int)register0x00000010 + -0x2c);
        goto LAB_0041472e;
      }
      *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + -0x44);
      *(undefined1 **)((int)register0x00000010 + -0x48) =
           (undefined1 *)((int)register0x00000010 + -0x28);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4146d5;
      FUN_00426b10();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -0x40);
    } while (*(char *)((int)register0x00000010 + -0x3c) == '\0');
    *(undefined1 **)((int)register0x00000010 + -0x48) =
         (undefined1 *)((int)register0x00000010 + -0x1c);
    *(undefined1 *)((int)register0x00000010 + -0x44) = 1;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4146f7;
    FUN_00426f80();
    *(undefined **)((int)register0x00000010 + -0x48) = &DAT_005d716c;
    *(undefined4 *)((int)register0x00000010 + -0x44) =
         *(undefined4 *)((int)register0x00000010 + -0x28);
    *(undefined1 *)((int)register0x00000010 + -0x40) =
         *(undefined1 *)((int)register0x00000010 + -0x24);
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414716;
    FUN_00426620();
    bVar8 = false;
    iVar4 = *(int *)((int)register0x00000010 + -0x18);
  } while( true );
LAB_0041472e:
  if (iVar4 < 0) goto LAB_004147f8;
  *(int *)((int)register0x00000010 + -0x2c) = iVar4;
  *(int *)((int)register0x00000010 + -0x48) =
       *(int *)((int)register0x00000010 + 4) + 0x38 +
       (*(int *)((int)register0x00000010 + -0x10) + -1) * -0x18;
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414754;
  FUN_004332d0();
  if (*(int *)((int)register0x00000010 + -0x44) == 0) goto LAB_004147f8;
  *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + -0x44);
  *(undefined1 **)((int)register0x00000010 + -0x48) =
       (undefined1 *)((int)register0x00000010 + -0x28);
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414770;
  FUN_00426b10();
  *(undefined4 *)((int)register0x00000010 + -0x20) =
       *(undefined4 *)((int)register0x00000010 + -0x40);
  if (*(char *)((int)register0x00000010 + -0x3c) != '\0') {
    *(undefined1 **)((int)register0x00000010 + -0x48) =
         (undefined1 *)((int)register0x00000010 + -0x20);
    *(undefined1 *)((int)register0x00000010 + -0x44) = 1;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414792;
    FUN_00426f80();
    *(undefined4 *)((int)register0x00000010 + -0x48) =
         *(undefined4 *)((int)register0x00000010 + -0x20);
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x41479e;
    FUN_00412dd0();
    iVar4 = *(int *)((int)register0x00000010 + -0x20);
    if (*(short *)(iVar4 + 0x1a) != *(short *)((int)register0x00000010 + -0x44)) {
      *(short *)(iVar4 + 0x18) = *(short *)((int)register0x00000010 + -0x44);
      *(undefined **)((int)register0x00000010 + -0x48) = &DAT_005d716c;
      *(undefined4 *)((int)register0x00000010 + -0x44) =
           *(undefined4 *)((int)register0x00000010 + -0x28);
      *(undefined1 *)((int)register0x00000010 + -0x40) =
           *(undefined1 *)((int)register0x00000010 + -0x24);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4147ed;
      FUN_00426620();
      bVar8 = false;
      iVar4 = *(int *)((int)register0x00000010 + -0x18);
      goto LAB_00414595;
    }
    *(int *)((int)register0x00000010 + -0x48) =
         *(int *)((int)register0x00000010 + 4) + 0x38 +
         *(int *)((int)register0x00000010 + -0x14) * 8;
    *(int *)((int)register0x00000010 + -0x44) = iVar4;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4147c5;
    FUN_004330d0();
  }
  iVar4 = *(int *)((int)register0x00000010 + -0x2c) + -1;
  goto LAB_0041472e;
LAB_004147f8:
  *(undefined **)((int)register0x00000010 + -0x48) = &DAT_005d716c;
  *(undefined4 *)((int)register0x00000010 + -0x44) =
       *(undefined4 *)((int)register0x00000010 + -0x28);
  *(undefined1 *)((int)register0x00000010 + -0x40) =
       *(undefined1 *)((int)register0x00000010 + -0x24);
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414817;
  FUN_00426620();
LAB_00414521:
  if (DAT_005d7d30 == '\0') {
    iVar4 = 0;
    uVar2 = 0;
  }
  else {
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414537;
    FUN_0045e520();
    uVar2 = *(undefined4 *)((int)register0x00000010 + -0x48);
    iVar4 = *(int *)((int)register0x00000010 + -0x44);
  }
  *(int *)((int)register0x00000010 + -0x30) = iVar4;
  if (iVar4 != 0) {
    *(undefined4 *)((int)register0x00000010 + -4) = uVar2;
    *(undefined4 *)((int)register0x00000010 + -0x48) = uVar2;
    *(int *)((int)register0x00000010 + -0x44) = iVar4;
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414556;
    FUN_0045ee40();
    *(undefined4 *)((int)register0x00000010 + -0x48) = *(undefined4 *)((int)register0x00000010 + -4)
    ;
    *(undefined4 *)((int)register0x00000010 + -0x44) =
         *(undefined4 *)((int)register0x00000010 + -0x30);
    *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x41456a;
    FUN_0045e630();
  }
  *(undefined4 *)((int)register0x00000010 + -0x48) = *(undefined4 *)((int)register0x00000010 + 4);
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x414576;
  FUN_00414960();
  iVar4 = *(int *)((int)register0x00000010 + -0x44);
  if (iVar4 == 0) {
    *(undefined4 *)((int)register0x00000010 + 8) = 0;
    return;
  }
  bVar8 = *(int *)((int)register0x00000010 + -0x30) != 0;
  goto LAB_00414595;
}



/* Function: FUN_00414840 */

void FUN_00414840(void)

{
  int iVar1;
  int iVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  bool bVar4;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x1c);
      iVar1 = *(int *)((int)register0x00000010 + 8);
      if (*(short *)(iVar1 + 0x3c) != 0) {
        *(int *)((int)register0x00000010 + -0xc) = DAT_005dde90;
        *(int *)((int)register0x00000010 + -4) = DAT_005dde90 + 1;
        iVar2 = *(int *)(iVar1 + 0x34);
        *(int *)((int)register0x00000010 + -8) = iVar2;
        if (iVar2 == DAT_005dde90 + 1) {
          *(int *)((int)register0x00000010 + -0x1c) = iVar1 + 0x34;
          *(int *)((int)register0x00000010 + -0x18) = DAT_005dde90 + -1;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x414896;
          FUN_00402770();
          bVar4 = *(int *)((int)register0x00000010 + -8) == *(int *)((int)register0x00000010 + -4);
        }
        else {
          *(int *)((int)register0x00000010 + -0x1c) = iVar1 + 0x34;
          *(int *)((int)register0x00000010 + -0x18) = DAT_005dde90;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4148ae;
          FUN_00402770();
          bVar4 = *(int *)((int)register0x00000010 + -8) == *(int *)((int)register0x00000010 + -4);
        }
        if (bVar4) {
          *(undefined4 *)((int)register0x00000010 + -0x10) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined1 **)((int)register0x00000010 + -0x1c) =
               (undefined1 *)((int)register0x00000010 + -0x10);
          *(undefined1 *)((int)register0x00000010 + -0x18) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41492d;
          FUN_00426f80();
        }
        else {
          iVar1 = *(int *)((int)register0x00000010 + 8);
          if ((uint)*(ushort *)(iVar1 + 0x1a) == (uint)*(ushort *)(iVar1 + 0x3c) ||
              (int)((uint)*(ushort *)(iVar1 + 0x1a) - (uint)*(ushort *)(iVar1 + 0x3c)) < 0) {
            *(uint *)((int)register0x00000010 + -0x1c) =
                 *(int *)((int)register0x00000010 + 4) + 0x38 +
                 (*(uint *)((int)register0x00000010 + -0xc) >> 1 & 1) * 0x18;
            *(int *)((int)register0x00000010 + -0x18) = iVar1;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x414912;
            FUN_004330d0();
          }
          else {
            *(uint *)((int)register0x00000010 + -0x1c) =
                 *(int *)((int)register0x00000010 + 4) + 8 +
                 (*(uint *)((int)register0x00000010 + -0xc) >> 1 & 1) * 0x18;
            *(int *)((int)register0x00000010 + -0x18) = iVar1;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4148ee;
            FUN_004330d0();
          }
        }
        return;
      }
      *(char **)((int)register0x00000010 + -0x1c) =
           "uncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/clas..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x24;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x414947;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x41494d;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00414960 */

void FUN_00414960(void)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  uint uVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x14);
      bVar1 = **(byte **)((int)register0x00000010 + 4);
      uVar4 = (uint)(char)(bVar1 >> 1);
      if (uVar4 < 0x44) {
        bVar2 = (&DAT_005cc6a0)[uVar4];
        *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005ddde0;
        *(uint *)((int)register0x00000010 + -0x10) = (uint)bVar2;
        *(byte *)((int)register0x00000010 + -0xc) = bVar1;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4149a6;
        FUN_00429c40();
        iVar3 = *(int *)((int)register0x00000010 + -8);
        if (iVar3 != 0) {
          *(int *)((int)register0x00000010 + -4) = iVar3;
          *(int *)((int)register0x00000010 + -0x14) = iVar3;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4149ba;
          FUN_00412a30();
          *(undefined4 *)((int)register0x00000010 + 8) =
               *(undefined4 *)((int)register0x00000010 + -4);
          return;
        }
        *(undefined4 *)((int)register0x00000010 + 8) = 0;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4149dc;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar5 + -4) = 0x4149e2;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_004149f0 */

void FUN_004149f0(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
code_r0x004149f0:
  puVar5 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar5 = (undefined1 *)((int)register0x00000010 + -0x20);
    *(int *)((int)register0x00000010 + -4) = DAT_005ddf40;
    *(int *)((int)register0x00000010 + -8) = DAT_005ddf44;
    iVar2 = 0;
    iVar3 = DAT_005ddf40;
    iVar4 = DAT_005ddf44;
    do {
      if (iVar4 <= iVar2) {
        DAT_005f5da9 = 1;
        return;
      }
      uVar1 = *(uint *)(iVar3 + iVar2 * 4);
      if (0x3ff < uVar1) goto LAB_00414ac6;
      *(int *)((int)register0x00000010 + -0xc) = iVar2;
      iVar2 = *(int *)(DAT_005ddf14 + uVar1 * 4);
      iVar4 = *(int *)(iVar2 + 0x8c0);
      if (iVar4 == 0) {
        *(int *)((int)register0x00000010 + -0x10) = iVar2;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x20000;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005f84f0;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x414a8e;
        FUN_004119f0();
        if (*(int *)((int)register0x00000010 + -0x14) == 0) goto LAB_00414ab0;
        *(int *)(*(int *)((int)register0x00000010 + -0x10) + 0x8c0) =
             *(int *)((int)register0x00000010 + -0x14);
      }
      else {
        *(int *)((int)register0x00000010 + -0x20) = iVar4;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x20000;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x414a6a;
        FUN_0046f470();
      }
      iVar2 = *(int *)((int)register0x00000010 + -0xc) + 1;
      iVar4 = *(int *)((int)register0x00000010 + -8);
      iVar3 = *(int *)((int)register0x00000010 + -4);
    } while( true );
  }
  goto LAB_00414ad3;
LAB_00414ab0:
  *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004cc288;
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x2a;
  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x414ac6;
  FUN_00469a20();
LAB_00414ac6:
  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x414ad2;
  FUN_0046ee00();
LAB_00414ad3:
  *(undefined4 *)(puVar5 + -4) = 0x414ad8;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar5;
  goto code_r0x004149f0;
}



/* Function: FUN_00414ae0 */

void FUN_00414ae0(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -8) = 0;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x414aff;
      FUN_0041b100();
      if (*(char *)((int)register0x00000010 + -4) == '\0') {
        DAT_005f5da9 = 0;
        return;
      }
      *(undefined **)((int)register0x00000010 + -8) = &DAT_004c616a;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x414b29;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x414b2f;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00414b40 */

void FUN_00414b40(void)

{
  int iVar1;
  uint uVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x18);
      if ((**(byte **)((int)register0x00000010 + 0x10) & *(byte *)((int)register0x00000010 + 0x14))
          != 0) {
        uVar2 = *(uint *)((int)register0x00000010 + 4) >> 0x16;
        iVar1 = *(int *)(DAT_005ddf14 + uVar2 * 4);
        *(char *)((int)register0x00000010 + -5) = (char)(1 << ((byte)uVar2 & 7));
        iVar1 = *(int *)(iVar1 + 0x8c0) + (*(uint *)((int)register0x00000010 + 4) >> 0x19);
        *(int *)((int)register0x00000010 + -4) = iVar1;
        *(int *)((int)register0x00000010 + -0x18) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414ba9;
        FUN_00402470();
        if ((*(byte *)((int)register0x00000010 + -5) & *(byte *)((int)register0x00000010 + -0x14))
            != 0) {
          *(undefined1 *)((int)register0x00000010 + 0x1c) = 1;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(byte *)((int)register0x00000010 + -0x14) = *(byte *)((int)register0x00000010 + -5);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414bd0;
        FUN_004027f0();
        *(undefined1 *)((int)register0x00000010 + 0x1c) = 0;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414bde;
      FUN_0043a810();
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414be3;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x18) =
           "runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
      ;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x39;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414bf9;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c0d;
      FUN_0043aef0();
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c12;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c17;
      FUN_0043a870();
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c1c;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c7f9f;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x18;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c32;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c46;
      FUN_0043aef0();
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c2927;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 1;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c5c;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c70;
      FUN_0043aef0();
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c2946;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c86;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414c8b;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c2b05;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 4;
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414cb1;
      FUN_00420630();
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c2a1d;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 3;
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0xffffffff;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414cd7;
      FUN_00420630();
      *(undefined1 *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x96) = 2;
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004ca43c;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x414d02;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x414d08;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00414d10 */

void FUN_00414d10(undefined4 param_1,undefined4 param_2)

{
  FUN_00433860(param_2,param_1,0);
  FUN_004026b0(&DAT_005f68b8,param_1,0);
  FUN_00437120(VirtualAlloc_exref,0,param_1,0x3000,4);
  return;
}



/* Function: FUN_00414d90 */

void FUN_00414d90(undefined4 param_1,int param_2)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004026b0(&DAT_005f68b8,-param_2,-(uint)(param_2 != 0));
  FUN_00414f20(param_1,param_2);
  return;
}



/* Function: FUN_00414df0 */

void FUN_00414df0(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004026b0(&DAT_005f68b8,param_3,0);
  FUN_00415080(param_1,param_2);
  return;
}



/* Function: FUN_00414e50 */

void FUN_00414e50(undefined4 param_1,int param_2,undefined4 param_3)

{
  FUN_00433860(param_3,-param_2,-(uint)(param_2 != 0));
  FUN_004026b0(&DAT_005f68b8,-param_2,-(uint)(param_2 != 0));
  FUN_00415280(param_1,param_2);
  return;
}



/* Function: FUN_00414ec0 */

void FUN_00414ec0(undefined4 param_1,int param_2)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004026b0(&DAT_005f68b8,-param_2,-(uint)(param_2 != 0));
  FUN_00414f20(param_1,param_2);
  return;
}



/* Function: FUN_00414f20 */

void FUN_00414f20(void)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  bool bVar6;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x24);
      *(code **)((int)register0x00000010 + -0x24) = VirtualFree_exref;
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4000;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x414f5d;
      FUN_004370d0();
      if (*(int *)((int)register0x00000010 + -0x14) != 0) {
        return;
      }
      iVar1 = *(int *)((int)register0x00000010 + 4);
      uVar3 = *(uint *)((int)register0x00000010 + 8);
      while( true ) {
        if (uVar3 == 0) {
          return;
        }
        *(uint *)((int)register0x00000010 + -0x10) = uVar3;
        *(int *)((int)register0x00000010 + -4) = iVar1;
        uVar4 = uVar3;
        while( true ) {
          *(uint *)((int)register0x00000010 + -8) = uVar3;
          if (uVar3 < 0x1000) {
            bVar6 = false;
            uVar2 = uVar3;
          }
          else {
            *(code **)((int)register0x00000010 + -0x24) = VirtualFree_exref;
            *(int *)((int)register0x00000010 + -0x20) = iVar1;
            *(uint *)((int)register0x00000010 + -0x1c) = uVar3;
            *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4000;
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0x414fcd;
            FUN_004370d0();
            bVar6 = *(int *)((int)register0x00000010 + -0x14) == 0;
            uVar2 = *(uint *)((int)register0x00000010 + -8);
            uVar4 = *(uint *)((int)register0x00000010 + -0x10);
            iVar1 = *(int *)((int)register0x00000010 + -4);
          }
          if (!bVar6) break;
          uVar3 = uVar2 >> 1 & 0xfffff000;
        }
        if (uVar2 < 0x1000) break;
        uVar3 = uVar4 - uVar2;
        iVar1 = iVar1 + uVar2;
      }
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x414fef;
      FUN_0046f970();
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           *(undefined4 *)((int)register0x00000010 + -0x24);
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x414ffb;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c7fb7;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x18;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x415011;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x24) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x415025;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c862e;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x19;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x41503b;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x24) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x41504f;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x415054;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x415059;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x24) =
           "runtime: failed to decommit pages/cpu/classes/gc/pause:cpu-seconds/cpu/classes/gc/total:cpu-seconds/gc/limiter/last-enabled:gc-cycle/memory/classes/heap/stacks:bytes/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does no..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x21;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x41506f;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x415075;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00415080 */

void FUN_00415080(void)

{
  uint uVar1;
  char *pcVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  bool bVar7;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x28);
      *(code **)((int)register0x00000010 + -0x28) = VirtualAlloc_exref;
      *(undefined4 *)((int)register0x00000010 + -0x24) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x1000;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 4;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4150c5;
      FUN_00437120();
      iVar3 = *(int *)((int)register0x00000010 + 4);
      if (*(int *)((int)register0x00000010 + -0x14) == iVar3) {
        return;
      }
      uVar4 = *(uint *)((int)register0x00000010 + 8);
      while( true ) {
        if (uVar4 == 0) {
          return;
        }
        *(uint *)((int)register0x00000010 + -0xc) = uVar4;
        *(int *)((int)register0x00000010 + -4) = iVar3;
        uVar5 = uVar4;
        while( true ) {
          *(uint *)((int)register0x00000010 + -0x10) = uVar4;
          if (uVar4 < 0x1000) {
            bVar7 = false;
            uVar1 = uVar4;
          }
          else {
            *(code **)((int)register0x00000010 + -0x28) = VirtualAlloc_exref;
            *(int *)((int)register0x00000010 + -0x24) = iVar3;
            *(uint *)((int)register0x00000010 + -0x20) = uVar4;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x1000;
            *(undefined4 *)((int)register0x00000010 + -0x18) = 4;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41513c;
            FUN_00437120();
            bVar7 = *(int *)((int)register0x00000010 + -0x14) == 0;
            iVar3 = *(int *)((int)register0x00000010 + -4);
            uVar5 = *(uint *)((int)register0x00000010 + -0xc);
            uVar1 = *(uint *)((int)register0x00000010 + -0x10);
          }
          if (!bVar7) break;
          uVar4 = uVar1 >> 1 & 0xfffff000;
        }
        if (uVar1 < 0x1000) break;
        uVar4 = uVar5 - uVar1;
        iVar3 = iVar3 + uVar1;
      }
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x415164;
      FUN_0046f970();
      pcVar2 = *(char **)((int)register0x00000010 + -0x28);
      *(char **)((int)register0x00000010 + -8) = pcVar2;
      if (pcVar2 != (char *)0x8) goto LAB_004151e9;
      do {
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x415175;
        FUN_0043a810();
        *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c8647;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x19;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41518b;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x28) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41519f;
        FUN_0043ad50();
        *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c862e;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x19;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4151b5;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x28) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4151c9;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4151ce;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4151d3;
        FUN_0043a870();
        pcVar2 = 
        "out of memory is nil, not value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
        ;
        *(char **)((int)register0x00000010 + -0x28) =
             "out of memory is nil, not value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0xd;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4151e9;
        FUN_00469a20();
LAB_004151e9:
      } while (pcVar2 == (char *)0x5af);
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4151f5;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c8647;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x19;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41520b;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41521f;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c862e;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x19;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x415235;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x415249;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41524e;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x415253;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004ca45b;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x415269;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x41526f;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_00415280 */

void FUN_00415280(undefined4 param_1,undefined4 param_2)

{
  code *pcVar1;
  int local_8;
  
  pcVar1 = VirtualFree_exref;
  FUN_004370d0(VirtualFree_exref,param_1,0,0x8000);
  if (local_8 != 0) {
    return;
  }
  FUN_0046f970();
  FUN_0043a810();
  FUN_0043b060(&DAT_004c7fb7,0x18);
  FUN_0043ad50(param_2,0);
  FUN_0043b060(&DAT_004c862e,0x19);
  FUN_0043ad50(pcVar1,0);
  FUN_0043aa10();
  FUN_0043a870();
  FUN_00469a20("runtime: failed to release pagesruntime: fixalloc size too largeinvalid limiter event type foundscanstack: goroutine not stoppedscavenger state is already wiredsweep increased allocation countremovespecial on invalid pointergetWeakHandle on invalid pointerruntime: root level max pages = NtAssociateWaitCompletionPacket"
               ,0x20);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



/* Function: FUN_00415340 */

void FUN_00415340(undefined4 param_1,undefined4 param_2)

{
  int in_FS_OFFSET;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x4153d0;
    FUN_0046d980();
  }
  FUN_00437120(VirtualAlloc_exref,param_1,param_2,0x2000,4);
  if (local_4 != 0) {
    return;
  }
  FUN_00437120(VirtualAlloc_exref,0,param_2,0x2000,4);
  return;
}



/* Function: FUN_004153e0 */

void FUN_004153e0(void)

{
  uint uVar1;
  bool bVar2;
  undefined8 *puVar3;
  uint uVar4;
  undefined4 *puVar5;
  int iVar6;
  undefined *puVar7;
  undefined4 *puVar8;
  undefined4 uVar9;
  uint uVar10;
  undefined1 *puVar11;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined8 uVar12;
  
  do {
    puVar11 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) <
        (undefined1 *)((int)register0x00000010 + -0xa4)) {
      puVar11 = (undefined1 *)((int)register0x00000010 + -0x124);
      if (DAT_005f5daa != '\0') {
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004ae2a0;
      *(undefined4 *)((int)register0x00000010 + -0x120) = 0x44;
      *(undefined4 *)((int)register0x00000010 + -0x11c) = 0x45;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41542a;
      FUN_0046a780();
      puVar3 = *(undefined8 **)((int)register0x00000010 + -0x118);
      DAT_005d6fb4 = 0x44;
      DAT_005d6fb8 = 0x45;
      if (DAT_005f5fd0 != 0) {
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415451;
        FUN_0046ed80();
        *in_EDI = puVar3;
        in_EDI[1] = DAT_005d6fb0;
      }
      DAT_005d6fb0 = puVar3;
      *puVar3 = DAT_00550bd4;
      for (uVar4 = 1; (int)uVar4 < 0x44; uVar4 = uVar4 + 1) {
        if (DAT_005d6fb4 <= uVar4) goto LAB_00416fa2;
        DAT_005d6fb0[uVar4] = (double)(ushort)((&DAT_005cc900)[uVar4] + 1);
      }
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x7ff00000;
      uVar4 = DAT_005d6fb4 + 1;
      uVar12 = *(undefined8 *)((int)register0x00000010 + -0x48);
      if (DAT_005d6fb8 < uVar4) {
        *(undefined8 *)((int)register0x00000010 + -0x100) = uVar12;
        *(undefined8 **)((int)register0x00000010 + -0x124) = DAT_005d6fb0;
        *(uint *)((int)register0x00000010 + -0x120) = uVar4;
        *(uint *)((int)register0x00000010 + -0x11c) = DAT_005d6fb8;
        *(undefined4 *)((int)register0x00000010 + -0x118) = 1;
        *(undefined **)((int)register0x00000010 + -0x114) = &DAT_004ae2a0;
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415513;
        FUN_0046a830();
        DAT_005d6fb8 = *(uint *)((int)register0x00000010 + -0x108);
        puVar3 = *(undefined8 **)((int)register0x00000010 + -0x110);
        uVar4 = *(uint *)((int)register0x00000010 + -0x10c);
        if (DAT_005f5fd0 != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415534;
          FUN_0046ed80();
          *in_EDI = puVar3;
          in_EDI[1] = DAT_005d6fb0;
        }
        uVar12 = *(undefined8 *)((int)register0x00000010 + -0x100);
        DAT_005d6fb0 = puVar3;
      }
      DAT_005d6fb4 = uVar4;
      DAT_005d6fb0[uVar4 - 1] = uVar12;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415562;
      FUN_0040d750();
      DAT_005d6fc4 = *(undefined4 *)((int)register0x00000010 + -0x120);
      DAT_005d6fc8 = *(undefined4 *)((int)register0x00000010 + -0x11c);
      uVar9 = *(undefined4 *)((int)register0x00000010 + -0x124);
      if (DAT_005f5fd0 != 0) {
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415588;
        FUN_0046ed80();
        *in_EDI = uVar9;
        in_EDI[1] = DAT_005d6fc0;
      }
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) = 0x38;
      *(undefined4 *)((int)register0x00000010 + -0x11c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4155b7;
      DAT_005d6fc0 = uVar9;
      FUN_00468700();
      *(undefined4 *)((int)register0x00000010 + -4) =
           *(undefined4 *)((int)register0x00000010 + -0x118);
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -0x118);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c7fcf;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x18;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4155e6;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = 0;
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415609;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b24;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x54) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x27;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415658;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x54);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41567e;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b50;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x58) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004cc2b2;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x2a;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4156cd;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x58);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4156f3;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b7c;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x5c) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x25;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415742;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x5c);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415768;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536ba8;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x60) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/cpu/classes/gc/pause:cpu-seconds/cpu/classes/gc/total:cpu-seconds/gc/limiter/last-enabled:gc-cycle/memory/classes/heap/stacks:bytes/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a cor..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x21;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4157b7;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x60);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4157dd;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bd4;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -100) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/cpu/classes/gc/total:cpu-seconds/gc/limiter/last-enabled:gc-cycle/memory/classes/heap/stacks:bytes/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x21;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41582c;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -100);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415852;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bf4;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x68) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1d;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4158a1;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x68);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4158c7;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bf8;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x6c) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004cbe68;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x28;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415916;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x6c);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41593c;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bfc;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x70) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004cc788;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x2c;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41598b;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x70);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4159b1;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536c00;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x74) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x27;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415a00;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x74);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415a26;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b28;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x78) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004ca08e;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1e;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415a75;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x78);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415a9b;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b2c;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 4;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x7c) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1d;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415aea;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x7c);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415b10;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b30;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x80) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004ca0ac;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1e;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415b5f;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x80);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415b85;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b34;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x84) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/gc/cycles/forced:gc-cycles/memory/classes/other:bytes/memory/classes/total:bytesfailed to set sweep barrierwork.nwait was > work.nproc not in stack roots range [allocated pages below zero?address not a stack addressmspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[ori..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1b;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415bd4;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x84);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415bfa;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b38;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x88) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c8bfe;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1a;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415c49;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x88);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415c6f;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b3c;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 8;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x8c) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c736a;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x16;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415cbe;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x8c);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415ce4;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b40;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 8;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x90) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c617d;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415d33;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x90);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415d59;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b44;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 8;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x94) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c67e8;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415da8;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x94);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415dce;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b48;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 8;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x98) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c67fc;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415e1d;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x98);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415e43;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b4c;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0x9c) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1d;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415e92;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0x9c);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415eb8;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b54;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xa0) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c6d65;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x15;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415f07;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xa0);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415f2d;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b58;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xa4) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c79fe;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x17;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415f7c;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xa4);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415fa2;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b5c;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xa8) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1c;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x415fee;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xa8);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416011;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b60;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xac) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c6810;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41605d;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xac);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416080;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b64;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xb0) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c7380;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x16;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4160cc;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xb0);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4160ef;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b68;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xb4) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c6190;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41613b;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xb4);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41615e;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b6c;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c6824;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416194;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = 0;
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4161b7;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b70;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4161ed;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = 0;
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416210;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b74;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xb8) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c61a3;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41625c;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xb8);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41627f;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b78;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xbc) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c7fe7;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x18;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4162cb;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xbc);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4162ee;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b80;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xc0) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1c;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41633a;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xc0);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41635d;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b84;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/gc/limiter/last-enabled:gc-cycle/memory/classes/heap/stacks:bytes/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larg..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x21;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416393;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = 0;
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4163b6;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b88;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c5bda;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x12;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4163ec;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = 0;
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41640f;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b8c;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1d;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416445;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = 0;
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416468;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b90;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xc4) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004ca47a;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4164b4;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xc4);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4164d7;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b94;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -200) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page s..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x22;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416523;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -200);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416546;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b98;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xcc) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly ..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x23;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416592;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xcc);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4165b5;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536b9c;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xd0) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/memory/classes/heap/stacks:bytes/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtim..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x21;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416601;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xd0);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416624;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536ba0;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 1;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xd4) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/memory/classes/heap/unused:bytes/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrierunc..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x21;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416670;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xd4);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416693;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536ba4;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xd8) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004cc2dc;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x2a;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4166df;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xd8);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416702;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bac;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xdc) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004cc4d5;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x2b;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41674e;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xdc);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416771;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bb0;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xe0) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004cc071;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x29;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4167bd;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xe0);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4167e0;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bb4;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xe4) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004cc306;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x2a;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41682c;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xe4);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41684f;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bb8;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 1;
      uVar4 = 0;
      uVar10 = 0;
      for (iVar6 = 0; *(uint *)((int)register0x00000010 + -0xe8) = uVar4, iVar6 < 2;
          iVar6 = iVar6 + 1) {
        if (*(uint *)((int)register0x00000010 + iVar6 * 4 + -0x30) >> 6 != 0) goto LAB_00416f96;
        uVar4 = *(uint *)((int)register0x00000010 + iVar6 * 4 + -0x30) & 0x3f;
        uVar1 = uVar4 - 0x20;
        *(int *)((int)register0x00000010 + -0x3c) = 1 << ((byte)uVar1 & 0x1f);
        uVar4 = *(uint *)((int)register0x00000010 + -0xe8) |
                1 << ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20);
        in_EDI = (undefined4 *)
                 (*(uint *)((int)register0x00000010 + -0x3c) & -(uint)(uVar1 < 0x20) |
                 -(uint)(-uVar1 < 0x20) & 1U >> ((byte)-uVar1 & 0x1f));
        uVar10 = uVar10 | (uint)in_EDI;
      }
      *(uint *)((int)register0x00000010 + -0x4c) = uVar10;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/c..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x24;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416925;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xe8);
      puVar5[1] = *(undefined4 *)((int)register0x00000010 + -0x4c);
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x41694b;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bbc;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xec) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004ca499;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416997;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xec);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x4169ba;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bc0;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xf0) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/memory/classes/other:bytes/memory/classes/total:bytesfailed to set sweep barrierwork.nwait was > work.nproc not in stack roots range [allocated pages below zero?address not a stack addressmspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine tra..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1b;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416a06;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xf0);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416a29;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bc4;
      uVar9 = 0;
      bVar2 = false;
      while (!bVar2) {
        uVar9 = 2;
        bVar2 = true;
      }
      *(undefined4 *)((int)register0x00000010 + -0xf4) = uVar9;
      *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
      *(undefined4 *)((int)register0x00000010 + -0x120) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(char **)((int)register0x00000010 + -0x11c) =
           "/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x118) = 0x27;
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416a75;
      FUN_00406220();
      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
      *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xf4);
      puVar5[1] = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = puVar5[2];
        *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416a98;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      puVar5[2] = &PTR_LAB_00536bc8;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 1;
      iVar6 = 0;
      uVar4 = 0;
      uVar10 = 0;
      while( true ) {
        *(uint *)((int)register0x00000010 + -0xf8) = uVar4;
        if (1 < iVar6) {
          *(uint *)((int)register0x00000010 + -0x50) = uVar10;
          *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
          *(undefined4 *)((int)register0x00000010 + -0x120) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(char **)((int)register0x00000010 + -0x11c) =
               "/memory/classes/total:bytesfailed to set sweep barrierwork.nwait was > work.nproc not in stack roots range [allocated pages below zero?address not a stack addressmspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMi..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1b;
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416b6e;
          FUN_00406220();
          puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
          *puVar5 = *(undefined4 *)((int)register0x00000010 + -0xf8);
          puVar5[1] = *(undefined4 *)((int)register0x00000010 + -0x50);
          if (DAT_005f5fd0 != 0) {
            uVar9 = puVar5[2];
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416b94;
            FUN_0046ed70();
            *in_EDI = uVar9;
          }
          puVar5[2] = &PTR_LAB_00536bcc;
          *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
          *(undefined4 *)((int)register0x00000010 + -0x120) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c8660;
          *(undefined4 *)((int)register0x00000010 + -0x118) = 0x19;
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416bca;
          FUN_00406220();
          puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
          *puVar5 = 0;
          puVar5[1] = 0;
          if (DAT_005f5fd0 != 0) {
            uVar9 = puVar5[2];
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416bed;
            FUN_0046ed70();
            *in_EDI = uVar9;
          }
          puVar5[2] = &PTR_LAB_00536bd0;
          *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
          *(undefined4 *)((int)register0x00000010 + -0x120) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(char **)((int)register0x00000010 + -0x11c) =
               "/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
          ;
          *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1c;
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416c23;
          FUN_00406220();
          puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
          *puVar5 = 0;
          puVar5[1] = 0;
          if (DAT_005f5fd0 != 0) {
            uVar9 = puVar5[2];
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416c46;
            FUN_0046ed70();
            *in_EDI = uVar9;
          }
          puVar5[2] = &PTR_LAB_00536bd8;
          *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
          *(undefined4 *)((int)register0x00000010 + -0x120) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004c7fff;
          *(undefined4 *)((int)register0x00000010 + -0x118) = 0x18;
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416c7c;
          FUN_00406220();
          puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
          *puVar5 = 0;
          puVar5[1] = 0;
          if (DAT_005f5fd0 != 0) {
            uVar9 = puVar5[2];
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416c9f;
            FUN_0046ed70();
            *in_EDI = uVar9;
          }
          puVar5[2] = &PTR_LAB_00536bdc;
          *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
          *(undefined4 *)((int)register0x00000010 + -0x120) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(char **)((int)register0x00000010 + -0x11c) =
               "/sched/pauses/stopping/gc:seconds/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x118) = 0x21;
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416cd5;
          FUN_00406220();
          puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
          *puVar5 = 0;
          puVar5[1] = 0;
          if (DAT_005f5fd0 != 0) {
            uVar9 = puVar5[2];
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416cf8;
            FUN_0046ed70();
            *in_EDI = uVar9;
          }
          puVar5[2] = &PTR_LAB_00536be0;
          *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
          *(undefined4 *)((int)register0x00000010 + -0x120) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(char **)((int)register0x00000010 + -0x11c) =
               "/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/me..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x118) = 0x24;
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416d2e;
          FUN_00406220();
          puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
          *puVar5 = 0;
          puVar5[1] = 0;
          if (DAT_005f5fd0 != 0) {
            uVar9 = puVar5[2];
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416d51;
            FUN_0046ed70();
            *in_EDI = uVar9;
          }
          puVar5[2] = &PTR_LAB_00536be4;
          *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
          *(undefined4 *)((int)register0x00000010 + -0x120) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004ca0ca;
          *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1e;
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416d87;
          FUN_00406220();
          puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
          *puVar5 = 0;
          puVar5[1] = 0;
          if (DAT_005f5fd0 != 0) {
            uVar9 = puVar5[2];
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416daa;
            FUN_0046ed70();
            *in_EDI = uVar9;
          }
          puVar5[2] = &PTR_LAB_00536be8;
          *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
          *(undefined4 *)((int)register0x00000010 + -0x120) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(char **)((int)register0x00000010 + -0x11c) =
               "/sched/pauses/total/other:secondsmin must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:by..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x118) = 0x21;
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416de0;
          FUN_00406220();
          puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
          *puVar5 = 0;
          puVar5[1] = 0;
          if (DAT_005f5fd0 != 0) {
            uVar9 = puVar5[2];
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416e03;
            FUN_0046ed70();
            *in_EDI = uVar9;
          }
          puVar5[2] = &PTR_LAB_00536bec;
          *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
          *(undefined4 *)((int)register0x00000010 + -0x120) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined **)((int)register0x00000010 + -0x11c) = &DAT_004ca0e8;
          *(undefined4 *)((int)register0x00000010 + -0x118) = 0x1e;
          *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416e39;
          FUN_00406220();
          puVar5 = *(undefined4 **)((int)register0x00000010 + -0x114);
          *puVar5 = 0;
          puVar5[1] = 0;
          if (DAT_005f5fd0 == 0) {
            uVar9 = *(undefined4 *)((int)register0x00000010 + -4);
          }
          else {
            uVar9 = puVar5[2];
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416e65;
            FUN_0046ed90();
            *in_EDI = uVar9;
            uVar9 = *(undefined4 *)((int)register0x00000010 + -4);
            in_EDI[1] = uVar9;
            in_EDI[2] = DAT_005d6db4;
          }
          puVar5[2] = &PTR_LAB_00536bf0;
          puVar7 = PTR_PTR_005cf1a0;
          iVar6 = DAT_005cf1a4;
          DAT_005d6db4 = uVar9;
          while (0 < iVar6) {
            *(int *)((int)register0x00000010 + -0x40) = iVar6;
            puVar5 = (undefined4 *)((int)register0x00000010 + -0x28);
            *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416ec1;
            FUN_0046f410();
            if (*(char *)((int)register0x00000010 + -0xc) == '\0') {
              *(undefined **)((int)register0x00000010 + -8) = puVar7;
              *(undefined4 *)((int)register0x00000010 + -0x124) = 0;
              *(undefined **)((int)register0x00000010 + -0x120) = &DAT_004ca106;
              *(undefined4 *)((int)register0x00000010 + -0x11c) = 0x1e;
              *(undefined4 *)((int)register0x00000010 + -0x118) =
                   *(undefined4 *)((int)register0x00000010 + -0x28);
              *(undefined4 *)((int)register0x00000010 + -0x114) =
                   *(undefined4 *)((int)register0x00000010 + -0x24);
              *(undefined **)((int)register0x00000010 + -0x110) = &DAT_004c2eeb;
              *(undefined4 *)((int)register0x00000010 + -0x10c) = 7;
              *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416f1a;
              FUN_00451e50();
              *(undefined **)((int)register0x00000010 + -0x124) = &DAT_004aff60;
              *(undefined4 *)((int)register0x00000010 + -0x120) = DAT_005d6db4;
              *(undefined4 *)((int)register0x00000010 + -0x11c) =
                   *(undefined4 *)((int)register0x00000010 + -0x108);
              *(undefined4 *)((int)register0x00000010 + -0x118) =
                   *(undefined4 *)((int)register0x00000010 + -0x104);
              *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416f42;
              FUN_00406220();
              puVar8 = *(undefined4 **)((int)register0x00000010 + -0x114);
              *puVar8 = 0;
              puVar8[1] = 0;
              if (DAT_005f5fd0 != 0) {
                uVar9 = puVar8[2];
                *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416f65;
                FUN_0046ed70();
                *puVar5 = uVar9;
              }
              puVar8[2] = &PTR_LAB_00536ab4;
              puVar7 = *(undefined **)((int)register0x00000010 + -8);
            }
            puVar7 = puVar7 + 0x20;
            iVar6 = *(int *)((int)register0x00000010 + -0x40) + -1;
          }
          DAT_005f5daa = 1;
          return;
        }
        if (*(uint *)((int)register0x00000010 + iVar6 * 4 + -0x38) >> 6 != 0) break;
        uVar4 = *(uint *)((int)register0x00000010 + iVar6 * 4 + -0x38) & 0x3f;
        *(int *)((int)register0x00000010 + -0x3c) = 1 << ((byte)uVar4 & 0x1f);
        uVar1 = uVar4 - 0x20;
        iVar6 = iVar6 + 1;
        uVar4 = *(uint *)((int)register0x00000010 + -0xf8) |
                *(uint *)((int)register0x00000010 + -0x3c) & -(uint)(uVar4 < 0x20);
        in_EDI = (undefined4 *)(-(uint)(-uVar1 < 0x20) & 1U >> ((byte)-uVar1 & 0x1f));
        uVar10 = uVar10 | 1 << ((byte)uVar1 & 0x1f) & -(uint)(uVar1 < 0x20) | (uint)in_EDI;
      }
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416f96;
      FUN_0046ee00();
LAB_00416f96:
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416fa2;
      FUN_0046ee00();
LAB_00416fa2:
      *(undefined4 *)((int)register0x00000010 + -0x128) = 0x416fa7;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar11 + -4) = 0x416fad;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar11;
  } while( true );
}



/* Function: FUN_00416ff0 */

void FUN_00416ff0(void)

{
  int *piVar1;
  int *piVar2;
  int iVar3;
  undefined4 uVar4;
  uint uVar5;
  int iVar6;
  undefined4 uVar7;
  undefined1 *puVar8;
  undefined4 uVar9;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  
code_r0x00416ff0:
  puVar8 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar8 = (undefined1 *)((int)register0x00000010 + -0x18);
    if (DAT_005f5e04 == 0) {
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005f5df4;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x417025;
      FUN_0040ecf0();
      if ((DAT_005f5df8 != (int *)0x0) && (DAT_005f5df8[2] != 0xcc)) goto LAB_004170ae;
      if (DAT_005f5dfc != (int *)0x0) goto LAB_00417090;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x1000;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
      *(undefined **)((int)register0x00000010 + -0x10) = &DAT_005f84f0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x417060;
      FUN_004119f0();
      DAT_005f5dfc = *(int **)((int)register0x00000010 + -0xc);
      *DAT_005f5dfc = (int)DAT_005f5e00;
      DAT_005f5e00 = DAT_005f5dfc;
      if (DAT_005f6280 != '\0') goto LAB_00417090;
      iVar3 = 0;
      do {
        if (iVar3 < 0x80) {
          uVar5 = iVar3 + (iVar3 / 5 + (iVar3 >> 0x1f)) * -5;
          if (4 < uVar5) goto code_r0x004171cd;
        }
        else {
LAB_00417090:
          piVar2 = DAT_005f5dfc;
          piVar1 = DAT_005f5dfc + 1;
          DAT_005f5dfc = (int *)DAT_005f5dfc[1];
          *piVar1 = (int)DAT_005f5df8;
          DAT_005f5df8 = piVar2;
LAB_004170ae:
          uVar5 = DAT_005f5df8[2];
          if (uVar5 < 0xcc) {
            *(int **)((int)register0x00000010 + -4) = DAT_005f5df8;
            *(uint *)((int)register0x00000010 + -8) = uVar5;
            *(int **)((int)register0x00000010 + -0x18) = DAT_005f5df8 + 2;
            *(undefined4 *)((int)register0x00000010 + -0x14) = 1;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4170dd;
            FUN_00402690();
            iVar3 = *(int *)((int)register0x00000010 + -8) * 5;
            if (DAT_005f5fd0 == 0) {
              uVar4 = *(undefined4 *)((int)register0x00000010 + 8);
              iVar6 = *(int *)((int)register0x00000010 + -4);
              uVar7 = *(undefined4 *)((int)register0x00000010 + 0x10);
              uVar9 = *(undefined4 *)((int)register0x00000010 + 0x14);
            }
            else {
              *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x417105;
              FUN_0046ede0();
              uVar4 = *(undefined4 *)((int)register0x00000010 + 8);
              *in_EDI = uVar4;
              iVar6 = *(int *)((int)register0x00000010 + -4);
              in_EDI[1] = *(undefined4 *)(iVar6 + 0x10 + iVar3 * 4);
              uVar7 = *(undefined4 *)((int)register0x00000010 + 0x10);
              in_EDI[2] = uVar7;
              in_EDI[3] = *(undefined4 *)(iVar6 + 0x1c + iVar3 * 4);
              uVar9 = *(undefined4 *)((int)register0x00000010 + 0x14);
              in_EDI[4] = uVar9;
              in_EDI[5] = *(undefined4 *)(iVar6 + 0x20 + iVar3 * 4);
              in_EDI[6] = *(undefined4 *)((int)register0x00000010 + 4);
              in_EDI[7] = *(undefined4 *)(iVar6 + 0x14 + iVar3 * 4);
            }
            *(undefined4 *)(iVar6 + 0x10 + iVar3 * 4) = uVar4;
            *(undefined4 *)(iVar6 + 0x18 + iVar3 * 4) =
                 *(undefined4 *)((int)register0x00000010 + 0xc);
            *(undefined4 *)(iVar6 + 0x1c + iVar3 * 4) = uVar7;
            *(undefined4 *)(iVar6 + 0x20 + iVar3 * 4) = uVar9;
            *(undefined4 *)(iVar6 + 0x14 + iVar3 * 4) = *(undefined4 *)((int)register0x00000010 + 4)
            ;
            *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005f5df4;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41716c;
            FUN_0040f0e0();
            *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005f5df0;
            *(undefined4 *)((int)register0x00000010 + -0x14) = 8;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x417183;
            FUN_00402820();
            return;
          }
          iVar3 = 0xcc;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x417191;
          FUN_0046ee00();
        }
        (&DAT_005f6280)[iVar3] = (&DAT_005cc2cc)[uVar5];
        iVar3 = iVar3 + 1;
      } while( true );
    }
    goto LAB_004171d7;
  }
  goto LAB_004171ee;
code_r0x004171cd:
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4171d7;
  FUN_0046edf0();
LAB_004171d7:
  *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c8017;
  *(undefined4 *)((int)register0x00000010 + -0x14) = 0x18;
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4171ed;
  FUN_00469a20();
LAB_004171ee:
  *(undefined4 *)(puVar8 + -4) = 0x4171f3;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar8;
  goto code_r0x00416ff0;
}



/* Function: FUN_00417200 */

void FUN_00417200(void)

{
  int in_FS_OFFSET;
  int in_stack_fffffff4;
  char local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 'g';
    FUN_0046d980();
  }
  FUN_00402510(&DAT_005f5df0);
  if (in_stack_fffffff4 == 0) {
    FUN_00402540(&DAT_005f5df0,0,1);
    if (local_4 != '\0') {
      FUN_00444df0(&PTR_LAB_00536c60);
    }
  }
  return;
}



/* Function: FUN_004177d0 */

void FUN_004177d0(void)

{
  undefined *puVar1;
  uint *puVar2;
  char *pcVar3;
  int *piVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int iVar7;
  int iVar8;
  char *pcVar9;
  undefined **ppuVar10;
  int iVar11;
  undefined1 *puVar12;
  byte bVar13;
  char *pcVar14;
  uint uVar15;
  int iVar16;
  uint uVar17;
  int in_FS_OFFSET;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x6c);
      pcVar9 = *(char **)((int)register0x00000010 + 4);
      if (pcVar9 != (char *)0x0) {
        if ((pcVar9[0xf] & 0x1fU) == 0x16) {
          if (*(int *)(pcVar9 + 0x20) != 0) {
            uVar15 = *(uint *)((int)register0x00000010 + 8);
            iVar7 = *(int *)(DAT_005ddf14 + (uVar15 >> 0x16) * 4);
            if (iVar7 == 0) {
              iVar7 = 0;
            }
            else {
              iVar7 = *(int *)(iVar7 + (uVar15 >> 0xb & 0x7fc));
            }
            if ((iVar7 == 0) || (*(char *)(iVar7 + 0x41) == '\0')) {
              if (DAT_005f626c != 0) {
                return;
              }
              *(char **)((int)register0x00000010 + -0x28) = pcVar9;
              *(uint *)((int)register0x00000010 + -0x6c) = uVar15;
              *(undefined4 *)((int)register0x00000010 + -0x68) = 0;
              *(undefined4 *)((int)register0x00000010 + -100) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417875;
              FUN_004688e0();
              iVar7 = *(int *)((int)register0x00000010 + -0x60);
              if (iVar7 != 0) {
                bVar13 = *(byte *)(*(int *)((int)register0x00000010 + -0x5c) + 0x3e);
                if ((((bVar13 & 1) == 0) &&
                    (0x80 < *(uint *)(*(int *)((int)register0x00000010 + -0x5c) + 0x44))) &&
                   (bVar13 >> 1 != 0)) {
                  iVar7 = iVar7 + 8;
                }
                if (*(int *)((int)register0x00000010 + 8) == iVar7) {
                  pcVar9 = *(char **)((int)register0x00000010 + -0x28);
                }
                else {
                  pcVar9 = *(char **)((int)register0x00000010 + -0x28);
                  puVar2 = *(uint **)(pcVar9 + 0x20);
                  if (((puVar2 == (uint *)0x0) || (puVar2[1] != 0)) || (0xf < *puVar2))
                  goto LAB_00417d52;
                }
                iVar7 = *(int *)((int)register0x00000010 + 0xc);
                if (iVar7 == 0) {
                  *(undefined1 **)((int)register0x00000010 + -8) = &LAB_00417ee0;
                  *(undefined1 **)((int)register0x00000010 + -4) =
                       (undefined1 *)((int)register0x00000010 + 4);
                  *(undefined1 **)((int)register0x00000010 + -0x6c) =
                       (undefined1 *)((int)register0x00000010 + -8);
                  *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417acf;
                  FUN_0046d890();
                  return;
                }
                if ((*(byte *)(iVar7 + 0xf) & 0x1f) == 0x13) {
                  *(int *)((int)register0x00000010 + -0x30) = iVar7;
                  if ((*(ushort *)(iVar7 + 0x22) & 0x8000) == 0) {
                    if (*(short *)(iVar7 + 0x20) == 1) {
                      if ((*(byte *)(iVar7 + 0xc) & 1) == 0) {
                        iVar8 = 0x24;
                      }
                      else {
                        iVar8 = 0x34;
                      }
                      pcVar3 = *(char **)(iVar7 + iVar8);
                      *(char **)((int)register0x00000010 + -0x2c) = pcVar3;
                      if (pcVar3 == pcVar9) {
LAB_00417a53:
                        uVar15 = *(ushort *)(iVar7 + 0x22) & 0x7fff;
                        if ((short)uVar15 == 0) {
                          iVar8 = 0;
                          iVar7 = 0;
LAB_00417aab:
                          iVar16 = 0;
                          for (iVar11 = 0; iVar11 < iVar8; iVar11 = iVar11 + 1) {
                            piVar4 = *(int **)(iVar7 + iVar11 * 4);
                            uVar15 = (uint)*(byte *)((int)piVar4 + 0xd);
                            iVar16 = (iVar16 + -1 + uVar15 & -uVar15) + *piVar4;
                          }
                          *(uint *)((int)register0x00000010 + -0x38) = iVar16 + 3U & 0xfffffffc;
                          *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417b01;
                          FUN_00417200();
                          *(undefined1 **)((int)register0x00000010 + -0x20) = &LAB_00417e70;
                          *(undefined1 **)((int)register0x00000010 + -0x1c) =
                               (undefined1 *)((int)register0x00000010 + 4);
                          *(undefined1 **)((int)register0x00000010 + -0x18) =
                               (undefined1 *)((int)register0x00000010 + 0xc);
                          *(undefined4 *)((int)register0x00000010 + -0x14) =
                               *(undefined4 *)((int)register0x00000010 + -0x38);
                          *(undefined4 *)((int)register0x00000010 + -0x10) =
                               *(undefined4 *)((int)register0x00000010 + -0x2c);
                          *(undefined4 *)((int)register0x00000010 + -0xc) =
                               *(undefined4 *)((int)register0x00000010 + -0x28);
                          *(undefined1 **)((int)register0x00000010 + -0x6c) =
                               (undefined1 *)((int)register0x00000010 + -0x20);
                          *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417b3f;
                          FUN_0046d890();
                          return;
                        }
                        if ((*(byte *)(iVar7 + 0xc) & 1) == 0) {
                          iVar8 = 0x24;
                        }
                        else {
                          iVar8 = 0x34;
                        }
                        uVar17 = (uint)*(ushort *)(iVar7 + 0x20);
                        uVar15 = uVar15 + uVar17 & 0xffff;
                        iVar7 = iVar7 + iVar8;
                        if (uVar17 <= uVar15) {
                          iVar8 = uVar15 - uVar17;
                          iVar7 = iVar7 + (-iVar8 >> 0x1f & uVar17 << 2);
                          goto LAB_00417aab;
                        }
                        *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417b4c;
                        FUN_0046ee80();
                      }
                      else if ((pcVar3[0xf] & 0x1fU) == 0x16) {
                        if ((pcVar3[0xc] & 1U) == 0) {
                          pcVar14 = (char *)0x0;
                        }
                        else {
                          pcVar14 = pcVar3 + 0x24;
                        }
                        if (pcVar14 != (char *)0x0) {
                          if ((pcVar9[0xc] & 1U) == 0) {
                            pcVar14 = (char *)0x0;
                          }
                          else {
                            bVar13 = pcVar9[0xf] & 0x1f;
                            if (bVar13 < 0x15) {
                              if (bVar13 < 0x13) {
                                if (bVar13 == 0x11) {
                                  pcVar14 = pcVar9 + 0x2c;
                                }
                                else if (bVar13 == 0x12) {
                                  pcVar14 = pcVar9 + 0x28;
                                }
                                else {
LAB_004179f4:
                                  pcVar14 = pcVar9 + 0x20;
                                }
                              }
                              else if (bVar13 == 0x13) {
                                pcVar14 = pcVar9 + 0x24;
                              }
                              else {
                                pcVar14 = pcVar9 + 0x30;
                              }
                            }
                            else if (bVar13 < 0x17) {
                              if (bVar13 == 0x15) {
                                pcVar14 = pcVar9 + 0x40;
                              }
                              else {
                                pcVar14 = pcVar9 + 0x24;
                              }
                            }
                            else if (bVar13 == 0x17) {
                              pcVar14 = pcVar9 + 0x24;
                            }
                            else {
                              if (bVar13 != 0x19) goto LAB_004179f4;
                              pcVar14 = pcVar9 + 0x30;
                            }
                          }
                          if (pcVar14 != (char *)0x0) goto LAB_00417b4c;
                        }
                        if (*(int *)(pcVar9 + 0x20) == *(int *)(pcVar3 + 0x20)) goto LAB_00417a53;
                      }
                      else if ((pcVar3[0xf] & 0x1fU) == 0x14) {
                        if (*(int *)(pcVar3 + 0x28) != 0) {
                          if (*(int *)((int)register0x00000010 + 4) == 0) {
                            iVar8 = 0;
                          }
                          else {
                            *(char **)((int)register0x00000010 + -0x6c) = pcVar3;
                            *(int *)((int)register0x00000010 + -0x68) =
                                 *(int *)((int)register0x00000010 + 4);
                            *(undefined1 *)((int)register0x00000010 + -100) = 1;
                            *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417a3b;
                            FUN_00468020();
                            iVar8 = *(int *)((int)register0x00000010 + -0x60);
                            pcVar9 = *(char **)((int)register0x00000010 + -0x28);
                            iVar7 = *(int *)((int)register0x00000010 + -0x30);
                          }
                          if (iVar8 == 0) goto LAB_00417b4c;
                        }
                        goto LAB_00417a53;
                      }
LAB_00417b4c:
                      *(char **)((int)register0x00000010 + -0x6c) = pcVar9;
                      *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417b54;
                      FUN_00462470();
                      *(undefined4 *)((int)register0x00000010 + -0x24) =
                           *(undefined4 *)((int)register0x00000010 + -0x68);
                      *(undefined4 *)((int)register0x00000010 + -0x34) =
                           *(undefined4 *)((int)register0x00000010 + -100);
                      *(undefined4 *)((int)register0x00000010 + -0x6c) =
                           *(undefined4 *)((int)register0x00000010 + -0x30);
                      *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417b70;
                      FUN_00462470();
                      uVar5 = *(undefined4 *)((int)register0x00000010 + -0x68);
                      uVar6 = *(undefined4 *)((int)register0x00000010 + -100);
                      *(undefined4 *)((int)register0x00000010 + -0x6c) = 0;
                      *(char **)((int)register0x00000010 + -0x68) =
                           "runtime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu..." /* TRUNCATED STRING LITERAL */
                      ;
                      *(undefined4 *)((int)register0x00000010 + -100) = 0x22;
                      *(undefined4 *)((int)register0x00000010 + -0x60) =
                           *(undefined4 *)((int)register0x00000010 + -0x24);
                      *(undefined4 *)((int)register0x00000010 + -0x5c) =
                           *(undefined4 *)((int)register0x00000010 + -0x34);
                      pcVar9 = 
                      " to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                      ;
                      *(char **)((int)register0x00000010 + -0x58) =
                           " to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                      ;
                      *(undefined4 *)((int)register0x00000010 + -0x54) = 0xe;
                      *(undefined4 *)((int)register0x00000010 + -0x50) = uVar5;
                      *(undefined4 *)((int)register0x00000010 + -0x4c) = uVar6;
                      *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417bc0;
                      FUN_00451ee0();
                      *(undefined4 *)((int)register0x00000010 + -0x6c) =
                           *(undefined4 *)((int)register0x00000010 + -0x48);
                      *(undefined4 *)((int)register0x00000010 + -0x68) =
                           *(undefined4 *)((int)register0x00000010 + -0x44);
                      *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417bd4;
                      FUN_00469a20();
                    }
                    *(char **)((int)register0x00000010 + -0x6c) = pcVar9;
                    *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417bdc;
                    FUN_00462470();
                    *(undefined4 *)((int)register0x00000010 + -0x24) =
                         *(undefined4 *)((int)register0x00000010 + -0x68);
                    *(undefined4 *)((int)register0x00000010 + -0x34) =
                         *(undefined4 *)((int)register0x00000010 + -100);
                    *(undefined4 *)((int)register0x00000010 + -0x6c) =
                         *(undefined4 *)((int)register0x00000010 + -0x30);
                    *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417bf8;
                    FUN_00462470();
                    uVar5 = *(undefined4 *)((int)register0x00000010 + -0x68);
                    uVar6 = *(undefined4 *)((int)register0x00000010 + -100);
                    *(undefined4 *)((int)register0x00000010 + -0x6c) = 0;
                    *(char **)((int)register0x00000010 + -0x68) =
                         "runtime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu..." /* TRUNCATED STRING LITERAL */
                    ;
                    *(undefined4 *)((int)register0x00000010 + -100) = 0x22;
                    *(undefined4 *)((int)register0x00000010 + -0x60) =
                         *(undefined4 *)((int)register0x00000010 + -0x24);
                    *(undefined4 *)((int)register0x00000010 + -0x5c) =
                         *(undefined4 *)((int)register0x00000010 + -0x34);
                    pcVar9 = 
                    " to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                    ;
                    *(char **)((int)register0x00000010 + -0x58) =
                         " to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                    ;
                    *(undefined4 *)((int)register0x00000010 + -0x54) = 0xe;
                    *(undefined4 *)((int)register0x00000010 + -0x50) = uVar5;
                    *(undefined4 *)((int)register0x00000010 + -0x4c) = uVar6;
                    *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417c48;
                    FUN_00451ee0();
                    *(undefined4 *)((int)register0x00000010 + -0x6c) =
                         *(undefined4 *)((int)register0x00000010 + -0x48);
                    *(undefined4 *)((int)register0x00000010 + -0x68) =
                         *(undefined4 *)((int)register0x00000010 + -0x44);
                    *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417c5c;
                    FUN_00469a20();
                  }
                  *(char **)((int)register0x00000010 + -0x6c) = pcVar9;
                  *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417c64;
                  FUN_00462470();
                  *(undefined4 *)((int)register0x00000010 + -0x24) =
                       *(undefined4 *)((int)register0x00000010 + -0x68);
                  *(undefined4 *)((int)register0x00000010 + -0x34) =
                       *(undefined4 *)((int)register0x00000010 + -100);
                  *(undefined4 *)((int)register0x00000010 + -0x6c) =
                       *(undefined4 *)((int)register0x00000010 + -0x30);
                  *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417c80;
                  FUN_00462470();
                  uVar5 = *(undefined4 *)((int)register0x00000010 + -0x68);
                  uVar6 = *(undefined4 *)((int)register0x00000010 + -100);
                  *(undefined4 *)((int)register0x00000010 + -0x6c) = 0;
                  *(char **)((int)register0x00000010 + -0x68) =
                       "runtime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu..." /* TRUNCATED STRING LITERAL */
                  ;
                  *(undefined4 *)((int)register0x00000010 + -100) = 0x22;
                  *(undefined4 *)((int)register0x00000010 + -0x60) =
                       *(undefined4 *)((int)register0x00000010 + -0x24);
                  *(undefined4 *)((int)register0x00000010 + -0x5c) =
                       *(undefined4 *)((int)register0x00000010 + -0x34);
                  *(char **)((int)register0x00000010 + -0x58) =
                       " to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                  ;
                  *(undefined4 *)((int)register0x00000010 + -0x54) = 0xe;
                  *(undefined4 *)((int)register0x00000010 + -0x50) = uVar5;
                  *(undefined4 *)((int)register0x00000010 + -0x4c) = uVar6;
                  *(undefined **)((int)register0x00000010 + -0x48) = &DAT_004c5bec;
                  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x12;
                  *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417ce2;
                  FUN_00451f90();
                  *(undefined4 *)((int)register0x00000010 + -0x6c) =
                       *(undefined4 *)((int)register0x00000010 + -0x40);
                  *(undefined4 *)((int)register0x00000010 + -0x68) =
                       *(undefined4 *)((int)register0x00000010 + -0x3c);
                  *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417cf6;
                  FUN_00469a20();
                }
                *(int *)((int)register0x00000010 + -0x6c) = iVar7;
                *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417cfe;
                FUN_00462470();
                uVar5 = *(undefined4 *)((int)register0x00000010 + -0x68);
                uVar6 = *(undefined4 *)((int)register0x00000010 + -100);
                *(undefined4 *)((int)register0x00000010 + -0x6c) = 0;
                *(undefined **)((int)register0x00000010 + -0x68) = &DAT_004cc09a;
                *(undefined4 *)((int)register0x00000010 + -100) = 0x29;
                *(undefined4 *)((int)register0x00000010 + -0x60) = uVar5;
                *(undefined4 *)((int)register0x00000010 + -0x5c) = uVar6;
                *(char **)((int)register0x00000010 + -0x58) =
                     ", not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
                ;
                *(undefined4 *)((int)register0x00000010 + -0x54) = 0x10;
                *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417d3e;
                FUN_00451e50();
                *(undefined4 *)((int)register0x00000010 + -0x6c) =
                     *(undefined4 *)((int)register0x00000010 + -0x50);
                *(undefined4 *)((int)register0x00000010 + -0x68) =
                     *(undefined4 *)((int)register0x00000010 + -0x4c);
                *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417d52;
                FUN_00469a20();
LAB_00417d52:
                *(char **)((int)register0x00000010 + -0x6c) =
                     "runtime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
                ;
                *(undefined4 *)((int)register0x00000010 + -0x68) = 0x41;
                *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417d68;
                FUN_00469a20();
                return;
              }
              puVar1 = *(undefined **)((int)register0x00000010 + 8);
              if (puVar1 == &DAT_005f5da0) {
                return;
              }
              for (ppuVar10 = &PTR_DAT_005ccde0; ppuVar10 != (undefined **)0x0;
                  ppuVar10 = (undefined **)ppuVar10[0x48]) {
                if ((ppuVar10[0x18] <= puVar1) && (puVar1 < ppuVar10[0x19])) {
                  return;
                }
                if ((ppuVar10[0x1a] <= puVar1) && (puVar1 < ppuVar10[0x1b])) {
                  return;
                }
                if ((ppuVar10[0x1c] <= puVar1) && (puVar1 < ppuVar10[0x1d])) {
                  return;
                }
                if ((ppuVar10[0x1e] <= puVar1) && (puVar1 < ppuVar10[0x1f])) {
                  return;
                }
              }
              *(char **)((int)register0x00000010 + -0x6c) =
                   "runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slo..." /* TRUNCATED STRING LITERAL */
              ;
              *(undefined4 *)((int)register0x00000010 + -0x68) = 0x34;
              *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417dba;
              FUN_00469a20();
            }
            *(char **)((int)register0x00000010 + -0x6c) =
                 "runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
            ;
            *(undefined4 *)((int)register0x00000010 + -0x68) = 0x40;
            *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417dd0;
            FUN_00469a20();
          }
          pcVar9 = 
          "nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
          ;
          *(char **)((int)register0x00000010 + -0x6c) =
               "nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
          ;
          *(undefined4 *)((int)register0x00000010 + -0x68) = 0xe;
          *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417de6;
          FUN_00469a20();
        }
        *(char **)((int)register0x00000010 + -0x6c) = pcVar9;
        *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417dee;
        FUN_00462470();
        uVar5 = *(undefined4 *)((int)register0x00000010 + -0x68);
        uVar6 = *(undefined4 *)((int)register0x00000010 + -100);
        *(undefined4 *)((int)register0x00000010 + -0x6c) = 0;
        *(undefined **)((int)register0x00000010 + -0x68) = &DAT_004cbe90;
        *(undefined4 *)((int)register0x00000010 + -100) = 0x28;
        *(undefined4 *)((int)register0x00000010 + -0x60) = uVar5;
        *(undefined4 *)((int)register0x00000010 + -0x5c) = uVar6;
        *(char **)((int)register0x00000010 + -0x58) =
             ", not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x54) = 0xd;
        *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417e2e;
        FUN_00451e50();
        *(undefined4 *)((int)register0x00000010 + -0x6c) =
             *(undefined4 *)((int)register0x00000010 + -0x50);
        *(undefined4 *)((int)register0x00000010 + -0x68) =
             *(undefined4 *)((int)register0x00000010 + -0x4c);
        *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417e42;
        FUN_00469a20();
      }
      *(undefined **)((int)register0x00000010 + -0x6c) = &DAT_004cc500;
      *(undefined4 *)((int)register0x00000010 + -0x68) = 0x2b;
      *(undefined4 *)((int)register0x00000010 + -0x70) = 0x417e58;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar12 + -4) = 0x417e5e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
}



/* Function: FUN_00417f10 */

void FUN_00417f10(void)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  int iVar4;
  undefined4 uVar5;
  undefined1 *puVar6;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -8);
      uVar3 = *(uint *)((int)register0x00000010 + 8);
      if (uVar3 < 0x4001) {
        if (uVar3 < 4) {
          uVar3 = 4;
        }
        **(uint **)((int)register0x00000010 + 4) = uVar3;
        iVar1 = (int)(0x4000 / (ulong)uVar3) * uVar3;
        if (DAT_005f5fd0 == 0) {
          uVar2 = *(undefined4 *)((int)register0x00000010 + 0xc);
          iVar4 = *(int *)((int)register0x00000010 + 4);
          uVar5 = *(undefined4 *)((int)register0x00000010 + 0x10);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0xc) = 0x417f70;
          FUN_0046eda0();
          uVar2 = *(undefined4 *)((int)register0x00000010 + 0xc);
          *in_EDI = uVar2;
          iVar4 = *(int *)((int)register0x00000010 + 4);
          in_EDI[1] = *(undefined4 *)(iVar4 + 4);
          uVar5 = *(undefined4 *)((int)register0x00000010 + 0x10);
          in_EDI[2] = uVar5;
          in_EDI[3] = *(undefined4 *)(iVar4 + 8);
        }
        *(undefined4 *)(iVar4 + 4) = uVar2;
        *(undefined4 *)(iVar4 + 8) = uVar5;
        *(undefined4 *)(iVar4 + 0xc) = 0;
        *(undefined4 *)(iVar4 + 0x10) = 0;
        *(undefined4 *)(iVar4 + 0x14) = 0;
        *(int *)(iVar4 + 0x18) = iVar1;
        *(undefined4 *)(iVar4 + 0x1c) = 0;
        if (DAT_005f5fd0 == 0) {
          uVar2 = *(undefined4 *)((int)register0x00000010 + 0x14);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0xc) = 0x417fc7;
          FUN_0046ed80();
          uVar2 = *(undefined4 *)((int)register0x00000010 + 0x14);
          *in_EDI = uVar2;
          in_EDI[1] = *(undefined4 *)(iVar4 + 0x20);
        }
        *(undefined4 *)(iVar4 + 0x20) = uVar2;
        *(undefined1 *)(iVar4 + 0x24) = 1;
        return;
      }
      *(char **)((int)register0x00000010 + -8) =
           "runtime: fixalloc size too largeinvalid limiter event type foundscanstack: goroutine not stoppedscavenger state is already wiredsweep increased allocation countremovespecial on invalid pointergetWeakHandle on invalid pointerruntime: root level max pages = NtAssociateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x20;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x417ff4;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x417ffa;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_00418000 */

void FUN_00418000(void)

{
  undefined4 *puVar1;
  code *pcVar2;
  uint *puVar3;
  uint uVar4;
  uint *puVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x18);
      puVar3 = *(uint **)((int)register0x00000010 + 4);
      if (*puVar3 != 0) {
        puVar5 = (uint *)puVar3[3];
        if (puVar5 != (uint *)0x0) {
          puVar3[3] = *puVar5;
          puVar3[7] = puVar3[7] + *puVar3;
          if ((char)puVar3[9] != '\0') {
            *(uint **)((int)register0x00000010 + -8) = puVar5;
            uVar4 = *puVar3;
            *(uint **)((int)register0x00000010 + -0x18) = puVar5;
            *(uint *)((int)register0x00000010 + -0x14) = uVar4;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x418050;
            FUN_0046f470();
            puVar5 = *(uint **)((int)register0x00000010 + -8);
          }
          *(uint **)((int)register0x00000010 + 8) = puVar5;
          return;
        }
        if (puVar3[5] < *puVar3) {
          uVar4 = puVar3[8];
          *(uint *)((int)register0x00000010 + -0x18) = puVar3[6];
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
          *(uint *)((int)register0x00000010 + -0x10) = uVar4;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41807b;
          FUN_004119f0();
          puVar3 = *(uint **)((int)register0x00000010 + 4);
          puVar3[4] = *(uint *)((int)register0x00000010 + -0xc);
          puVar3[5] = puVar3[6];
        }
        uVar4 = puVar3[4];
        puVar1 = (undefined4 *)puVar3[1];
        if (puVar1 != (undefined4 *)0x0) {
          *(uint *)((int)register0x00000010 + -4) = uVar4;
          pcVar2 = (code *)*puVar1;
          *(uint *)((int)register0x00000010 + -0x18) = puVar3[2];
          *(uint *)((int)register0x00000010 + -0x14) = uVar4;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4180aa;
          (*pcVar2)();
          puVar3 = *(uint **)((int)register0x00000010 + 4);
          uVar4 = *(uint *)((int)register0x00000010 + -4);
        }
        puVar3[4] = puVar3[4] + *puVar3;
        puVar3[5] = puVar3[5] - *puVar3;
        puVar3[7] = puVar3[7] + *puVar3;
        *(uint *)((int)register0x00000010 + 8) = uVar4;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4180d1;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x18) =
           "runtime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unl..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x34;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4180e7;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4180ec;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c7a2c;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x17;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x418102;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x418108;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_00418110 */

void FUN_00418110(int *param_1,int *param_2)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  param_1[7] = param_1[7] - *param_1;
  *param_2 = param_1[3];
  param_1[3] = (int)param_2;
  return;
}



/* Function: FUN_00418140 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_00418140(void)

{
  int in_FS_OFFSET;
  undefined *puVar1;
  undefined *puVar2;
  undefined4 uVar3;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar1 = &DAT_005d716c;
  uVar3 = 0x80000000;
  FUN_00402770(&DAT_005d716c,0x80000000);
  FUN_00423520();
  puVar2 = puVar1;
  FUN_00423650();
  FUN_00420c20(&DAT_005f6780,puVar1,puVar2,uVar3);
  _DAT_005d7698 = 1;
  _DAT_005d769c = 1;
  return;
}



/* Function: FUN_004181c0 */

void FUN_004181c0(void)

{
  undefined4 *puVar1;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined4 *puVar2;
  undefined4 local_8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar2 = (undefined4 *)0x2;
  FUN_004096b0(&DAT_004abc80);
  FUN_00411710(&DAT_004b1b40);
  *puVar2 = &LAB_00418300;
  puVar1 = puVar2;
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed70();
    *in_EDI = local_8;
  }
  puVar2[1] = local_8;
  FUN_00444df0(puVar2);
  FUN_00411710(&DAT_004b1b40);
  *puVar1 = &LAB_004182c0;
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed70();
    *in_EDI = local_8;
  }
  puVar1[1] = local_8;
  FUN_00444df0(puVar1);
  FUN_0040a470(local_8,0);
  FUN_0040a470(local_8,0);
  DAT_005f9530 = 1;
  return;
}



/* Function: FUN_00418440 */

void FUN_00418440(int param_1)

{
  int in_FS_OFFSET;
  bool bVar1;
  int local_18;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  bVar1 = DAT_005f9530 != '\0';
  if (bVar1) {
    FUN_00402510(&DAT_005f5e4c);
  }
  if ((!bVar1 || local_18 != 0) || (DAT_005f5e04 != 0)) {
    return;
  }
  if (param_1 == 0) {
    FUN_00422dd0(&DAT_005f6780);
    FUN_004027a0(&DAT_005f67e8);
    return;
  }
  if (param_1 != 1) {
    if (param_1 == 2) {
      FUN_00402510(&DAT_005d76d8);
      return;
    }
    return;
  }
  thunk_FUN_00402510(&DAT_005f6780);
  if (-1 < local_18) {
    FUN_004027a0(&DAT_005f9520);
    return;
  }
  return;
}



/* Function: FUN_004185b0 */

void FUN_004185b0(int param_1,uint param_2,undefined4 param_3,undefined4 param_4)

{
  int *piVar1;
  long lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  bool bVar7;
  bool bVar8;
  undefined *puVar9;
  undefined4 *puVar10;
  uint3 uVar11;
  undefined4 uVar12;
  char cVar13;
  undefined4 in_stack_ffffff74;
  undefined3 uVar14;
  undefined1 local_70 [12];
  undefined4 *local_64;
  int local_60;
  uint local_5c;
  int local_58;
  undefined *local_54;
  uint local_50;
  int local_4c;
  int local_48;
  uint local_44;
  int local_40;
  int local_3c;
  undefined *local_38;
  int *local_34;
  int local_30;
  int local_2c;
  int local_28;
  code *local_24;
  int local_20;
  int local_1c;
  undefined1 *local_18;
  undefined **local_14;
  undefined1 *local_10;
  undefined1 *local_c;
  undefined1 *local_8;
  code **local_4;
  
  while (&local_1c <= *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (code **)0x418d54;
    FUN_0046d980();
  }
  local_4 = (code **)0x0;
  iVar6 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  piVar1 = (int *)(*(int *)(iVar6 + 0x18) + 0x7c);
  *piVar1 = *piVar1 + 1;
  piVar1 = *(int **)(iVar6 + 0x18);
  iVar6 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  if (((*piVar1 == iVar6) || (iVar4 = piVar1[0x1f], 1 < iVar4)) || (piVar1[0x1e] != 0)) {
    iVar4 = piVar1[0x1f];
    piVar1[0x1f] = iVar4 + -1;
    if ((iVar4 == 1) && (*(char *)(iVar6 + 0x69) != '\0')) {
      *(undefined4 *)(iVar6 + 8) = 0xfffffade;
    }
    return;
  }
  piVar1[0x1f] = iVar4 + -1;
  if ((iVar4 == 1) && (*(char *)(iVar6 + 0x69) != '\0')) {
    *(undefined4 *)(iVar6 + 8) = 0xfffffade;
  }
  iVar6 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  iVar4 = *(int *)(iVar6 + 0xf0);
  local_28 = iVar4;
  if (iVar4 != 0) {
    if (DAT_005f5fd0 != 0) {
      uVar12 = *(undefined4 *)(iVar6 + 0xf0);
      FUN_0046ed70();
      *in_EDI = uVar12;
    }
    *(undefined4 *)(iVar6 + 0xf0) = 0;
    local_24 = FUN_00418e60;
    local_4 = &local_24;
    local_28 = iVar4;
    local_20 = iVar6;
    local_1c = iVar4;
  }
  do {
    iVar6 = param_1;
    uVar3 = param_2;
    FUN_00418440(param_1,param_2,param_3,param_4);
    if ((char)in_stack_ffffff74 == '\0') {
      bVar8 = false;
    }
    else {
      FUN_00426bd0();
      bVar8 = iVar6 != -1;
    }
  } while (bVar8);
  bVar8 = local_28 != 0;
  uVar14 = (undefined3)((uint)in_stack_ffffff74 >> 8);
  cVar13 = '\x12';
  FUN_0044c750(&DAT_005d7698,uVar3 & 0xffffff00,0,0);
  uVar3 = param_2;
  FUN_00418440(param_1,param_2,param_3,param_4);
  uVar11 = (uint3)(uVar3 >> 8);
  if (cVar13 != '\0') {
    if (DAT_005f6220 == 1) {
      local_4c = 1;
    }
    else if (DAT_005f6220 == 2) {
      local_4c = 2;
    }
    else {
      local_4c = 0;
    }
    uVar3 = (uint)uVar11 << 8;
    FUN_0044c750(&DAT_005cc290,uVar3,0,0,CONCAT31(uVar14,0x12));
    puVar9 = &DAT_005cc28c;
    uVar3 = uVar3 & 0xffffff00;
    uVar12 = 0;
    FUN_0044c750(&DAT_005cc28c,uVar3,0,0,0x12);
    DAT_005d76a8 = param_1 == 2;
    if (DAT_005d7d30 == '\0') {
      uVar5 = 0;
      puVar9 = (undefined *)0x0;
    }
    else {
      uVar5 = uVar3;
      FUN_0045e520();
      uVar3 = uVar5;
    }
    if (uVar5 != 0) {
      local_38 = puVar9;
      FUN_0045e980(puVar9,uVar5);
      FUN_0045e630(local_38);
      uVar3 = uVar5;
    }
    local_2c = DAT_005d7020;
    local_3c = DAT_005d7024;
    iVar6 = 0;
    while( true ) {
      if (local_3c <= iVar6) {
        FUN_0041a8e0();
        FUN_0046d890(&PTR_FUN_00536af8);
        DAT_005d76dc = DAT_005f5e88;
        DAT_005d76e0 = DAT_005f5e88;
        if ((int)DAT_005f5e8c < (int)DAT_005f5e88) {
          DAT_005d76dc = DAT_005f5e8c;
        }
        puVar9 = &DAT_005f67e8;
        FUN_004027a0();
        DAT_005d7710 = uVar12;
        DAT_005d770c = uVar3;
        DAT_005d7704 = 0;
        DAT_005d7708 = 0;
        DAT_005d76a4 = local_4c;
        uVar3 = DAT_005d770c;
        FUN_0046fa70();
        DAT_005d76e8 = uVar3;
        DAT_005d76e4 = puVar9;
        local_54 = DAT_005d76e4;
        local_50 = DAT_005d76e8;
        FUN_0046ef49();
        local_c = &LAB_00418e20;
        local_8 = local_70;
        FUN_0046d890(&local_c);
        bVar7 = CARRY4(DAT_005d773c,local_5c);
        DAT_005d773c = DAT_005d773c + local_5c;
        DAT_005d7740 = DAT_005d7740 + local_58 + (uint)bVar7;
        bVar7 = CARRY4(local_5c,DAT_005d7744);
        DAT_005d7744 = local_5c + DAT_005d7744;
        DAT_005d7748 = local_58 + DAT_005d7748 + (uint)bVar7;
        FUN_0046d890(&PTR_LAB_00536b00);
        FUN_0041ba10();
        FUN_00402690(&DAT_005d76d8,1);
        FUN_00420ca0(&DAT_005f6780,local_54,local_50,DAT_005f5e88,param_1,param_2,param_3,param_4);
        puVar9 = &DAT_005f61a0;
        FUN_0041bfd0(&DAT_005f61a0,1,local_54,local_50);
        if (local_4c != 0) {
          FUN_004488e0((uint)puVar9 & 0xffffff00);
        }
        FUN_00402770(&DAT_005f5e04,1);
        DAT_005f5fd0 = CONCAT31(DAT_005f5fd0._1_3_,DAT_005f5e04 == 1 || DAT_005f5e04 == 2);
        DAT_005d7658 = 0xffffffff;
        DAT_005d7664 = 0xffffffff;
        FUN_0041cd30();
        FUN_00420b50();
        puVar10 = &DAT_005f5e08;
        uVar5 = 1;
        FUN_00402770();
        iVar6 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
        piVar1 = (int *)(*(int *)(iVar6 + 0x18) + 0x7c);
        *piVar1 = *piVar1 + 1;
        local_30 = *(int *)(iVar6 + 0x18);
        FUN_0046fa70();
        local_44 = DAT_005d773c;
        lVar2 = (ulong)(uint)((int)puVar10 - (int)local_64) * (ulong)DAT_005d76e0;
        uVar3 = (uint)lVar2;
        iVar6 = (int)((ulong)lVar2 >> 0x20) +
                DAT_005d76e0 * ((uVar5 - local_60) - (uint)(puVar10 < local_64)) +
                ((int)puVar10 - (int)local_64) * ((int)DAT_005d76e0 >> 0x1f);
        bVar7 = CARRY4(DAT_005d773c,uVar3);
        DAT_005d773c = DAT_005d773c + uVar3;
        DAT_005d7740 = DAT_005d7740 + iVar6 + (uint)bVar7;
        bVar7 = CARRY4(uVar3,DAT_005d7744);
        DAT_005d7744 = uVar3 + DAT_005d7744;
        DAT_005d7748 = DAT_005d7748 + iVar6 + (uint)bVar7;
        local_18 = &LAB_00418d60;
        local_14 = &local_54;
        local_10 = local_70;
        FUN_0046d890(&local_18);
        uVar5 = uVar5 & 0xffffff00;
        FUN_0044cab0(&DAT_005cc28c,uVar5,0);
        iVar6 = *(int *)(local_30 + 0x7c);
        iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
        *(int *)(local_30 + 0x7c) = iVar6 + -1;
        if ((iVar6 == 1) && (*(char *)(iVar4 + 0x69) != '\0')) {
          *(undefined4 *)(iVar4 + 8) = 0xfffffade;
        }
        if (local_4c != 0) {
          FUN_0046d830(&PTR_LAB_00536b14);
        }
        FUN_0044cab0(&DAT_005d7698,uVar5 & 0xffffff00,0);
        if (bVar8) {
          (**local_4)();
        }
        return;
      }
      local_34 = *(int **)(local_2c + iVar6 * 4);
      local_40 = iVar6;
      FUN_00402510(local_34[0xc] + 0x254);
      if (uVar3 != DAT_005dde90) break;
      iVar6 = local_40 + 1;
    }
    local_44 = DAT_005dde90;
    local_48 = *local_34;
    FUN_0043a810();
    FUN_0043b060(&DAT_004c3a49,0xb);
    FUN_0043ae80(local_48,local_48 >> 0x1f);
    FUN_0043b060(&DAT_004c364d,10);
    FUN_0043ad50(uVar3,0);
    FUN_0043b060(" != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                 ,0xd);
    FUN_0043ad50(local_44,0);
    FUN_0043aa10();
    FUN_0043a870();
    FUN_00469a20(&DAT_004c6838,0x14);
    FUN_00438440();
    return;
  }
  FUN_0044cab0(&DAT_005d7698,(uint)uVar11 << 8,0);
  if (bVar8) {
    (**local_4)();
  }
  return;
}



/* Function: FUN_00418e60 */

void FUN_00418e60(void)

{
  int iVar1;
  int in_EDX;
  undefined4 uVar2;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d900();
  }
  iVar1 = *(int *)(in_EDX + 4);
  uVar2 = *(undefined4 *)(in_EDX + 8);
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = uVar2;
    in_EDI[1] = *(undefined4 *)(iVar1 + 0xf0);
  }
  *(undefined4 *)(iVar1 + 0xf0) = uVar2;
  return;
}



/* Function: FUN_00418ea0 */

void FUN_00418ea0(void)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  bool bVar3;
  undefined *puVar4;
  uint in_stack_ffffffa4;
  uint uVar5;
  char local_41;
  undefined *local_40;
  uint local_3c;
  undefined4 local_38 [5];
  uint local_24;
  int local_20;
  undefined1 *local_1c;
  char *local_18;
  undefined1 *local_14;
  undefined4 *local_10;
  undefined1 *local_c;
  undefined1 local_8;
  undefined **local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (undefined **)0x419215;
    FUN_0046d980();
  }
  uVar5 = in_stack_ffffffa4 & 0xffffff00;
  FUN_0044c750(&DAT_005d769c,uVar5,0,0,0x12);
  while ((DAT_005f5e04 == 1 && (DAT_005d7658 == DAT_005d7664))) {
    FUN_0041b100(0);
    if ((char)uVar5 != '\0') break;
    uVar5 = uVar5 & 0xffffff00;
    FUN_0044c750(&DAT_005cc28c,uVar5,0,0,0x12);
    DAT_005d76c8 = 1;
    DAT_005f5e0c = 0;
    local_c = &LAB_00419400;
    local_8 = 0x1f;
    local_4 = &PTR_LAB_00536aec;
    FUN_0046d890(&local_c);
    if (DAT_005f5e0c == 0) {
      do {
        puVar4 = &DAT_005f5dbe;
        FUN_00402470();
      } while ((char)uVar5 != '\0');
      FUN_0046fa70();
      iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
      DAT_005d76f4 = puVar4;
      DAT_005d76f8 = uVar5;
      *(undefined4 *)(iVar1 + 0x78) = 5;
      local_40 = puVar4;
      local_3c = uVar5;
      if (DAT_005f5fd0 != 0) {
        uVar2 = *(undefined4 *)(iVar1 + 0x74);
        FUN_0046ed70();
        *in_EDI = uVar2;
      }
      *(undefined **)(iVar1 + 0x74) = &DAT_004c2c46;
      in_EDI = local_38;
      FUN_0046ef49();
      local_14 = &LAB_004193c0;
      local_10 = local_38;
      FUN_0046d890(&local_14);
      bVar3 = CARRY4(DAT_005d773c,local_24);
      DAT_005d773c = DAT_005d773c + local_24;
      DAT_005d7740 = DAT_005d7740 + local_20 + (uint)bVar3;
      bVar3 = CARRY4(DAT_005d7744,local_24);
      DAT_005d7744 = DAT_005d7744 + local_24;
      DAT_005d7748 = DAT_005d7748 + local_20 + (uint)bVar3;
      local_41 = '\0';
      local_1c = &LAB_00419320;
      local_18 = &local_41;
      FUN_0046d890(&local_1c);
      if (local_41 == '\0') {
        FUN_00450f40();
        uVar5 = 0;
        FUN_00402770(&DAT_005f5e08,0);
        uVar5 = uVar5 & 0xffffff00;
        FUN_0041bfd0(&DAT_005f61a0,uVar5,local_40,local_3c);
        FUN_0041e6c0();
        DAT_005d76c8 = 0;
        FUN_0042bd00();
        FUN_0044cab0(&DAT_005d769c,uVar5 & 0xffffff00,0);
        FUN_004488e0(1);
        FUN_00421880(&DAT_005f6780,local_40,local_3c,DAT_005f5e88,DAT_005d76a8);
        FUN_0046f41a();
        FUN_00419480();
        return;
      }
      DAT_005f5dbf = 1;
      iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
      *(undefined4 *)(iVar1 + 0x78) = 0;
      if (DAT_005f5fd0 != 0) {
        uVar2 = *(undefined4 *)(iVar1 + 0x74);
        FUN_0046ed70();
        *in_EDI = uVar2;
      }
      *(undefined4 *)(iVar1 + 0x74) = 0;
      local_14 = &LAB_00419220;
      local_10 = local_38;
      FUN_0046d890(&local_14);
      uVar5 = uVar5 & 0xffffff00;
      FUN_0044cab0(&DAT_005cc28c,uVar5,0);
    }
    else {
      uVar5 = uVar5 & 0xffffff00;
      FUN_0044cab0(&DAT_005cc28c,uVar5,0);
    }
  }
  FUN_0044cab0(&DAT_005d769c,uVar5 & 0xffffff00,0);
  return;
}



/* Function: FUN_00419480 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_00419480(void)

{
  int *piVar1;
  char cVar2;
  long lVar3;
  undefined4 uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  undefined4 uVar10;
  uint uVar11;
  undefined1 *puVar12;
  undefined4 *in_EDI;
  undefined4 *puVar13;
  int in_FS_OFFSET;
  bool bVar14;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) <
        (undefined1 *)((int)register0x00000010 + -0x160)) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x1e0);
      *(int **)((int)register0x00000010 + -0x1e0) = &DAT_005f5e04;
      *(undefined4 *)((int)register0x00000010 + -0x1dc) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4194b8;
      FUN_00402770();
      DAT_005f5fd0 = CONCAT31(DAT_005f5fd0._1_3_,DAT_005f5e04 == 1 || DAT_005f5e04 == 2);
      *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f67e8;
      *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4194e4;
      FUN_004027a0();
      DAT_005d7714 = *(uint *)((int)register0x00000010 + -0x1dc);
      DAT_005d7718 = *(uint *)((int)register0x00000010 + -0x1d8);
      *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4194fe;
      FUN_0046fa70();
      iVar7 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      iVar8 = *(int *)(iVar7 + 0x18);
      *(undefined4 *)((int)register0x00000010 + -0x130) =
           *(undefined4 *)((int)register0x00000010 + -0x1e0);
      *(undefined4 *)((int)register0x00000010 + -0x114) =
           *(undefined4 *)((int)register0x00000010 + -0x1dc);
      piVar1 = (int *)(iVar8 + 0x7c);
      *piVar1 = *piVar1 + 1;
      iVar7 = *(int *)(iVar7 + 0x18);
      *(undefined4 *)(iVar7 + 0x78) = 5;
      if (DAT_005f5fd0 != 0) {
        uVar4 = *(undefined4 *)(iVar7 + 0x74);
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419541;
        FUN_0046ed70();
        *in_EDI = uVar4;
      }
      *(int *)((int)register0x00000010 + -0x24) = iVar7;
      *(undefined **)(iVar7 + 0x74) = &DAT_004c2c46;
      *(undefined1 *)(iVar7 + 0x96) = 2;
      uVar4 = *(undefined4 *)(iVar7 + 0x50);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar4;
      *(undefined4 *)((int)register0x00000010 + -0x1e0) = uVar4;
      *(undefined4 *)((int)register0x00000010 + -0x1dc) = 2;
      *(undefined1 *)((int)register0x00000010 + -0x1d8) = 6;
      *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419579;
      FUN_0043dac0();
      *(undefined1 **)((int)register0x00000010 + -0xe0) = &LAB_0041a8b0;
      *(undefined4 *)((int)register0x00000010 + -0xdc) =
           *(undefined4 *)((int)register0x00000010 + -0x130);
      *(undefined4 *)((int)register0x00000010 + -0xd8) =
           *(undefined4 *)((int)register0x00000010 + -0x114);
      *(undefined1 **)((int)register0x00000010 + -0x1e0) =
           (undefined1 *)((int)register0x00000010 + -0xe0);
      *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4195b1;
      FUN_0046d890();
      *(undefined1 *)((int)register0x00000010 + -0x1be) = 0;
      *(undefined1 **)((int)register0x00000010 + -0x18) = &LAB_0041a7b0;
      *(undefined1 **)((int)register0x00000010 + -0x14) =
           (undefined1 *)((int)register0x00000010 + -0x1be);
      *(undefined1 **)((int)register0x00000010 + -0x1e0) =
           (undefined1 *)((int)register0x00000010 + -0x18);
      *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4195dd;
      FUN_0046d890();
      *(undefined1 *)(*(int *)((int)register0x00000010 + -0x24) + 0x96) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x1e0) =
           *(undefined4 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x1dc) = 4;
      *(undefined4 *)((int)register0x00000010 + -0x1d8) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41960a;
      FUN_0043d640();
      if (DAT_005d7d30 == '\0') {
        iVar7 = 0;
        uVar4 = 0;
      }
      else {
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419620;
        FUN_0045e520();
        uVar4 = *(undefined4 *)((int)register0x00000010 + -0x1e0);
        iVar7 = *(int *)((int)register0x00000010 + -0x1dc);
      }
      if (iVar7 != 0) {
        *(int *)((int)register0x00000010 + -0x144) = iVar7;
        *(undefined4 *)((int)register0x00000010 + -0x28) = uVar4;
        *(undefined4 *)((int)register0x00000010 + -0x1e0) = uVar4;
        *(int *)((int)register0x00000010 + -0x1dc) = iVar7;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419645;
        FUN_0045ea80();
        *(undefined4 *)((int)register0x00000010 + -0x1e0) =
             *(undefined4 *)((int)register0x00000010 + -0x28);
        *(undefined4 *)((int)register0x00000010 + -0x1dc) =
             *(undefined4 *)((int)register0x00000010 + -0x144);
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41965f;
        FUN_0045e630();
      }
      iVar7 = *(int *)((int)register0x00000010 + -0x24);
      *(undefined4 *)(iVar7 + 0x78) = 0;
      if (DAT_005f5fd0 != 0) {
        uVar4 = *(undefined4 *)(iVar7 + 0x74);
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41967f;
        FUN_0046ed70();
        *in_EDI = uVar4;
      }
      *(undefined4 *)(iVar7 + 0x74) = 0;
      if (DAT_005f5e04 == 0) {
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f6890;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4196a4;
        FUN_004027a0();
        DAT_005f9528 = *(undefined4 *)((int)register0x00000010 + -0x1dc);
        DAT_005f952c = *(undefined4 *)((int)register0x00000010 + -0x1d8);
        *(undefined ***)((int)register0x00000010 + -0x1e0) = &PTR_LAB_00536ae8;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4196c6;
        FUN_0046d890();
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4196cc;
        FUN_0046fa70();
        *(undefined4 *)((int)register0x00000010 + -0x134) =
             *(undefined4 *)((int)register0x00000010 + -0x1e0);
        *(undefined4 *)((int)register0x00000010 + -0x118) =
             *(undefined4 *)((int)register0x00000010 + -0x1dc);
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4196e6;
        FUN_0046fad0();
        uVar6 = *(uint *)((int)register0x00000010 + -0x1d8);
        uVar5 = (uint)((ulong)*(uint *)((int)register0x00000010 + -0x1e0) * 1000000000);
        *(int *)((int)register0x00000010 + -0x94) = DAT_005d7708;
        iVar8 = uVar6 + uVar5;
        *(int *)((int)register0x00000010 + -0x108) = iVar8;
        iVar7 = *(int *)((int)register0x00000010 + -0x1dc) * 1000000000 +
                (int)((ulong)*(uint *)((int)register0x00000010 + -0x1e0) * 1000000000 >> 0x20) +
                ((int)uVar6 >> 0x1f) + (uint)CARRY4(uVar6,uVar5);
        *(int *)((int)register0x00000010 + -0x104) = iVar7;
        DAT_005d76fc = *(uint *)((int)register0x00000010 + -0x134);
        uVar6 = DAT_005d76fc - *(uint *)((int)register0x00000010 + 8);
        bVar14 = CARRY4(DAT_005d7704,uVar6);
        DAT_005d7704 = DAT_005d7704 + uVar6;
        DAT_005d7708 = ((*(int *)((int)register0x00000010 + -0x118) -
                        *(int *)((int)register0x00000010 + 0xc)) -
                       (uint)(DAT_005d76fc < *(uint *)((int)register0x00000010 + 8))) +
                       *(int *)((int)register0x00000010 + -0x94) + (uint)bVar14;
        DAT_005d7700 = *(int *)((int)register0x00000010 + -0x118);
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f8500;
        *(int *)((int)register0x00000010 + -0x1dc) = iVar8;
        *(int *)((int)register0x00000010 + -0x1d8) = iVar7;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419790;
        FUN_004027c0();
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f9520;
        *(undefined4 *)((int)register0x00000010 + -0x1dc) =
             *(undefined4 *)((int)register0x00000010 + -0x134);
        *(undefined4 *)((int)register0x00000010 + -0x1d8) =
             *(undefined4 *)((int)register0x00000010 + -0x118);
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4197b4;
        FUN_004027c0();
        iVar8 = DAT_005d7708;
        iVar7 = (DAT_005f9510 & 0xff) * 8;
        *(uint *)(&DAT_005f8510 + iVar7) = DAT_005d7704;
        *(int *)(&DAT_005f8514 + iVar7) = iVar8;
        iVar7 = (DAT_005f9510 & 0xff) * 8;
        *(undefined4 *)(&DAT_005f8d10 + iVar7) = *(undefined4 *)((int)register0x00000010 + -0x108);
        *(undefined4 *)(&DAT_005f8d14 + iVar7) = *(undefined4 *)((int)register0x00000010 + -0x104);
        bVar14 = CARRY4(DAT_005f8508,DAT_005d7704);
        DAT_005f8508 = DAT_005f8508 + DAT_005d7704;
        DAT_005f850c = DAT_005f850c + DAT_005d7708 + (uint)bVar14;
        *(int *)((int)register0x00000010 + -0x94) = (int)DAT_005d76e0 >> 0x1f;
        *(int *)((int)register0x00000010 + -0x98) = DAT_005d7740;
        in_EDI = (undefined4 *)
                 (*(uint *)((int)register0x00000010 + -0x134) -
                 *(uint *)((int)register0x00000010 + 0x10));
        uVar6 = (uint)((ulong)DAT_005d76e0 * ZEXT48(in_EDI));
        iVar7 = ((*(int *)((int)register0x00000010 + -0x118) -
                 *(int *)((int)register0x00000010 + 0x14)) -
                (uint)(*(uint *)((int)register0x00000010 + -0x134) <
                      *(uint *)((int)register0x00000010 + 0x10))) * DAT_005d76e0 +
                (int)((ulong)DAT_005d76e0 * ZEXT48(in_EDI) >> 0x20) +
                *(int *)((int)register0x00000010 + -0x94) * (int)in_EDI;
        bVar14 = CARRY4(DAT_005d773c,uVar6);
        DAT_005d773c = DAT_005d773c + uVar6;
        DAT_005d7740 = *(int *)((int)register0x00000010 + -0x98) + iVar7 + (uint)bVar14;
        bVar14 = CARRY4(DAT_005d7744,uVar6);
        DAT_005d7744 = DAT_005d7744 + uVar6;
        DAT_005d7748 = DAT_005d7748 + iVar7 + (uint)bVar14;
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005d7724;
        *(undefined4 *)((int)register0x00000010 + -0x1dc) =
             *(undefined4 *)((int)register0x00000010 + -0x134);
        *(undefined4 *)((int)register0x00000010 + -0x1d8) =
             *(undefined4 *)((int)register0x00000010 + -0x118);
        *(undefined1 *)((int)register0x00000010 + -0x1d4) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4198e0;
        FUN_00433b20();
        *(uint *)((int)register0x00000010 + -0x1e0) = DAT_005d7744 - DAT_005d7734;
        *(uint *)((int)register0x00000010 + -0x1dc) =
             (DAT_005d7748 - DAT_005d7738) - (uint)(DAT_005d7744 < DAT_005d7734);
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419908;
        FUN_00464a40();
        *(undefined8 *)((int)register0x00000010 + -0xa0) =
             *(undefined8 *)((int)register0x00000010 + -0x1d8);
        *(undefined4 *)((int)register0x00000010 + -0x1e0) = DAT_005d7774;
        *(undefined4 *)((int)register0x00000010 + -0x1dc) = DAT_005d7778;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41992f;
        FUN_00464a40();
        _DAT_005f9518 =
             *(double *)((int)register0x00000010 + -0xa0) /
             *(double *)((int)register0x00000010 + -0x1d8);
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f60b0;
        *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1d8) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419965;
        thunk_FUN_004027c0();
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f60b8;
        *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1d8) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419984;
        thunk_FUN_004027c0();
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005d8ac0;
        *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1d8) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4199a3;
        thunk_FUN_004027c0();
        if (DAT_005d76a8 != '\0') {
          _DAT_005f9514 = _DAT_005f9514 + 1;
        }
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005d76c0;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4199c4;
        FUN_0040ecf0();
        DAT_005f9510 = DAT_005f9510 + 1;
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005d76c4;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4199d8;
        FUN_00442aa0();
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005d76c0;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4199e8;
        FUN_0040f0e0();
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005dde40;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x4199f6;
        FUN_00425ae0();
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f61a0;
        *(undefined4 *)((int)register0x00000010 + -0x1dc) =
             *(undefined4 *)((int)register0x00000010 + -0x134);
        *(undefined4 *)((int)register0x00000010 + -0x1d8) =
             *(undefined4 *)((int)register0x00000010 + -0x118);
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419a1a;
        FUN_0041c080();
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f5e1c;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419a29;
        FUN_00430d00();
        *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005d716c;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419a37;
        FUN_004265a0();
        *(undefined4 *)((int)register0x00000010 + -0xa4) =
             *(undefined4 *)((int)register0x00000010 + -0x1dc);
        cVar2 = *(char *)((int)register0x00000010 + -0x1d8);
        *(char *)((int)register0x00000010 + -0x1a5) = cVar2;
        if (*(char *)((int)register0x00000010 + -0x1be) == '\0') {
          if (cVar2 != '\0') {
LAB_00419a68:
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419a76;
            FUN_0046ef46();
            *(undefined1 **)((int)register0x00000010 + -0x50) = &LAB_0041a770;
            *(undefined4 *)((int)register0x00000010 + -0x4c) =
                 *(undefined4 *)((int)register0x00000010 + -0x134);
            *(undefined4 *)((int)register0x00000010 + -0x48) =
                 *(undefined4 *)((int)register0x00000010 + -0x118);
            puVar13 = (undefined4 *)((int)register0x00000010 + -0x44);
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419ab2;
            FUN_0046f41a();
            *(undefined1 **)((int)register0x00000010 + -0x1e0) =
                 (undefined1 *)((int)register0x00000010 + -0x50);
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419ac1;
            FUN_0046d890();
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419ac6;
            FUN_004312c0();
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419acb;
            FUN_00428f10();
            *(undefined ***)((int)register0x00000010 + -0x1e0) = &PTR_LAB_00536ae0;
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419ad9;
            FUN_0046d890();
            *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
            *(undefined1 *)((int)register0x00000010 + -8) = 0;
            *(undefined1 **)((int)register0x00000010 + -0xc) = &LAB_0041a6f0;
            *(undefined1 *)((int)register0x00000010 + -8) = 0x21;
            *(undefined ***)((int)register0x00000010 + -4) = &PTR_LAB_00536af0;
            *(undefined1 **)((int)register0x00000010 + -0x1e0) =
                 (undefined1 *)((int)register0x00000010 + -0xc);
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419b1e;
            FUN_0046d890();
            if (*(char *)((int)register0x00000010 + -0x1a5) != '\0') {
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005d716c;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                   *(undefined4 *)((int)register0x00000010 + -0xa4);
              *(char *)((int)register0x00000010 + -0x1d8) =
                   *(char *)((int)register0x00000010 + -0x1a5);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419b44;
              FUN_00426620();
            }
            if (DAT_005f6224 < 1) {
code_r0x0041a53f:
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005d71a0;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a54d;
              FUN_0040ecf0();
              *(undefined4 *)((int)register0x00000010 + -0xe4) = DAT_005d71b4;
              *(undefined4 *)((int)register0x00000010 + -0x20) = DAT_005d71b0;
              DAT_005d71b4 = 0;
              _DAT_005d71b8 = 0;
              if (DAT_005f5fd0 != 0) {
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a590;
                FUN_0046ed70();
                *puVar13 = DAT_005d71b0;
              }
              DAT_005d71b0 = 0;
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005d71a0;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a5ac;
              FUN_0040f0e0();
              iVar7 = 0;
              while (iVar7 < *(int *)((int)register0x00000010 + -0xe4)) {
                *(int *)((int)register0x00000010 + -0xa8) = iVar7;
                *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                     *(undefined4 *)(*(int *)((int)register0x00000010 + -0x20) + iVar7 * 8);
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a5cb;
                FUN_00408d50();
                iVar7 = *(int *)((int)register0x00000010 + -0xa8) + 1;
              }
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f6780;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a5ec;
              FUN_004229b0();
              if (0x40000000 < *(uint *)((int)register0x00000010 + -0x1dc) &&
                  *(int *)((int)register0x00000010 + -0x1d8) == 0 ||
                  *(int *)((int)register0x00000010 + -0x1d8) != 0) {
                *(undefined ***)((int)register0x00000010 + -0x1e0) = &PTR_LAB_00536af4;
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a619;
                FUN_0046d890();
              }
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005cc28c;
              *(undefined1 *)((int)register0x00000010 + -0x1dc) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x1d8) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a635;
              FUN_0044cab0();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005cc290;
              *(undefined1 *)((int)register0x00000010 + -0x1dc) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x1d8) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a651;
              FUN_0044cab0();
              iVar7 = *(int *)(*(int *)((int)register0x00000010 + -0x24) + 0x7c);
              iVar8 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
              *(int *)(*(int *)((int)register0x00000010 + -0x24) + 0x7c) = iVar7 + -1;
              if ((iVar7 == 1) && (*(char *)(iVar8 + 0x69) != '\0')) {
                *(undefined4 *)(iVar8 + 8) = 0xfffffade;
              }
              return;
            }
            *(double *)((int)register0x00000010 + -0xa0) = DAT_00550c98 * _DAT_005f9518;
            in_EDI = (undefined4 *)((int)register0x00000010 + -0x1bd);
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419b76;
            FUN_0046ef4a();
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419b7b;
            FUN_0043a810();
            *(uint *)((int)register0x00000010 + -0x1e0) = DAT_005d76e4 - DAT_005f5f18;
            *(uint *)((int)register0x00000010 + -0x1dc) =
                 (DAT_005d76e8 - DAT_005f5f1c) - (uint)(DAT_005d76e4 < DAT_005f5f18);
            *(undefined4 *)((int)register0x00000010 + -0x1d8) = 1000000;
            *(undefined4 *)((int)register0x00000010 + -0x1d4) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419bb3;
            FUN_00464c70();
            uVar5 = *(uint *)((int)register0x00000010 + -0x1d0);
            uVar11 = *(uint *)((int)register0x00000010 + -0x1cc);
            uVar6 = 0x17;
            while ((9 < uVar5 && uVar11 == 0 || uVar11 != 0 || (0x13 < (int)uVar6))) {
              *(uint *)((int)register0x00000010 + -0xf0) = uVar6;
              *(uint *)((int)register0x00000010 + -0x110) = uVar5;
              uVar9 = (uVar5 % 10 + (uVar11 % 10) * 6) / 10;
              lVar3 = (ulong)(uVar11 % 10) * 0x19999999 + CONCAT44(uVar11 / 10,uVar5 / 10);
              in_EDI = (undefined4 *)lVar3;
              iVar7 = uVar9 + (int)in_EDI;
              *(int *)((int)register0x00000010 + -0xa4) = iVar7;
              uVar5 = *(uint *)((int)register0x00000010 + -0xf0);
              if (0x17 < uVar5) goto LAB_0041a692;
              *(char *)((int)register0x00000010 + (uVar5 - 0x1bd)) =
                   (char)*(undefined4 *)((int)register0x00000010 + -0x110) + (char)iVar7 * -10 + '0'
              ;
              uVar6 = uVar5 - 1;
              if (uVar5 == 0x15) {
                *(undefined1 *)((int)register0x00000010 + -0x1a9) = 0x2e;
                uVar6 = 0x13;
              }
              uVar11 = (int)((ulong)lVar3 >> 0x20) + (uint)CARRY4(uVar9,(uint)in_EDI);
              uVar5 = *(uint *)((int)register0x00000010 + -0xa4);
            }
            if (uVar6 < 0x18) {
              *(char *)((int)register0x00000010 + (uVar6 - 0x1bd)) = (char)uVar5 + '0';
              *(int *)((int)register0x00000010 + -0x10c) =
                   (int)*(double *)((int)register0x00000010 + -0xa0);
              *(int *)((int)register0x00000010 + -0x94) =
                   (int)*(double *)((int)register0x00000010 + -0xa0) >> 0x1f;
              *(uint *)((int)register0x00000010 + -0xa4) = DAT_005f9510;
              *(undefined1 **)((int)register0x00000010 + -0x1e0) =
                   (undefined1 *)((int)register0x00000010 + -0x164);
              *(undefined1 **)((int)register0x00000010 + -0x1dc) =
                   (undefined1 *)
                   ((int)register0x00000010 + ((uVar6 & (int)(uVar6 - 0x18) >> 0x1f) - 0x1bd));
              *(uint *)((int)register0x00000010 + -0x1d8) = -(uVar6 - 0x18);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419d07;
              FUN_00452050();
              *(undefined4 *)((int)register0x00000010 + -0x10) =
                   *(undefined4 *)((int)register0x00000010 + -0x1d4);
              *(undefined4 *)((int)register0x00000010 + -0xa8) =
                   *(undefined4 *)((int)register0x00000010 + -0x1d0);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419d22;
              FUN_0043a810();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c2a20;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 3;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419d38;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                   *(undefined4 *)((int)register0x00000010 + -0xa4);
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419d4f;
              FUN_0043ad50();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c2948;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 2;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419d65;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                   *(undefined4 *)((int)register0x00000010 + -0x10);
              *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                   *(undefined4 *)((int)register0x00000010 + -0xa8);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419d7f;
              FUN_0043b060();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c294a;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 2;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419d95;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                   *(undefined4 *)((int)register0x00000010 + -0x10c);
              *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                   *(undefined4 *)((int)register0x00000010 + -0x94);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419daf;
              FUN_0043ae80();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c2a23;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 3;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419dc5;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419dca;
              FUN_0043a870();
              *(int *)((int)register0x00000010 + -0xfc) = DAT_005d76e8;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419ded;
              uVar6 = DAT_005d76e4;
              FUN_0046ef4a();
              *(uint *)((int)register0x00000010 + -0x68) = DAT_005d76ec;
              *(int *)((int)register0x00000010 + -100) = DAT_005d76f0;
              *(uint *)((int)register0x00000010 + -0x60) = DAT_005d76f4;
              *(int *)((int)register0x00000010 + -0x5c) = DAT_005d76f8;
              *(uint *)((int)register0x00000010 + -0x58) = DAT_005d76fc;
              *(int *)((int)register0x00000010 + -0x54) = DAT_005d7700;
              iVar8 = *(int *)((int)register0x00000010 + -0xfc);
              iVar7 = 0;
              while (iVar7 < 3) {
                uVar5 = *(uint *)((int)register0x00000010 + iVar7 * 8 + -0x68);
                *(uint *)((int)register0x00000010 + -0x100) = uVar5;
                uVar11 = ((uint *)((int)register0x00000010 + iVar7 * 8 + -0x68))[1];
                *(uint *)((int)register0x00000010 + -0xfc) = uVar11;
                if (iVar7 != 0) {
                  *(int *)((int)register0x00000010 + -0xe8) = iVar7;
                  *(int *)((int)register0x00000010 + -0x94) = iVar8;
                  *(uint *)((int)register0x00000010 + -0xa4) = uVar6;
                  *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419f2e;
                  FUN_0043a810();
                  *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c2927;
                  *(undefined4 *)((int)register0x00000010 + -0x1dc) = 1;
                  *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419f44;
                  FUN_0043b060();
                  *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419f49;
                  FUN_0043a870();
                  iVar7 = *(int *)((int)register0x00000010 + -0xe8);
                  uVar6 = *(uint *)((int)register0x00000010 + -0xa4);
                  iVar8 = *(int *)((int)register0x00000010 + -0x94);
                  uVar11 = *(uint *)((int)register0x00000010 + -0xfc);
                  uVar5 = *(uint *)((int)register0x00000010 + -0x100);
                }
                *(undefined1 **)((int)register0x00000010 + -0x1e0) =
                     (undefined1 *)((int)register0x00000010 + -0x1bd);
                *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0x18;
                *(undefined4 *)((int)register0x00000010 + -0x1d8) = 0x18;
                *(int *)((int)register0x00000010 + -0xa8) = iVar7 + 1;
                *(uint *)((int)register0x00000010 + -0x1d4) = uVar5 - uVar6;
                *(uint *)((int)register0x00000010 + -0x1d0) =
                     (uVar11 - iVar8) - (uint)(uVar5 < uVar6);
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419e7b;
                FUN_0041bb80();
                *(undefined1 **)((int)register0x00000010 + -0x1e0) =
                     (undefined1 *)((int)register0x00000010 + -0x184);
                *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                     *(undefined4 *)((int)register0x00000010 + -0x1cc);
                *(undefined4 *)((int)register0x00000010 + -0x1d8) =
                     *(undefined4 *)((int)register0x00000010 + -0x1c8);
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419e97;
                FUN_00452050();
                *(undefined4 *)((int)register0x00000010 + -0x10) =
                     *(undefined4 *)((int)register0x00000010 + -0x1d4);
                *(undefined4 *)((int)register0x00000010 + -0xac) =
                     *(undefined4 *)((int)register0x00000010 + -0x1d0);
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419eb2;
                FUN_0043a810();
                *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                     *(undefined4 *)((int)register0x00000010 + -0x10);
                *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                     *(undefined4 *)((int)register0x00000010 + -0xac);
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419ecc;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419ed1;
                FUN_0043a870();
                iVar8 = *(int *)((int)register0x00000010 + -0xfc);
                uVar6 = *(uint *)((int)register0x00000010 + -0x100);
                iVar7 = *(int *)((int)register0x00000010 + -0xa8);
              }
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419f76;
              FUN_0043a810();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c3a54;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0xb;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419f8c;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419f91;
              FUN_0043a870();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f6840;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419fa0;
              thunk_FUN_004027a0();
              *(undefined4 *)((int)register0x00000010 + -0x138) =
                   *(undefined4 *)((int)register0x00000010 + -0x1dc);
              *(undefined4 *)((int)register0x00000010 + -0x11c) =
                   *(undefined4 *)((int)register0x00000010 + -0x1d8);
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f6848;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419fc4;
              thunk_FUN_004027a0();
              *(undefined4 *)((int)register0x00000010 + -0x13c) =
                   *(undefined4 *)((int)register0x00000010 + -0x1dc);
              *(undefined4 *)((int)register0x00000010 + -0x120) =
                   *(undefined4 *)((int)register0x00000010 + -0x1d8);
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f6850;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x419fe8;
              thunk_FUN_004027a0();
              *(undefined4 *)((int)register0x00000010 + -0x140) =
                   *(undefined4 *)((int)register0x00000010 + -0x1dc);
              *(undefined4 *)((int)register0x00000010 + -0x124) =
                   *(undefined4 *)((int)register0x00000010 + -0x1d8);
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f6858;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a00d;
              thunk_FUN_004027a0();
              uVar4 = *(undefined4 *)((int)register0x00000010 + -0x1dc);
              *(undefined4 *)((int)register0x00000010 + -0x128) =
                   *(undefined4 *)((int)register0x00000010 + -0x1d8);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a02c;
              FUN_0046ef46();
              lVar3 = ZEXT48(DAT_005d76dc) * (ulong)(DAT_005d76ec - DAT_005d76e4);
              *(int *)((int)register0x00000010 + -0x90) = (int)lVar3;
              *(uint *)((int)register0x00000010 + -0x8c) =
                   ((DAT_005d76f0 - DAT_005d76e8) - (uint)(DAT_005d76ec < DAT_005d76e4)) *
                   (int)DAT_005d76dc + (int)((ulong)lVar3 >> 0x20) +
                   (DAT_005d76ec - DAT_005d76e4) * ((int)DAT_005d76dc >> 0x1f);
              *(undefined4 *)((int)register0x00000010 + -0x88) =
                   *(undefined4 *)((int)register0x00000010 + -0x138);
              *(undefined4 *)((int)register0x00000010 + -0x84) =
                   *(undefined4 *)((int)register0x00000010 + -0x11c);
              *(uint *)((int)register0x00000010 + -0x80) =
                   *(uint *)((int)register0x00000010 + -0x140) +
                   *(uint *)((int)register0x00000010 + -0x13c);
              *(uint *)((int)register0x00000010 + -0x7c) =
                   *(int *)((int)register0x00000010 + -0x124) +
                   *(int *)((int)register0x00000010 + -0x120) +
                   (uint)CARRY4(*(uint *)((int)register0x00000010 + -0x140),
                                *(uint *)((int)register0x00000010 + -0x13c));
              *(undefined4 *)((int)register0x00000010 + -0x78) = uVar4;
              *(undefined4 *)((int)register0x00000010 + -0x74) =
                   *(undefined4 *)((int)register0x00000010 + -0x128);
              lVar3 = ZEXT48(DAT_005d76dc) * (ulong)(DAT_005d76fc - DAT_005d76f4);
              *(int *)((int)register0x00000010 + -0x70) = (int)lVar3;
              *(uint *)((int)register0x00000010 + -0x6c) =
                   ((DAT_005d7700 - DAT_005d76f8) - (uint)(DAT_005d76fc < DAT_005d76f4)) *
                   (int)DAT_005d76dc + (int)((ulong)lVar3 >> 0x20) +
                   (DAT_005d76fc - DAT_005d76f4) * ((int)DAT_005d76dc >> 0x1f);
              iVar7 = 0;
              puVar13 = DAT_005d76dc;
              while (iVar7 < 5) {
                *(int *)((int)register0x00000010 + -0xec) = iVar7;
                uVar10 = *(undefined4 *)((int)register0x00000010 + iVar7 * 8 + -0x90);
                *(undefined4 *)((int)register0x00000010 + -0xf8) = uVar10;
                uVar4 = ((undefined4 *)((int)register0x00000010 + iVar7 * 8 + -0x90))[1];
                *(undefined4 *)((int)register0x00000010 + -0xf4) = uVar4;
                if ((iVar7 == 2) || (iVar7 == 3)) {
                  *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a1da;
                  FUN_0043a810();
                  *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c2924;
                  *(undefined4 *)((int)register0x00000010 + -0x1dc) = 1;
                  *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a1f0;
                  FUN_0043b060();
                  *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a1f5;
                  FUN_0043a870();
                  uVar4 = *(undefined4 *)((int)register0x00000010 + -0xf4);
                  uVar10 = *(undefined4 *)((int)register0x00000010 + -0xf8);
                }
                else if (iVar7 != 0) {
                  *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a215;
                  FUN_0043a810();
                  *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c2927;
                  *(undefined4 *)((int)register0x00000010 + -0x1dc) = 1;
                  *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a22b;
                  FUN_0043b060();
                  *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a230;
                  FUN_0043a870();
                  uVar4 = *(undefined4 *)((int)register0x00000010 + -0xf4);
                  uVar10 = *(undefined4 *)((int)register0x00000010 + -0xf8);
                }
                *(undefined1 **)((int)register0x00000010 + -0x1e0) =
                     (undefined1 *)((int)register0x00000010 + -0x1bd);
                *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0x18;
                *(undefined4 *)((int)register0x00000010 + -0x1d8) = 0x18;
                *(undefined4 *)((int)register0x00000010 + -0x1d4) = uVar10;
                *(undefined4 *)((int)register0x00000010 + -0x1d0) = uVar4;
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a143;
                FUN_0041bb80();
                *(undefined1 **)((int)register0x00000010 + -0x1e0) =
                     (undefined1 *)((int)register0x00000010 + -0x1a4);
                *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                     *(undefined4 *)((int)register0x00000010 + -0x1cc);
                *(undefined4 *)((int)register0x00000010 + -0x1d8) =
                     *(undefined4 *)((int)register0x00000010 + -0x1c8);
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a15f;
                FUN_00452050();
                *(undefined4 *)((int)register0x00000010 + -0x10) =
                     *(undefined4 *)((int)register0x00000010 + -0x1d4);
                *(undefined4 *)((int)register0x00000010 + -0xa8) =
                     *(undefined4 *)((int)register0x00000010 + -0x1d0);
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a17a;
                FUN_0043a810();
                *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                     *(undefined4 *)((int)register0x00000010 + -0x10);
                *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                     *(undefined4 *)((int)register0x00000010 + -0xa8);
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a194;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a199;
                FUN_0043a870();
                iVar7 = *(int *)((int)register0x00000010 + -0xec) + 1;
              }
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f6800;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a258;
              FUN_004027a0();
              *(uint *)((int)register0x00000010 + -0xa4) =
                   *(uint *)((int)register0x00000010 + -0x1d8) << 0xc |
                   *(uint *)((int)register0x00000010 + -0x1dc) >> 0x14;
              *(uint *)((int)register0x00000010 + -0xb0) =
                   *(uint *)((int)register0x00000010 + -0x1d8) >> 0x14;
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f6810;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a289;
              FUN_004027a0();
              *(uint *)((int)register0x00000010 + -0xb4) = DAT_005d7710 >> 0x14;
              *(uint *)((int)register0x00000010 + -0xb8) =
                   DAT_005d7710 << 0xc | DAT_005d770c >> 0x14;
              *(uint *)((int)register0x00000010 + -0xbc) = DAT_005d7718 >> 0x14;
              *(uint *)((int)register0x00000010 + -0xc0) =
                   DAT_005d7718 << 0xc | DAT_005d7714 >> 0x14;
              *(uint *)((int)register0x00000010 + -0xc4) = DAT_005d7720 >> 0x14;
              *(uint *)((int)register0x00000010 + -200) = DAT_005d7720 << 0xc | DAT_005d771c >> 0x14
              ;
              *(uint *)((int)register0x00000010 + -0xcc) = DAT_005f67e4 >> 0x14;
              *(uint *)((int)register0x00000010 + -0xd0) =
                   DAT_005f67e4 << 0xc | DAT_005f67e0 >> 0x14;
              *(uint *)((int)register0x00000010 + -0x94) = DAT_005d76e0;
              *(int *)((int)register0x00000010 + -0x98) = (int)DAT_005d76e0 >> 0x1f;
              *(uint *)((int)register0x00000010 + -0xd4) =
                   *(uint *)((int)register0x00000010 + -0x1dc) >> 0x14;
              *(undefined4 *)((int)register0x00000010 + -300) =
                   *(undefined4 *)((int)register0x00000010 + -0x1d8);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a35a;
              FUN_0043a810();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c3342;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 9;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a370;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                   *(undefined4 *)((int)register0x00000010 + -0xb8);
              *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                   *(undefined4 *)((int)register0x00000010 + -0xb4);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a38a;
              FUN_0043ad50();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c294c;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 2;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a3a0;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                   *(undefined4 *)((int)register0x00000010 + -0xc0);
              *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                   *(undefined4 *)((int)register0x00000010 + -0xbc);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a3ba;
              FUN_0043ad50();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c294c;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 2;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a3d0;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                   *(undefined4 *)((int)register0x00000010 + -200);
              *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                   *(undefined4 *)((int)register0x00000010 + -0xc4);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a3ea;
              FUN_0043ad50();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c2c4b;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 5;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a400;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                   *(undefined4 *)((int)register0x00000010 + -0xd0);
              *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                   *(undefined4 *)((int)register0x00000010 + -0xcc);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a41a;
              FUN_0043ad50();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c3657;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 10;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a430;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                   *(undefined4 *)((int)register0x00000010 + -0xa4);
              *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                   *(undefined4 *)((int)register0x00000010 + -0xb0);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a44a;
              FUN_0043ad50();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c3f13;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0xc;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a460;
              FUN_0043b060();
              *(uint *)((int)register0x00000010 + -0x1e0) =
                   *(uint *)((int)register0x00000010 + -300) << 0xc |
                   *(uint *)((int)register0x00000010 + -0xd4);
              *(uint *)((int)register0x00000010 + -0x1dc) =
                   *(uint *)((int)register0x00000010 + -300) >> 0x14;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a484;
              FUN_0043ad50();
              *(char **)((int)register0x00000010 + -0x1e0) =
                   " MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
              ;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0xd;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a49a;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e0) =
                   *(undefined4 *)((int)register0x00000010 + -0x94);
              *(undefined4 *)((int)register0x00000010 + -0x1dc) =
                   *(undefined4 *)((int)register0x00000010 + -0x98);
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a4b4;
              FUN_0043ae80();
              *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c294e;
              *(undefined4 *)((int)register0x00000010 + -0x1dc) = 2;
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a4ca;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a4cf;
              FUN_0043a870();
              if (DAT_005d76a8 != '\0') {
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a4df;
                FUN_0043a810();
                *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_004c334b;
                *(undefined4 *)((int)register0x00000010 + -0x1dc) = 9;
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a4f5;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a4fa;
                FUN_0043a870();
              }
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a4ff;
              FUN_0043a810();
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a504;
              FUN_0043aa10();
              *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a509;
              FUN_0043a870();
              iVar7 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
              cVar2 = *(char *)(iVar7 + 0x8b);
              *(char *)(iVar7 + 0x8b) = cVar2 + -1;
              if (cVar2 == '\x01') {
                *(undefined **)((int)register0x00000010 + -0x1e0) = &DAT_005f5e5c;
                *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a53d;
                FUN_0040f0e0();
              }
              goto code_r0x0041a53f;
            }
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a692;
            FUN_0046edf0();
LAB_0041a692:
            *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a69c;
            FUN_0046edf0();
            goto LAB_0041a69c;
          }
        }
        else {
          if (cVar2 == '\0') goto LAB_00419a68;
LAB_0041a69c:
          *(char **)((int)register0x00000010 + -0x1e0) =
               "non-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an a..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0x35;
          *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a6b2;
          FUN_00469a20();
        }
        *(char **)((int)register0x00000010 + -0x1e0) =
             "failed to set sweep barrierwork.nwait was > work.nproc not in stack roots range [allocated pages below zero?address not a stack addressmspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServers..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0x1b;
        *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a6c8;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x1e0) =
           "gc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x1dc) = 0x1d;
      *(undefined4 *)((int)register0x00000010 + -0x1e4) = 0x41a6de;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar12 + -4) = 0x41a6e4;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
}



/* Function: FUN_0041a8e0 */

void FUN_0041a8e0(void)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined4 *local_14;
  undefined4 local_10;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (DAT_005f5e88 <= DAT_005f5e98) {
    return;
  }
  iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
  *piVar1 = *piVar1 + 1;
  iVar2 = *(int *)(iVar2 + 0x18);
  local_14 = (undefined4 *)0x1;
  FUN_004096b0(&DAT_004abcc0);
  iVar3 = *(int *)(iVar2 + 0x7c);
  iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(int *)(iVar2 + 0x7c) = iVar3 + -1;
  if ((iVar3 == 1) && (*(char *)(iVar4 + 0x69) != '\0')) {
    *(undefined4 *)(iVar4 + 8) = 0xfffffade;
  }
  for (; DAT_005f5e98 < DAT_005f5e88; DAT_005f5e98 = DAT_005f5e98 + 1) {
    iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
    *piVar1 = *piVar1 + 1;
    iVar2 = *(int *)(iVar2 + 0x18);
    FUN_00411710(&DAT_004b1ba0);
    *local_14 = &LAB_0041aa50;
    if (DAT_005f5fd0 != 0) {
      FUN_0046ed70();
      *in_EDI = local_10;
    }
    local_14[1] = local_10;
    FUN_00444df0(local_14);
    iVar3 = *(int *)(iVar2 + 0x7c);
    iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    *(int *)(iVar2 + 0x7c) = iVar3 + -1;
    if ((iVar3 == 1) && (*(char *)(iVar4 + 0x69) != '\0')) {
      *(undefined4 *)(iVar4 + 8) = 0xfffffade;
    }
    local_14 = (undefined4 *)0x0;
    FUN_0040a470(local_10);
  }
  return;
}



/* Function: FUN_0041aa90 */

void FUN_0041aa90(void)

{
  int *piVar1;
  undefined4 uVar2;
  uint uVar3;
  int iVar4;
  byte bVar5;
  undefined *puVar6;
  int iVar7;
  undefined *puVar8;
  undefined4 uVar9;
  int iVar10;
  int iVar11;
  undefined1 uVar12;
  undefined1 *puVar13;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar13 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar13 = (undefined1 *)((int)register0x00000010 + -0x58);
      iVar11 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      *(int *)((int)register0x00000010 + -0x14) = iVar11;
      iVar11 = *(int *)(iVar11 + 0x18);
      *(undefined4 *)(iVar11 + 0x78) = 0xe;
      if (DAT_005f5fd0 != 0) {
        uVar9 = *(undefined4 *)(iVar11 + 0x74);
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41aad2;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      *(char **)(iVar11 + 0x74) =
           "GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion";
      *(undefined **)((int)register0x00000010 + -0x58) = &DAT_004b6a40;
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41aaeb;
      FUN_00411710();
      iVar11 = *(int *)((int)register0x00000010 + -0x14);
      iVar7 = *(int *)(iVar11 + 0x18);
      iVar10 = *(int *)((int)register0x00000010 + -0x54);
      *(undefined4 *)(iVar7 + 0x78) = 0;
      if (DAT_005f5fd0 != 0) {
        uVar9 = *(undefined4 *)(iVar7 + 0x74);
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ab0f;
        FUN_0046ed70();
        *in_EDI = uVar9;
      }
      *(int *)((int)register0x00000010 + -0x18) = iVar10;
      *(undefined4 *)(iVar7 + 0x74) = 0;
      *(int *)(iVar10 + 0xc) = iVar11;
      iVar11 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      piVar1 = (int *)(*(int *)(iVar11 + 0x18) + 0x7c);
      *piVar1 = *piVar1 + 1;
      *(undefined4 *)(iVar10 + 0x10) = *(undefined4 *)(iVar11 + 0x18);
      *(undefined4 *)((int)register0x00000010 + -0x58) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined1 **)((int)register0x00000010 + -0x54) =
           (undefined1 *)((int)register0x00000010 + -0x40);
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ab4d;
      FUN_00409890();
      while( true ) {
        *(undefined ***)((int)register0x00000010 + -0x58) = &PTR_LAB_00536ae4;
        *(undefined4 *)((int)register0x00000010 + -0x54) =
             *(undefined4 *)((int)register0x00000010 + -0x18);
        *(undefined2 *)((int)register0x00000010 + -0x50) = 0xa1b;
        *(undefined4 *)((int)register0x00000010 + -0x4c) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ab72;
        FUN_00469a60();
        iVar11 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
        piVar1 = (int *)(*(int *)(iVar11 + 0x18) + 0x7c);
        *piVar1 = *piVar1 + 1;
        *(undefined4 *)(*(int *)((int)register0x00000010 + -0x18) + 0x10) =
             *(undefined4 *)(iVar11 + 0x18);
        iVar11 = *(int *)(*(int *)(*(int *)((int)register0x00000010 + -0x14) + 0x18) + 0x58);
        if (DAT_005f5e08 == 0) break;
        if (*(int *)(iVar11 + 0x960) == 0) {
LAB_0041aed9:
          *(char **)((int)register0x00000010 + -0x58) =
               "gcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
          ;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0x1c;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41aeef;
          FUN_00469a20();
          break;
        }
        *(int *)((int)register0x00000010 + -0x10) = iVar11;
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41abbf;
        FUN_0046fa70();
        uVar9 = *(undefined4 *)((int)register0x00000010 + -0x58);
        *(undefined4 *)((int)register0x00000010 + -0x3c) = uVar9;
        uVar2 = *(undefined4 *)((int)register0x00000010 + -0x54);
        *(undefined4 *)((int)register0x00000010 + -0x34) = uVar2;
        iVar11 = *(int *)((int)register0x00000010 + -0x10);
        *(undefined4 *)(iVar11 + 0x964) = uVar9;
        *(undefined4 *)(iVar11 + 0x968) = uVar2;
        if (*(int *)(iVar11 + 0x960) == 3) {
          iVar11 = iVar11 + 0x958;
          *(int *)((int)register0x00000010 + -0x58) = iVar11;
          *(undefined1 *)((int)register0x00000010 + -0x54) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x50) = uVar9;
          *(undefined4 *)((int)register0x00000010 + -0x4c) = uVar2;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ac06;
          FUN_0041c970();
          uVar12 = *(undefined1 *)((int)register0x00000010 + -0x48);
        }
        else {
          uVar12 = 0;
        }
        *(undefined1 *)((int)register0x00000010 + -0x41) = uVar12;
        *(undefined4 **)((int)register0x00000010 + -0x58) = &DAT_005d7664;
        *(undefined4 *)((int)register0x00000010 + -0x54) = 0xffffffff;
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ac27;
        FUN_00402690();
        puVar6 = *(undefined **)((int)register0x00000010 + -0x50);
        puVar8 = DAT_005d7658;
        if (DAT_005d7658 == puVar6) {
LAB_0041ae58:
          *(undefined **)((int)register0x00000010 + -0x24) = puVar6;
          *(undefined **)((int)register0x00000010 + -0x1c) = puVar8;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ae65;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x58) = &DAT_004c6d7a;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0x15;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ae7b;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x58) =
               *(undefined4 *)((int)register0x00000010 + -0x24);
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ae8f;
          FUN_0043ad50();
          *(char **)((int)register0x00000010 + -0x58) =
               " work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
          ;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0xd;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41aea5;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x58) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41aeb9;
          FUN_0043ad50();
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41aebe;
          FUN_0043aa10();
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41aec3;
          FUN_0043a870();
          *(char **)((int)register0x00000010 + -0x58) =
               "work.nwait was > work.nproc not in stack roots range [allocated pages below zero?address not a stack addressmspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_Lis..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0x1b;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41aed9;
          FUN_00469a20();
          goto LAB_0041aed9;
        }
        *(undefined1 **)((int)register0x00000010 + -0xc) = &LAB_0041af60;
        *(undefined4 *)((int)register0x00000010 + -8) =
             *(undefined4 *)((int)register0x00000010 + -0x14);
        *(undefined4 *)((int)register0x00000010 + -4) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined1 **)((int)register0x00000010 + -0x58) =
             (undefined1 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ac5f;
        FUN_0046d890();
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ac65;
        FUN_0046fa70();
        uVar9 = *(undefined4 *)(*(int *)((int)register0x00000010 + -0x10) + 0x960);
        uVar3 = *(uint *)((int)register0x00000010 + -0x58);
        *(uint *)((int)register0x00000010 + -0x40) = uVar3;
        iVar11 = *(int *)((int)register0x00000010 + -0x54);
        *(int *)((int)register0x00000010 + -0x38) = iVar11;
        *(undefined **)((int)register0x00000010 + -0x58) = &DAT_005f6780;
        *(undefined4 *)((int)register0x00000010 + -0x54) = uVar9;
        iVar7 = uVar3 - *(uint *)((int)register0x00000010 + -0x3c);
        *(int *)((int)register0x00000010 + -0x2c) = iVar7;
        *(int *)((int)register0x00000010 + -0x50) = iVar7;
        iVar11 = (iVar11 - *(int *)((int)register0x00000010 + -0x34)) -
                 (uint)(uVar3 < *(uint *)((int)register0x00000010 + -0x3c));
        *(int *)((int)register0x00000010 + -0x28) = iVar11;
        *(int *)((int)register0x00000010 + -0x4c) = iVar11;
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41acac;
        FUN_004226a0();
        if (*(char *)((int)register0x00000010 + -0x41) != '\0') {
          *(int *)((int)register0x00000010 + -0x58) =
               *(int *)((int)register0x00000010 + -0x10) + 0x958;
          *(undefined1 *)((int)register0x00000010 + -0x54) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x50) =
               *(undefined4 *)((int)register0x00000010 + -0x40);
          *(undefined4 *)((int)register0x00000010 + -0x4c) =
               *(undefined4 *)((int)register0x00000010 + -0x38);
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41acdb;
          FUN_0041cb30();
        }
        if (*(int *)(*(int *)((int)register0x00000010 + -0x10) + 0x960) == 2) {
          *(int *)((int)register0x00000010 + -0x58) =
               *(int *)((int)register0x00000010 + -0x10) + 0x950;
          *(undefined4 *)((int)register0x00000010 + -0x54) =
               *(undefined4 *)((int)register0x00000010 + -0x2c);
          *(undefined4 *)((int)register0x00000010 + -0x50) =
               *(undefined4 *)((int)register0x00000010 + -0x28);
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ad05;
          thunk_FUN_004026b0();
        }
        *(undefined4 **)((int)register0x00000010 + -0x58) = &DAT_005d7664;
        *(undefined4 *)((int)register0x00000010 + -0x54) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ad1b;
        FUN_00402690();
        puVar6 = *(undefined **)((int)register0x00000010 + -0x50);
        if (DAT_005d7658 < puVar6) {
          *(undefined **)((int)register0x00000010 + -0x30) = puVar6;
          *(undefined **)((int)register0x00000010 + -0x1c) = DAT_005d7658;
          *(undefined4 *)((int)register0x00000010 + -0x20) =
               *(undefined4 *)(*(int *)((int)register0x00000010 + -0x10) + 0x960);
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41adbb;
          puVar8 = DAT_005d7658;
          FUN_0043a810();
          *(char **)((int)register0x00000010 + -0x58) =
               "runtime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
          ;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0x1d;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41add1;
          FUN_0043b060();
          *(int *)((int)register0x00000010 + -0x58) = *(int *)((int)register0x00000010 + -0x20);
          *(int *)((int)register0x00000010 + -0x54) =
               *(int *)((int)register0x00000010 + -0x20) >> 0x1f;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ade4;
          FUN_0043ae80();
          *(char **)((int)register0x00000010 + -0x58) =
               " work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
          ;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0xd;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41adfa;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x58) =
               *(undefined4 *)((int)register0x00000010 + -0x30);
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ae0e;
          FUN_0043ad50();
          *(char **)((int)register0x00000010 + -0x58) =
               " work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
          ;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0xd;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ae24;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x58) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ae38;
          FUN_0043ad50();
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ae3d;
          FUN_0043aa10();
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ae42;
          FUN_0043a870();
          puVar6 = &DAT_004c7a43;
          *(undefined **)((int)register0x00000010 + -0x58) = &DAT_004c7a43;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0x17;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ae58;
          FUN_00469a20();
          goto LAB_0041ae58;
        }
        *(undefined4 *)(*(int *)((int)register0x00000010 + -0x10) + 0x960) = 0;
        if (DAT_005d7658 == puVar6) {
          *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ad4f;
          FUN_0041b100();
          bVar5 = *(byte *)((int)register0x00000010 + -0x54) ^ 1;
        }
        else {
          bVar5 = 0;
        }
        if (bVar5 != 0) {
          iVar11 = *(int *)((int)register0x00000010 + -0x18);
          iVar7 = *(int *)(iVar11 + 0x10);
          iVar10 = *(int *)(iVar7 + 0x7c);
          iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
          *(int *)(iVar7 + 0x7c) = iVar10 + -1;
          if ((iVar10 == 1) && (*(char *)(iVar4 + 0x69) != '\0')) {
            *(undefined4 *)(iVar4 + 8) = 0xfffffade;
          }
          *(undefined4 *)(iVar11 + 0x10) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41ad9b;
          FUN_00418ea0();
        }
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = *(undefined4 *)(iVar11 + 0x960);
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41aefe;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x58) = &DAT_004c3f1f;
      *(undefined4 *)((int)register0x00000010 + -0x54) = 0xc;
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41af14;
      FUN_0043b060();
      *(int *)((int)register0x00000010 + -0x58) = *(int *)((int)register0x00000010 + -0x20);
      *(int *)((int)register0x00000010 + -0x54) = *(int *)((int)register0x00000010 + -0x20) >> 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41af27;
      FUN_0043ae80();
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41af2c;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41af31;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x58) =
           "gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x54) = 0x26;
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x41af47;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar13 + -4) = 0x41af4d;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar13;
  } while( true );
}



/* Function: FUN_0041b100 */

void FUN_0041b100(int param_1)

{
  int in_FS_OFFSET;
  int local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x41b19a;
    FUN_0046d980();
  }
  if (((param_1 != 0) && (*(int *)(param_1 + 0x96c) != 0)) &&
     ((*(int *)(*(int *)(param_1 + 0x96c) + 0xc) != 0 ||
      (*(int *)(*(int *)(param_1 + 0x970) + 0xc) != 0)))) {
    return;
  }
  FUN_004027a0(&DAT_005d75a0);
  if (local_4 != 0 || local_8 != 0) {
    return;
  }
  if (DAT_005d7650 < DAT_005d7654) {
    return;
  }
  return;
}



/* Function: FUN_0041b1a0 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_0041b1a0(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  undefined1 *puVar6;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x44);
      if (DAT_005f5e04 == 2) {
        DAT_005d765c = *(undefined4 *)((int)register0x00000010 + 4);
        DAT_005d7660 = *(undefined4 *)((int)register0x00000010 + 8);
        *(int *)((int)register0x00000010 + -0xc) = DAT_005d75a0;
        *(int *)((int)register0x00000010 + -0x10) = DAT_005d75a4;
        if ((DAT_005d75a4 == 0 && DAT_005d75a0 == 0) && (DAT_005d7654 <= DAT_005d7650)) {
          if (0 < DAT_005f6214) {
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b221;
            FUN_0041ced0();
          }
          DAT_005d7690 = 0;
          _DAT_005d7694 = 0;
          if (DAT_005f5fd0 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b24a;
            FUN_0046ed70();
            *in_EDI = DAT_005d768c;
          }
          DAT_005d768c = 0;
          *(int *)((int)register0x00000010 + -4) = DAT_005d7020;
          *(int *)((int)register0x00000010 + -0x14) = DAT_005d7024;
          iVar5 = 0;
          iVar3 = DAT_005d7020;
          iVar4 = DAT_005d7024;
          while( true ) {
            iVar2 = DAT_005d7024;
            iVar1 = DAT_005d7020;
            if (iVar4 <= iVar5) {
              for (iVar5 = 0; iVar5 < iVar2; iVar5 = iVar5 + 1) {
                iVar3 = *(int *)(*(int *)(iVar1 + iVar5 * 4) + 0x30);
                if (iVar3 != 0) {
                  *(undefined4 *)(iVar3 + 0xc) = 0;
                }
              }
              *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f6780;
              *(undefined4 *)((int)register0x00000010 + -0x40) = DAT_005d7648;
              *(undefined4 *)((int)register0x00000010 + -0x3c) = DAT_005d764c;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b32c;
              FUN_00422560();
              return;
            }
            *(int *)((int)register0x00000010 + -0x18) = iVar5;
            iVar5 = *(int *)(iVar3 + iVar5 * 4);
            *(int *)((int)register0x00000010 + -8) = iVar5;
            if (DAT_005f6214 < 1) {
              *(int *)((int)register0x00000010 + -0x44) = iVar5 + 0x988;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b2be;
              FUN_00433de0();
            }
            else {
              *(int *)((int)register0x00000010 + -0x44) = iVar5;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b2ab;
              FUN_00433e50();
            }
            iVar5 = *(int *)((int)register0x00000010 + -8);
            if ((*(int *)(iVar5 + 0x96c) != 0) &&
               ((*(int *)(*(int *)(iVar5 + 0x96c) + 0xc) != 0 ||
                (*(int *)(*(int *)(iVar5 + 0x970) + 0xc) != 0)))) break;
            *(int *)((int)register0x00000010 + -0x44) = iVar5 + 0x96c;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b27b;
            FUN_00428960();
            iVar5 = *(int *)((int)register0x00000010 + -0x18) + 1;
            iVar3 = *(int *)((int)register0x00000010 + -4);
            iVar4 = *(int *)((int)register0x00000010 + -0x14);
          }
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b335;
          FUN_0043a810();
          iVar5 = **(int **)((int)register0x00000010 + -8);
          *(int *)((int)register0x00000010 + -0x1c) = iVar5;
          *(int *)((int)register0x00000010 + -0x20) = iVar5 >> 0x1f;
          *(char *)((int)register0x00000010 + -0x35) =
               (char)(*(int **)((int)register0x00000010 + -8))[0x261];
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b356;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c3a6a;
          *(undefined4 *)((int)register0x00000010 + -0x40) = 0xb;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b36c;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x44) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x40) =
               *(undefined4 *)((int)register0x00000010 + -0x20);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b380;
          FUN_0043ae80();
          *(char **)((int)register0x00000010 + -0x44) =
               " flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
          ;
          *(undefined4 *)((int)register0x00000010 + -0x40) = 0xd;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b396;
          FUN_0043b060();
          *(undefined1 *)((int)register0x00000010 + -0x44) =
               *(undefined1 *)((int)register0x00000010 + -0x35);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b3a3;
          FUN_0043aa50();
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b3a8;
          FUN_0043a870();
          if (*(int *)(*(int *)((int)register0x00000010 + -8) + 0x96c) == 0) {
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b488;
            FUN_0043a810();
            *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c3f43;
            *(undefined4 *)((int)register0x00000010 + -0x40) = 0xc;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b49e;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b4a3;
            FUN_0043a870();
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x14) =
                 *(undefined4 *)(*(int *)(*(int *)((int)register0x00000010 + -8) + 0x96c) + 0xc);
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b3c6;
            FUN_0043a810();
            *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c3354;
            *(undefined4 *)((int)register0x00000010 + -0x40) = 9;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b3dc;
            FUN_0043b060();
            *(int *)((int)register0x00000010 + -0x44) = *(int *)((int)register0x00000010 + -0x14);
            *(int *)((int)register0x00000010 + -0x40) =
                 *(int *)((int)register0x00000010 + -0x14) >> 0x1f;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b3ef;
            FUN_0043ae80();
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b3f4;
            FUN_0043a870();
          }
          if (*(int *)(*(int *)((int)register0x00000010 + -8) + 0x970) == 0) goto LAB_0041b461;
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)(*(int *)(*(int *)((int)register0x00000010 + -8) + 0x970) + 0xc);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b40e;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c335d;
          *(undefined4 *)((int)register0x00000010 + -0x40) = 9;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b424;
          FUN_0043b060();
          *(int *)((int)register0x00000010 + -0x44) = *(int *)((int)register0x00000010 + -0x14);
          *(int *)((int)register0x00000010 + -0x40) =
               *(int *)((int)register0x00000010 + -0x14) >> 0x1f;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b437;
          FUN_0043ae80();
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b43c;
          FUN_0043a870();
          do {
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b441;
            FUN_0043a810();
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b446;
            FUN_0043aa10();
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b44b;
            FUN_0043a870();
            *(char **)((int)register0x00000010 + -0x44) =
                 "P has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitComple..." /* TRUNCATED STRING LITERAL */
            ;
            *(undefined4 *)((int)register0x00000010 + -0x40) = 0x2f;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b461;
            FUN_00469a20();
LAB_0041b461:
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b466;
            FUN_0043a810();
            *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c3f4f;
            *(undefined4 *)((int)register0x00000010 + -0x40) = 0xc;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b47c;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b481;
            FUN_0043a870();
          } while( true );
        }
        *(uint *)((int)register0x00000010 + -0x24) = DAT_005d7650;
        *(uint *)((int)register0x00000010 + -0x28) = DAT_005d7654;
        *(int *)((int)register0x00000010 + -0x14) = DAT_005d7668;
        *(int *)((int)register0x00000010 + -0x1c) = DAT_005d7668 >> 0x1f;
        *(int *)((int)register0x00000010 + -0x18) = DAT_005d766c;
        *(int *)((int)register0x00000010 + -0x20) = DAT_005d766c >> 0x1f;
        *(int *)((int)register0x00000010 + -0x2c) = DAT_005d7670;
        *(int *)((int)register0x00000010 + -0x30) = DAT_005d7670 >> 0x1f;
        *(undefined4 *)((int)register0x00000010 + -0x34) = DAT_005d7674;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b4fe;
        FUN_0043a810();
        *(char **)((int)register0x00000010 + -0x44) =
             "runtime: full=runtime: want=MB; allocated RtlGetVersion";
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0xe;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b514;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b528;
        FUN_0043aef0();
        *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c2d56;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 6;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b53e;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b552;
        FUN_0043ad50();
        *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c2d5c;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 6;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b568;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0x28);
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b57c;
        FUN_0043ad50();
        *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c3f2b;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0xc;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b592;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0x14);
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -0x1c);
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b5a6;
        FUN_0043ae80();
        *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c3a5f;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0xb;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b5bc;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0x18);
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b5d0;
        FUN_0043ae80();
        *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004c3f37;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0xc;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b5e6;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0x2c);
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -0x30);
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b5fa;
        FUN_0043ae80();
        *(char **)((int)register0x00000010 + -0x44) =
             " nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0xd;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b610;
        FUN_0043b060();
        *(int *)((int)register0x00000010 + -0x44) = *(int *)((int)register0x00000010 + -0x34);
        *(int *)((int)register0x00000010 + -0x40) =
             *(int *)((int)register0x00000010 + -0x34) >> 0x1f;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b623;
        FUN_0043ae80();
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b628;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b62d;
        FUN_0043a870();
        *(undefined **)((int)register0x00000010 + -0x44) = &DAT_004adee0;
        *(undefined ***)((int)register0x00000010 + -0x40) = &PTR_DAT_00550d18;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b645;
        FUN_00469650();
      }
      *(char **)((int)register0x00000010 + -0x44) =
           "in gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgoche..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x38;
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x41b65b;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x41b661;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_0041b670 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_0041b670(void)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  undefined1 *puVar5;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x18);
      if (DAT_005f5e04 == 0) {
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005ddde0;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b6a5;
        FUN_0040ecf0();
        DAT_005dde90 = DAT_005dde90 + 2;
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005d716c;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b6c4;
        FUN_00402770();
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005ddea8;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b6e3;
        FUN_004027c0();
        _DAT_005ddf50 = DAT_005ddf44;
        _DAT_005ddf54 = DAT_005ddf48;
        uVar3 = DAT_005ddf40;
        if (DAT_005f5fd0 != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b710;
          FUN_0046ed80();
          *in_EDI = uVar3;
          in_EDI[1] = DAT_005ddf4c;
        }
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005ddec8;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b740;
        DAT_005ddf4c = uVar3;
        FUN_004027c0();
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005dded0;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b757;
        thunk_FUN_00402770();
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005ddde0;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b767;
        FUN_0040f0e0();
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005d7170;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b77e;
        FUN_00402770();
        if (*(int *)((int)register0x00000010 + 4) == 2) {
          *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005ddde0;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b797;
          FUN_0040ecf0();
          DAT_005ddec0 = 0;
          *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005ddde0;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b7b2;
          FUN_0040f0e0();
          *(int *)((int)register0x00000010 + -4) = DAT_005d7020;
          *(int *)((int)register0x00000010 + -8) = DAT_005d7024;
          iVar4 = 0;
          iVar1 = DAT_005d7020;
          iVar2 = DAT_005d7024;
          while (iVar4 < iVar2) {
            *(int *)((int)register0x00000010 + -0xc) = iVar4;
            *(undefined4 *)((int)register0x00000010 + -0x18) =
                 *(undefined4 *)(*(int *)(iVar1 + iVar4 * 4) + 0x30);
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b832;
            FUN_00414310();
            iVar1 = *(int *)((int)register0x00000010 + -4);
            iVar2 = *(int *)((int)register0x00000010 + -8);
            iVar4 = *(int *)((int)register0x00000010 + -0xc) + 1;
          }
          do {
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b84a;
            FUN_00426bd0();
          } while (*(int *)((int)register0x00000010 + -0x18) != -1);
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b855;
          FUN_00428f10();
          do {
            *(undefined1 *)((int)register0x00000010 + -0x18) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b85e;
            FUN_00429020();
          } while (*(char *)((int)register0x00000010 + -0x14) != '\0');
          *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005f5e1c;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b876;
          FUN_00430d00();
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b87b;
          FUN_004312c0();
          *(undefined1 *)((int)register0x00000010 + 8) = 1;
          return;
        }
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005d7160;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b7da;
        FUN_0040ecf0();
        if (DAT_005d7168 != '\0') {
          DAT_005d7168 = '\0';
          *(undefined4 *)((int)register0x00000010 + -0x18) = DAT_005d7164;
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
          *(undefined1 *)((int)register0x00000010 + -0x10) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b807;
          FUN_0043cda0();
        }
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005d7160;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b817;
        FUN_0040f0e0();
        *(undefined1 *)((int)register0x00000010 + 8) = 0;
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004cc0c3;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x29;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b89a;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x41b8a0;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_0041b8b0 */

void FUN_0041b8b0(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x18);
      *(undefined ***)((int)register0x00000010 + -0x18) = &PTR_LAB_00536afc;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b8d5;
      FUN_0043c360();
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005ddde0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b8e5;
      FUN_0040ecf0();
      *(undefined4 *)((int)register0x00000010 + -0xc) = DAT_005ddf44;
      *(undefined4 *)((int)register0x00000010 + -4) = DAT_005ddf40;
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005ddde0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b909;
      FUN_0040f0e0();
      iVar2 = *(int *)((int)register0x00000010 + -0xc);
      iVar3 = *(int *)((int)register0x00000010 + -4);
      iVar4 = 0;
      while( true ) {
        if (iVar2 <= iVar4) {
          DAT_005d7648 = 0;
          DAT_005d764c = 0;
          *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005f67e8;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b97d;
          FUN_004027a0();
          DAT_005d76ac = *(undefined4 *)((int)register0x00000010 + -0x14);
          DAT_005d76b0 = *(undefined4 *)((int)register0x00000010 + -0x10);
          return;
        }
        uVar1 = *(uint *)(iVar3 + iVar4 * 4);
        if (0x3ff < uVar1) break;
        *(int *)((int)register0x00000010 + -8) = iVar4;
        *(int *)((int)register0x00000010 + -0x18) = *(int *)(DAT_005ddf14 + uVar1 * 4) + 0x840;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x40;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b93b;
        FUN_0046f470();
        iVar4 = *(int *)((int)register0x00000010 + -8) + 1;
        iVar2 = *(int *)((int)register0x00000010 + -0xc);
        iVar3 = *(int *)((int)register0x00000010 + -4);
      }
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41b9a1;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar5 + -4) = 0x41b9a7;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_0041ba10 */

void FUN_0041ba10(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int *in_EDI;
  int in_FS_OFFSET;
  int local_c;
  int local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x41bb78;
    FUN_0046d980();
  }
  if (DAT_005d6dbc != (undefined4 *)0x0) {
    (*(code *)*DAT_005d6dbc)();
  }
  local_4 = DAT_005d6fd0;
  local_8 = DAT_005d6fd4;
  iVar2 = 0;
  while (iVar2 < local_8) {
    local_c = iVar2;
    FUN_00408fc0(*(undefined4 *)(local_4 + iVar2 * 4),0);
    iVar2 = local_c + 1;
  }
  if (DAT_005d6dc0 != 0) {
    FUN_0040acf0(DAT_005d6dc0,&local_c);
  }
  FUN_0040ecf0(&DAT_005d8560);
  iVar2 = DAT_005d8564;
  while (iVar2 != 0) {
    iVar3 = *(int *)(iVar2 + 4);
    if (DAT_005f5fd0 != 0) {
      iVar1 = *(int *)(iVar2 + 4);
      FUN_0046ed70();
      *in_EDI = iVar1;
    }
    *(undefined4 *)(iVar2 + 4) = 0;
    iVar2 = iVar3;
  }
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed70();
    *in_EDI = DAT_005d8564;
  }
  DAT_005d8564 = 0;
  FUN_0040f0e0(&DAT_005d8560);
  FUN_0040ecf0(&DAT_005d8568);
  iVar2 = DAT_005d856c;
  while (iVar2 != 0) {
    iVar3 = *(int *)(iVar2 + 0x10);
    if (DAT_005f5fd0 != 0) {
      iVar1 = *(int *)(iVar2 + 0x10);
      FUN_0046ed70();
      *in_EDI = iVar1;
    }
    *(undefined4 *)(iVar2 + 0x10) = 0;
    iVar2 = iVar3;
  }
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed70();
    *in_EDI = DAT_005d856c;
  }
  DAT_005d856c = 0;
  FUN_0040f0e0(&DAT_005d8568);
  return;
}



/* Function: FUN_0041bb80 */

void FUN_0041bb80(void)

{
  ulong uVar1;
  long lVar2;
  undefined8 uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  undefined4 uVar9;
  undefined1 *puVar10;
  uint unaff_EBP;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint in_EDI;
  uint uVar14;
  int in_FS_OFFSET;
  bool bVar15;
  
  do {
    puVar10 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar10 = (undefined1 *)((int)register0x00000010 + -0x30);
      uVar6 = *(uint *)((int)register0x00000010 + 0x14);
      uVar7 = *(uint *)((int)register0x00000010 + 0x10);
      uVar14 = CONCAT31((int3)(in_EDI >> 8),9999999 < uVar7) &
               CONCAT31((int3)(unaff_EBP >> 8),uVar6 == 0);
      if (uVar6 != 0 || (char)uVar14 != '\0') {
        *(uint *)((int)register0x00000010 + -0x30) = uVar7;
        *(uint *)((int)register0x00000010 + -0x2c) = uVar6;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 1000000;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x41bc7f;
        FUN_00464c70();
        uVar7 = *(uint *)((int)register0x00000010 + -0x20);
        uVar11 = *(uint *)((int)register0x00000010 + -0x1c);
        uVar13 = *(uint *)((int)register0x00000010 + 8);
        uVar6 = uVar13 - 1;
        *(uint *)((int)register0x00000010 + -0xc) = uVar6;
        iVar4 = *(int *)((int)register0x00000010 + 4);
        uVar12 = uVar6;
        break;
      }
      uVar1 = (ulong)(uVar6 % 1000) * 0x418937 + CONCAT44(uVar6 / 1000,uVar7 / 1000) +
              (ulong)(((uVar6 % 1000) * 0x128 + uVar7 % 1000) / 1000);
      if (uVar1 == 0) {
        uVar3 = 0;
        if (*(int *)((int)register0x00000010 + 8) != 0) {
          puVar10 = *(undefined1 **)((int)register0x00000010 + 4);
          *puVar10 = 0x30;
          *(undefined1 **)((int)register0x00000010 + 0x18) = puVar10;
          *(undefined4 *)((int)register0x00000010 + 0x1c) = 1;
          *(undefined4 *)((int)register0x00000010 + 0x20) =
               *(undefined4 *)((int)register0x00000010 + 0xc);
          return;
        }
        goto LAB_0041bde1;
      }
      iVar4 = 3;
      for (; bVar15 = (int)(uVar1 >> 0x20) == 0, !bVar15 || 99 < (uint)uVar1 && bVar15;
          uVar1 = (ulong)uVar14 * 0x19999999 +
                  CONCAT44(*(undefined4 *)((int)register0x00000010 + -4),(uint)uVar1 / 10) +
                  (ulong)(((uint)uVar1 % 10 + uVar14 * 6) / 10)) {
LAB_0041bdea:
        uVar14 = (uint)(uVar1 >> 0x20);
        *(uint *)((int)register0x00000010 + -4) = uVar14 / 10;
        uVar14 = uVar14 % 10;
        iVar4 = iVar4 + -1;
      }
      unaff_EBP = (*(int *)((int)register0x00000010 + 8) - iVar4) - 1;
      *(uint *)((int)register0x00000010 + -0x10) = unaff_EBP;
      iVar4 = *(int *)((int)register0x00000010 + 4);
      uVar14 = *(int *)((int)register0x00000010 + 8) - 1;
      while( true ) {
        uVar6 = (uint)(uVar1 >> 0x20);
        uVar7 = (uint)uVar1;
        bVar15 = uVar6 == 0;
        in_EDI = CONCAT31((int3)((uint)iVar4 >> 8),bVar15);
        if ((bVar15 && (uVar7 < 10 || !bVar15)) && ((int)uVar14 < (int)unaff_EBP)) break;
        *(uint *)((int)register0x00000010 + -0x18) = uVar7;
        iVar4 = (int)((uVar1 & 0xffffffff) / 10);
        *(int *)((int)register0x00000010 + -4) = iVar4;
        uVar7 = (uVar7 + iVar4 * -10 + (uVar6 % 10) * 6) / 10;
        lVar2 = (ulong)(uVar6 % 10) * 0x19999999 +
                CONCAT44(uVar6 / 10,*(undefined4 *)((int)register0x00000010 + -4));
        uVar6 = (uint)lVar2;
        uVar11 = (uint)((ulong)lVar2 >> 0x20);
        iVar4 = uVar6 + uVar7;
        *(int *)((int)register0x00000010 + -4) = iVar4;
        in_EDI = *(uint *)((int)register0x00000010 + 8);
        unaff_EBP = uVar11;
        if (in_EDI <= uVar14) goto LAB_0041bfb9;
        *(char *)(*(int *)((int)register0x00000010 + 4) + uVar14) =
             (char)*(undefined4 *)((int)register0x00000010 + -0x18) + (char)iVar4 * -10 + '0';
        uVar13 = uVar14 - 1;
        unaff_EBP = *(uint *)((int)register0x00000010 + -0x10);
        if (uVar13 == unaff_EBP) {
          if (in_EDI <= uVar13) goto LAB_0041bfb0;
          iVar4 = *(int *)((int)register0x00000010 + 4);
          *(undefined1 *)((uVar14 - 1) + iVar4) = 0x2e;
          uVar13 = uVar14 - 2;
        }
        else {
          iVar4 = *(int *)((int)register0x00000010 + 4);
        }
        uVar1 = CONCAT44(uVar11 + CARRY4(uVar6,uVar7),*(undefined4 *)((int)register0x00000010 + -4))
        ;
        uVar14 = uVar13;
      }
      unaff_EBP = uVar7 + 0x30;
      uVar6 = *(uint *)((int)register0x00000010 + 8);
      if (uVar14 < uVar6) {
        iVar4 = *(int *)((int)register0x00000010 + 4);
        *(char *)(iVar4 + uVar14) = (char)unaff_EBP;
        *(uint *)((int)register0x00000010 + 0x18) =
             iVar4 + ((int)-(*(int *)((int)register0x00000010 + 0xc) - uVar14) >> 0x1f & uVar14);
        *(uint *)((int)register0x00000010 + 0x1c) = uVar6 - uVar14;
        *(uint *)((int)register0x00000010 + 0x20) = *(int *)((int)register0x00000010 + 0xc) - uVar14
        ;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x41bfb0;
      FUN_0046edf0();
LAB_0041bfb0:
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x41bfb9;
      FUN_0046edf0();
LAB_0041bfb9:
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x41bfc2;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar10 + -4) = 0x41bfc8;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar10;
  } while( true );
LAB_0041bcad:
  uVar8 = uVar6;
  uVar6 = CONCAT31((int3)((uint)iVar4 >> 8),uVar11 != 0) |
          CONCAT31((int3)(uVar13 >> 8),9 < uVar7) & CONCAT31((int3)(uVar14 >> 8),uVar11 == 0);
  if (((char)uVar6 == '\0') && ((int)uVar8 < (int)uVar12)) {
    uVar14 = *(uint *)((int)register0x00000010 + 8);
    if (uVar8 < uVar14) {
      iVar4 = *(int *)((int)register0x00000010 + 4);
      *(char *)(iVar4 + uVar8) = (char)uVar7 + '0';
      *(uint *)((int)register0x00000010 + 0x18) =
           ((int)-(*(int *)((int)register0x00000010 + 0xc) - uVar8) >> 0x1f & uVar8) + iVar4;
      *(uint *)((int)register0x00000010 + 0x1c) = uVar14 - uVar8;
      *(uint *)((int)register0x00000010 + 0x20) = *(int *)((int)register0x00000010 + 0xc) - uVar8;
      return;
    }
    *(undefined4 *)((int)register0x00000010 + -0x34) = 0x41bdcf;
    FUN_0046edf0();
LAB_0041bdcf:
    *(undefined4 *)((int)register0x00000010 + -0x34) = 0x41bdd8;
    FUN_0046edf0();
LAB_0041bdd8:
    *(undefined4 *)((int)register0x00000010 + -0x34) = 0x41bde1;
    FUN_0046edf0();
    uVar3 = CONCAT44(uVar8,uVar6);
LAB_0041bde1:
    uVar9 = (undefined4)((ulong)uVar3 >> 0x20);
    iVar4 = 0;
    *(undefined4 *)((int)register0x00000010 + -0x34) = 0x41bdea;
    FUN_0046edf0();
    uVar1 = CONCAT44(uVar9,(int)uVar3);
    goto LAB_0041bdea;
  }
  *(uint *)((int)register0x00000010 + -0x14) = uVar7;
  *(uint *)((int)register0x00000010 + -4) = uVar7 / 10;
  uVar7 = (uVar7 % 10 + (uVar11 % 10) * 6) / 10;
  lVar2 = (ulong)(uVar11 % 10) * 0x19999999 +
          CONCAT44(uVar11 / 10,*(undefined4 *)((int)register0x00000010 + -4));
  uVar6 = (uint)lVar2;
  iVar5 = uVar6 + uVar7;
  *(int *)((int)register0x00000010 + -4) = iVar5;
  uVar13 = *(uint *)((int)register0x00000010 + 8);
  if (uVar13 <= uVar8) goto LAB_0041bdd8;
  *(uint *)((int)register0x00000010 + -8) = uVar8;
  iVar4 = *(int *)((int)register0x00000010 + 4);
  *(char *)(iVar4 + uVar8) =
       (char)*(undefined4 *)((int)register0x00000010 + -0x14) + (char)iVar5 * -10 + '0';
  uVar14 = uVar8 - 1;
  uVar8 = *(uint *)((int)register0x00000010 + -0xc);
  if (uVar14 == uVar8) {
    if (uVar13 <= uVar14) goto LAB_0041bdcf;
    iVar5 = *(int *)((int)register0x00000010 + -8);
    *(undefined1 *)(iVar5 + -1 + iVar4) = 0x2e;
    uVar14 = iVar5 - 2;
  }
  else {
    uVar13 = *(uint *)((int)register0x00000010 + 8);
  }
  uVar11 = (int)((ulong)lVar2 >> 0x20) + (uint)CARRY4(uVar6,uVar7);
  uVar7 = *(uint *)((int)register0x00000010 + -4);
  uVar6 = uVar14;
  uVar12 = uVar8;
  goto LAB_0041bcad;
}



/* Function: FUN_0041bfd0 */

void FUN_0041bfd0(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
      *(undefined4 *)((int)register0x00000010 + -8) = 1;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x41c005;
      FUN_00402540();
      if (*(char *)((int)register0x00000010 + -4) != '\0') {
        if (*(char *)(*(int *)((int)register0x00000010 + 4) + 5) !=
            *(char *)((int)register0x00000010 + 8)) {
          *(int *)((int)register0x00000010 + -0x10) = *(int *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0xc) =
               *(undefined4 *)((int)register0x00000010 + 0xc);
          *(undefined4 *)((int)register0x00000010 + -8) =
               *(undefined4 *)((int)register0x00000010 + 0x10);
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0x41c034;
          FUN_0041c220();
          iVar1 = *(int *)((int)register0x00000010 + 4);
          *(undefined1 *)(iVar1 + 5) = *(undefined1 *)((int)register0x00000010 + 8);
          *(undefined1 *)(iVar1 + 6) = 1;
          return;
        }
        *(undefined **)((int)register0x00000010 + -0x10) = &DAT_004cc942;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x2d;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x41c05e;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x10) =
           "failed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: g..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x2f;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x41c074;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x41c07a;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_0041c080 */

void FUN_0041c080(void)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  int iVar4;
  int iVar5;
  undefined1 *puVar6;
  uint uVar7;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x18);
      if (*(char *)(*(int *)((int)register0x00000010 + 4) + 6) != '\0') {
        iVar4 = *(int *)((int)register0x00000010 + 4) + 0x38;
        *(int *)((int)register0x00000010 + -4) = iVar4;
        *(int *)((int)register0x00000010 + -0x18) = iVar4;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41c0b6;
        thunk_FUN_004027a0();
        uVar1 = *(uint *)((int)register0x00000010 + -0x14);
        iVar4 = *(int *)((int)register0x00000010 + -0x10);
        iVar5 = *(int *)((int)register0x00000010 + 0xc);
        uVar7 = *(uint *)((int)register0x00000010 + 8);
        if (iVar4 < iVar5 || iVar5 == iVar4 && uVar1 <= uVar7) {
          uVar2 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x44);
          *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
          lVar3 = (ulong)(uVar7 - uVar1) * (ulong)uVar2;
          *(int *)((int)register0x00000010 + -0xc) = (int)lVar3;
          *(uint *)((int)register0x00000010 + -8) =
               ((iVar5 - iVar4) - (uint)(uVar7 < uVar1)) * uVar2 + (int)((ulong)lVar3 >> 0x20) +
               ((int)uVar2 >> 0x1f) * (uVar7 - uVar1);
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41c125;
          FUN_0041c600();
          iVar5 = *(int *)((int)register0x00000010 + 0xc);
          uVar7 = *(uint *)((int)register0x00000010 + 8);
        }
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(uint *)((int)register0x00000010 + -0x14) = uVar7;
        *(int *)((int)register0x00000010 + -0x10) = iVar5;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41c142;
        thunk_FUN_004027c0();
        iVar4 = *(int *)((int)register0x00000010 + 4);
        *(undefined1 *)(iVar4 + 6) = 0;
        *(int *)((int)register0x00000010 + -0x18) = iVar4;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41c152;
        FUN_0041c7d0();
        return;
      }
      *(char **)((int)register0x00000010 + -0x18) =
           "finishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sw..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x2f;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x41c16c;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x41c172;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_0041c180 */

void FUN_0041c180(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
      *(undefined4 *)((int)register0x00000010 + -8) = 1;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x41c1b1;
      FUN_00402540();
      if (*(char *)((int)register0x00000010 + -4) == '\0') {
        return;
      }
      if (*(char *)(*(int *)((int)register0x00000010 + 4) + 6) == '\0') {
        *(int *)((int)register0x00000010 + -0x10) = *(int *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -8) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x41c1de;
        FUN_0041c220();
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x41c1ea;
        FUN_0041c7d0();
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x10) = &DAT_004c802f;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x18;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x41c208;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x41c20e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_0041c220 */

void FUN_0041c220(void)

{
  int *piVar1;
  byte bVar2;
  long lVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  undefined1 *puVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int in_FS_OFFSET;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0x7c);
      *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0x38;
      *(int *)((int)register0x00000010 + -0x7c) = *(int *)((int)register0x00000010 + 4) + 0x38;
      *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c24f;
      thunk_FUN_004027a0();
      iVar5 = *(int *)((int)register0x00000010 + -0x74);
      iVar8 = *(int *)((int)register0x00000010 + 0xc);
      if (iVar8 == iVar5 &&
          *(uint *)((int)register0x00000010 + 8) < *(uint *)((int)register0x00000010 + -0x78) ||
          iVar8 < iVar5) {
        return;
      }
      *(uint *)((int)register0x00000010 + -0x5c) = *(uint *)((int)register0x00000010 + -0x78);
      *(int *)((int)register0x00000010 + -0x50) = iVar5;
      iVar5 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x44);
      *(int *)((int)register0x00000010 + -0x14) = iVar5;
      *(int *)((int)register0x00000010 + -0x18) = iVar5 >> 0x1f;
      *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + 4) + 0x20;
      *(undefined4 *)((int)register0x00000010 + -0x7c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(uint *)((int)register0x00000010 + -0x78) = *(uint *)((int)register0x00000010 + 8);
      *(int *)((int)register0x00000010 + -0x74) = iVar8;
      *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c2bf;
      thunk_FUN_004027c0();
      *(undefined4 *)((int)register0x00000010 + -0x7c) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c2cc;
      thunk_FUN_004027a0();
      iVar5 = *(int *)((int)register0x00000010 + -0x78);
      *(int *)((int)register0x00000010 + -0x60) = iVar5;
      iVar8 = *(int *)((int)register0x00000010 + -0x74);
      *(int *)((int)register0x00000010 + -0x54) = iVar8;
      uVar6 = *(uint *)((int)register0x00000010 + 8) - *(uint *)((int)register0x00000010 + -0x5c);
      *(uint *)((int)register0x00000010 + -0x1c) = uVar6;
      lVar3 = (ulong)uVar6 * (ulong)*(uint *)((int)register0x00000010 + -0x14);
      *(int *)((int)register0x00000010 + -0x4c) = (int)lVar3;
      *(uint *)((int)register0x00000010 + -0x1c) =
           *(int *)((int)register0x00000010 + -0x18) * *(int *)((int)register0x00000010 + -0x1c) +
           (int)((ulong)lVar3 >> 0x20) +
           ((*(int *)((int)register0x00000010 + 0xc) - *(int *)((int)register0x00000010 + -0x50)) -
           (uint)(*(uint *)((int)register0x00000010 + 8) <
                 *(uint *)((int)register0x00000010 + -0x5c))) *
           *(uint *)((int)register0x00000010 + -0x14);
      if (iVar5 != 0 || iVar8 != 0) {
        *(undefined4 *)((int)register0x00000010 + -0x7c) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(int *)((int)register0x00000010 + -0x78) = -iVar5;
        *(uint *)((int)register0x00000010 + -0x74) = -(uint)(iVar5 != 0) - iVar8;
        *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c34d;
        thunk_FUN_004026b0();
      }
      *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0x30;
      *(int *)((int)register0x00000010 + -0x7c) = *(int *)((int)register0x00000010 + 4) + 0x30;
      *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c364;
      thunk_FUN_004027a0();
      uVar6 = *(uint *)((int)register0x00000010 + -0x78);
      iVar5 = *(int *)((int)register0x00000010 + -0x74);
      if (uVar6 != 0 || iVar5 != 0) {
        *(int *)((int)register0x00000010 + -0x58) = iVar5;
        *(uint *)((int)register0x00000010 + -100) = uVar6;
        *(undefined4 *)((int)register0x00000010 + -0x7c) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(uint *)((int)register0x00000010 + -0x78) = -uVar6;
        *(uint *)((int)register0x00000010 + -0x74) = -(uint)(uVar6 != 0) - iVar5;
        *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c3a3;
        thunk_FUN_004026b0();
        uVar6 = *(uint *)((int)register0x00000010 + -100);
        iVar5 = *(int *)((int)register0x00000010 + -0x58);
      }
      iVar8 = *(int *)((int)register0x00000010 + 4);
      if (*(char *)(iVar8 + 7) != '\0') {
        iVar13 = *(int *)((int)register0x00000010 + -0x54);
        uVar10 = *(uint *)((int)register0x00000010 + -0x60);
LAB_0041c416:
        if (*(char *)(iVar8 + 5) != '\0') {
          *(uint *)((int)register0x00000010 + -0x38) = uVar10;
          *(int *)((int)register0x00000010 + -0x34) = iVar13;
          *(uint *)((int)register0x00000010 + -0x48) = uVar6;
          *(int *)((int)register0x00000010 + -0x44) = iVar5;
          *(undefined4 *)((int)register0x00000010 + -0x7c) =
               *(undefined4 *)((int)register0x00000010 + -0x4c);
          *(undefined4 *)((int)register0x00000010 + -0x78) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c444;
          FUN_00464a40();
          *(double *)((int)register0x00000010 + -0x7c) =
               DAT_00550c48 * *(double *)((int)register0x00000010 + -0x74);
          *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c45c;
          FUN_004649a0();
          uVar10 = *(uint *)((int)register0x00000010 + -0x74) +
                   *(uint *)((int)register0x00000010 + -0x38);
          iVar13 = *(int *)((int)register0x00000010 + -0x70) +
                   *(int *)((int)register0x00000010 + -0x34) +
                   (uint)CARRY4(*(uint *)((int)register0x00000010 + -0x74),
                                *(uint *)((int)register0x00000010 + -0x38));
          uVar6 = *(uint *)((int)register0x00000010 + -0x48);
          iVar5 = *(int *)((int)register0x00000010 + -0x44);
          iVar8 = *(int *)((int)register0x00000010 + 4);
        }
        *(int *)((int)register0x00000010 + -0x7c) = iVar8;
        uVar7 = *(uint *)((int)register0x00000010 + -0x4c) - uVar6;
        *(uint *)((int)register0x00000010 + -0x78) = uVar7 - uVar10;
        *(uint *)((int)register0x00000010 + -0x74) =
             (((*(int *)((int)register0x00000010 + -0x1c) - iVar5) -
              (uint)(*(uint *)((int)register0x00000010 + -0x4c) < uVar6)) - iVar13) -
             (uint)(uVar7 < uVar10);
        *(uint *)((int)register0x00000010 + -0x70) = uVar10;
        *(int *)((int)register0x00000010 + -0x6c) = iVar13;
        *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c4a7;
        FUN_0041c600();
        return;
      }
      iVar13 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      piVar1 = (int *)(*(int *)(iVar13 + 0x18) + 0x7c);
      *piVar1 = *piVar1 + 1;
      *(int *)((int)register0x00000010 + -0xc) = DAT_005d7020;
      *(int *)((int)register0x00000010 + -0x20) = DAT_005d7024;
      iVar4 = *(int *)(iVar13 + 0x18);
      *(int *)((int)register0x00000010 + -0x10) = iVar4;
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -0x54);
      *(uint *)((int)register0x00000010 + -0x30) = uVar6;
      *(undefined4 *)((int)register0x00000010 + -0x24) =
           *(undefined4 *)((int)register0x00000010 + -0x60);
      uVar6 = *(uint *)((int)register0x00000010 + -0x30);
      iVar13 = 0;
      iVar11 = DAT_005d7020;
      iVar12 = DAT_005d7024;
LAB_0041c4d1:
      if (iVar12 <= iVar13) {
        iVar13 = *(int *)(iVar4 + 0x7c);
        iVar11 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
        *(int *)(iVar4 + 0x7c) = iVar13 + -1;
        if ((iVar13 == 1) && (*(char *)(iVar11 + 0x69) != '\0')) {
          *(undefined4 *)(iVar11 + 8) = 0xfffffade;
        }
        iVar13 = *(int *)((int)register0x00000010 + -0x14);
        uVar10 = *(uint *)((int)register0x00000010 + -0x24);
        goto LAB_0041c416;
      }
      *(int *)((int)register0x00000010 + -0x44) = iVar5;
      *(int *)((int)register0x00000010 + -0x28) = iVar13;
      *(uint *)((int)register0x00000010 + -0x48) = uVar6;
      *(int *)((int)register0x00000010 + -0x7c) = *(int *)(iVar11 + iVar13 * 4) + 0x958;
      *(undefined4 *)((int)register0x00000010 + -0x78) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x74) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c50e;
      FUN_0041c9f0();
      bVar2 = *(byte *)((int)register0x00000010 + -0x70);
      uVar6 = *(uint *)((int)register0x00000010 + -0x6c);
      iVar5 = *(int *)((int)register0x00000010 + -0x68);
      if (bVar2 < 2) {
        if (bVar2 == 0) {
          iVar8 = *(int *)((int)register0x00000010 + -0x14);
          iVar4 = *(int *)((int)register0x00000010 + -0x24);
          iVar5 = *(int *)((int)register0x00000010 + -0x44);
          uVar6 = *(uint *)((int)register0x00000010 + -0x48);
        }
        else {
LAB_0041c561:
          *(int *)((int)register0x00000010 + -0x3c) = iVar5;
          *(uint *)((int)register0x00000010 + -0x40) = uVar6;
          *(undefined **)((int)register0x00000010 + -0x7c) = &DAT_005d8ac0;
          *(uint *)((int)register0x00000010 + -0x78) = uVar6;
          *(int *)((int)register0x00000010 + -0x74) = iVar5;
          *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c57f;
          thunk_FUN_004026b0();
          uVar6 = *(uint *)((int)register0x00000010 + -0x40) +
                  *(uint *)((int)register0x00000010 + -0x48);
          iVar5 = *(int *)((int)register0x00000010 + -0x3c) +
                  *(int *)((int)register0x00000010 + -0x44) +
                  (uint)CARRY4(*(uint *)((int)register0x00000010 + -0x40),
                               *(uint *)((int)register0x00000010 + -0x48));
          iVar8 = *(int *)((int)register0x00000010 + -0x14);
          iVar4 = *(int *)((int)register0x00000010 + -0x24);
        }
LAB_0041c4ab:
        iVar13 = *(int *)((int)register0x00000010 + -0x28) + 1;
        iVar11 = *(int *)((int)register0x00000010 + -0xc);
        iVar12 = *(int *)((int)register0x00000010 + -0x20);
        *(int *)((int)register0x00000010 + -0x14) = iVar8;
        *(int *)((int)register0x00000010 + -0x24) = iVar4;
        iVar8 = *(int *)((int)register0x00000010 + 4);
        iVar4 = *(int *)((int)register0x00000010 + -0x10);
        goto LAB_0041c4d1;
      }
      if ((bVar2 == 2) || (bVar2 == 3)) {
        iVar4 = uVar6 + *(uint *)((int)register0x00000010 + -0x24);
        iVar8 = iVar5 + *(int *)((int)register0x00000010 + -0x14) +
                (uint)CARRY4(uVar6,*(uint *)((int)register0x00000010 + -0x24));
        iVar5 = *(int *)((int)register0x00000010 + -0x44);
        uVar6 = *(uint *)((int)register0x00000010 + -0x48);
        goto LAB_0041c4ab;
      }
      if (bVar2 == 4) goto LAB_0041c561;
      *(char **)((int)register0x00000010 + -0x7c) =
           "invalid limiter event type foundscanstack: goroutine not stoppedscavenger state is already wiredsweep increased allocation countremovespecial on invalid pointergetWeakHandle on invalid pointerruntime: root level max pages = NtAssociateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x78) = 0x20;
      *(undefined4 *)((int)register0x00000010 + -0x80) = 0x41c5f0;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar9 + -4) = 0x41c5f6;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
}



/* Function: FUN_0041c600 */

void FUN_0041c600(int param_1,uint param_2,int param_3,uint param_4,int param_5)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int in_FS_OFFSET;
  undefined4 in_stack_ffffffe8;
  uint3 uVar8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar1 = *(uint *)(param_1 + 8);
  uVar2 = *(uint *)(param_1 + 0xc);
  uVar3 = *(uint *)(param_1 + 0x10) - uVar1;
  uVar4 = (*(int *)(param_1 + 0x14) - uVar2) - (uint)(*(uint *)(param_1 + 0x10) < uVar1);
  uVar7 = param_4 - param_2;
  uVar5 = (param_5 - param_3) - (uint)(param_4 < param_2);
  uVar8 = (uint3)((uint)in_stack_ffffffe8 >> 8);
  if ((uVar5 == 0 && uVar7 != 0 || 0 < (int)uVar5) &&
     (uVar4 < uVar5 || uVar5 == uVar4 && uVar3 <= uVar7)) {
    uVar1 = *(uint *)(param_1 + 0x18);
    *(uint *)(param_1 + 0x18) = uVar1 + (uVar7 - uVar3);
    *(uint *)(param_1 + 0x1c) =
         *(int *)(param_1 + 0x1c) + ((uVar5 - uVar4) - (uint)(uVar7 < uVar3)) +
         (uint)CARRY4(uVar1,uVar7 - uVar3);
    *(undefined4 *)(param_1 + 8) = *(undefined4 *)(param_1 + 0x10);
    *(undefined4 *)(param_1 + 0xc) = *(undefined4 *)(param_1 + 0x14);
    if (uVar4 != 0 || uVar3 != 0) {
      FUN_00402810(param_1 + 4,CONCAT31(uVar8,1));
      FUN_00402770(param_1 + 0x40,DAT_005f9510 + 1);
    }
    return;
  }
  if (((int)uVar5 < 0) &&
     (uVar6 = (param_3 - param_5) - (uint)(param_2 < param_4),
     uVar2 < uVar6 || uVar1 <= param_2 - param_4 && uVar2 == uVar6)) {
    *(undefined4 *)(param_1 + 8) = 0;
    *(undefined4 *)(param_1 + 0xc) = 0;
  }
  else {
    *(uint *)(param_1 + 8) = uVar1 - (param_2 - param_4);
    *(uint *)(param_1 + 0xc) =
         (uVar2 - ((param_3 - param_5) - (uint)(param_2 < param_4))) -
         (uint)(uVar1 < param_2 - param_4);
  }
  if ((uVar5 != 0 || uVar7 != 0) && (uVar4 == 0 && uVar3 == 0)) {
    FUN_00402810(param_1 + 4,(uint)uVar8 << 8);
  }
  return;
}



/* Function: FUN_0041c7d0 */

void FUN_0041c7d0(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)((int)register0x00000010 + 4)
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x41c7f9;
      FUN_00402700();
      if (*(int *)((int)register0x00000010 + -4) == 1) {
        return;
      }
      *(char **)((int)register0x00000010 + -0xc) =
           "double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = 0xd;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x41c81a;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x41c820;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_0041c830 */

void FUN_0041c830(void)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 1;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x41c865;
      FUN_00402540();
      if (*(char *)((int)register0x00000010 + -8) != '\0') {
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x41c88e;
        FUN_0041c220();
        uVar1 = *(uint *)((int)register0x00000010 + 0x10);
        iVar2 = *(int *)((int)register0x00000010 + 4);
        *(uint *)(iVar2 + 0x44) = uVar1;
        uVar3 = (uint)((ulong)uVar1 * 1000000000);
        *(uint *)(iVar2 + 0x10) = uVar3;
        uVar4 = (int)((ulong)uVar1 * 1000000000 >> 0x20) + ((int)uVar1 >> 0x1f) * 1000000000;
        *(uint *)(iVar2 + 0x14) = uVar4;
        uVar1 = *(uint *)(iVar2 + 0xc);
        if (uVar3 < *(uint *)(iVar2 + 8) && uVar1 == uVar4 || uVar4 < uVar1) {
          iVar2 = *(int *)((int)register0x00000010 + 4);
          *(uint *)(iVar2 + 8) = uVar3;
          *(uint *)(iVar2 + 0xc) = uVar4;
          *(int *)((int)register0x00000010 + -4) = iVar2 + 0x40;
          *(int *)((int)register0x00000010 + -0x14) = iVar2 + 4;
          *(undefined1 *)((int)register0x00000010 + -0x10) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x41c926;
          FUN_00402810();
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(int *)((int)register0x00000010 + -0x10) = DAT_005f9510 + 1;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x41c93d;
          FUN_00402770();
        }
        else if (uVar1 == uVar4 && *(uint *)(iVar2 + 8) < uVar3 || uVar1 < uVar4) {
          *(int *)((int)register0x00000010 + -0x14) = *(int *)((int)register0x00000010 + 4) + 4;
          *(undefined1 *)((int)register0x00000010 + -0x10) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x41c901;
          FUN_00402810();
        }
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x41c949;
        FUN_0041c7d0();
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004cbeb8;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x28;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x41c963;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x41c969;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_0041c970 */

void FUN_0041c970(undefined4 param_1,byte param_2,undefined4 param_3,uint param_4)

{
  int in_FS_OFFSET;
  undefined4 in_stack_fffffffc;
  byte bVar1;
  
  while (bVar1 = (byte)((uint)in_stack_fffffffc >> 0x18),
        &stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    in_stack_fffffffc = 0;
    FUN_0046d980();
  }
  FUN_004027a0(param_1);
  if (bVar1 >> 5 != 0) {
    return;
  }
  FUN_004027c0(param_1,param_3,(uint)param_2 << 0x1d | param_4 & 0x1fffffff);
  return;
}



/* Function: FUN_0041c9f0 */

void FUN_0041c9f0(undefined4 param_1,uint param_2,uint param_3)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int in_FS_OFFSET;
  undefined4 local_24;
  undefined4 local_20;
  undefined1 local_14;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  while( true ) {
    FUN_004027a0(param_1);
    if ((byte)(local_20 >> 0x1d) == 0) {
      return;
    }
    uVar2 = local_20 & 0x1fffffff | param_3 & 0xe0000000;
    if ((int)param_3 < (int)uVar2 || param_2 < local_24 && param_3 == uVar2) {
      iVar1 = 0;
      iVar3 = 0;
    }
    else {
      iVar3 = param_2 - local_24;
      iVar1 = (param_3 - uVar2) - (uint)(param_2 < local_24);
    }
    if (iVar1 == 0 && iVar3 == 0) break;
    FUN_00402640(param_1);
    if (local_14 != '\0') {
      return;
    }
  }
  return;
}



/* Function: FUN_0041cb30 */

void FUN_0041cb30(void)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  char *pcVar5;
  uint uVar6;
  int iVar7;
  undefined1 *puVar8;
  int iVar9;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x28);
      do {
        *(undefined4 *)((int)register0x00000010 + -0x28) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cb55;
        FUN_004027a0();
        uVar2 = *(uint *)((int)register0x00000010 + -0x20);
        pcVar5 = (char *)(uVar2 >> 0x1d);
        if (*(byte *)((int)register0x00000010 + 8) != (byte)(uVar2 >> 0x1d)) goto LAB_0041cca4;
        *(uint *)((int)register0x00000010 + -4) = uVar2;
        *(undefined4 *)((int)register0x00000010 + -8) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x28) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cb93;
        FUN_00402640();
      } while (*(char *)((int)register0x00000010 + -0x14) == '\0');
      uVar2 = *(uint *)((int)register0x00000010 + 0x10);
      uVar6 = uVar2 & 0xe0000000 | *(uint *)((int)register0x00000010 + -4) & 0x1fffffff;
      uVar3 = *(uint *)((int)register0x00000010 + 0xc);
      uVar4 = *(uint *)((int)register0x00000010 + -8);
      if ((int)uVar2 < (int)uVar6 || uVar3 < uVar4 && uVar2 == uVar6) {
        iVar7 = 0;
        iVar9 = 0;
      }
      else {
        iVar9 = uVar3 - uVar4;
        iVar7 = (uVar2 - uVar6) - (uint)(uVar3 < uVar4);
      }
      if (iVar7 == 0 && iVar9 == 0) {
        return;
      }
      bVar1 = *(byte *)((int)register0x00000010 + 8);
      if (bVar1 < 3) {
        if (bVar1 == 1) {
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f61d0;
          *(int *)((int)register0x00000010 + -0x24) = iVar9;
          *(int *)((int)register0x00000010 + -0x20) = iVar7;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cc22;
          thunk_FUN_004026b0();
          return;
        }
        if (bVar1 == 2) {
code_r0x0041cc2a:
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f61c0;
          *(int *)((int)register0x00000010 + -0x24) = iVar9;
          *(int *)((int)register0x00000010 + -0x20) = iVar7;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cc40;
          thunk_FUN_004026b0();
          return;
        }
      }
      else {
        if (bVar1 == 3) goto code_r0x0041cc2a;
        if (bVar1 == 4) {
          *(int *)((int)register0x00000010 + -0xc) = iVar7;
          *(int *)((int)register0x00000010 + -0x10) = iVar9;
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f61d0;
          *(int *)((int)register0x00000010 + -0x24) = iVar9;
          *(int *)((int)register0x00000010 + -0x20) = iVar7;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cc67;
          thunk_FUN_004026b0();
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005d8ac0;
          *(undefined4 *)((int)register0x00000010 + -0x24) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x20) =
               *(undefined4 *)((int)register0x00000010 + -0xc);
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cc86;
          thunk_FUN_004026b0();
          return;
        }
      }
      pcVar5 = 
      "limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanu..." /* TRUNCATED STRING LITERAL */
      ;
      *(char **)((int)register0x00000010 + -0x28) =
           "limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanu..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x33;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cca4;
      FUN_00469a20();
LAB_0041cca4:
      *(char **)((int)register0x00000010 + -4) = pcVar5;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41ccad;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x28) = "runtime: want=MB; allocated RtlGetVersion";
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0xe;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41ccc3;
      FUN_0043b060();
      *(uint *)((int)register0x00000010 + -0x28) = (uint)*(byte *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41ccdb;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c2c50;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 5;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41ccf1;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cd05;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cd0a;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cd0f;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x28) =
           "limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
      ;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x3e;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x41cd25;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x41cd2b;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_0041cd30 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_0041cd30(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  uint uVar7;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  int *local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (int *)0x41cec0;
    FUN_0046d980();
  }
  DAT_005d7668 = 0;
  DAT_005d766c = 0;
  FUN_00402520(&DAT_005d6e1c);
  if (local_4 == (int *)0x0) {
    iVar2 = 0;
    iVar3 = 0;
  }
  else {
    iVar3 = *local_4;
    iVar2 = local_4[1];
  }
  for (iVar6 = 0; iVar6 < iVar2; iVar6 = iVar6 + 1) {
    iVar1 = *(int *)(iVar3 + iVar6 * 4);
    uVar7 = (*(int *)(iVar1 + 0x6c) - *(int *)(iVar1 + 0x68)) + 0x3ffffU >> 0x12;
    if ((int)DAT_005d7668 < (int)uVar7) {
      DAT_005d7668 = uVar7;
    }
    uVar7 = (*(int *)(iVar1 + 0x74) - *(int *)(iVar1 + 0x70)) + 0x3ffffU >> 0x12;
    if ((int)DAT_005d766c < (int)uVar7) {
      DAT_005d766c = uVar7;
    }
  }
  DAT_005ddf5c = DAT_005ddf44;
  _DAT_005ddf60 = DAT_005ddf44;
  iVar3 = DAT_005ddf44;
  uVar4 = DAT_005ddf40;
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = uVar4;
    in_EDI[1] = DAT_005ddf58;
  }
  DAT_005d7690 = DAT_005d6fe4;
  _DAT_005d7694 = DAT_005d6fe4;
  iVar2 = DAT_005d6fe4;
  uVar5 = DAT_005d6fe0;
  DAT_005d7670 = iVar3;
  DAT_005ddf58 = uVar4;
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = uVar5;
    in_EDI[1] = DAT_005d768c;
  }
  DAT_005d768c = uVar5;
  DAT_005d7674 = iVar2;
  DAT_005d7650 = 0;
  DAT_005d7654 = DAT_005d7668 + DAT_005d766c + DAT_005d7670 + 2 + iVar2;
  DAT_005d7678 = 2;
  DAT_005d767c = DAT_005d7668 + 2;
  DAT_005d7680 = DAT_005d766c + 2 + DAT_005d7668;
  DAT_005d7684 = DAT_005d7670 + 2 + DAT_005d766c + DAT_005d7668;
  DAT_005d7688 = iVar2 + 2 + DAT_005d7670 + DAT_005d766c + DAT_005d7668;
  return;
}



/* Function: FUN_0041ced0 */

void FUN_0041ced0(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x1c);
      if (DAT_005d7654 <= DAT_005d7650) {
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
        *(undefined1 **)((int)register0x00000010 + -8) = &LAB_0041cfb0;
        *(undefined1 **)((int)register0x00000010 + -4) =
             (undefined1 *)((int)register0x00000010 + -0x14);
        *(undefined1 **)((int)register0x00000010 + -0x1c) =
             (undefined1 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41cf1d;
        FUN_0043c3e0();
        return;
      }
      *(uint *)((int)register0x00000010 + -0xc) = DAT_005d7650;
      *(uint *)((int)register0x00000010 + -0x10) = DAT_005d7654;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41cf2e;
      FUN_0043a810();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41cf42;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c2b09;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 4;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41cf58;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41cf6c;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c684c;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41cf82;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41cf87;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c7a5a;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x17;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x41cf9d;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x41cfa3;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_0041d0f0 */

void FUN_0041d0f0(undefined4 param_1,uint param_2,char param_3)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined *puVar5;
  int iVar6;
  int in_FS_OFFSET;
  bool bVar7;
  int *in_stack_ffffffac;
  uint local_44;
  int local_40;
  uint local_34;
  int local_30;
  undefined4 *local_2c;
  int local_28;
  uint local_24;
  uint local_20;
  int local_1c;
  int local_18;
  int local_14;
  undefined1 *local_10;
  int local_c;
  uint *local_8;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x41d525;
    FUN_0046d980();
  }
  local_34 = 0;
  local_30 = 0;
  if ((param_2 < DAT_005d7678) || (DAT_005d767c <= param_2)) {
    if ((param_2 < DAT_005d767c) || (DAT_005d7680 <= param_2)) {
      puVar4 = DAT_005f5e00;
      if (param_2 == 0) {
        while (puVar4 != (undefined4 *)0x0) {
LAB_0041d3db:
          local_2c = puVar4;
          FUN_00402510(puVar4 + 2);
          in_stack_ffffffac = (int *)((int)in_stack_ffffffac * 0x14);
          FUN_0041fcf0(local_2c + 4,in_stack_ffffffac,&DAT_005f6280,param_1,0);
          puVar4 = (undefined4 *)*local_2c;
        }
        puVar5 = (undefined *)0x0;
      }
      else if (param_2 == 1) {
        FUN_0046d890(&PTR_LAB_00536c14);
        puVar5 = (undefined *)0x0;
      }
      else {
        if ((param_2 < DAT_005d7680) || (DAT_005d7684 <= param_2)) {
          if ((DAT_005d7684 <= param_2) && (param_2 < DAT_005d7688)) {
            if (param_2 - DAT_005d7684 < DAT_005d7690) {
              local_14 = *(int *)(DAT_005d768c + (param_2 - DAT_005d7684) * 4);
              FUN_00402510(local_14 + 0x4c);
              uVar2 = DAT_005d7660;
              if (((in_stack_ffffffac == (int *)0x4) || (in_stack_ffffffac == (int *)0x3)) &&
                 (*(int *)(local_14 + 100) == 0 && *(int *)(local_14 + 0x60) == 0)) {
                *(undefined4 *)(local_14 + 0x60) = DAT_005d765c;
                *(undefined4 *)(local_14 + 100) = uVar2;
              }
              local_10 = &LAB_0041d530;
              local_c = local_14;
              local_8 = &local_34;
              local_4 = param_1;
              FUN_0046d890(&local_10);
              puVar5 = &DAT_005f6828;
              goto LAB_0041d2a5;
            }
            FUN_0046ee00();
          }
          FUN_0043a810();
          local_20 = DAT_005d7684;
          local_24 = DAT_005d7688;
          FUN_0043a810();
          FUN_0043b060(&DAT_004c8047,0x18);
          FUN_0043ad50(param_2,0);
          FUN_0043b060(" not in stack roots range [allocated pages below zero?address not a stack addressmspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandle..." /* TRUNCATED STRING LITERAL */
                       ,0x1b);
          FUN_0043ad50(local_20,0);
          FUN_0043b060(&DAT_004c293a,2);
          FUN_0043ad50(local_24,0);
          FUN_0043b060(&DAT_004c2946,2);
          FUN_0043a870();
          puVar4 = (undefined4 *)&DAT_004c61c9;
          in_stack_ffffffac = (int *)&DAT_00000013;
          FUN_00469a20(&DAT_004c61c9,0x13);
          goto LAB_0041d3db;
        }
        FUN_0041d840(param_1,param_2 - DAT_005d7680);
        puVar5 = (undefined *)0x0;
      }
    }
    else {
      FUN_00402520(&DAT_005d6e1c);
      if (in_stack_ffffffac == (int *)0x0) {
        iVar3 = 0;
        local_1c = 0;
      }
      else {
        local_1c = *in_stack_ffffffac;
        iVar3 = in_stack_ffffffac[1];
      }
      iVar6 = 0;
      while (iVar6 < iVar3) {
        iVar1 = *(int *)(local_1c + iVar6 * 4);
        local_28 = iVar6;
        FUN_0041d6b0(*(int *)(iVar1 + 0x70),*(int *)(iVar1 + 0x74) - *(int *)(iVar1 + 0x70),
                     *(undefined4 *)(iVar1 + 0x118),param_1,param_2 - DAT_005d767c);
        bVar7 = CARRY4(local_44,local_34);
        local_34 = local_44 + local_34;
        local_30 = local_40 + local_30 + (uint)bVar7;
        iVar6 = local_28 + 1;
      }
      puVar5 = &DAT_005f6830;
    }
  }
  else {
    FUN_00402520(&DAT_005d6e1c);
    if (in_stack_ffffffac == (int *)0x0) {
      iVar3 = 0;
      local_18 = 0;
    }
    else {
      local_18 = *in_stack_ffffffac;
      iVar3 = in_stack_ffffffac[1];
    }
    iVar6 = 0;
    while (iVar6 < iVar3) {
      iVar1 = *(int *)(local_18 + iVar6 * 4);
      local_28 = iVar6;
      FUN_0041d6b0(*(int *)(iVar1 + 0x68),*(int *)(iVar1 + 0x6c) - *(int *)(iVar1 + 0x68),
                   *(undefined4 *)(iVar1 + 0x110),param_1,param_2 - DAT_005d7678);
      bVar7 = CARRY4(local_34,local_44);
      local_34 = local_34 + local_44;
      local_30 = local_30 + local_40 + (uint)bVar7;
      iVar6 = local_28 + 1;
    }
    puVar5 = &DAT_005f6830;
  }
LAB_0041d2a5:
  if (((puVar5 != (undefined *)0x0) && (local_30 != 0 || local_34 != 0)) &&
     (thunk_FUN_004026b0(puVar5,local_34,local_30), param_3 != '\0')) {
    FUN_0041e870(local_34,local_30);
  }
  return;
}



/* Function: FUN_0041d6b0 */

void FUN_0041d6b0(int param_1,uint param_2,int param_3,undefined4 param_4,int param_5)

{
  uint uVar1;
  int iVar2;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar1 = param_5 * 0x40000;
  if (uVar1 < param_2) {
    if (param_2 < uVar1 + 0x40000) {
      iVar2 = param_2 + param_5 * -0x40000;
    }
    else {
      iVar2 = 0x40000;
    }
    FUN_0041fcf0(param_1 + uVar1,iVar2,param_5 * 0x2000 + param_3,param_4,0,iVar2);
    return;
  }
  return;
}



/* Function: FUN_0041d840 */

void FUN_0041d840(void)

{
  byte bVar1;
  char cVar2;
  int iVar3;
  uint uVar4;
  undefined4 *puVar5;
  int iVar6;
  undefined1 *puVar7;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x38);
      if (*(uint *)((int)register0x00000010 + 8) < DAT_005ddf5c) {
        uVar4 = *(uint *)(DAT_005ddf58 + *(uint *)((int)register0x00000010 + 8) * 4);
        if (uVar4 < 0x400) {
          iVar3 = *(int *)(DAT_005ddf14 + uVar4 * 4);
          *(int *)((int)register0x00000010 + -0xc) = iVar3;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = DAT_005dde90;
          iVar6 = 0;
          do {
            if (0x3f < iVar6) {
              return;
            }
            *(int *)((int)register0x00000010 + -0x10) = iVar6;
            *(int *)((int)register0x00000010 + -0x38) = iVar3 + 0x880 + iVar6;
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41d8c3;
            FUN_00402470();
            bVar1 = *(byte *)((int)register0x00000010 + -0x34);
            if (bVar1 != 0) {
              *(byte *)((int)register0x00000010 + -0x21) = bVar1;
              for (uVar4 = 0; uVar4 < 8; uVar4 = uVar4 + 1) {
                if ((bVar1 & (byte)(1 << ((byte)uVar4 & 0x1f))) != 0) {
                  *(uint *)((int)register0x00000010 + -0x14) = uVar4;
                  iVar6 = *(int *)(*(int *)((int)register0x00000010 + -0xc) +
                                  (uVar4 + *(int *)((int)register0x00000010 + -0x10) * 8) * 4);
                  *(int *)((int)register0x00000010 + -0x18) = iVar6;
                  *(int *)((int)register0x00000010 + -0x38) = iVar6 + 0x3f;
                  *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41d90d;
                  FUN_00402470();
                  cVar2 = *(char *)((int)register0x00000010 + -0x34);
                  if (cVar2 != '\x01') {
LAB_0041daec:
                    *(char *)((int)register0x00000010 + -0x22) = cVar2;
                    *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41daf5;
                    FUN_0043a810();
                    *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c3661;
                    *(undefined4 *)((int)register0x00000010 + -0x34) = 10;
                    *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41db0b;
                    FUN_0043b060();
                    *(uint *)((int)register0x00000010 + -0x38) =
                         (uint)*(byte *)((int)register0x00000010 + -0x22);
                    *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
                    *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41db23;
                    FUN_0043ad50();
                    *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41db28;
                    FUN_0043aa10();
                    *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41db2d;
                    FUN_0043a870();
                    *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004cc581;
                    *(undefined4 *)((int)register0x00000010 + -0x34) = 0x2b;
                    *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41db43;
                    FUN_00469a20();
                    goto LAB_0041db43;
                  }
                  if (DAT_005f5da9 == '\0') {
                    iVar6 = *(int *)((int)register0x00000010 + -0x18);
                    puVar5 = *(undefined4 **)(iVar6 + 0x34);
                    if ((puVar5 != *(undefined4 **)((int)register0x00000010 + -0x1c)) &&
                       (puVar5 != (undefined4 *)
                                  ((int)*(undefined4 **)((int)register0x00000010 + -0x1c) + 3))) {
LAB_0041da80:
                      *(undefined4 **)((int)register0x00000010 + -8) = puVar5;
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41da89;
                      FUN_0043a810();
                      *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c2d68;
                      *(undefined4 *)((int)register0x00000010 + -0x34) = 6;
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41da9f;
                      FUN_0043b060();
                      *(undefined4 *)((int)register0x00000010 + -0x38) =
                           *(undefined4 *)((int)register0x00000010 + -8);
                      *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41dab3;
                      FUN_0043ad50();
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41dab8;
                      FUN_0043a9d0();
                      *(undefined4 *)((int)register0x00000010 + -0x38) =
                           *(undefined4 *)((int)register0x00000010 + -0x1c);
                      *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41dacc;
                      FUN_0043ad50();
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41dad1;
                      FUN_0043aa10();
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41dad6;
                      FUN_0043a870();
                      cVar2 = -0x47;
                      *(char **)((int)register0x00000010 + -0x38) =
                           "gc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
                      ;
                      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x10;
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41daec;
                      FUN_00469a20();
                      goto LAB_0041daec;
                    }
                  }
                  else {
                    iVar6 = *(int *)((int)register0x00000010 + -0x18);
                  }
                  *(int *)((int)register0x00000010 + -4) = iVar6 + 0x4c;
                  *(int *)((int)register0x00000010 + -0x38) = iVar6 + 0x4c;
                  *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41d956;
                  FUN_0040ecf0();
                  iVar6 = *(int *)((int)register0x00000010 + -0x18);
                  for (puVar5 = *(undefined4 **)(iVar6 + 0x50); puVar5 != (undefined4 *)0x0;
                      puVar5 = (undefined4 *)*puVar5) {
                    *(undefined4 **)((int)register0x00000010 + -0x20) = puVar5;
                    cVar2 = *(char *)(puVar5 + 2);
                    if (cVar2 == '\x01') {
                      uVar4 = *(uint *)(iVar6 + 0x44);
                      if (uVar4 == 0) {
                        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41da80;
                        FUN_00438080();
                        goto LAB_0041da80;
                      }
                      if ((*(byte *)(iVar6 + 0x3e) & 1) == 0) {
                        *(uint *)((int)register0x00000010 + -0x38) =
                             *(int *)(iVar6 + 0xc) + ((uint)puVar5[1] / uVar4) * uVar4;
                        *(undefined4 *)((int)register0x00000010 + -0x34) =
                             *(undefined4 *)((int)register0x00000010 + 4);
                        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41da3d;
                        FUN_0041fe10();
                        puVar5 = *(undefined4 **)((int)register0x00000010 + -0x20);
                      }
                      *(undefined4 **)((int)register0x00000010 + -0x38) = puVar5 + 3;
                      *(undefined4 *)((int)register0x00000010 + -0x34) = 4;
                      *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005cc260;
                      *(undefined4 *)((int)register0x00000010 + -0x2c) =
                           *(undefined4 *)((int)register0x00000010 + 4);
                      *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41da6e;
                      FUN_0041fcf0();
                      iVar6 = *(int *)((int)register0x00000010 + -0x18);
                      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x20);
                    }
                    else if (cVar2 == '\x02') {
                      *(undefined4 **)((int)register0x00000010 + -0x38) = puVar5 + 3;
                      *(undefined4 *)((int)register0x00000010 + -0x34) = 4;
                      *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005cc260;
                      *(undefined4 *)((int)register0x00000010 + -0x2c) =
                           *(undefined4 *)((int)register0x00000010 + 4);
                      *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41d9fb;
                      FUN_0041fcf0();
                      iVar6 = *(int *)((int)register0x00000010 + -0x18);
                      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x20);
                    }
                    else if (cVar2 == '\x06') {
                      *(undefined4 **)((int)register0x00000010 + -0x38) = puVar5 + 3;
                      *(undefined4 *)((int)register0x00000010 + -0x34) = 4;
                      *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005cc260;
                      *(undefined4 *)((int)register0x00000010 + -0x2c) =
                           *(undefined4 *)((int)register0x00000010 + 4);
                      *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
                      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41d9c4;
                      FUN_0041fcf0();
                      iVar6 = *(int *)((int)register0x00000010 + -0x18);
                      puVar5 = *(undefined4 **)((int)register0x00000010 + -0x20);
                    }
                  }
                  *(undefined4 *)((int)register0x00000010 + -0x38) =
                       *(undefined4 *)((int)register0x00000010 + -4);
                  *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41d96c;
                  FUN_0040f0e0();
                  bVar1 = *(byte *)((int)register0x00000010 + -0x21);
                  uVar4 = *(uint *)((int)register0x00000010 + -0x14);
                }
              }
            }
            iVar6 = *(int *)((int)register0x00000010 + -0x10) + 1;
            iVar3 = *(int *)((int)register0x00000010 + -0xc);
          } while( true );
        }
LAB_0041db43:
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41db4d;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x41db52;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar7 + -4) = 0x41db58;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_0041db60 */

void FUN_0041db60(int param_1)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  undefined4 uVar8;
  uint uVar9;
  undefined *puVar10;
  uint uVar11;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  bool bVar12;
  bool bVar13;
  double dVar14;
  ulong in_stack_ffffff60;
  undefined8 uVar15;
  uint local_98;
  uint uStack_94;
  code *local_20;
  int local_1c;
  int local_18;
  undefined1 *local_14;
  int local_10;
  uint local_c;
  uint local_8;
  code **local_4;
  
  while (&local_20 <= *(code ***)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (code **)0x41e1dd;
    FUN_0046d980();
  }
  local_4 = (code **)0x0;
  if (**(int **)(param_1 + 0x18) == **(int **)(in_FS_OFFSET + DAT_005f5ed0)) {
    return;
  }
  iVar3 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  if ((0 < *(int *)(*(int *)(iVar3 + 0x18) + 0x7c)) ||
     (*(int *)(*(int *)(iVar3 + 0x18) + 0x78) != 0)) {
    return;
  }
  iVar6 = *(int *)(iVar3 + 0xf0);
  bVar13 = iVar6 == 0;
  if (!bVar13) {
    if (DAT_005f5fd0 != 0) {
      uVar8 = *(undefined4 *)(iVar3 + 0xf0);
      FUN_0046ed70();
      *in_EDI = uVar8;
    }
    bVar13 = iVar6 == 0;
    *(undefined4 *)(iVar3 + 0xf0) = 0;
    local_20 = FUN_0041e230;
    local_4 = &local_20;
    local_1c = iVar3;
    local_18 = iVar6;
  }
  bVar13 = !bVar13;
  bVar1 = false;
  while( true ) {
    uVar15 = CONCAT44((int)(in_stack_ffffff60 >> 0x20),&DAT_005f61a4);
    FUN_00402470();
    if ((char)((ulong)uVar15 >> 0x20) != '\0') {
      if (bVar1) {
        if (DAT_005d7d30 == '\0') {
          iVar3 = 0;
          uVar8 = 0;
        }
        else {
          FUN_0045e520();
          uVar8 = (undefined4)uVar15;
          iVar3 = (int)((ulong)uVar15 >> 0x20);
        }
        if (iVar3 == 0) {
          *(undefined1 *)(param_1 + 0x72) = 0;
        }
        else {
          FUN_0045eff0(uVar8,iVar3);
          *(undefined1 *)(param_1 + 0x72) = 0;
          FUN_0045e630(uVar8,iVar3);
        }
      }
      if (bVar13) {
        (**local_4)();
      }
      return;
    }
    uVar8 = (undefined4)((ulong)uVar15 >> 0x20);
    FUN_004027a0(&DAT_005f6878);
    dVar14 = (double)CONCAT44(local_98,uVar8);
    FUN_004027a0(&DAT_005f6880);
    uVar7 = -*(int *)(param_1 + 0x110);
    uVar4 = -(uint)(*(int *)(param_1 + 0x110) != 0) - *(int *)(param_1 + 0x114);
    FUN_00464a40(uVar7,uVar4);
    dVar14 = dVar14 * (double)CONCAT44(uStack_94,local_98);
    FUN_004649a0(dVar14);
    uVar11 = (uint)((ulong)dVar14 >> 0x20);
    uVar5 = uStack_94;
    uVar2 = local_98;
    if (local_98 < 0x10000 && uStack_94 == 0 || (int)uStack_94 < 0) {
      FUN_00464a40(0x10000,0);
      dVar14 = (double)CONCAT44(uStack_94,local_98) * (double)CONCAT44(local_98,uVar8);
      FUN_004649a0(dVar14);
      uVar11 = (uint)((ulong)dVar14 >> 0x20);
      uVar5 = 0;
      uVar4 = uStack_94;
      uVar7 = local_98;
      uVar2 = 0x10000;
    }
    puVar10 = &DAT_005f6838;
    uVar9 = uVar2;
    thunk_FUN_004027a0();
    if (uVar11 != 0 && local_98 == 0 || 0 < (int)local_98) {
      in_EDI = (undefined4 *)
               (CONCAT31((int3)((uint)in_EDI >> 8),uVar11 < uVar2) &
               CONCAT31((int3)(uVar9 >> 8),uVar5 == local_98));
      if ((uVar5 == local_98 || (int)uVar5 < (int)local_98) && (char)in_EDI == '\0') {
        uVar11 = *(uint *)(param_1 + 0x110);
        *(uint *)(param_1 + 0x110) = uVar11 + uVar7;
        in_EDI = (undefined4 *)(*(int *)(param_1 + 0x114) + uVar4 + (uint)CARRY4(uVar11,uVar7));
        *(undefined4 **)(param_1 + 0x114) = in_EDI;
        local_98 = uVar5;
        uVar11 = uVar2;
      }
      else {
        FUN_00464a40(uVar11,local_98);
        uVar7 = *(uint *)(param_1 + 0x110);
        iVar3 = *(int *)(param_1 + 0x114);
        FUN_004649a0((double)CONCAT44(uStack_94,local_98) * (double)CONCAT44(local_98,uVar8));
        uVar4 = local_98 + uVar7;
        *(uint *)(param_1 + 0x110) = uVar4 + 1;
        *(uint *)(param_1 + 0x114) =
             uStack_94 + iVar3 + (uint)CARRY4(local_98,uVar7) + (uint)(0xfffffffe < uVar4);
      }
      uVar7 = -uVar11;
      puVar10 = &DAT_005f6838;
      thunk_FUN_004026b0();
      bVar12 = uVar2 < uVar11;
      uVar2 = uVar2 - uVar11;
      uVar5 = (uVar5 - local_98) - (uint)bVar12;
      local_98 = -(uint)(uVar11 != 0) - local_98;
      uVar11 = uVar7;
      if (uVar5 == 0 && uVar2 == 0) {
        if (bVar1) {
          if (DAT_005d7d30 == '\0') {
            uVar7 = 0;
            puVar10 = (undefined *)0x0;
          }
          else {
            FUN_0045e520();
          }
          if (uVar7 == 0) {
            *(undefined1 *)(param_1 + 0x72) = 0;
          }
          else {
            FUN_0045eff0(puVar10,uVar7);
            *(undefined1 *)(param_1 + 0x72) = 0;
            FUN_0045e630(puVar10,uVar7);
          }
        }
        if (bVar13) {
          (**local_4)();
        }
        return;
      }
    }
    if (!bVar1) {
      if (DAT_005d7d30 == '\0') {
        uVar7 = 0;
        puVar10 = (undefined *)0x0;
      }
      else {
        uVar7 = uVar11;
        FUN_0045e520();
        uVar11 = uVar7;
      }
      if (uVar7 == 0) {
        *(undefined1 *)(param_1 + 0x72) = 1;
      }
      else {
        FUN_0045ef40(puVar10);
        *(undefined1 *)(param_1 + 0x72) = 1;
        uVar11 = uVar7;
        FUN_0045e630(puVar10);
      }
    }
    local_14 = &LAB_0041e1f0;
    local_10 = param_1;
    in_stack_ffffff60 = CONCAT44(uVar11,&local_14);
    local_c = uVar2;
    local_8 = uVar5;
    FUN_0046d890();
    iVar3 = *(int *)(param_1 + 0x48);
    iVar6 = param_1;
    if (DAT_005f5fd0 != 0) {
      uVar8 = *(undefined4 *)(param_1 + 0x48);
      FUN_0046ed70();
      *in_EDI = uVar8;
    }
    *(undefined4 *)(iVar6 + 0x48) = 0;
    if (iVar3 != 0) {
      FUN_00418ea0();
      iVar6 = param_1;
    }
    if (-1 < *(int *)(iVar6 + 0x114)) break;
    if (*(char *)(iVar6 + 0x69) == '\0') {
      FUN_0041e730();
      iVar6 = param_1;
      if ((char)in_stack_ffffff60 != '\0') break;
      bVar1 = true;
    }
    else {
      in_stack_ffffff60 = in_stack_ffffff60 & 0xffffffff00000000;
      FUN_0046d830(&PTR_LAB_00536b14);
      bVar1 = true;
    }
  }
  if (DAT_005d7d30 == '\0') {
    iVar3 = 0;
    uVar8 = 0;
  }
  else {
    FUN_0045e520();
    uVar8 = (undefined4)in_stack_ffffff60;
    iVar3 = (int)(in_stack_ffffff60 >> 0x20);
    iVar6 = param_1;
  }
  if (iVar3 == 0) {
    *(undefined1 *)(iVar6 + 0x72) = 0;
  }
  else {
    FUN_0045eff0(uVar8,iVar3);
    *(undefined1 *)(param_1 + 0x72) = 0;
    FUN_0045e630(uVar8,iVar3);
  }
  if (bVar13) {
    (**local_4)();
  }
  return;
}



/* Function: FUN_0041e230 */

void FUN_0041e230(void)

{
  int iVar1;
  int in_EDX;
  undefined4 uVar2;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d900();
  }
  iVar1 = *(int *)(in_EDX + 4);
  uVar2 = *(undefined4 *)(in_EDX + 8);
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = uVar2;
    in_EDI[1] = *(undefined4 *)(iVar1 + 0xf0);
  }
  *(undefined4 *)(iVar1 + 0xf0) = uVar2;
  return;
}



/* Function: FUN_0041e270 */

void FUN_0041e270(void)

{
  undefined4 uVar1;
  undefined4 uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  undefined *puVar7;
  int iVar8;
  uint uVar9;
  undefined *puVar10;
  uint uVar11;
  undefined1 *puVar12;
  int *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x54);
      iVar6 = *(int *)((int)register0x00000010 + 4);
      if (DAT_005f5fd0 != 0) {
        iVar8 = *(int *)(iVar6 + 0x48);
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e29f;
        FUN_0046ed70();
        *in_EDI = iVar8;
      }
      *(undefined4 *)(iVar6 + 0x48) = 0;
      *(undefined4 **)((int)register0x00000010 + -0x54) = &DAT_005f5e08;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e2b6;
      FUN_00402510();
      if (*(int *)((int)register0x00000010 + -0x50) == 0) {
        iVar6 = *(int *)((int)register0x00000010 + 4);
        *(undefined4 *)(iVar6 + 0x110) = 0;
        *(undefined4 *)(iVar6 + 0x114) = 0;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e2e0;
      FUN_0046fa70();
      iVar6 = *(int *)(*(int *)(*(int *)((int)register0x00000010 + 4) + 0x18) + 0x58);
      uVar1 = *(undefined4 *)((int)register0x00000010 + -0x54);
      *(undefined4 *)((int)register0x00000010 + -0x38) = uVar1;
      uVar2 = *(undefined4 *)((int)register0x00000010 + -0x50);
      *(undefined4 *)((int)register0x00000010 + -0x30) = uVar2;
      *(int *)((int)register0x00000010 + -0x54) = iVar6 + 0x958;
      *(undefined1 *)((int)register0x00000010 + -0x50) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = uVar1;
      *(undefined4 *)((int)register0x00000010 + -0x48) = uVar2;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e315;
      FUN_0041c970();
      *(undefined1 *)((int)register0x00000010 + -0x3d) =
           *(undefined1 *)((int)register0x00000010 + -0x44);
      *(undefined4 **)((int)register0x00000010 + -0x54) = &DAT_005d7664;
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0xffffffff;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e334;
      FUN_00402690();
      puVar7 = *(undefined **)((int)register0x00000010 + -0x4c);
      puVar10 = DAT_005d7658;
      if (DAT_005d7658 != puVar7) {
        *(undefined4 *)((int)register0x00000010 + -0x54) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x50) = 2;
        *(undefined1 *)((int)register0x00000010 + -0x4c) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e35f;
        FUN_0043dac0();
        *(int *)((int)register0x00000010 + -0x54) =
             *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58) + 0x96c;
        *(undefined4 *)((int)register0x00000010 + -0x50) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x4c) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e38f;
        FUN_0041fa20();
        *(undefined4 *)((int)register0x00000010 + -0x24) =
             *(undefined4 *)((int)register0x00000010 + -0x48);
        *(undefined4 *)((int)register0x00000010 + -0x20) =
             *(undefined4 *)((int)register0x00000010 + -0x44);
        *(undefined4 *)((int)register0x00000010 + -0x54) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x50) = 4;
        *(undefined4 *)((int)register0x00000010 + -0x4c) = 2;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e3bb;
        FUN_0043d640();
        *(undefined **)((int)register0x00000010 + -0x54) = &DAT_005f6880;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e3ca;
        FUN_004027a0();
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + -0x50);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -0x4c);
        *(undefined8 *)((int)register0x00000010 + -0x2c) =
             *(undefined8 *)((int)register0x00000010 + -0x1c);
        *(undefined4 *)((int)register0x00000010 + -0x54) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x50) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e3fa;
        FUN_00464a40();
        *(undefined4 *)((int)register0x00000010 + -8) =
             *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x110);
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x114);
        *(double *)((int)register0x00000010 + -0x54) =
             *(double *)((int)register0x00000010 + -0x2c) *
             *(double *)((int)register0x00000010 + -0x4c);
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e428;
        FUN_004649a0();
        uVar3 = *(uint *)((int)register0x00000010 + -0x4c);
        iVar6 = *(int *)((int)register0x00000010 + -0x48);
        uVar4 = *(uint *)((int)register0x00000010 + -8);
        uVar11 = uVar4 + uVar3;
        iVar8 = *(int *)((int)register0x00000010 + -0xc);
        iVar5 = *(int *)((int)register0x00000010 + 4);
        *(uint *)(iVar5 + 0x110) = uVar11 + 1;
        *(uint *)(iVar5 + 0x114) =
             iVar8 + iVar6 + (uint)CARRY4(uVar4,uVar3) + (uint)(0xfffffffe < uVar11);
        *(undefined4 **)((int)register0x00000010 + -0x54) = &DAT_005d7664;
        *(undefined4 *)((int)register0x00000010 + -0x50) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e468;
        FUN_00402690();
        puVar7 = *(undefined **)((int)register0x00000010 + -0x4c);
        if (puVar7 <= DAT_005d7658) {
          if (DAT_005d7658 == puVar7) {
            *(undefined4 *)((int)register0x00000010 + -0x54) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e488;
            FUN_0041b100();
            if (*(char *)((int)register0x00000010 + -0x50) == '\0') {
              if (DAT_005f5fd0 == 0) {
                iVar6 = *(int *)((int)register0x00000010 + 4);
              }
              else {
                *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e4a6;
                FUN_0046ed80();
                iVar6 = *(int *)((int)register0x00000010 + 4);
                *in_EDI = iVar6;
                in_EDI[1] = *(int *)(iVar6 + 0x48);
              }
              *(int *)(iVar6 + 0x48) = iVar6;
            }
          }
          *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e4bb;
          FUN_0046fa70();
          iVar6 = *(int *)(*(int *)(*(int *)((int)register0x00000010 + 4) + 0x18) + 0x58);
          uVar3 = *(uint *)((int)register0x00000010 + -0x54);
          *(uint *)((int)register0x00000010 + -0x3c) = uVar3;
          iVar8 = *(int *)((int)register0x00000010 + -0x50);
          *(int *)((int)register0x00000010 + -0x34) = iVar8;
          *(int *)((int)register0x00000010 + -4) = iVar6;
          uVar4 = *(uint *)(iVar6 + 0x948);
          uVar11 = *(uint *)((int)register0x00000010 + -0x38);
          uVar9 = uVar3 - uVar11;
          iVar5 = *(int *)((int)register0x00000010 + -0x30);
          *(uint *)(iVar6 + 0x948) = uVar4 + uVar9;
          *(uint *)(iVar6 + 0x94c) =
               *(int *)(iVar6 + 0x94c) + ((iVar8 - iVar5) - (uint)(uVar3 < uVar11)) +
               (uint)CARRY4(uVar4,uVar9);
          if (*(char *)((int)register0x00000010 + -0x3d) != '\0') {
            *(int *)((int)register0x00000010 + -0x54) = iVar6 + 0x958;
            *(undefined1 *)((int)register0x00000010 + -0x50) = 2;
            *(uint *)((int)register0x00000010 + -0x4c) = uVar3;
            *(undefined4 *)((int)register0x00000010 + -0x48) =
                 *(undefined4 *)((int)register0x00000010 + -0x34);
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e529;
            FUN_0041cb30();
            iVar6 = *(int *)((int)register0x00000010 + -4);
          }
          iVar8 = *(int *)(iVar6 + 0x94c);
          uVar3 = *(uint *)(iVar6 + 0x948);
          if (0 < iVar8 || iVar8 == 0 && 5000 < uVar3) {
            *(undefined **)((int)register0x00000010 + -0x54) = &DAT_005f6840;
            *(uint *)((int)register0x00000010 + -0x50) = uVar3;
            *(int *)((int)register0x00000010 + -0x4c) = iVar8;
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e575;
            thunk_FUN_004026b0();
            *(undefined **)((int)register0x00000010 + -0x54) = &DAT_005f61a0;
            *(undefined4 *)((int)register0x00000010 + -0x50) =
                 *(undefined4 *)((int)register0x00000010 + -0x3c);
            *(undefined4 *)((int)register0x00000010 + -0x4c) =
                 *(undefined4 *)((int)register0x00000010 + -0x34);
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e593;
            FUN_0041c180();
            iVar6 = *(int *)((int)register0x00000010 + -4);
            *(undefined4 *)(iVar6 + 0x948) = 0;
            *(undefined4 *)(iVar6 + 0x94c) = 0;
          }
          return;
        }
        *(undefined **)((int)register0x00000010 + -0x14) = puVar7;
        *(undefined **)((int)register0x00000010 + -8) = DAT_005d7658;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e5bc;
        puVar10 = DAT_005d7658;
        FUN_0043a810();
        *(undefined **)((int)register0x00000010 + -0x54) = &DAT_004c6d7a;
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0x15;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e5d2;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x54) =
             *(undefined4 *)((int)register0x00000010 + -0x14);
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e5e6;
        FUN_0043ad50();
        *(char **)((int)register0x00000010 + -0x54) =
             " work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0xd;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e5fc;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x54) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e610;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e615;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e61a;
        FUN_0043a870();
        puVar7 = &DAT_004c7a43;
        *(undefined **)((int)register0x00000010 + -0x54) = &DAT_004c7a43;
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0x17;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e630;
        FUN_00469a20();
      }
      *(undefined **)((int)register0x00000010 + -0x10) = puVar7;
      *(undefined **)((int)register0x00000010 + -8) = puVar10;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e63d;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x54) = &DAT_004c7396;
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0x16;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e653;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x54) =
           *(undefined4 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e667;
      FUN_0043ad50();
      *(char **)((int)register0x00000010 + -0x54) =
           " work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0xd;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e67d;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x54) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e691;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e696;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e69b;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x54) = &DAT_004c61dc;
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x41e6b1;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar12 + -4) = 0x41e6b7;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
}



/* Function: FUN_0041e6c0 */

void FUN_0041e6c0(void)

{
  int in_FS_OFFSET;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x41e726;
    FUN_0046d980();
  }
  FUN_0040ecf0(&DAT_005d76b4);
  local_4 = DAT_005d76b8;
  DAT_005d76b8 = 0;
  DAT_005d76bc = 0;
  FUN_00442aa0(&local_4);
  FUN_0040f0e0(&DAT_005d76b4);
  return;
}



/* Function: FUN_0041e730 */

void FUN_0041e730(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int in_FS_OFFSET;
  int in_stack_ffffffec;
  int in_stack_fffffff0;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040ecf0(&DAT_005d76b4);
  FUN_00402510(&DAT_005f5e08);
  iVar3 = DAT_005d76bc;
  iVar2 = DAT_005d76b8;
  if (in_stack_ffffffec == 0) {
    FUN_0040f0e0(&DAT_005d76b4);
    return;
  }
  iVar1 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(undefined4 *)(iVar1 + 0x5c) = 0;
  iVar4 = iVar1;
  if (DAT_005d76bc != 0) {
    *(int *)(DAT_005d76bc + 0x5c) = iVar1;
    iVar4 = DAT_005d76b8;
  }
  DAT_005d76b8 = iVar4;
  DAT_005d76bc = iVar1;
  thunk_FUN_004027a0(&DAT_005f6838);
  if (in_stack_fffffff0 < 1 && (in_stack_fffffff0 != 0 || in_stack_ffffffec == 0)) {
    FUN_00469a60(&PTR_LAB_00536c38,&DAT_005d76b4,0x80b,2);
    return;
  }
  DAT_005d76b8 = iVar2;
  DAT_005d76bc = iVar3;
  if (iVar3 != 0) {
    *(undefined4 *)(iVar3 + 0x5c) = 0;
  }
  FUN_0040f0e0(&DAT_005d76b4);
  return;
}



/* Function: FUN_0041e870 */

void FUN_0041e870(undefined4 param_1,undefined4 param_2)

{
  int iVar1;
  int iVar2;
  int in_FS_OFFSET;
  bool bVar3;
  double dVar4;
  undefined8 in_stack_ffffffbc;
  undefined4 uVar6;
  ulong uVar5;
  uint in_stack_ffffffc4;
  uint uVar7;
  int iStack_38;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (DAT_005d76b8 == 0) {
    thunk_FUN_004026b0(&DAT_005f6838,param_1,param_2);
    return;
  }
  uVar6 = (undefined4)((ulong)in_stack_ffffffbc >> 0x20);
  FUN_004027a0(&DAT_005f6880);
  dVar4 = (double)CONCAT44(in_stack_ffffffc4,uVar6);
  FUN_00464a40(param_1,param_2);
  dVar4 = dVar4 * (double)CONCAT44(iStack_38,in_stack_ffffffc4);
  FUN_004649a0(dVar4);
  uVar5 = (ulong)dVar4 & 0xffffffff00000000;
  uVar7 = in_stack_ffffffc4;
  FUN_0040ecf0(&DAT_005d76b4);
  iVar2 = iStack_38;
  while( true ) {
    iVar1 = DAT_005d76b8;
    if ((DAT_005d76b8 == 0) || (iVar2 < 1 && (iVar2 != 0 || in_stack_ffffffc4 == 0)))
    goto LAB_0041ea1c;
    if ((DAT_005d76b8 != 0) && (DAT_005d76b8 = *(int *)(DAT_005d76b8 + 0x5c), DAT_005d76b8 == 0)) {
      DAT_005d76bc = 0;
    }
    bVar3 = CARRY4(in_stack_ffffffc4,*(uint *)(iVar1 + 0x110));
    in_stack_ffffffc4 = in_stack_ffffffc4 + *(uint *)(iVar1 + 0x110);
    iVar2 = iVar2 + *(int *)(iVar1 + 0x114) + (uint)bVar3;
    if (iVar2 < 0) break;
    *(undefined4 *)(iVar1 + 0x110) = 0;
    *(undefined4 *)(iVar1 + 0x114) = 0;
    uVar5 = 0;
    uVar7 = uVar7 & 0xffffff00;
    FUN_0043cda0(iVar1,0,uVar7);
  }
  *(uint *)(iVar1 + 0x110) = in_stack_ffffffc4;
  *(int *)(iVar1 + 0x114) = iVar2;
  *(undefined4 *)(iVar1 + 0x5c) = 0;
  iVar2 = iVar1;
  if (DAT_005d76bc != 0) {
    *(int *)(DAT_005d76bc + 0x5c) = iVar1;
    iVar2 = DAT_005d76b8;
  }
  DAT_005d76b8 = iVar2;
  DAT_005d76bc = iVar1;
  iVar2 = 0;
  in_stack_ffffffc4 = 0;
LAB_0041ea1c:
  if (0 < iVar2 || iVar2 == 0 && in_stack_ffffffc4 != 0) {
    uVar6 = (undefined4)(uVar5 >> 0x20);
    FUN_004027a0(&DAT_005f6878);
    dVar4 = (double)CONCAT44(uVar7,uVar6);
    FUN_00464a40(in_stack_ffffffc4,iVar2);
    FUN_004649a0(dVar4 * (double)CONCAT44(iStack_38,uVar7));
    thunk_FUN_004026b0(&DAT_005f6838,uVar7,iStack_38);
  }
  FUN_0040f0e0(&DAT_005d76b4);
  return;
}



/* Function: FUN_0041ead0 */

void FUN_0041ead0(void)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  undefined *puVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  int *piVar8;
  uint uVar9;
  undefined1 *puVar10;
  undefined **ppuVar11;
  int in_FS_OFFSET;
  
  do {
    puVar10 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) <
        (undefined1 *)((int)register0x00000010 + -0x14)) {
      puVar10 = (undefined1 *)((int)register0x00000010 + -0x94);
      *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0x4c;
      *(int *)((int)register0x00000010 + -0x94) = *(int *)((int)register0x00000010 + 4) + 0x4c;
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41eb09;
      FUN_00402510();
      if ((*(uint *)((int)register0x00000010 + -0x90) & 0x1000) != 0) {
        *(undefined4 *)((int)register0x00000010 + -0x94) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41eb28;
        FUN_00402510();
        puVar3 = (undefined *)(*(uint *)((int)register0x00000010 + -0x90) & 0xffffefff);
        if (puVar3 < (undefined *)0x3) {
          if (puVar3 == (undefined *)0x1) goto LAB_0041eb49;
        }
        else {
          if ((undefined *)0x4 < puVar3) {
            if (puVar3 == (undefined *)0x6) {
              *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
              *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
              return;
            }
code_r0x0041ecb4:
            *(undefined4 *)((int)register0x00000010 + -0x94) =
                 *(undefined4 *)((int)register0x00000010 + -4);
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ecc3;
            FUN_00402510();
            *(undefined4 *)((int)register0x00000010 + -0xc) =
                 *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x54);
            *(undefined4 *)((int)register0x00000010 + -0x10) =
                 *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x58);
            *(undefined4 *)((int)register0x00000010 + -0x74) =
                 *(undefined4 *)((int)register0x00000010 + -0x90);
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41eceb;
            FUN_0043a810();
            *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c3f67;
            *(undefined4 *)((int)register0x00000010 + -0x90) = 0xc;
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ed01;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x94) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ed10;
            FUN_0043afe0();
            *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c2ef2;
            *(undefined4 *)((int)register0x00000010 + -0x90) = 7;
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ed26;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x94) =
                 *(undefined4 *)((int)register0x00000010 + -0xc);
            *(undefined4 *)((int)register0x00000010 + -0x90) =
                 *(undefined4 *)((int)register0x00000010 + -0x10);
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ed40;
            FUN_0043ad50();
            *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c61ef;
            *(undefined4 *)((int)register0x00000010 + -0x90) = 0x13;
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ed56;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x94) =
                 *(undefined4 *)((int)register0x00000010 + -0x74);
            *(undefined4 *)((int)register0x00000010 + -0x90) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ed6a;
            FUN_0043ad50();
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ed6f;
            FUN_0043aa10();
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ed74;
            FUN_0043a870();
            *(char **)((int)register0x00000010 + -0x94) =
                 "mark - bad statusscanobject n == 0swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
            ;
            *(undefined4 *)((int)register0x00000010 + -0x90) = 0x11;
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ed8a;
            FUN_00469a20();
            do {
              *(undefined1 **)((int)register0x00000010 + -0x94) =
                   (undefined1 *)((int)register0x00000010 + -0x6c);
              *(undefined1 **)((int)register0x00000010 + -0x90) =
                   (undefined1 *)((int)register0x00000010 + -0x3c);
              *(undefined4 *)((int)register0x00000010 + -0x8c) =
                   *(undefined4 *)((int)register0x00000010 + 8);
              *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41eda9;
              FUN_0041f260();
              *(undefined1 **)((int)register0x00000010 + -0x94) =
                   (undefined1 *)((int)register0x00000010 + -0x6c);
              *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41edb5;
              FUN_00459030();
LAB_0041edb5:
            } while (*(int *)((int)register0x00000010 + -100) != 0);
            iVar4 = *(int *)((int)register0x00000010 + 4);
            iVar5 = *(int *)(iVar4 + 0x14);
            piVar8 = (int *)0x1;
            while( true ) {
              *(int *)((int)register0x00000010 + -8) = iVar5;
              if ((char)piVar8 == '\0') {
                *(undefined4 *)((int)register0x00000010 + -8) = *(undefined4 *)(iVar5 + 0x10);
              }
              else {
                piVar8 = (int *)0x0;
              }
              iVar5 = *(int *)((int)register0x00000010 + -8);
              if (iVar5 == 0) break;
              *(char *)((int)register0x00000010 + -0x79) = (char)piVar8;
              if (*(int *)(iVar5 + 0xc) != 0) {
                *(int *)((int)register0x00000010 + -0x94) = iVar5 + 0xc;
                *(undefined4 *)((int)register0x00000010 + -0x90) = 4;
                *(undefined **)((int)register0x00000010 + -0x8c) = &DAT_005cc260;
                *(undefined4 *)((int)register0x00000010 + -0x88) =
                     *(undefined4 *)((int)register0x00000010 + 8);
                *(undefined1 **)((int)register0x00000010 + -0x84) =
                     (undefined1 *)((int)register0x00000010 + -0x3c);
                *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ee38;
                FUN_0041fcf0();
                iVar4 = *(int *)((int)register0x00000010 + 4);
                piVar8 = (int *)(uint)*(byte *)((int)register0x00000010 + -0x79);
              }
              if (*(int *)(*(int *)((int)register0x00000010 + -8) + 0x10) != 0) {
                *(int *)((int)register0x00000010 + -0x94) =
                     *(int *)((int)register0x00000010 + -8) + 0x10;
                *(undefined4 *)((int)register0x00000010 + -0x90) = 4;
                *(undefined **)((int)register0x00000010 + -0x8c) = &DAT_005cc260;
                *(undefined4 *)((int)register0x00000010 + -0x88) =
                     *(undefined4 *)((int)register0x00000010 + 8);
                *(undefined1 **)((int)register0x00000010 + -0x84) =
                     (undefined1 *)((int)register0x00000010 + -0x3c);
                *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ee82;
                FUN_0041fcf0();
                iVar4 = *(int *)((int)register0x00000010 + 4);
                piVar8 = (int *)(uint)*(byte *)((int)register0x00000010 + -0x79);
              }
              if (**(char **)((int)register0x00000010 + -8) != '\0') {
                *(undefined1 **)((int)register0x00000010 + -0x94) =
                     (undefined1 *)((int)register0x00000010 + -8);
                *(undefined4 *)((int)register0x00000010 + -0x90) = 4;
                *(undefined **)((int)register0x00000010 + -0x8c) = &DAT_005cc260;
                *(undefined4 *)((int)register0x00000010 + -0x88) =
                     *(undefined4 *)((int)register0x00000010 + 8);
                *(undefined1 **)((int)register0x00000010 + -0x84) =
                     (undefined1 *)((int)register0x00000010 + -0x3c);
                *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41eed4;
                FUN_0041fcf0();
                iVar4 = *(int *)((int)register0x00000010 + 4);
                piVar8 = (int *)(uint)*(byte *)((int)register0x00000010 + -0x79);
              }
              iVar5 = *(int *)((int)register0x00000010 + -8);
            }
            iVar4 = *(int *)(iVar4 + 0x10);
            if (iVar4 != 0) {
              *(undefined1 **)((int)register0x00000010 + -0x94) =
                   (undefined1 *)((int)register0x00000010 + -0x3c);
              *(int *)((int)register0x00000010 + -0x90) = iVar4;
              *(undefined1 *)((int)register0x00000010 + -0x8c) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ef01;
              FUN_00426000();
            }
            *(undefined4 *)((int)register0x00000010 + -0x94) =
                 *(undefined4 *)((int)register0x00000010 + -0x24);
            *(undefined4 *)((int)register0x00000010 + -0x90) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x8c) =
                 *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ef1e;
            FUN_004262f0();
            *(undefined4 *)((int)register0x00000010 + -0x18) =
                 *(undefined4 *)((int)register0x00000010 + -0x88);
            do {
              do {
                *(undefined1 **)((int)register0x00000010 + -0x94) =
                     (undefined1 *)((int)register0x00000010 + -0x3c);
                *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ef32;
                FUN_004260f0();
                uVar6 = (uint)*(byte *)((int)register0x00000010 + -0x8c);
                if (*(int *)((int)register0x00000010 + -0x90) == 0) {
                  while (iVar4 = *(int *)((int)register0x00000010 + -0x24), iVar4 != 0) {
                    uVar6 = *(uint *)(iVar4 + 0x10);
                    *(uint *)((int)register0x00000010 + -0x24) = uVar6;
                    *(undefined4 *)(iVar4 + 0xc) = 0;
                    *(int *)((int)register0x00000010 + -0x94) = iVar4;
                    *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ef86;
                    FUN_00428d50();
                  }
                  if (((*(int *)((int)register0x00000010 + -0x30) == 0) &&
                      (*(int *)((int)register0x00000010 + -0x28) == 0)) &&
                     (*(int *)((int)register0x00000010 + -0x2c) == 0)) {
                    *(undefined4 *)((int)register0x00000010 + 0xc) =
                         *(undefined4 *)((int)register0x00000010 + -0x14);
                    *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
                    return;
                  }
                  puVar3 = &DAT_004c8679;
                  *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c8679;
                  *(undefined4 *)((int)register0x00000010 + -0x90) = 0x19;
                  *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41efdc;
                  FUN_00469a20();
                }
                else {
                  puVar3 = (undefined *)
                           (*(int *)((int)register0x00000010 + -0x90) -
                           *(int *)((int)register0x00000010 + -0x3c));
                  piVar8 = *(int **)((int)register0x00000010 + -0x18);
                }
                while (piVar8 != (int *)0x0) {
                  if (puVar3 < (undefined *)*piVar8) {
                    piVar8 = (int *)piVar8[3];
                  }
                  else {
                    if (puVar3 < (undefined *)*piVar8 + piVar8[1]) goto LAB_0041ef51;
                    piVar8 = (int *)piVar8[4];
                  }
                }
                piVar8 = (int *)0x0;
LAB_0041ef51:
              } while ((piVar8 == (int *)0x0) ||
                      (puVar3 = (undefined *)piVar8[2], puVar3 == (undefined *)0x0));
              piVar8[2] = 0;
              for (ppuVar11 = &PTR_DAT_005ccde0; ppuVar11 != (undefined **)0x0;
                  ppuVar11 = (undefined **)ppuVar11[0x48]) {
                if ((ppuVar11[0x28] <= puVar3) && (puVar3 < ppuVar11[0x22])) goto LAB_0041f01f;
              }
              ppuVar11 = (undefined **)0x0;
LAB_0041f01f:
              iVar4 = *piVar8;
              piVar8 = (int *)(ppuVar11[0x27] + *(int *)(puVar3 + 0xc));
              uVar2 = *(undefined4 *)(puVar3 + 8);
              if ((char)uVar6 == '\0') {
                *(int *)((int)register0x00000010 + -0x94) =
                     iVar4 + *(int *)((int)register0x00000010 + -0x3c);
                *(undefined4 *)((int)register0x00000010 + -0x90) = uVar2;
                *(int **)((int)register0x00000010 + -0x8c) = piVar8;
                *(undefined4 *)((int)register0x00000010 + -0x88) =
                     *(undefined4 *)((int)register0x00000010 + 8);
                *(undefined1 **)((int)register0x00000010 + -0x84) =
                     (undefined1 *)((int)register0x00000010 + -0x3c);
                *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f080;
                FUN_0041fcf0();
              }
              else {
                *(int *)((int)register0x00000010 + -0x94) =
                     iVar4 + *(int *)((int)register0x00000010 + -0x3c);
                *(undefined4 *)((int)register0x00000010 + -0x90) = uVar2;
                *(int **)((int)register0x00000010 + -0x8c) = piVar8;
                *(undefined4 *)((int)register0x00000010 + -0x88) =
                     *(undefined4 *)((int)register0x00000010 + 8);
                *(undefined1 **)((int)register0x00000010 + -0x84) =
                     (undefined1 *)((int)register0x00000010 + -0x3c);
                *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f058;
                FUN_00420130();
              }
            } while( true );
          }
LAB_0041eb49:
          iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
          iVar5 = *(int *)((int)register0x00000010 + 4);
          if (iVar5 != iVar4) {
            iVar7 = *(int *)(iVar5 + 0x38);
            if (iVar7 == 0) {
              iVar7 = *(int *)(iVar5 + 0x1c);
            }
            uVar9 = *(int *)(iVar5 + 4) - iVar7;
            *(uint *)((int)register0x00000010 + -0x14) = uVar9;
            iVar4 = *(int *)(*(int *)(iVar4 + 0x18) + 0x58);
            uVar6 = *(uint *)(iVar4 + 0x11d8);
            *(uint *)(iVar4 + 0x11d8) = uVar6 + uVar9;
            *(uint *)(iVar4 + 0x11dc) = *(int *)(iVar4 + 0x11dc) + (uint)CARRY4(uVar6,uVar9);
            uVar6 = *(uint *)(iVar4 + 0x11e0);
            *(uint *)(iVar4 + 0x11e0) = uVar6 + 1;
            *(uint *)(iVar4 + 0x11e4) = *(int *)(iVar4 + 0x11e4) + (uint)(0xfffffffe < uVar6);
            *(int *)((int)register0x00000010 + -0x94) = iVar5;
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ebc4;
            FUN_00450b70();
            if (*(char *)((int)register0x00000010 + -0x90) == '\0') {
              *(undefined1 *)(*(int *)((int)register0x00000010 + 4) + 0x6b) = 1;
            }
            else {
              *(undefined4 *)((int)register0x00000010 + -0x94) =
                   *(undefined4 *)((int)register0x00000010 + 4);
              *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ebe9;
              FUN_00450c50();
            }
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ebfb;
            FUN_0046ef46();
            puVar1 = *(undefined4 **)((int)register0x00000010 + 4);
            uVar2 = puVar1[1];
            *(undefined4 *)((int)register0x00000010 + -0x3c) = *puVar1;
            *(undefined4 *)((int)register0x00000010 + -0x38) = uVar2;
            if (puVar1[10] != 0) {
              *(undefined4 **)((int)register0x00000010 + -0x94) = puVar1 + 10;
              *(undefined4 *)((int)register0x00000010 + -0x90) = 4;
              *(undefined **)((int)register0x00000010 + -0x8c) = &DAT_005cc260;
              *(undefined4 *)((int)register0x00000010 + -0x88) =
                   *(undefined4 *)((int)register0x00000010 + 8);
              *(undefined1 **)((int)register0x00000010 + -0x84) =
                   (undefined1 *)((int)register0x00000010 + -0x3c);
              *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ec46;
              FUN_0041fcf0();
            }
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ec58;
            FUN_0046ef44();
            *(undefined1 **)((int)register0x00000010 + -0x94) =
                 (undefined1 *)((int)register0x00000010 + -0x6c);
            *(undefined4 *)((int)register0x00000010 + -0x90) = 0xffffffff;
            *(undefined4 *)((int)register0x00000010 + -0x8c) = 0xffffffff;
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0xffffffff;
            *(undefined4 *)((int)register0x00000010 + -0x84) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined1 *)((int)register0x00000010 + -0x80) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41ec8c;
            FUN_00458b40();
            goto LAB_0041edb5;
          }
          puVar3 = &DAT_004c805f;
          *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c805f;
          *(undefined4 *)((int)register0x00000010 + -0x90) = 0x18;
          *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f09b;
          FUN_00469a20();
        }
        if (puVar3 != (undefined *)0x2) goto code_r0x0041ecb4;
        *(undefined4 *)((int)register0x00000010 + -0x94) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f0b4;
        FUN_00402510();
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x54);
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x58);
        *(undefined4 *)((int)register0x00000010 + -0x78) =
             *(undefined4 *)((int)register0x00000010 + -0x90);
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f0dc;
        FUN_0043a810();
        *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c3f67;
        *(undefined4 *)((int)register0x00000010 + -0x90) = 0xc;
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f0f2;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x94) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f101;
        FUN_0043afe0();
        *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c2ef2;
        *(undefined4 *)((int)register0x00000010 + -0x90) = 7;
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f117;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x94) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x90) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f131;
        FUN_0043ad50();
        *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c61ef;
        *(undefined4 *)((int)register0x00000010 + -0x90) = 0x13;
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f147;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x94) =
             *(undefined4 *)((int)register0x00000010 + -0x78);
        *(undefined4 *)((int)register0x00000010 + -0x90) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f15b;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f160;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f165;
        FUN_0043a870();
        *(char **)((int)register0x00000010 + -0x94) =
             "scanstack: goroutine not stoppedscavenger state is already wiredsweep increased allocation countremovespecial on invalid pointergetWeakHandle on invalid pointerruntime: root level max pages = NtAssociateWaitCompletionPacket"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x90) = 0x20;
        *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f17b;
        FUN_00469a20();
      }
      *(undefined4 *)((int)register0x00000010 + -0x94) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f18b;
      FUN_00402510();
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x54);
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x58);
      *(undefined4 *)((int)register0x00000010 + -0x70) =
           *(undefined4 *)((int)register0x00000010 + -0x90);
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f1b3;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c73ac;
      *(undefined4 *)((int)register0x00000010 + -0x90) = 0x16;
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f1c9;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x94) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f1d8;
      FUN_0043afe0();
      *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c2ef2;
      *(undefined4 *)((int)register0x00000010 + -0x90) = 7;
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f1ee;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x94) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x90) =
           *(undefined4 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f208;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c61ef;
      *(undefined4 *)((int)register0x00000010 + -0x90) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f21e;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x94) =
           *(undefined4 *)((int)register0x00000010 + -0x70);
      *(undefined4 *)((int)register0x00000010 + -0x90) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f232;
      FUN_0043aef0();
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f237;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f23c;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x94) = &DAT_004c73c2;
      *(undefined4 *)((int)register0x00000010 + -0x90) = 0x16;
      *(undefined4 *)((int)register0x00000010 + -0x98) = 0x41f252;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar10 + -4) = 0x41f258;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar10;
  } while( true );
}



/* Function: FUN_0041f260 */

void FUN_0041f260(int *param_1,int param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int in_FS_OFFSET;
  bool bVar5;
  bool bVar6;
  uint in_stack_ffffffc8;
  int in_stack_ffffffcc;
  undefined4 in_stack_ffffffd0;
  int in_stack_ffffffd4;
  undefined4 local_28;
  int local_24;
  int local_20;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar2 = *param_1;
  if (iVar2 == 0) {
    bVar5 = false;
    bVar6 = false;
  }
  else {
    bVar5 = *(char *)(iVar2 + 0x28) == '\x03';
    bVar6 = *(char *)(iVar2 + 0x28) == '\x06';
  }
  if (((*(char *)(param_2 + 8) == '\0') && (!bVar5)) && (!bVar6)) {
    FUN_00451440(param_1,in_stack_ffffffc8 & 0xffffff00);
    if (0 < in_stack_ffffffcc) {
      FUN_0041fcf0(param_1[7] + in_stack_ffffffcc * -4,in_stack_ffffffcc * 4,in_stack_ffffffd0,
                   param_3,param_2);
    }
    if (0 < in_stack_ffffffd4) {
      FUN_0041fcf0(param_1[8],in_stack_ffffffd4 << 2,local_28,param_3,param_2);
    }
    if (param_1[7] != 0) {
      for (iVar2 = 0; iVar2 < local_20; iVar2 = iVar2 + 1) {
        iVar1 = *(int *)(local_24 + iVar2 * 0x10);
        iVar4 = param_1[7];
        if (-1 < iVar1) {
          iVar4 = param_1[8];
        }
        uVar3 = iVar1 + iVar4;
        if ((uint)param_1[5] <= uVar3) {
          FUN_004261f0(param_2,uVar3,iVar2 * 0x10 + local_24);
        }
      }
    }
    return;
  }
  if (param_1[7] != 0) {
    uVar3 = param_1[7] - param_1[5];
    if (uVar3 != 0) {
      FUN_00420130(param_1[5],uVar3,0,param_3,param_2);
      in_stack_ffffffc8 = uVar3;
    }
  }
  FUN_004510b0(param_1);
  if (in_stack_ffffffc8 != 0) {
    FUN_00420130(param_1[8]);
  }
  if ((bVar5) || (bVar6)) {
    *(undefined1 *)(param_2 + 8) = 1;
  }
  else {
    *(undefined1 *)(param_2 + 8) = 0;
  }
  return;
}



/* Function: FUN_0041f490 */

void FUN_0041f490(void)

{
  code *pcVar1;
  int iVar2;
  int *piVar3;
  undefined **ppuVar4;
  int iVar5;
  undefined4 uVar6;
  uint uVar7;
  undefined1 *puVar8;
  int iVar9;
  char cVar10;
  uint uVar11;
  uint uVar12;
  int in_FS_OFFSET;
  bool bVar13;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x4c);
      if ((char)DAT_005f5fd0 != '\0') break;
      *(undefined **)((int)register0x00000010 + -0x4c) = &DAT_004c7a71;
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x17;
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41fa07;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x41fa0d;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
  uVar12 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x10);
  *(uint *)((int)register0x00000010 + -0x34) = uVar12;
  iVar2 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x14);
  uVar11 = *(uint *)((int)register0x00000010 + 8);
  if ((uVar11 & 0xc) == 0) {
    iVar9 = 0x7fffffff;
    uVar7 = 0xffffffff;
    ppuVar4 = (undefined **)0x0;
  }
  else {
    uVar7 = uVar12 + 100000;
    if ((uVar11 & 4) == 0) {
      if ((uVar11 & 8) == 0) {
        ppuVar4 = (undefined **)0x0;
      }
      else {
        ppuVar4 = &PTR_LAB_00536c3c;
      }
    }
    else {
      ppuVar4 = &PTR_FUN_00536c40;
    }
    iVar9 = iVar2 + (uint)(0xfffe795f < uVar12);
  }
  *(undefined ***)((int)register0x00000010 + -8) = ppuVar4;
  iVar5 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x50);
  *(int *)((int)register0x00000010 + -0xc) = iVar5;
  *(undefined4 *)((int)register0x00000010 + -4) = *(undefined4 *)(*(int *)(iVar5 + 0x18) + 0x58);
  if (DAT_005d7654 <= DAT_005d7650) goto LAB_0041f579;
  *(int *)((int)register0x00000010 + -0x10) = iVar2;
  *(uint *)((int)register0x00000010 + -0x2c) = uVar7;
  *(int *)((int)register0x00000010 + -0x28) = iVar9;
  *(bool *)((int)register0x00000010 + -0x35) = (uVar11 & 2) != 0;
LAB_0041f8dd:
  if (*(char *)(iVar5 + 0x69) == '\0') {
    bVar13 = false;
  }
  else if ((uVar11 & 1) == 0) {
    *(undefined **)((int)register0x00000010 + -0x4c) = &DAT_005d8574;
    *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f902;
    FUN_00402470();
    if (*(char *)((int)register0x00000010 + -0x48) == '\0') {
      bVar13 = *(int *)(*(int *)((int)register0x00000010 + -4) + 0x1190) != 0;
      iVar5 = *(int *)((int)register0x00000010 + -0xc);
      iVar9 = *(int *)((int)register0x00000010 + -0x28);
      uVar11 = *(uint *)((int)register0x00000010 + 8);
      iVar2 = *(int *)((int)register0x00000010 + -0x10);
      uVar7 = *(uint *)((int)register0x00000010 + -0x2c);
    }
    else {
      iVar5 = *(int *)((int)register0x00000010 + -0xc);
      uVar7 = *(uint *)((int)register0x00000010 + -0x2c);
      iVar9 = *(int *)((int)register0x00000010 + -0x28);
      uVar11 = *(uint *)((int)register0x00000010 + 8);
      iVar2 = *(int *)((int)register0x00000010 + -0x10);
      bVar13 = true;
    }
  }
  else {
    bVar13 = true;
  }
  if (bVar13) {
LAB_0041f579:
    piVar3 = *(int **)((int)register0x00000010 + 4);
    do {
      *(int *)((int)register0x00000010 + -0x28) = iVar9;
      *(int *)((int)register0x00000010 + -0x30) = iVar2;
      *(uint *)((int)register0x00000010 + -0x2c) = uVar7;
      if (*(char *)(iVar5 + 0x69) == '\0') {
        bVar13 = false;
      }
      else if ((uVar11 & 1) == 0) {
        *(undefined **)((int)register0x00000010 + -0x4c) = &DAT_005d8574;
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f5cc;
        FUN_00402470();
        if (*(char *)((int)register0x00000010 + -0x48) == '\0') {
          bVar13 = *(int *)(*(int *)((int)register0x00000010 + -4) + 0x1190) != 0;
          piVar3 = *(int **)((int)register0x00000010 + 4);
          iVar2 = *(int *)((int)register0x00000010 + -0x30);
        }
        else {
          piVar3 = *(int **)((int)register0x00000010 + 4);
          iVar2 = *(int *)((int)register0x00000010 + -0x30);
          bVar13 = true;
        }
      }
      else {
        bVar13 = true;
      }
      if (bVar13) {
        uVar6 = *(undefined4 *)((int)register0x00000010 + -0x34);
        goto LAB_0041f82f;
      }
      if (DAT_005d75a4 == 0 && DAT_005d75a0 == 0) {
        *(int **)((int)register0x00000010 + -0x4c) = piVar3;
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f64b;
        FUN_00428a80();
        piVar3 = *(int **)((int)register0x00000010 + 4);
        iVar2 = *(int *)((int)register0x00000010 + -0x30);
      }
      iVar9 = *piVar3;
      if ((iVar9 == 0) || (iVar5 = *(int *)(iVar9 + 0xc), iVar5 == 0)) {
        iVar9 = 0;
      }
      else {
        *(uint *)(iVar9 + 0xc) = iVar5 - 1U;
        if (0x1fb < iVar5 - 1U) goto LAB_0041f8b4;
        iVar9 = *(int *)(iVar9 + 0xc + iVar5 * 4);
      }
      if (iVar9 == 0) {
        *(int **)((int)register0x00000010 + -0x4c) = piVar3;
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f696;
        FUN_004288a0();
        iVar9 = *(int *)((int)register0x00000010 + -0x48);
        if (iVar9 == 0) {
          *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f6a3;
          FUN_00433e10();
          *(undefined4 *)((int)register0x00000010 + -0x4c) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f6af;
          FUN_004288a0();
          iVar9 = *(int *)((int)register0x00000010 + -0x48);
        }
        iVar2 = *(int *)((int)register0x00000010 + -0x30);
        piVar3 = *(int **)((int)register0x00000010 + 4);
      }
      if (iVar9 == 0) {
        uVar6 = *(undefined4 *)((int)register0x00000010 + -0x34);
        goto LAB_0041f82f;
      }
      *(int *)((int)register0x00000010 + -0x4c) = iVar9;
      *(int **)((int)register0x00000010 + -0x48) = piVar3;
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f6dd;
      FUN_0041fe10();
      iVar2 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x14);
      uVar12 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x10);
      if ((uVar12 < 2000 || iVar2 != 0) && iVar2 < 1) {
        iVar9 = *(int *)((int)register0x00000010 + -0x28);
        iVar2 = *(int *)((int)register0x00000010 + -0x30);
        uVar6 = *(undefined4 *)((int)register0x00000010 + -0x34);
        uVar7 = *(uint *)((int)register0x00000010 + -0x2c);
      }
      else {
        *(undefined **)((int)register0x00000010 + -0x4c) = &DAT_005f6820;
        *(uint *)((int)register0x00000010 + -0x48) = uVar12;
        *(int *)((int)register0x00000010 + -0x44) = iVar2;
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f73a;
        thunk_FUN_004026b0();
        if ((*(uint *)((int)register0x00000010 + 8) & 2) == 0) {
          iVar2 = *(int *)((int)register0x00000010 + -0x30);
          uVar6 = *(undefined4 *)((int)register0x00000010 + -0x34);
        }
        else {
          uVar12 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x10);
          iVar2 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x14);
          *(uint *)((int)register0x00000010 + -0x4c) =
               uVar12 - *(uint *)((int)register0x00000010 + -0x34);
          *(uint *)((int)register0x00000010 + -0x48) =
               (iVar2 - *(int *)((int)register0x00000010 + -0x30)) -
               (uint)(uVar12 < *(uint *)((int)register0x00000010 + -0x34));
          *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f771;
          FUN_0041e870();
          iVar2 = 0;
          uVar6 = 0;
        }
        iVar9 = *(int *)((int)register0x00000010 + 4);
        uVar12 = *(uint *)(iVar9 + 0x10);
        iVar5 = *(int *)(iVar9 + 0x14);
        *(undefined4 *)(iVar9 + 0x10) = 0;
        *(undefined4 *)(iVar9 + 0x14) = 0;
        uVar7 = *(uint *)((int)register0x00000010 + -0x2c) - uVar12;
        iVar9 = (*(int *)((int)register0x00000010 + -0x28) - iVar5) -
                (uint)(*(uint *)((int)register0x00000010 + -0x2c) < uVar12);
        if (iVar9 < 0 || iVar9 == 0 && uVar7 == 0) {
          uVar12 = uVar7 + 100000;
          if (*(undefined4 **)((int)register0x00000010 + -8) == (undefined4 *)0x0) {
            cVar10 = '\0';
          }
          else {
            *(uint *)((int)register0x00000010 + -0x14) = uVar12;
            *(uint *)((int)register0x00000010 + -0x18) = uVar7;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar6;
            *(int *)((int)register0x00000010 + -0x20) = iVar2;
            *(int *)((int)register0x00000010 + -0x24) = iVar9;
            pcVar1 = (code *)**(undefined4 **)((int)register0x00000010 + -8);
            *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f7de;
            (*pcVar1)();
            cVar10 = *(char *)((int)register0x00000010 + -0x4c);
            uVar6 = *(undefined4 *)((int)register0x00000010 + -0x1c);
            uVar7 = *(uint *)((int)register0x00000010 + -0x18);
            iVar9 = *(int *)((int)register0x00000010 + -0x24);
            uVar12 = *(uint *)((int)register0x00000010 + -0x14);
            iVar2 = *(int *)((int)register0x00000010 + -0x20);
          }
          if (cVar10 != '\0') {
            piVar3 = *(int **)((int)register0x00000010 + 4);
            goto LAB_0041f82f;
          }
          iVar9 = iVar9 + (uint)(0xfffe795f < uVar7);
          uVar7 = uVar12;
        }
      }
      uVar11 = *(uint *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x34) = uVar6;
      piVar3 = *(int **)((int)register0x00000010 + 4);
      iVar5 = *(int *)((int)register0x00000010 + -0xc);
    } while( true );
  }
  *(uint **)((int)register0x00000010 + -0x4c) = &DAT_005d7650;
  *(undefined4 *)((int)register0x00000010 + -0x48) = 1;
  *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f979;
  FUN_00402690();
  if (DAT_005d7654 <= *(int *)((int)register0x00000010 + -0x44) - 1U) {
    iVar5 = *(int *)((int)register0x00000010 + -0xc);
    uVar7 = *(uint *)((int)register0x00000010 + -0x2c);
    iVar9 = *(int *)((int)register0x00000010 + -0x28);
    uVar11 = *(uint *)((int)register0x00000010 + 8);
    iVar2 = *(int *)((int)register0x00000010 + -0x10);
    goto LAB_0041f579;
  }
  *(undefined4 *)((int)register0x00000010 + -0x4c) = *(undefined4 *)((int)register0x00000010 + 4);
  *(uint *)((int)register0x00000010 + -0x48) = *(int *)((int)register0x00000010 + -0x44) - 1U;
  *(undefined1 *)((int)register0x00000010 + -0x44) =
       *(undefined1 *)((int)register0x00000010 + -0x35);
  *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f99f;
  FUN_0041d0f0();
  if (*(undefined4 **)((int)register0x00000010 + -8) == (undefined4 *)0x0) {
    cVar10 = '\0';
  }
  else {
    pcVar1 = (code *)**(undefined4 **)((int)register0x00000010 + -8);
    *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f9af;
    (*pcVar1)();
    cVar10 = *(char *)((int)register0x00000010 + -0x4c);
  }
  if (cVar10 != '\0') {
    piVar3 = *(int **)((int)register0x00000010 + 4);
    iVar2 = *(int *)((int)register0x00000010 + -0x10);
    uVar6 = *(undefined4 *)((int)register0x00000010 + -0x34);
LAB_0041f82f:
    *(undefined4 *)((int)register0x00000010 + -0x34) = uVar6;
    *(int *)((int)register0x00000010 + -0x30) = iVar2;
    iVar2 = piVar3[4];
    iVar9 = piVar3[5];
    if (iVar2 != 0 && iVar9 == 0 || 0 < iVar9) {
      *(undefined **)((int)register0x00000010 + -0x4c) = &DAT_005f6820;
      *(int *)((int)register0x00000010 + -0x48) = iVar2;
      *(int *)((int)register0x00000010 + -0x44) = iVar9;
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f871;
      thunk_FUN_004026b0();
      if ((*(uint *)((int)register0x00000010 + 8) & 2) != 0) {
        uVar12 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x10);
        iVar2 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x14);
        *(uint *)((int)register0x00000010 + -0x4c) =
             uVar12 - *(uint *)((int)register0x00000010 + -0x34);
        *(uint *)((int)register0x00000010 + -0x48) =
             (iVar2 - *(int *)((int)register0x00000010 + -0x30)) -
             (uint)(uVar12 < *(uint *)((int)register0x00000010 + -0x34));
        *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f89e;
        FUN_0041e870();
      }
      iVar2 = *(int *)((int)register0x00000010 + 4);
      *(undefined4 *)(iVar2 + 0x10) = 0;
      *(undefined4 *)(iVar2 + 0x14) = 0;
    }
    return;
  }
  goto LAB_0041f8c0;
LAB_0041f8b4:
  *(undefined4 *)((int)register0x00000010 + -0x50) = 0x41f8c0;
  FUN_0046edf0();
LAB_0041f8c0:
  uVar11 = *(uint *)((int)register0x00000010 + 8);
  iVar5 = *(int *)((int)register0x00000010 + -0xc);
  uVar7 = *(uint *)((int)register0x00000010 + -0x2c);
  iVar9 = *(int *)((int)register0x00000010 + -0x28);
  iVar2 = *(int *)((int)register0x00000010 + -0x10);
  goto LAB_0041f8dd;
}



/* Function: FUN_0041fa20 */

void FUN_0041fa20(void)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  int iVar5;
  undefined1 *puVar6;
  int iVar7;
  int in_FS_OFFSET;
  bool bVar8;
  
code_r0x0041fa20:
  puVar6 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
    puVar6 = (undefined1 *)((int)register0x00000010 + -0x20);
    if ((char)DAT_005f5fd0 != '\0') {
      piVar4 = *(int **)((int)register0x00000010 + 4);
      iVar2 = piVar4[4];
      iVar5 = piVar4[5];
      iVar7 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x50);
      *(int *)((int)register0x00000010 + -4) = iVar7;
      uVar3 = -iVar2;
      iVar5 = -(uint)(iVar2 != 0) - iVar5;
      iVar2 = *(int *)((int)register0x00000010 + 0xc);
      uVar1 = *(uint *)((int)register0x00000010 + 8);
      do {
        *(uint *)((int)register0x00000010 + -0xc) = uVar3;
        *(int *)((int)register0x00000010 + -8) = iVar5;
        if (*(char *)(iVar7 + 0x69) == '\0') {
          *(undefined **)((int)register0x00000010 + -0x20) = &DAT_005f61a4;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fab0;
          FUN_00402470();
          bVar8 = *(char *)((int)register0x00000010 + -0x1c) == '\0';
          piVar4 = *(int **)((int)register0x00000010 + 4);
          iVar5 = *(int *)((int)register0x00000010 + -8);
          iVar2 = *(int *)((int)register0x00000010 + 0xc);
          uVar3 = *(uint *)((int)register0x00000010 + -0xc);
          uVar1 = *(uint *)((int)register0x00000010 + 8);
        }
        else {
          bVar8 = false;
        }
        if ((!bVar8) ||
           (iVar7 = piVar4[5] + iVar5 + (uint)CARRY4(piVar4[4],uVar3),
           (uVar1 <= piVar4[4] + uVar3 || iVar2 != iVar7) && (iVar2 == iVar7 || iVar2 < iVar7)))
        goto LAB_0041fcac;
        if (DAT_005d75a4 == 0 && DAT_005d75a0 == 0) {
          *(int **)((int)register0x00000010 + -0x20) = piVar4;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fb35;
          FUN_00428a80();
          piVar4 = *(int **)((int)register0x00000010 + 4);
          iVar5 = *(int *)((int)register0x00000010 + -8);
          uVar3 = *(uint *)((int)register0x00000010 + -0xc);
        }
        iVar2 = *piVar4;
        if ((iVar2 == 0) || (iVar7 = *(int *)(iVar2 + 0xc), iVar7 == 0)) {
          iVar2 = 0;
        }
        else {
          *(uint *)(iVar2 + 0xc) = iVar7 - 1U;
          if (0x1fb < iVar7 - 1U) goto LAB_0041fcc2;
          iVar2 = *(int *)(iVar2 + 0xc + iVar7 * 4);
        }
        if (iVar2 == 0) {
          *(int **)((int)register0x00000010 + -0x20) = piVar4;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fb78;
          FUN_004288a0();
          iVar2 = *(int *)((int)register0x00000010 + -0x1c);
          if (iVar2 == 0) {
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fb85;
            FUN_00433e10();
            *(undefined4 *)((int)register0x00000010 + -0x20) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fb91;
            FUN_004288a0();
            iVar2 = *(int *)((int)register0x00000010 + -0x1c);
          }
          piVar4 = *(int **)((int)register0x00000010 + 4);
          iVar5 = *(int *)((int)register0x00000010 + -8);
          uVar3 = *(uint *)((int)register0x00000010 + -0xc);
        }
        if (iVar2 == 0) {
          if (DAT_005d7654 <= DAT_005d7650) {
LAB_0041fcac:
            uVar1 = piVar4[4];
            iVar2 = piVar4[5];
            *(uint *)((int)register0x00000010 + 0x10) = uVar1 + uVar3;
            *(uint *)((int)register0x00000010 + 0x14) = iVar5 + iVar2 + (uint)CARRY4(uVar1,uVar3);
            return;
          }
          *(uint **)((int)register0x00000010 + -0x20) = &DAT_005d7650;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fbd3;
          FUN_00402690();
          if (DAT_005d7654 <= *(int *)((int)register0x00000010 + -0x18) - 1U) {
            piVar4 = *(int **)((int)register0x00000010 + 4);
            iVar5 = *(int *)((int)register0x00000010 + -8);
            uVar3 = *(uint *)((int)register0x00000010 + -0xc);
            goto LAB_0041fcac;
          }
          *(undefined4 *)((int)register0x00000010 + -0x20) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(uint *)((int)register0x00000010 + -0x1c) =
               *(int *)((int)register0x00000010 + -0x18) - 1U;
          *(undefined1 *)((int)register0x00000010 + -0x18) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fbf9;
          FUN_0041d0f0();
          uVar3 = *(uint *)((int)register0x00000010 + -0xc) +
                  *(uint *)((int)register0x00000010 + -0x14);
          iVar5 = *(int *)((int)register0x00000010 + -8) + *(int *)((int)register0x00000010 + -0x10)
                  + (uint)CARRY4(*(uint *)((int)register0x00000010 + -0xc),
                                 *(uint *)((int)register0x00000010 + -0x14));
        }
        else {
          *(int *)((int)register0x00000010 + -0x20) = iVar2;
          *(int **)((int)register0x00000010 + -0x1c) = piVar4;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fc26;
          FUN_0041fe10();
          iVar2 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x14);
          uVar1 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x10);
          if ((uVar1 < 2000 || iVar2 != 0) && iVar2 < 1) {
            iVar5 = *(int *)((int)register0x00000010 + -8);
            uVar3 = *(uint *)((int)register0x00000010 + -0xc);
          }
          else {
            *(undefined **)((int)register0x00000010 + -0x20) = &DAT_005f6820;
            *(uint *)((int)register0x00000010 + -0x1c) = uVar1;
            *(int *)((int)register0x00000010 + -0x18) = iVar2;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fc77;
            thunk_FUN_004026b0();
            iVar2 = *(int *)((int)register0x00000010 + 4);
            uVar1 = *(uint *)(iVar2 + 0x10);
            iVar7 = *(int *)(iVar2 + 0x14);
            *(undefined4 *)(iVar2 + 0x10) = 0;
            *(undefined4 *)(iVar2 + 0x14) = 0;
            uVar3 = uVar1 + *(uint *)((int)register0x00000010 + -0xc);
            iVar5 = iVar7 + *(int *)((int)register0x00000010 + -8) +
                    (uint)CARRY4(uVar1,*(uint *)((int)register0x00000010 + -0xc));
          }
        }
        iVar2 = *(int *)((int)register0x00000010 + 0xc);
        iVar7 = *(int *)((int)register0x00000010 + -4);
        uVar1 = *(uint *)((int)register0x00000010 + 8);
        piVar4 = *(int **)((int)register0x00000010 + 4);
      } while( true );
    }
    goto LAB_0041fcce;
  }
  goto LAB_0041fce5;
LAB_0041fcc2:
  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fcce;
  FUN_0046edf0();
LAB_0041fcce:
  *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004c8077;
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x18;
  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x41fce4;
  FUN_00469a20();
LAB_0041fce5:
  *(undefined4 *)(puVar6 + -4) = 0x41fcea;
  FUN_0046afb0();
  register0x00000010 = (BADSPACEBASE *)puVar6;
  goto code_r0x0041fa20;
}



/* Function: FUN_0041fcf0 */

void FUN_0041fcf0(int param_1,uint param_2,int param_3,int param_4,uint *param_5)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int in_FS_OFFSET;
  uint uVar5;
  int in_stack_ffffffe4;
  int in_stack_ffffffe8;
  int iVar6;
  undefined4 in_stack_ffffffec;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar2 = 0;
  while (uVar2 < param_2) {
    uVar3 = (uint)*(byte *)(param_3 + (uVar2 >> 5));
    if (uVar3 == 0) {
      uVar2 = uVar2 + 0x20;
    }
    else {
      iVar4 = 0;
      for (; (iVar4 < 8 && (uVar2 < param_2)); uVar2 = uVar2 + 4) {
        iVar6 = in_stack_ffffffe8;
        if (((uVar3 & 1) != 0) && (uVar1 = *(uint *)(uVar2 + param_1), uVar1 != 0)) {
          uVar5 = uVar2;
          FUN_004688e0(uVar1,param_1,uVar2);
          if (in_stack_ffffffe4 == 0) {
            iVar6 = in_stack_ffffffe8;
            if (((param_5 != (uint *)0x0) && (*param_5 <= uVar1)) && (uVar1 < param_5[1])) {
              FUN_00426000(param_5,uVar1,uVar5 & 0xffffff00);
              iVar6 = in_stack_ffffffe8;
            }
          }
          else {
            iVar6 = param_4;
            FUN_00420350(in_stack_ffffffe4,param_1,uVar2,in_stack_ffffffe8,param_4,in_stack_ffffffec
                        );
            in_stack_ffffffe4 = in_stack_ffffffe8;
          }
        }
        iVar4 = iVar4 + 1;
        uVar3 = uVar3 >> 1;
        in_stack_ffffffe8 = iVar6;
      }
    }
  }
  return;
}



/* Function: FUN_0041fe10 */

void FUN_0041fe10(void)

{
  int iVar1;
  uint uVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  undefined1 *puVar8;
  int *piVar9;
  int iVar10;
  int iVar11;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x60);
      uVar4 = *(uint *)((int)register0x00000010 + 4);
      iVar5 = *(int *)(*(int *)(DAT_005ddf14 + (uVar4 >> 0x16) * 4) + (uVar4 >> 0xb & 0x7fc));
      uVar6 = *(uint *)(iVar5 + 0x44);
      if (uVar6 != 0) {
        if ((*(byte *)(iVar5 + 0x3e) & 1) == 0) {
          if (uVar6 < 0x20001) {
            *(uint *)((int)register0x00000010 + -0x1c) = uVar6;
            *(int *)((int)register0x00000010 + -0x60) = iVar5;
            *(uint *)((int)register0x00000010 + -0x5c) = uVar4;
            *(undefined4 *)((int)register0x00000010 + -100) = 0x41fe9b;
            FUN_00412000();
            uVar3 = *(undefined4 *)((int)register0x00000010 + -0x58);
            iVar5 = *(int *)((int)register0x00000010 + -0x54);
            uVar4 = *(uint *)((int)register0x00000010 + -0x50);
            uVar7 = *(undefined4 *)((int)register0x00000010 + -0x4c);
            uVar6 = *(uint *)((int)register0x00000010 + -0x1c);
            goto LAB_0041feaf;
          }
          if (*(uint *)(iVar5 + 0xc) != uVar4) {
LAB_0042001e:
            iVar11 = *(int *)(iVar5 + 0xc);
            uVar4 = (*(int *)(iVar5 + 0x44) + iVar11) - uVar4;
            if (0x20000 < uVar4) {
              uVar4 = 0x20000;
            }
            *(uint *)((int)register0x00000010 + -0x1c) = uVar4;
            *(int *)((int)register0x00000010 + -0x60) = iVar5;
            *(int *)((int)register0x00000010 + -0x5c) = iVar11;
            *(undefined4 *)((int)register0x00000010 + -100) = 0x420044;
            FUN_00412000();
            iVar5 = *(int *)((int)register0x00000010 + -0x54);
            *(undefined4 *)((int)register0x00000010 + -0x60) =
                 *(undefined4 *)((int)register0x00000010 + -0x58);
            *(int *)((int)register0x00000010 + -0x5c) = iVar5;
            *(undefined4 *)((int)register0x00000010 + -0x58) =
                 *(undefined4 *)((int)register0x00000010 + -0x50);
            *(undefined4 *)((int)register0x00000010 + -0x54) =
                 *(undefined4 *)((int)register0x00000010 + -0x4c);
            *(int *)((int)register0x00000010 + -0x50) =
                 *(int *)((int)register0x00000010 + 4) - iVar5;
            *(int *)((int)register0x00000010 + -0x4c) =
                 *(int *)((int)register0x00000010 + -0x1c) + *(int *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -100) = 0x42007e;
            FUN_004122e0();
            uVar3 = *(undefined4 *)((int)register0x00000010 + -0x48);
            iVar5 = *(int *)((int)register0x00000010 + -0x44);
            uVar4 = *(uint *)((int)register0x00000010 + -0x40);
            uVar7 = *(undefined4 *)((int)register0x00000010 + -0x3c);
            uVar6 = *(uint *)((int)register0x00000010 + -0x1c);
LAB_0041feaf:
            *(uint *)((int)register0x00000010 + -0x1c) = uVar6;
            iVar10 = *(int *)((int)register0x00000010 + 4);
            iVar11 = 0;
            do {
              *(int *)((int)register0x00000010 + -0x28) = iVar11;
              if (uVar4 == 0) {
                *(undefined4 *)((int)register0x00000010 + -0x14) = uVar3;
                *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
                uVar3 = *(undefined4 *)((int)register0x00000010 + -0x14);
              }
              else {
                *(int *)((int)register0x00000010 + -0x2c) = iVar5;
                iVar11 = 0;
                if (uVar4 != 0) {
                  for (; (uVar4 >> iVar11 & 1) == 0; iVar11 = iVar11 + 1) {
                  }
                }
                uVar4 = uVar4 ^ 1 << ((byte)iVar11 & 0x1f);
                iVar5 = *(int *)((int)register0x00000010 + -0x2c);
                uVar6 = *(uint *)((int)register0x00000010 + -0x1c);
                *(int *)((int)register0x00000010 + -0x18) = iVar5 + iVar11 * 4;
              }
              piVar9 = *(int **)((int)register0x00000010 + -0x18);
              if (piVar9 == (int *)0x0) {
                *(undefined4 *)((int)register0x00000010 + -0x60) = uVar3;
                *(int *)((int)register0x00000010 + -0x5c) = iVar5;
                *(uint *)((int)register0x00000010 + -0x58) = uVar4;
                *(undefined4 *)((int)register0x00000010 + -0x54) = uVar7;
                *(uint *)((int)register0x00000010 + -0x50) = iVar10 + uVar6;
                *(undefined4 *)((int)register0x00000010 + -100) = 0x41ff25;
                FUN_00412170();
                piVar9 = *(int **)((int)register0x00000010 + -0x3c);
                if (piVar9 == (int *)0x0) {
                  iVar5 = *(int *)((int)register0x00000010 + 8);
                  uVar4 = *(uint *)(iVar5 + 8);
                  uVar6 = *(uint *)((int)register0x00000010 + -0x1c);
                  *(uint *)(iVar5 + 8) = uVar4 + uVar6;
                  *(uint *)(iVar5 + 0xc) = *(int *)(iVar5 + 0xc) + (uint)CARRY4(uVar4,uVar6);
                  uVar4 = *(uint *)(iVar5 + 0x10);
                  uVar6 = *(uint *)((int)register0x00000010 + -0x28);
                  *(uint *)(iVar5 + 0x10) = uVar4 + uVar6;
                  *(uint *)(iVar5 + 0x14) = *(int *)(iVar5 + 0x14) + (uint)CARRY4(uVar4,uVar6);
                  return;
                }
                uVar3 = *(undefined4 *)((int)register0x00000010 + -0x4c);
                iVar5 = *(int *)((int)register0x00000010 + -0x48);
                uVar4 = *(uint *)((int)register0x00000010 + -0x44);
                uVar7 = *(undefined4 *)((int)register0x00000010 + -0x40);
                iVar10 = *(int *)((int)register0x00000010 + 4);
                uVar6 = *(uint *)((int)register0x00000010 + -0x1c);
              }
              *(undefined4 *)((int)register0x00000010 + -0x30) = uVar3;
              *(int **)((int)register0x00000010 + -0x18) = piVar9;
              iVar1 = *piVar9;
              iVar11 = *(int *)((int)register0x00000010 + -0x18) - iVar10;
              if ((iVar1 != 0) &&
                 (*(int *)((int)register0x00000010 + -0x20) = iVar1, uVar6 <= (uint)(iVar1 - iVar10)
                 )) {
                *(int *)((int)register0x00000010 + -8) = iVar11;
                *(undefined4 *)((int)register0x00000010 + -4) = uVar7;
                *(uint *)((int)register0x00000010 + -0x34) = uVar4;
                *(int *)((int)register0x00000010 + -0xc) = iVar5;
                *(undefined4 *)((int)register0x00000010 + -0x60) =
                     *(undefined4 *)((int)register0x00000010 + -0x20);
                *(int *)((int)register0x00000010 + -0x5c) = iVar10;
                *(int *)((int)register0x00000010 + -0x58) = iVar11;
                *(undefined4 *)((int)register0x00000010 + -100) = 0x41ff97;
                FUN_004688e0();
                if (*(int *)((int)register0x00000010 + -0x54) != 0) {
                  *(int *)((int)register0x00000010 + -0x60) =
                       *(int *)((int)register0x00000010 + -0x54);
                  *(undefined4 *)((int)register0x00000010 + -0x5c) =
                       *(undefined4 *)((int)register0x00000010 + 4);
                  *(undefined4 *)((int)register0x00000010 + -0x58) =
                       *(undefined4 *)((int)register0x00000010 + -8);
                  *(undefined4 *)((int)register0x00000010 + -0x54) =
                       *(undefined4 *)((int)register0x00000010 + -0x50);
                  *(undefined4 *)((int)register0x00000010 + -0x50) =
                       *(undefined4 *)((int)register0x00000010 + 8);
                  *(undefined4 *)((int)register0x00000010 + -0x4c) =
                       *(undefined4 *)((int)register0x00000010 + -0x4c);
                  *(undefined4 *)((int)register0x00000010 + -100) = 0x41ffcf;
                  FUN_00420350();
                }
                iVar11 = *(int *)((int)register0x00000010 + -8);
                iVar5 = *(int *)((int)register0x00000010 + -0xc);
                uVar4 = *(uint *)((int)register0x00000010 + -0x34);
                uVar7 = *(undefined4 *)((int)register0x00000010 + -4);
                uVar6 = *(uint *)((int)register0x00000010 + -0x1c);
                iVar10 = *(int *)((int)register0x00000010 + 4);
              }
              iVar11 = iVar11 + 4;
              uVar3 = *(undefined4 *)((int)register0x00000010 + -0x30);
            } while( true );
          }
          *(int *)((int)register0x00000010 + -0x38) = iVar5;
          piVar9 = *(int **)((int)register0x00000010 + 8);
          uVar6 = uVar4;
LAB_0042009d:
          uVar6 = uVar6 + 0x20000;
          if ((uint)(*(int *)(iVar5 + 0x44) + *(int *)(iVar5 + 0xc)) <= uVar6) goto LAB_0042001e;
          iVar11 = *piVar9;
          if (iVar11 == 0) {
LAB_004200c7:
            *(uint *)((int)register0x00000010 + -0x24) = uVar6;
            *(int **)((int)register0x00000010 + -0x60) = piVar9;
            *(uint *)((int)register0x00000010 + -0x5c) = uVar6;
            *(undefined4 *)((int)register0x00000010 + -100) = 0x4200d7;
            FUN_00428650();
            iVar5 = *(int *)((int)register0x00000010 + -0x38);
            uVar6 = *(uint *)((int)register0x00000010 + -0x24);
            piVar9 = *(int **)((int)register0x00000010 + 8);
            uVar4 = *(uint *)((int)register0x00000010 + 4);
            goto LAB_0042009d;
          }
          uVar2 = *(uint *)(iVar11 + 0xc);
          if (uVar2 == 0x1fc) goto LAB_004200c7;
          if (uVar2 < 0x1fc) {
            *(uint *)(iVar11 + 0x10 + uVar2 * 4) = uVar6;
            *(int *)(iVar11 + 0xc) = *(int *)(iVar11 + 0xc) + 1;
            goto LAB_0042009d;
          }
          *(undefined4 *)((int)register0x00000010 + -100) = 0x4200f3;
          FUN_0046edf0();
        }
        *(char **)((int)register0x00000010 + -0x60) =
             "scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x1d;
        *(undefined4 *)((int)register0x00000010 + -100) = 0x420109;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x60) =
           "scanobject n == 0swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x11;
      *(undefined4 *)((int)register0x00000010 + -100) = 0x42011f;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x420125;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_00420130 */

void FUN_00420130(void)

{
  byte bVar1;
  uint *puVar2;
  long lVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  undefined1 *puVar7;
  int in_FS_OFFSET;
  
code_r0x00420130:
  puVar7 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar7 = (undefined1 *)((int)register0x00000010 + -0x20);
    uVar6 = *(uint *)((int)register0x00000010 + 8);
    iVar5 = *(int *)((int)register0x00000010 + 0xc);
    uVar4 = 0;
    do {
      if (uVar6 <= uVar4) {
        return;
      }
      if (iVar5 == 0) {
LAB_00420199:
        *(uint *)((int)register0x00000010 + -4) = uVar4;
        uVar6 = *(uint *)(uVar4 + *(int *)((int)register0x00000010 + 4));
        puVar2 = *(uint **)((int)register0x00000010 + 0x14);
        if (((puVar2 == (uint *)0x0) || (uVar6 < *puVar2)) || (puVar2[1] <= uVar6)) {
          *(uint *)((int)register0x00000010 + -8) = uVar6;
          *(uint *)((int)register0x00000010 + -0x20) = uVar6;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4201e6;
          FUN_00429300();
          iVar5 = *(int *)((int)register0x00000010 + -0x1c);
          if (iVar5 == 0) {
            uVar6 = *(uint *)((int)register0x00000010 + 8);
            iVar5 = *(int *)((int)register0x00000010 + 0xc);
            uVar4 = *(uint *)((int)register0x00000010 + -4);
          }
          else {
            lVar3 = (ulong)(uint)(*(int *)((int)register0x00000010 + -8) - *(int *)(iVar5 + 0xc)) *
                    (ulong)*(uint *)(iVar5 + 0x38);
            uVar6 = (uint)((ulong)lVar3 >> 0x20);
            if ((uVar6 < *(ushort *)(iVar5 + 0x1c)) ||
               (((byte)(1 << ((byte)((ulong)lVar3 >> 0x20) & 7)) &
                *(byte *)(*(int *)(iVar5 + 0x28) + (uVar6 >> 3))) != 0)) {
              *(uint *)((int)register0x00000010 + -0x20) =
                   *(int *)(iVar5 + 0x44) * uVar6 + *(int *)(iVar5 + 0xc);
              *(undefined4 *)((int)register0x00000010 + -0x1c) =
                   *(undefined4 *)((int)register0x00000010 + 4);
              *(undefined4 *)((int)register0x00000010 + -0x18) =
                   *(undefined4 *)((int)register0x00000010 + -4);
              *(int *)((int)register0x00000010 + -0x14) = iVar5;
              *(undefined4 *)((int)register0x00000010 + -0x10) =
                   *(undefined4 *)((int)register0x00000010 + 0x10);
              *(uint *)((int)register0x00000010 + -0xc) = uVar6;
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x420278;
              FUN_00420350();
              uVar6 = *(uint *)((int)register0x00000010 + 8);
              iVar5 = *(int *)((int)register0x00000010 + 0xc);
              uVar4 = *(uint *)((int)register0x00000010 + -4);
            }
            else {
              uVar6 = *(uint *)((int)register0x00000010 + 8);
              iVar5 = *(int *)((int)register0x00000010 + 0xc);
              uVar4 = *(uint *)((int)register0x00000010 + -4);
            }
          }
        }
        else {
          *(uint **)((int)register0x00000010 + -0x20) = puVar2;
          *(uint *)((int)register0x00000010 + -0x1c) = uVar6;
          *(undefined1 *)((int)register0x00000010 + -0x18) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4201c9;
          FUN_00426000();
          uVar6 = *(uint *)((int)register0x00000010 + 8);
          iVar5 = *(int *)((int)register0x00000010 + 0xc);
          uVar4 = *(uint *)((int)register0x00000010 + -4);
        }
      }
      else {
        bVar1 = *(byte *)((uVar4 >> 5) + iVar5);
        if (bVar1 == 0) {
          if ((uVar4 & 0x1f) != 0) goto LAB_0042029e;
          uVar4 = uVar4 + 0x1c;
        }
        else if ((bVar1 >> ((byte)(uVar4 >> 2) & 7) & 1) != 0) goto LAB_00420199;
      }
      uVar4 = uVar4 + 4;
    } while( true );
  }
  goto LAB_004202b5;
LAB_0042029e:
  *(char **)((int)register0x00000010 + -0x20) =
       "misaligned maskruntime: min = runtime: inUse=runtime: max = requested skip=bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
  ;
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0xf;
  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4202b4;
  FUN_00469a20();
LAB_004202b5:
  *(undefined4 *)(puVar7 + -4) = 0x4202ba;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar7;
  goto code_r0x00420130;
}



/* Function: FUN_004202c0 */

void FUN_004202c0(undefined4 param_1)

{
  int in_FS_OFFSET;
  int in_stack_fffffff4;
  undefined4 in_stack_fffffff8;
  undefined4 in_stack_fffffffc;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    in_stack_fffffffc = 0x420345;
    FUN_0046d980();
  }
  FUN_004688e0(param_1,0,0);
  if (in_stack_fffffff4 != 0) {
    FUN_00420350(in_stack_fffffff4,0,0,in_stack_fffffff8,
                 *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58) + 0x96c,
                 in_stack_fffffffc);
  }
  return;
}



/* Function: FUN_00420350 */

void FUN_00420350(void)

{
  int iVar1;
  int iVar2;
  byte bVar3;
  undefined1 *puVar4;
  uint uVar5;
  uint uVar6;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x1c);
      if ((*(uint *)((int)register0x00000010 + 4) & 3) == 0) {
        iVar1 = *(int *)((int)register0x00000010 + 0x10);
        uVar6 = *(uint *)((int)register0x00000010 + 0x18) >> 3;
        iVar2 = *(int *)(iVar1 + 0x2c) + uVar6;
        bVar3 = (byte)(1 << ((byte)*(uint *)((int)register0x00000010 + 0x18) & 7));
        if (DAT_005f5da9 == '\0') {
          if (((DAT_005f6214 < 1) ||
              (*(uint *)((int)register0x00000010 + 0x18) < (uint)*(ushort *)(iVar1 + 0x1c))) ||
             ((bVar3 & *(byte *)(*(int *)(iVar1 + 0x28) + uVar6)) != 0)) {
            if ((bVar3 & *(byte *)(*(int *)(iVar1 + 0x2c) + uVar6)) != 0) {
              return;
            }
            *(int *)((int)register0x00000010 + -0x1c) = iVar2;
            *(byte *)((int)register0x00000010 + -0x18) = bVar3;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4203ed;
            FUN_004027f0();
            iVar2 = *(int *)((int)register0x00000010 + 0x10);
            uVar6 = *(uint *)(iVar2 + 0xc);
            uVar5 = uVar6 >> 0x10 & 0x3f;
            iVar1 = *(int *)(DAT_005ddf14 + (uVar6 >> 0x16) * 4);
            bVar3 = (byte)(1 << ((byte)(uVar6 >> 0xd) & 7));
            if ((bVar3 & *(byte *)(iVar1 + 0x840 + uVar5)) == 0) {
              *(uint *)((int)register0x00000010 + -0x1c) = iVar1 + 0x840 + uVar5;
              *(byte *)((int)register0x00000010 + -0x18) = bVar3;
              *(undefined4 *)((int)register0x00000010 + -0x20) = 0x420449;
              FUN_004027f0();
              iVar2 = *(int *)((int)register0x00000010 + 0x10);
            }
            if ((*(byte *)(iVar2 + 0x3e) & 1) != 0) {
              iVar1 = *(int *)((int)register0x00000010 + 0x14);
              uVar6 = *(uint *)(iVar1 + 8);
              uVar5 = *(uint *)(iVar2 + 0x44);
              *(uint *)(iVar1 + 8) = uVar6 + uVar5;
              *(uint *)(iVar1 + 0xc) = *(int *)(iVar1 + 0xc) + (uint)CARRY4(uVar6,uVar5);
              return;
            }
            goto LAB_004204ab;
          }
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x1c) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x18) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)((int)register0x00000010 + 0xc);
          *(int *)((int)register0x00000010 + -0x10) = iVar2;
          *(byte *)((int)register0x00000010 + -0xc) = bVar3;
          *(undefined4 *)((int)register0x00000010 + -8) =
               *(undefined4 *)((int)register0x00000010 + 0x18);
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4204a2;
          FUN_00414b40();
          if (*(char *)((int)register0x00000010 + -4) != '\0') {
            return;
          }
LAB_004204ab:
          iVar2 = **(int **)((int)register0x00000010 + 0x14);
          if (iVar2 == 0) {
LAB_004204ce:
            *(int **)((int)register0x00000010 + -0x1c) = *(int **)((int)register0x00000010 + 0x14);
            *(undefined4 *)((int)register0x00000010 + -0x18) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4204de;
            FUN_00428650();
            return;
          }
          uVar6 = *(uint *)(iVar2 + 0xc);
          if (uVar6 == 0x1fc) goto LAB_004204ce;
          if (uVar6 < 0x1fc) {
            *(undefined4 *)(iVar2 + 0x10 + uVar6 * 4) = *(undefined4 *)((int)register0x00000010 + 4)
            ;
            *(int *)(iVar2 + 0xc) = *(int *)(iVar2 + 0xc) + 1;
            return;
          }
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4204f0;
          FUN_0046edf0();
        }
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4204f5;
        FUN_0043a810();
        *(char **)((int)register0x00000010 + -0x1c) =
             "runtime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x1d;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42050b;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42051f;
        FUN_0043aef0();
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c3f73;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0xc;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x420535;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x420549;
        FUN_0043aef0();
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c2927;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42055f;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x420573;
        FUN_0043aef0();
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c2946;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 2;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x420589;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42058e;
        FUN_0043a870();
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c2b05;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 4;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4205b4;
        FUN_00420630();
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c2a1d;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 3;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0xffffffff;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4205da;
        FUN_00420630();
        *(undefined1 *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x96) = 2;
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c6202;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x13;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x420605;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x1c) =
           "greyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid ch..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x23;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42061b;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x420621;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_00420630 */

void FUN_00420630(undefined4 param_1,undefined4 param_2,uint param_3,uint param_4)

{
  undefined1 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  bool bVar5;
  int iVar6;
  uint uVar7;
  int in_FS_OFFSET;
  char cVar8;
  uint uVar9;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar6 = *(int *)(DAT_005ddf14 + (param_3 >> 0x16) * 4);
  if (iVar6 == 0) {
    iVar6 = 0;
  }
  else {
    iVar6 = *(int *)(iVar6 + (param_3 >> 0xb & 0x7fc));
  }
  FUN_0043a810();
  FUN_0043b060(param_1,param_2);
  FUN_0043b060(&DAT_004c292b,1);
  FUN_0043aef0(param_3,0);
  FUN_0043a870();
  if (iVar6 != 0) {
    uVar2 = *(undefined4 *)(iVar6 + 0x48);
    uVar1 = *(undefined1 *)(iVar6 + 0x3e);
    uVar3 = *(undefined4 *)(iVar6 + 0x44);
    uVar4 = *(undefined4 *)(iVar6 + 0xc);
    FUN_0043a810();
    FUN_0043b060(&DAT_004c366b,10);
    FUN_0043aef0(uVar4,0);
    FUN_0043b060(&DAT_004c3366,9);
    FUN_0043aef0(uVar2,0);
    FUN_0043b060(" s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                 ,0xd);
    FUN_0043ad50(uVar1,0);
    FUN_0043b060(&DAT_004c3f7f,0xc);
    FUN_0043ad50(uVar3,0);
    uVar9 = 9;
    FUN_0043b060(&DAT_004c336f);
    FUN_0043a870();
    FUN_00402470(iVar6 + 0x3f);
    if ((int)(uVar9 & 0xff) < DAT_005cf154) {
      uVar2 = *(undefined4 *)(PTR_PTR_005cf150 + (uVar9 & 0xff) * 8);
      cVar8 = (char)*(undefined4 *)((int)(PTR_PTR_005cf150 + (uVar9 & 0xff) * 8) + 4);
      FUN_0043a810();
      FUN_0043b060(uVar2);
      FUN_0043aa10();
      FUN_0043a870();
    }
    else {
      FUN_0043a810();
      FUN_0043b060(&DAT_004c313a,8);
      FUN_0043ad50(uVar9 & 0xff,0);
      cVar8 = '\x02';
      FUN_0043b060(&DAT_004c2946);
      FUN_0043a870();
    }
    uVar9 = *(uint *)(iVar6 + 0x44);
    FUN_00402470(iVar6 + 0x3f);
    if ((cVar8 == '\x02') && (uVar9 == 0)) {
      uVar9 = param_4 + 4;
    }
    bVar5 = false;
    for (uVar7 = 0; uVar7 < uVar9; uVar7 = uVar7 + 4) {
      if ((uVar7 < 0x200) || ((param_4 - 0x40 < uVar7 && (uVar7 < param_4 + 0x40)))) {
        if (bVar5) {
          FUN_0043a810();
          FUN_0043b060(&DAT_004c2c55,5);
          FUN_0043a870();
        }
        uVar2 = *(undefined4 *)(param_3 + uVar7);
        FUN_0043a810();
        FUN_0043b060(&DAT_004c2a29,3);
        FUN_0043b060(param_1,param_2);
        FUN_0043b060(&DAT_004c2927,1);
        FUN_0043ad50(uVar7,0);
        FUN_0043b060(&DAT_004c2b0d,4);
        FUN_0043aef0(uVar2,0);
        FUN_0043a870();
        if (param_4 == uVar7) {
          FUN_0043a810();
          FUN_0043b060(&DAT_004c2b11,4);
          FUN_0043a870();
        }
        FUN_0043a810();
        FUN_0043aa10();
        FUN_0043a870();
        bVar5 = false;
      }
      else {
        bVar5 = true;
      }
    }
    if (bVar5) {
      FUN_0043a810();
      FUN_0043b060(&DAT_004c2c55,5);
      FUN_0043a870();
    }
    return;
  }
  FUN_0043a810();
  FUN_0043b060(&DAT_004c2ef9,7);
  FUN_0043a870();
  return;
}



/* Function: FUN_00420a30 */

void FUN_00420a30(int param_1,int param_2)

{
  uint uVar1;
  int iVar2;
  code *pcVar3;
  long lVar4;
  uint uVar5;
  uint uVar6;
  int in_FS_OFFSET;
  
  if (DAT_005f5da9 == '\0') {
    if (DAT_005f5e04 != 2) {
      lVar4 = (ulong)(uint)(param_2 - *(int *)(param_1 + 0xc)) * (ulong)*(uint *)(param_1 + 0x38);
      FUN_004027f0((uint)((ulong)lVar4 >> 0x23) + *(int *)(param_1 + 0x2c),
                   1 << ((byte)((ulong)lVar4 >> 0x20) & 7) & 0xff);
      uVar1 = *(uint *)(param_1 + 0xc);
      uVar5 = uVar1 >> 0x10 & 0x3f;
      uVar6 = 1 << ((byte)(uVar1 >> 0xd) & 7);
      iVar2 = *(int *)(DAT_005ddf14 + (uVar1 >> 0x16) * 4);
      if (((byte)uVar6 & *(byte *)(iVar2 + 0x840 + uVar5)) == 0) {
        FUN_004027f0(iVar2 + 0x840 + uVar5,uVar6 & 0xff);
      }
      iVar2 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
      uVar1 = *(uint *)(param_1 + 0x44);
      uVar5 = *(uint *)(iVar2 + 0x974);
      *(uint *)(iVar2 + 0x974) = uVar5 + uVar1;
      *(uint *)(iVar2 + 0x978) = *(int *)(iVar2 + 0x978) + (uint)CARRY4(uVar5,uVar1);
      return;
    }
    FUN_00469a20("mallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GC..." /* TRUNCATED STRING LITERAL */
                 ,0x32);
  }
  FUN_00469a20(&DAT_004cc7e0,0x2c);
  pcVar3 = (code *)swi(3);
  (*pcVar3)();
  return;
}



/* Function: FUN_00420b50 */

void FUN_00420b50(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int in_FS_OFFSET;
  int in_stack_ffffffe4;
  undefined4 in_stack_ffffffe8;
  
  while (iVar4 = DAT_005d7024, iVar3 = DAT_005d7020,
        &stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  for (iVar5 = 0; iVar5 < iVar4; iVar5 = iVar5 + 1) {
    iVar1 = *(int *)(iVar3 + iVar5 * 4);
    iVar2 = *(int *)(iVar1 + 0x30);
    iVar6 = in_stack_ffffffe4;
    if ((iVar2 != 0) && (*(int *)(iVar2 + 0x10) != 0)) {
      FUN_004688e0(*(int *)(iVar2 + 0x10),0,0);
      iVar6 = iVar1 + 0x96c;
      FUN_00420350(*(undefined4 *)(iVar2 + 0x10),0,0,in_stack_ffffffe4,iVar6,in_stack_ffffffe8);
    }
    in_stack_ffffffe4 = iVar6;
  }
  return;
}



/* Function: FUN_00420c20 */

void FUN_00420c20(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  *(undefined4 *)(param_1 + 0x10) = 0x400000;
  *(undefined4 *)(param_1 + 0x14) = 0;
  *(undefined4 *)(param_1 + 0x58) = 0xffffffff;
  *(undefined4 *)(param_1 + 0x5c) = 0xffffffff;
  FUN_00423440(param_1,param_2);
  FUN_004235c0(param_1,param_3,param_4);
  FUN_00423190(param_1,1);
  return;
}



/* Function: FUN_00420ca0 */

void FUN_00420ca0(int param_1,undefined4 param_2,undefined4 param_3,uint param_4,int param_5)

{
  undefined8 uVar1;
  int iVar2;
  undefined8 uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  int in_FS_OFFSET;
  bool bVar13;
  double dVar14;
  double dVar15;
  undefined4 uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uStack_70;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  dVar15 = DAT_00550c48 * (double)(int)param_4;
  dVar14 = DAT_00550c58 + dVar15;
  thunk_FUN_004027c0(param_1 + 0xa0,0,0);
  thunk_FUN_004027c0(param_1 + 0xa8,0,0);
  thunk_FUN_004027c0(param_1 + 0xb0,0,0);
  thunk_FUN_004027c0(param_1 + 0xb8,0,0);
  thunk_FUN_004027c0(param_1 + 0xc0,0,0);
  thunk_FUN_004027c0(param_1 + 200,0,0);
  thunk_FUN_004027c0(param_1 + 0xd0,0,0);
  uVar16 = 0;
  uVar18 = 0;
  thunk_FUN_004027c0(param_1 + 0xd8);
  *(undefined4 *)(param_1 + 0xe0) = param_2;
  *(undefined4 *)(param_1 + 0xe4) = param_3;
  FUN_004027a0();
  *(undefined4 *)(param_1 + 0x58) = uVar16;
  *(uint *)(param_1 + 0x5c) = uVar18;
  FUN_004649a0(dVar14);
  uVar19 = uVar18;
  FUN_00464a40(uVar18,uStack_70);
  dVar14 = (double)CONCAT44(uStack_70,uVar19) / dVar15 - DAT_00550bd4;
  uVar6 = uStack_70;
  if ((dVar14 < DAT_00550cc8) || (DAT_00550c50 < dVar14)) {
    FUN_00464a40(uVar18,uStack_70);
    if (dVar15 < (double)CONCAT44(uStack_70,uVar19)) {
      bVar13 = uVar18 != 0;
      uVar18 = uVar18 - 1;
      uVar6 = (uStack_70 - 1) + (uint)bVar13;
    }
    FUN_00464a40(uVar18,uVar6);
    *(double *)(param_1 + 0x108) =
         (dVar15 - (double)CONCAT44(uStack_70,uVar19)) / (double)(int)param_4;
  }
  else {
    *(undefined8 *)(param_1 + 0x108) = 0;
  }
  if (0 < DAT_005f6220) {
    *(undefined8 *)(param_1 + 0x108) = 0;
    uVar6 = (int)param_4 >> 0x1f;
    uVar18 = param_4;
  }
  iVar5 = DAT_005d7024;
  iVar4 = DAT_005d7020;
  for (iVar12 = 0; iVar12 < iVar5; iVar12 = iVar12 + 1) {
    iVar2 = *(int *)(iVar4 + iVar12 * 4);
    *(undefined4 *)(iVar2 + 0x948) = 0;
    *(undefined4 *)(iVar2 + 0x94c) = 0;
    *(undefined4 *)(iVar2 + 0x950) = 0;
    *(undefined4 *)(iVar2 + 0x954) = 0;
  }
  if (param_5 == 1) {
    if ((int)uVar6 < 1 && (uVar6 != 0 || uVar18 == 0)) {
      FUN_00423960(param_1,1);
    }
    else {
      FUN_00423960(param_1,0);
    }
  }
  else {
    FUN_00423960(param_1,param_4 - uVar18);
  }
  uVar19 = uVar6;
  uVar17 = uVar18;
  thunk_FUN_004027c0(param_1 + 0xe8,uVar18,uVar6);
  FUN_00421270(param_1);
  if (0 < DAT_005f6218) {
    FUN_004229b0(param_1);
    uVar7 = uVar17 >> 0x14;
    uVar9 = uVar19 << 0xc;
    FUN_004027a0(param_1 + 0xf8);
    uVar3 = CONCAT44(uVar19,uVar17);
    FUN_004027a0(&DAT_005f67f0);
    uVar8 = DAT_005d76b0 << 0xc;
    uVar11 = DAT_005d76b0 >> 0x14;
    uVar10 = DAT_005d76ac >> 0x14;
    uVar1 = *(undefined8 *)(param_1 + 0x108);
    FUN_0043a810();
    FUN_0043b060(&DAT_004c6860,0x14);
    FUN_0043aab0(uVar3);
    FUN_0043b060(&DAT_004c2f00,7);
    FUN_0043ad50(uVar19 << 0xc | uVar17 >> 0x14,uVar19 >> 0x14);
    FUN_0043b060(&DAT_004c2f07,7);
    FUN_0043ad50(uVar8 | uVar10,uVar11);
    FUN_0043b060(&DAT_004c294c,2);
    FUN_0043ad50(uVar7 | uVar9);
    FUN_0043b060(" MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                 ,0xd);
    FUN_0043ae80(uVar18,uVar6);
    FUN_0043b060(&DAT_004c2927,1);
    FUN_0043aab0(uVar1);
    FUN_0043aa10();
    FUN_0043a870();
  }
  return;
}



/* Function: FUN_00421270 */

void FUN_00421270(int param_1)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int in_FS_OFFSET;
  undefined8 in_stack_ffffff20;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint in_stack_ffffff28;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uStack_d4;
  undefined4 local_84;
  undefined4 uStack_80;
  undefined4 local_7c;
  undefined4 uStack_78;
  int local_60;
  uint local_5c;
  uint local_58;
  uint local_54;
  double local_50;
  double local_48;
  int local_40;
  uint local_3c;
  double local_38;
  double local_30;
  uint local_28;
  uint local_24;
  uint local_20;
  int local_1c;
  int local_18;
  int local_14;
  int local_10;
  int local_c;
  int local_8;
  int local_4;
  
  while (&local_60 <= *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x42187b;
    FUN_0046d980();
  }
  uVar7 = (uint)((ulong)in_stack_ffffff20 >> 0x20);
  thunk_FUN_00402510();
  local_54 = uVar7;
  if ((int)uVar7 < 0) {
    local_54 = 100000;
  }
  local_4 = param_1 + 0x70;
  local_8 = param_1 + 0xa0;
  local_c = param_1 + 0xa8;
  local_10 = param_1 + 0xb0;
  local_14 = param_1 + 0x80;
  local_18 = param_1 + 0x90;
  local_1c = param_1 + 0x88;
  FUN_004027a0();
  uVar1 = in_stack_ffffff28;
  uVar8 = uVar7;
  FUN_004027a0();
  uVar2 = uVar1;
  uVar9 = uVar8;
  thunk_FUN_004027a0();
  uVar6 = uVar2;
  uVar10 = uVar9;
  thunk_FUN_004027a0();
  uVar16 = uVar6;
  uVar11 = uVar10;
  thunk_FUN_004027a0();
  uVar17 = uVar16;
  local_5c = uVar11;
  FUN_004229b0();
  local_58 = uVar17;
  uVar12 = local_5c;
  FUN_004027a0();
  uVar18 = uVar17;
  uVar13 = uVar12;
  FUN_004027a0();
  local_20 = *(uint *)(param_1 + 0x78);
  local_24 = *(uint *)(param_1 + 0x7c);
  uVar19 = uVar18;
  uVar14 = uVar13;
  FUN_004027a0();
  uVar20 = uVar19;
  uVar15 = uVar14;
  FUN_004027a0();
  uVar5 = uVar11 + uVar10 + uVar9;
  iVar4 = uVar2 + uVar6 + (uint)CARRY4(uVar10,uVar9) + uVar16 + (uint)CARRY4(uVar11,uVar10 + uVar9);
  uVar2 = local_20 + uVar12 + uVar13;
  local_28 = local_24 + uVar17 + (uint)CARRY4(local_20,uVar12) + uVar18 +
             (uint)CARRY4(local_20 + uVar12,uVar13);
  local_20 = uVar15 + uVar8 + uVar14;
  iVar3 = uVar19 + uVar1 + (uint)CARRY4(uVar8,uVar14) + uVar20 + (uint)CARRY4(uVar15,uVar8 + uVar14)
  ;
  uVar1 = local_5c;
  if (uVar2 < uVar5 && local_28 == iVar4 || (int)local_28 < iVar4) {
    local_30 = DAT_00550bd4 + (double)(int)local_54 / DAT_00550c98;
    FUN_00464a40(local_5c - *(uint *)(param_1 + 0x58),
                 (local_58 - *(int *)(param_1 + 0x5c)) -
                 (uint)(local_5c < *(uint *)(param_1 + 0x58)));
    local_38 = (double)CONCAT44(uStack_d4,uVar20);
    FUN_00464a40(uVar2,local_28);
    local_38 = local_38 / (double)CONCAT44(uStack_d4,uVar20);
    FUN_00464a40(local_20,iVar3);
    FUN_004649a0(local_38 * (double)CONCAT44(uStack_d4,uVar20));
    local_28 = uStack_d4;
    local_3c = *(uint *)(param_1 + 0x58);
    local_40 = *(int *)(param_1 + 0x5c);
    local_24 = uVar20;
    FUN_00464a40(local_5c,local_58);
    FUN_004649a0(local_30 * (double)CONCAT44(uStack_d4,uVar20));
    uVar6 = local_28 + local_40 + (uint)CARRY4(local_24,local_3c);
    uVar1 = uVar20;
    local_58 = uStack_d4;
    local_28 = iVar3;
    uVar2 = local_20;
    if ((local_24 + local_3c <= uVar20 || uStack_d4 != uVar6) && (int)uVar6 <= (int)uStack_d4) {
      uVar1 = local_24 + local_3c;
      local_58 = uVar6;
    }
  }
  if (uVar1 < uVar7 && local_58 == in_stack_ffffff28 || (int)local_58 < (int)in_stack_ffffff28) {
    FUN_00464a40(uVar1,local_58);
    uVar1 = uVar20;
    FUN_004649a0(DAT_00550c70 * (double)CONCAT44(uStack_d4,uVar20));
    local_58 = uStack_d4;
    local_28 = iVar3;
    uVar2 = local_20;
    uVar20 = uVar1;
  }
  uVar6 = uVar2 - uVar5;
  iVar3 = (local_28 - iVar4) - (uint)(uVar2 < uVar5);
  if (uVar6 < 1000 && iVar3 == 0 || iVar3 < 0) {
    iVar3 = 0;
    uVar6 = 1000;
  }
  iVar4 = uVar1 - uVar7;
  local_60 = (local_58 - in_stack_ffffff28) - (uint)(uVar1 < uVar7);
  if (local_60 == 0 && iVar4 == 0 || local_60 < 0) {
    local_60 = 0;
    iVar4 = 1;
  }
  FUN_00464a40(uVar6,iVar3);
  local_30 = (double)CONCAT44(uStack_d4,uVar20);
  FUN_00464a40(iVar4,local_60);
  local_50 = local_30 / (double)CONCAT44(uStack_d4,uVar20);
  FUN_00464a40(iVar4,local_60);
  local_30 = (double)CONCAT44(uStack_d4,uVar20);
  FUN_00464a40(uVar6,iVar3);
  local_48 = local_30 / (double)CONCAT44(uStack_d4,uVar20);
  local_7c = SUB84(local_50,0);
  uStack_78 = (undefined4)((ulong)local_50 >> 0x20);
  local_4 = param_1 + 0x100;
  FUN_004027c0(param_1 + 0xf8,local_7c,uStack_78);
  local_84 = SUB84(local_48,0);
  uStack_80 = (undefined4)((ulong)local_48 >> 0x20);
  FUN_004027c0(local_4,local_84,uStack_80);
  return;
}



/* Function: FUN_00421880 */

void FUN_00421880(int param_1,uint param_2,int param_3,uint param_4)

{
  undefined8 uVar1;
  double dVar2;
  char cVar3;
  int iVar4;
  bool bVar5;
  int in_FS_OFFSET;
  double dVar6;
  double dVar7;
  undefined8 in_stack_ffffff40;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint in_stack_ffffff48;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  int iVar16;
  int iVar17;
  int iVar18;
  int iVar19;
  int iVar20;
  undefined4 uStack_b4;
  uint local_40;
  int local_3c;
  undefined4 local_38;
  int local_34;
  double local_30;
  double local_28;
  uint local_20;
  uint local_1c;
  int local_18;
  int local_14;
  int local_10;
  int local_c;
  int local_8;
  int local_4;
  
  while (&local_40 <= *(uint **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x422020;
    FUN_0046d980();
  }
  uVar12 = (uint)((ulong)in_stack_ffffff40 >> 0x20);
  FUN_004229b0();
  DAT_005f67e0 = uVar12;
  DAT_005f67e4 = in_stack_ffffff48;
  local_40 = param_2 - *(uint *)(param_1 + 0xe0);
  local_3c = (param_3 - *(int *)(param_1 + 0xe4)) - (uint)(param_2 < *(uint *)(param_1 + 0xe0));
  bVar5 = local_40 != 0 && local_3c == 0 || 0 < local_3c;
  dVar6 = DAT_00550c48;
  uVar12 = DAT_005f67e4;
  uVar8 = DAT_005f67e0;
  if (bVar5) {
    local_1c = (uint)((ulong)local_40 * (ulong)param_4);
    local_20 = (int)((ulong)local_40 * (ulong)param_4 >> 0x20) + param_4 * local_3c +
               ((int)param_4 >> 0x1f) * local_40;
    thunk_FUN_004027a0(param_1 + 0xc0);
    FUN_00464a40(uVar8);
    local_28 = (double)CONCAT44(uStack_b4,uVar12);
    uVar8 = local_20;
    FUN_00464a40(local_1c);
    dVar6 = DAT_00550c48 + local_28 / (double)CONCAT44(uStack_b4,uVar12);
  }
  local_4 = param_1 + 0x68;
  FUN_004027a0();
  if (uVar12 < *(uint *)(param_1 + 0x5c) ||
      uVar12 == *(uint *)(param_1 + 0x5c) && uVar8 <= *(uint *)(param_1 + 0x58)) {
    return;
  }
  if (bVar5) {
    local_1c = (uint)((ulong)local_40 * (ulong)param_4);
    local_20 = (int)((ulong)local_40 * (ulong)param_4 >> 0x20) + local_3c * param_4 +
               local_40 * ((int)param_4 >> 0x1f);
    thunk_FUN_004027a0(param_1 + 0xd8);
    FUN_00464a40(uVar8,uVar12);
    local_28 = (double)CONCAT44(uStack_b4,uVar12);
    uVar8 = local_20;
    FUN_00464a40(local_1c,local_20);
    local_28 = local_28 / (double)CONCAT44(uStack_b4,uVar12);
  }
  else {
    local_28 = 0.0;
  }
  local_28 = local_28 + dVar6;
  local_30 = DAT_00550bd4 - dVar6;
  local_8 = param_1 + 0xa0;
  local_c = param_1 + 0xa8;
  local_10 = param_1 + 0xb0;
  thunk_FUN_004027a0(local_8);
  uVar13 = uVar12;
  uVar9 = uVar8;
  thunk_FUN_004027a0(local_c);
  uVar14 = uVar13;
  uVar10 = uVar9;
  thunk_FUN_004027a0(local_10);
  uVar15 = uVar14;
  uVar11 = uVar10;
  FUN_004027a0(local_4);
  FUN_00464b10(uVar11 - *(uint *)(param_1 + 0x58),
               (uVar15 - *(int *)(param_1 + 0x5c)) - (uint)(uVar11 < *(uint *)(param_1 + 0x58)));
  local_28 = local_28 * (double)CONCAT44(uStack_b4,uVar15);
  FUN_00464a40(uVar8 + uVar9 + uVar10,
               uVar12 + uVar13 + (uint)CARRY4(uVar8,uVar9) + uVar14 +
               (uint)CARRY4(uVar8 + uVar9,uVar10));
  dVar7 = local_28 / (local_30 * (double)CONCAT44(uStack_b4,uVar15));
  uVar1 = *(undefined8 *)(param_1 + 0x20);
  *(double *)(param_1 + 0x20) = dVar7;
  for (iVar4 = 0; iVar4 < 4; iVar4 = iVar4 + 1) {
    dVar2 = *(double *)(param_1 + 0x28 + iVar4 * 8);
    if (*(double *)(param_1 + 0x20) < dVar2) {
      *(double *)(param_1 + 0x20) = dVar2;
    }
  }
  iVar4 = 0x18;
  FUN_0046f640(param_1 + 0x28,param_1 + 0x30,0x18);
  *(double *)(param_1 + 0x40) = dVar7;
  if (0 < DAT_005f6218) {
    FUN_0043a810();
    FUN_0043a810();
    FUN_0043b060(&DAT_004c2f0e,7);
    FUN_0043ae80((int)(dVar6 * DAT_00550c98),(int)(dVar6 * DAT_00550c98) >> 0x1f);
    FUN_0043b060(&DAT_004c2f15,7);
    FUN_0043ae80(0x19,0);
    uVar15 = 0xb;
    FUN_0043b060(&DAT_004c3a75,0xb);
    FUN_0043a870();
    local_14 = param_1 + 0x80;
    local_18 = param_1 + 0x90;
    thunk_FUN_004027a0(local_8);
    iVar16 = iVar4;
    uVar12 = uVar15;
    thunk_FUN_004027a0(local_c);
    iVar17 = iVar16;
    uVar8 = uVar12;
    thunk_FUN_004027a0(local_10);
    iVar18 = iVar17;
    uVar13 = uVar8;
    FUN_004027a0(local_14);
    iVar19 = iVar18;
    uVar14 = uVar13;
    FUN_004027a0(local_18);
    local_1c = *(uint *)(param_1 + 0x78);
    local_20 = *(int *)(param_1 + 0x7c);
    iVar20 = iVar19;
    FUN_0043a810();
    FUN_0043ae80(uVar15,iVar4);
    FUN_0043b060(&DAT_004c2927,1);
    FUN_0043ae80(uVar12,iVar16);
    FUN_0043b060(&DAT_004c2927,1);
    FUN_0043ae80(uVar8,iVar17);
    FUN_0043b060(&DAT_004c3378,9);
    FUN_0043ad50(local_1c + uVar13 + uVar14,
                 local_20 + iVar18 + (uint)CARRY4(local_1c,uVar13) + iVar19 +
                 (uint)CARRY4(local_1c + uVar13,uVar14));
    iVar4 = 9;
    FUN_0043b060(&DAT_004c3381,9);
    FUN_0043a870();
    FUN_004027a0(local_4);
    local_1c = *(undefined4 *)(param_1 + 0x58);
    local_20 = *(undefined4 *)(param_1 + 0x5c);
    local_34 = *(int *)(param_1 + 0x60);
    local_38 = *(undefined4 *)(param_1 + 100);
    FUN_0043a810();
    FUN_0043b060(&DAT_004c2a2c,3);
    FUN_0043ad50(local_1c,local_20);
    FUN_0043b060(&DAT_004c2d6e,6);
    FUN_0043ad50(iVar4,iVar20);
    FUN_0043b060(&DAT_004c3f8b,0xc);
    FUN_0043ae80(iVar4 - local_34);
    FUN_0043b060(", cons/mark  maxTrigger= pages/byte\n s.sweepgen= allocCount ProcessPrng",0xc);
    FUN_0043aab0(uVar1);
    FUN_0043b060(&DAT_004c2926,1);
    FUN_0043a870();
    FUN_0043a810();
    FUN_0043aa10();
    FUN_0043a870();
    iVar4 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
    cVar3 = *(char *)(iVar4 + 0x8b);
    *(char *)(iVar4 + 0x8b) = cVar3 + -1;
    if (cVar3 == '\x01') {
      FUN_0040f0e0(&DAT_005f5e5c);
    }
  }
  return;
}



/* Function: FUN_00422030 */

void FUN_00422030(void)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  undefined1 *puVar6;
  uint uVar7;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x14);
      *(int *)((int)register0x00000010 + -0x14) = *(int *)((int)register0x00000010 + 4) + 0xe8;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42205a;
      thunk_FUN_004027a0();
      if (*(int *)((int)register0x00000010 + -0xc) < 0 ||
          *(int *)((int)register0x00000010 + -0xc) == 0 &&
          *(int *)((int)register0x00000010 + -0x10) == 0) {
        return;
      }
      if (DAT_005f5e88 < 2) {
        return;
      }
      if (((**(int **)(in_FS_OFFSET + DAT_005f5ed0) == 0) ||
          (iVar3 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18), iVar3 == 0)) ||
         (piVar1 = *(int **)(iVar3 + 0x58), piVar1 == (int *)0x0)) {
        return;
      }
      iVar4 = *piVar1;
      *(int *)((int)register0x00000010 + -4) = iVar4;
      iVar3 = 0;
      while( true ) {
        if (4 < iVar3) {
          return;
        }
        *(int *)((int)register0x00000010 + -8) = iVar3;
        iVar3 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
        uVar2 = *(uint *)(iVar3 + 0x45c);
        uVar7 = *(uint *)(iVar3 + 0x458) << 0x11 ^ *(uint *)(iVar3 + 0x458);
        uVar7 = uVar2 >> 0x10 ^ uVar7 >> 7 ^ uVar2 ^ uVar7;
        uVar5 = (uint)((ulong)(uVar2 + uVar7) * (ulong)(DAT_005f5e88 - 1) >> 0x20);
        *(uint *)(iVar3 + 0x458) = uVar2;
        *(uint *)(iVar3 + 0x45c) = uVar7;
        if (iVar4 <= (int)uVar5) {
          uVar5 = uVar5 + 1;
        }
        if (DAT_005d7024 <= uVar5) break;
        iVar3 = *(int *)(DAT_005d7020 + uVar5 * 4);
        if (*(int *)(iVar3 + 4) == 1) {
          *(int *)((int)register0x00000010 + -0x14) = iVar3;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x422142;
          FUN_00447de0();
          if (*(char *)((int)register0x00000010 + -0x10) != '\0') {
            return;
          }
          iVar4 = *(int *)((int)register0x00000010 + -4);
        }
        iVar3 = *(int *)((int)register0x00000010 + -8) + 1;
      }
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x422163;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar6 + -4) = 0x422169;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_00422170 */

void FUN_00422170(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  undefined4 uVar7;
  int iVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  int iVar11;
  undefined1 *puVar12;
  int in_FS_OFFSET;
  bool bVar13;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x44);
      if (DAT_005f5e08 != 0) break;
      *(char **)((int)register0x00000010 + -0x44) =
           "gcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingFor..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x36;
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x422553;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar12 + -4) = 0x422559;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
  iVar8 = *(int *)((int)register0x00000010 + 0xc);
  iVar11 = *(int *)((int)register0x00000010 + 0x10);
  if (iVar11 == 0 && iVar8 == 0) {
    *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4221b3;
    FUN_0046fa70();
    iVar8 = *(int *)((int)register0x00000010 + -0x44);
    iVar11 = *(int *)((int)register0x00000010 + -0x40);
  }
  *(int *)((int)register0x00000010 + -0x20) = iVar11;
  *(int *)((int)register0x00000010 + -0x24) = iVar8;
  *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f61d8;
  *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4221d2;
  thunk_FUN_004027a0();
  uVar1 = *(uint *)((int)register0x00000010 + -0x24);
  uVar2 = (uint)(uVar1 < *(uint *)((int)register0x00000010 + -0x40));
  uVar3 = *(int *)((int)register0x00000010 + -0x20) - *(int *)((int)register0x00000010 + -0x3c);
  if (10000000 < uVar1 - *(uint *)((int)register0x00000010 + -0x40) && uVar3 == uVar2 ||
      0 < (int)(uVar3 - uVar2)) {
    *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f61a0;
    *(uint *)((int)register0x00000010 + -0x40) = uVar1;
    *(int *)((int)register0x00000010 + -0x3c) = *(int *)((int)register0x00000010 + -0x20);
    *(undefined4 *)((int)register0x00000010 + -0x48) = 0x422219;
    FUN_0041c180();
  }
  *(undefined4 *)((int)register0x00000010 + -0x44) = *(undefined4 *)((int)register0x00000010 + 8);
  *(undefined4 *)((int)register0x00000010 + -0x48) = 0x422225;
  FUN_0041b100();
  if (*(char *)((int)register0x00000010 + -0x40) == '\0') {
    *(undefined4 *)((int)register0x00000010 + 0x14) = 0;
    *(undefined4 *)((int)register0x00000010 + 0x18) =
         *(undefined4 *)((int)register0x00000010 + -0x24);
    *(undefined4 *)((int)register0x00000010 + 0x1c) =
         *(undefined4 *)((int)register0x00000010 + -0x20);
    return;
  }
  *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0xe8;
  *(int *)((int)register0x00000010 + -0x44) = *(int *)((int)register0x00000010 + 4) + 0xe8;
  *(undefined4 *)((int)register0x00000010 + -0x48) = 0x422249;
  thunk_FUN_004027a0();
  if (((*(int *)((int)register0x00000010 + -0x40) == 0 &&
        *(int *)((int)register0x00000010 + -0x3c) == 0 ||
        *(int *)((int)register0x00000010 + -0x3c) < 0) &&
      (*(double *)(*(int *)((int)register0x00000010 + 4) + 0x108) == 0.0)) &&
     (!NAN(*(double *)(*(int *)((int)register0x00000010 + 4) + 0x108)))) {
    *(undefined4 *)((int)register0x00000010 + 0x14) = 0;
    *(undefined4 *)((int)register0x00000010 + 0x18) =
         *(undefined4 *)((int)register0x00000010 + -0x24);
    *(undefined4 *)((int)register0x00000010 + 0x1c) =
         *(undefined4 *)((int)register0x00000010 + -0x20);
    return;
  }
  *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f5f38;
  *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4222a7;
  FUN_0040e520();
  if (*(int *)((int)register0x00000010 + -0x40) == 0) {
    *(undefined4 *)((int)register0x00000010 + 0x14) = 0;
    *(undefined4 *)((int)register0x00000010 + 0x18) =
         *(undefined4 *)((int)register0x00000010 + -0x24);
    *(undefined4 *)((int)register0x00000010 + 0x1c) =
         *(undefined4 *)((int)register0x00000010 + -0x20);
    return;
  }
  *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + -0x40);
  do {
    *(undefined4 *)((int)register0x00000010 + -0x44) = *(undefined4 *)((int)register0x00000010 + -4)
    ;
    *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4222fa;
    thunk_FUN_004027a0();
    iVar8 = *(int *)((int)register0x00000010 + -0x40);
    iVar11 = *(int *)((int)register0x00000010 + -0x3c);
    bVar5 = iVar8 != 0;
    bVar6 = iVar11 != 0;
    bVar4 = iVar11 >= 0;
    bVar13 = (bVar5 || bVar6) && bVar4;
    if (!bVar5 && !bVar6 || !bVar4) goto LAB_0042234d;
    *(bool *)((int)register0x00000010 + -0x29) = iVar8 == 0 && iVar11 == 0 || iVar11 < 0;
    *(undefined4 *)((int)register0x00000010 + -0x44) = *(undefined4 *)((int)register0x00000010 + -4)
    ;
    *(int *)((int)register0x00000010 + -0x38) = iVar8 + -1;
    *(uint *)((int)register0x00000010 + -0x34) = iVar11 + -1 + (uint)(iVar8 != 0);
    *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42233d;
    thunk_FUN_00402640();
  } while (*(char *)((int)register0x00000010 + -0x30) == '\0');
  bVar13 = *(char *)((int)register0x00000010 + -0x29) == '\0';
LAB_0042234d:
  if (bVar13) {
    *(undefined4 *)(*(int *)((int)register0x00000010 + 8) + 0x960) = 1;
  }
  else {
    iVar8 = *(int *)((int)register0x00000010 + 4);
    if ((*(double *)(iVar8 + 0x108) == 0.0) && (!NAN(*(double *)(iVar8 + 0x108)))) {
      *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f5f38;
      *(undefined4 *)((int)register0x00000010 + -0x40) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x422465;
      FUN_0040e4a0();
      *(undefined4 *)((int)register0x00000010 + 0x14) = 0;
      *(undefined4 *)((int)register0x00000010 + 0x18) =
           *(undefined4 *)((int)register0x00000010 + -0x24);
      *(undefined4 *)((int)register0x00000010 + 0x1c) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      return;
    }
    iVar11 = *(uint *)((int)register0x00000010 + -0x24) - *(uint *)(iVar8 + 0xe0);
    iVar8 = (*(int *)((int)register0x00000010 + -0x20) - *(int *)(iVar8 + 0xe4)) -
            (uint)(*(uint *)((int)register0x00000010 + -0x24) < *(uint *)(iVar8 + 0xe0));
    if (iVar11 != 0 && iVar8 == 0 || 0 < iVar8) {
      *(int *)((int)register0x00000010 + -0x18) = iVar8;
      *(int *)((int)register0x00000010 + -0x1c) = iVar11;
      uVar7 = *(undefined4 *)(*(int *)((int)register0x00000010 + 8) + 0x954);
      *(undefined4 *)((int)register0x00000010 + -0x44) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 8) + 0x950);
      *(undefined4 *)((int)register0x00000010 + -0x40) = uVar7;
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4223c7;
      FUN_00464a40();
      *(undefined8 *)((int)register0x00000010 + -0x14) =
           *(undefined8 *)((int)register0x00000010 + -0x3c);
      *(undefined4 *)((int)register0x00000010 + -0x44) =
           *(undefined4 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x40) =
           *(undefined4 *)((int)register0x00000010 + -0x18);
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4223e7;
      FUN_00464a40();
      if (*(double *)(*(int *)((int)register0x00000010 + 4) + 0x108) <
          *(double *)((int)register0x00000010 + -0x14) /
          *(double *)((int)register0x00000010 + -0x3c)) {
        *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f5f38;
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x422433;
        FUN_0040e4a0();
        *(undefined4 *)((int)register0x00000010 + 0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x18) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + 0x1c) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        return;
      }
    }
    *(undefined4 *)(*(int *)((int)register0x00000010 + 8) + 0x960) = 2;
  }
  uVar7 = *(undefined4 *)(*(int *)((int)register0x00000010 + -8) + 0xc);
  *(undefined4 *)((int)register0x00000010 + -8) = uVar7;
  if (DAT_005d7d30 == '\0') {
    uVar9 = 0;
    uVar10 = 0;
  }
  else {
    *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4224b8;
    FUN_0045e520();
    uVar10 = *(undefined4 *)((int)register0x00000010 + -0x44);
    uVar9 = *(undefined4 *)((int)register0x00000010 + -0x40);
    uVar7 = *(undefined4 *)((int)register0x00000010 + -8);
  }
  *(undefined4 *)((int)register0x00000010 + -0x28) = uVar9;
  *(undefined4 *)((int)register0x00000010 + -0xc) = uVar10;
  *(undefined4 *)((int)register0x00000010 + -0x44) = uVar7;
  *(undefined4 *)((int)register0x00000010 + -0x40) = 4;
  *(undefined4 *)((int)register0x00000010 + -0x3c) = 1;
  *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4224e5;
  FUN_0043d640();
  if (*(int *)((int)register0x00000010 + -0x28) != 0) {
    *(undefined4 *)((int)register0x00000010 + -0x44) =
         *(undefined4 *)((int)register0x00000010 + -0xc);
    *(int *)((int)register0x00000010 + -0x40) = *(int *)((int)register0x00000010 + -0x28);
    *(undefined4 *)((int)register0x00000010 + -0x3c) = *(undefined4 *)((int)register0x00000010 + -8)
    ;
    *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42250d;
    FUN_0045f5f0();
    *(undefined4 *)((int)register0x00000010 + -0x44) =
         *(undefined4 *)((int)register0x00000010 + -0xc);
    *(undefined4 *)((int)register0x00000010 + -0x40) =
         *(undefined4 *)((int)register0x00000010 + -0x28);
    *(undefined4 *)((int)register0x00000010 + -0x48) = 0x422521;
    FUN_0045e630();
  }
  *(undefined4 *)((int)register0x00000010 + 0x14) = *(undefined4 *)((int)register0x00000010 + -8);
  *(undefined4 *)((int)register0x00000010 + 0x18) = *(undefined4 *)((int)register0x00000010 + -0x24)
  ;
  *(undefined4 *)((int)register0x00000010 + 0x1c) = *(undefined4 *)((int)register0x00000010 + -0x20)
  ;
  return;
}



/* Function: FUN_00422560 */

void FUN_00422560(int param_1,int param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  int in_FS_OFFSET;
  undefined4 uVar3;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  *(int *)(param_1 + 0x98) = param_2;
  *(undefined4 *)(param_1 + 0x9c) = param_3;
  iVar1 = param_1 + 0x80;
  iVar2 = param_2;
  uVar3 = param_3;
  FUN_004027c0(param_1 + 0x68);
  thunk_FUN_004027a0(param_1 + 0xa0);
  FUN_004027c0(param_1 + 0x70);
  thunk_FUN_004027a0(param_1 + 0xa0);
  *(int *)(param_1 + 0x78) = iVar2;
  *(undefined4 *)(param_1 + 0x7c) = uVar3;
  thunk_FUN_004027a0(param_1 + 0xa8);
  FUN_004027c0(iVar1);
  *(undefined4 *)(param_1 + 0x58) = 0xffffffff;
  *(undefined4 *)(param_1 + 0x5c) = 0xffffffff;
  if (DAT_005d7d30 == '\0') {
    iVar2 = 0;
    iVar1 = 0;
  }
  else {
    FUN_0045e520();
  }
  if (iVar2 != 0) {
    FUN_0045fc30(iVar1,iVar2,param_2,param_3,iVar2,iVar1);
    FUN_0045e630(iVar1,iVar2);
  }
  return;
}



/* Function: FUN_004226a0 */

void FUN_004226a0(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x18);
      iVar1 = *(int *)((int)register0x00000010 + 8);
      if (iVar1 == 1) {
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0xe8;
        *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + 4) + 200;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x422751;
        thunk_FUN_004026b0();
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x14) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42276e;
        thunk_FUN_004026b0();
        return;
      }
      if (iVar1 == 2) {
        *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + 4) + 0xd0;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x422722;
        thunk_FUN_004026b0();
        return;
      }
      if (iVar1 == 3) {
        *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + 4) + 0xd8;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4226f1;
        thunk_FUN_004026b0();
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4226fd;
        FUN_00423860();
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004cbee0;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x28;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x422788;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x42278e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_004227a0 */

void FUN_004227a0(undefined4 param_1,int param_2,int param_3,int param_4,int param_5)

{
  int in_FS_OFFSET;
  undefined4 in_stack_ffffffe4;
  int in_stack_ffffffe8;
  undefined4 in_stack_fffffff0;
  undefined4 local_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_3 != 0 || param_2 != 0) {
    if (DAT_005d7d30 == '\0') {
      in_stack_ffffffe8 = 0;
      in_stack_ffffffe4 = 0;
    }
    else {
      FUN_0045e520();
    }
    FUN_004026b0(&DAT_005f67e8,param_2,param_3);
    if (in_stack_ffffffe8 != 0) {
      FUN_0045fc30(in_stack_ffffffe4,in_stack_ffffffe8,in_stack_fffffff0,local_c);
      FUN_0045e630(in_stack_ffffffe4,in_stack_ffffffe8);
    }
  }
  if (DAT_005f5e08 == 0) {
    if (param_4 != 0 || param_5 != 0) {
      FUN_004026b0(&DAT_005f67f0,param_4,param_5);
    }
  }
  else {
    FUN_00421270(param_1);
  }
  return;
}



/* Function: FUN_004228b0 */

void FUN_004228b0(int param_1,int param_2,uint param_3,int param_4)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_2 != 0) {
    uVar1 = *(uint *)(param_2 + 0x11d0);
    uVar2 = uVar1 + param_3;
    *(uint *)(param_2 + 0x11d0) = uVar2;
    iVar3 = *(int *)(param_2 + 0x11d4) + param_4 + (uint)CARRY4(uVar1,param_3);
    *(int *)(param_2 + 0x11d4) = iVar3;
    if ((0x1fff < uVar2 && iVar3 == 0 || 0 < iVar3) ||
        (uVar2 < 0xffffe001 && iVar3 == -1 || iVar3 < -1)) {
      FUN_004026b0(param_1 + 0x88,uVar2,iVar3);
      *(undefined4 *)(param_2 + 0x11d0) = 0;
      *(undefined4 *)(param_2 + 0x11d4) = 0;
    }
    return;
  }
  FUN_004026b0(param_1 + 0x88,param_3,param_4);
  return;
}



/* Function: FUN_004229b0 */

/* WARNING: Removing unreachable block (ram,0x00422a67) */
/* WARNING: Removing unreachable block (ram,0x00422a21) */

void FUN_004229b0(int param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004027a0(param_1 + 0x48);
  FUN_00422b00(param_1);
  FUN_004027a0(param_1 + 0x50);
  return;
}



/* Function: FUN_00422b00 */

/* WARNING: Removing unreachable block (ram,0x00422c51) */
/* WARNING: Type propagation algorithm not settling */

void FUN_00422b00(int param_1)

{
  int in_FS_OFFSET;
  int local_44;
  int local_40;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004027a0(param_1 + 0x120);
  FUN_004027a0(param_1 + 0x128);
  FUN_004027a0(param_1 + 0x130);
  FUN_004027a0(param_1 + 0x138);
  thunk_FUN_004027a0(param_1 + 8);
  if (local_44 != 0 || local_40 != 0) {
    return;
  }
  return;
}



/* Function: FUN_00422dd0 */

void FUN_00422dd0(void)

{
  int iVar1;
  long lVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined1 *puVar8;
  uint uVar9;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x48);
      *(undefined4 *)((int)register0x00000010 + -0x48) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x422df3;
      FUN_004229b0();
      uVar4 = *(uint *)((int)register0x00000010 + -0x44);
      uVar5 = *(uint *)((int)register0x00000010 + -0x40);
      uVar7 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x98);
      uVar6 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x9c);
      if (uVar4 <= uVar7 && uVar6 == uVar5 || uVar5 <= uVar6 && uVar6 != uVar5) {
        *(uint *)((int)register0x00000010 + 8) = uVar4;
        *(uint *)((int)register0x00000010 + 0xc) = uVar5;
        *(uint *)((int)register0x00000010 + 0x10) = uVar4;
        *(uint *)((int)register0x00000010 + 0x14) = uVar5;
        return;
      }
      *(uint *)((int)register0x00000010 + -0x18) = uVar5;
      *(uint *)((int)register0x00000010 + -0x1c) = uVar4;
      uVar4 = *(uint *)((int)register0x00000010 + -0x3c);
      uVar5 = *(uint *)((int)register0x00000010 + -0x38);
      if (uVar4 < uVar7 && uVar6 == uVar5 || uVar5 <= uVar6 && uVar6 != uVar5) {
        uVar4 = uVar7;
        uVar5 = uVar6;
      }
      *(uint *)((int)register0x00000010 + -4) = uVar6;
      *(uint *)((int)register0x00000010 + -8) = uVar7;
      uVar9 = (*(int *)((int)register0x00000010 + -0x18) - uVar6) -
              (uint)(*(uint *)((int)register0x00000010 + -0x1c) < uVar7);
      *(uint *)((int)register0x00000010 + -0xc) = uVar9;
      uVar9 = uVar9 >> 6;
      *(uint *)((int)register0x00000010 + -0x10) = uVar9;
      uVar6 = *(uint *)((int)register0x00000010 + -0x1c) - uVar7 >> 6 |
              *(int *)((int)register0x00000010 + -0xc) << 0x1a;
      *(uint *)((int)register0x00000010 + -0x14) = uVar6;
      lVar2 = (ulong)uVar6 * 0x2d;
      uVar3 = (uint)lVar2;
      uVar6 = uVar3 + uVar7;
      uVar7 = (int)((ulong)lVar2 >> 0x20) + uVar9 * 0x2d + *(int *)((int)register0x00000010 + -4) +
              (uint)CARRY4(uVar3,uVar7);
      if (uVar7 <= uVar5 && (uVar6 <= uVar4 || uVar5 != uVar7)) {
        uVar6 = uVar4;
        uVar7 = uVar5;
      }
      *(uint *)((int)register0x00000010 + -0x28) = uVar7;
      *(uint *)((int)register0x00000010 + -0x2c) = uVar6;
      uVar4 = (uint)((ulong)*(uint *)((int)register0x00000010 + -0x14) * 0x3d);
      uVar5 = uVar4 + *(uint *)((int)register0x00000010 + -8);
      uVar7 = *(int *)((int)register0x00000010 + -4) +
              (int)((ulong)*(uint *)((int)register0x00000010 + -0x14) * 0x3d >> 0x20) +
              *(int *)((int)register0x00000010 + -0x10) * 0x3d +
              (uint)CARRY4(uVar4,*(uint *)((int)register0x00000010 + -8));
      iVar1 = *(int *)((int)register0x00000010 + -0x18);
      uVar4 = *(uint *)((int)register0x00000010 + -0x1c);
      if (0x400000 < uVar4 && iVar1 == 0 || iVar1 != 0) {
        uVar6 = iVar1 + -1 + (uint)(0x3fffff < uVar4);
        if (uVar5 < uVar4 - 0x400000 && uVar6 == uVar7 || uVar7 <= uVar6 && uVar6 != uVar7) {
          uVar5 = uVar4 - 0x400000;
          uVar7 = uVar6;
        }
      }
      uVar4 = *(uint *)((int)register0x00000010 + -0x28);
      uVar6 = *(uint *)((int)register0x00000010 + -0x2c);
      if ((*(uint *)((int)register0x00000010 + -0x2c) <= uVar5 || uVar7 != uVar4) && uVar4 <= uVar7)
      {
        uVar6 = uVar5;
        uVar4 = uVar7;
      }
      *(uint *)((int)register0x00000010 + -0x20) = uVar4;
      *(uint *)((int)register0x00000010 + -0x24) = uVar6;
      *(int *)((int)register0x00000010 + -0x48) = *(int *)((int)register0x00000010 + 4) + 0x18;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x422fa8;
      FUN_004027a0();
      uVar4 = *(uint *)((int)register0x00000010 + -0x44);
      uVar5 = *(uint *)((int)register0x00000010 + -0x40);
      uVar7 = *(uint *)((int)register0x00000010 + -0x18);
      uVar6 = *(uint *)((int)register0x00000010 + -0x1c);
      if ((uVar4 <= uVar6 || uVar5 != uVar7) && (uVar5 < uVar7 || uVar5 == uVar7)) {
        uVar3 = uVar6 - uVar4;
        uVar4 = (uVar7 - uVar5) - (uint)(uVar6 < uVar4);
      }
      else {
        uVar4 = *(uint *)((int)register0x00000010 + -0x28);
        uVar3 = *(uint *)((int)register0x00000010 + -0x2c);
      }
      uVar5 = *(uint *)((int)register0x00000010 + -0x28);
      if (uVar4 == uVar5 && uVar3 < *(uint *)((int)register0x00000010 + -0x2c) || uVar4 < uVar5) {
        uVar4 = uVar5;
        uVar3 = *(uint *)((int)register0x00000010 + -0x2c);
      }
      uVar5 = *(uint *)((int)register0x00000010 + -0x20);
      if (uVar4 == uVar5 && *(uint *)((int)register0x00000010 + -0x24) < uVar3 ||
          uVar5 <= uVar4 && uVar4 != uVar5) {
        uVar3 = *(uint *)((int)register0x00000010 + -0x24);
        uVar4 = uVar5;
      }
      uVar5 = *(uint *)((int)register0x00000010 + -0x18);
      if ((uVar3 <= *(uint *)((int)register0x00000010 + -0x1c) || uVar4 != uVar5) &&
          (uVar4 < uVar5 || uVar4 == uVar5)) {
        *(uint *)((int)register0x00000010 + 8) = uVar3;
        *(uint *)((int)register0x00000010 + 0xc) = uVar4;
        *(uint *)((int)register0x00000010 + 0x10) = *(uint *)((int)register0x00000010 + -0x1c);
        *(uint *)((int)register0x00000010 + 0x14) = uVar5;
        return;
      }
      *(uint *)((int)register0x00000010 + -0x30) = uVar4;
      *(uint *)((int)register0x00000010 + -0x34) = uVar3;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4230ab;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x48) = &DAT_004c3142;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 8;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4230c1;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x48) =
           *(undefined4 *)((int)register0x00000010 + -0x34);
      *(undefined4 *)((int)register0x00000010 + -0x44) =
           *(undefined4 *)((int)register0x00000010 + -0x30);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4230d5;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x48) = &DAT_004c3675;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 10;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4230eb;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x48) =
           *(undefined4 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x44) =
           *(undefined4 *)((int)register0x00000010 + -0x18);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4230ff;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x423104;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x423109;
      FUN_0043a870();
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x42310e;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x48) = &DAT_004c3a80;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0xb;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x423124;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x48) =
           *(undefined4 *)((int)register0x00000010 + -0x2c);
      *(undefined4 *)((int)register0x00000010 + -0x44) =
           *(undefined4 *)((int)register0x00000010 + -0x28);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x423138;
      FUN_0043ad50();
      *(char **)((int)register0x00000010 + -0x48) =
           " maxTrigger= pages/byte\n s.sweepgen= allocCount ProcessPrng";
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0xc;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x42314e;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x48) =
           *(undefined4 *)((int)register0x00000010 + -0x24);
      *(undefined4 *)((int)register0x00000010 + -0x44) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x423162;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x423167;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x42316c;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x48) = &DAT_004cc96f;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x2d;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x423182;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x423188;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_00423190 */

void FUN_00423190(int param_1,char param_2)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int in_FS_OFFSET;
  double dVar5;
  undefined8 in_stack_ffffffb8;
  uint uVar6;
  uint uVar7;
  int in_stack_ffffffc0;
  int iVar10;
  long lVar8;
  long lVar9;
  undefined4 uStack_3c;
  undefined4 uVar11;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_2 == '\0') {
    uVar6 = (uint)((ulong)in_stack_ffffffb8 >> 0x20);
    FUN_004027a0();
    uVar2 = uVar6 + 0x100000;
    in_stack_ffffffc0 = in_stack_ffffffc0 + (uint)(0xffefffff < uVar6);
    FUN_004027c0(param_1 + 0x50);
  }
  else {
    uVar2 = 0;
    in_stack_ffffffc0 = 0;
    FUN_004027c0(param_1 + 0x50);
  }
  thunk_FUN_00402510();
  if ((int)uVar2 < 0) {
    lVar9 = -1;
  }
  else {
    uVar4 = uVar2;
    FUN_004027a0();
    iVar10 = in_stack_ffffffc0;
    uVar7 = uVar4;
    FUN_004027a0();
    uVar6 = *(uint *)(param_1 + 0x98);
    uVar3 = uVar4 + uVar6 + uVar7;
    lVar9 = (ulong)uVar2 * (ulong)uVar3;
    uVar1 = (uint)lVar9;
    uVar2 = (int)((ulong)lVar9 >> 0x20) + ((int)uVar2 >> 0x1f) * uVar3 +
            (in_stack_ffffffc0 + *(int *)(param_1 + 0x9c) + (uint)CARRY4(uVar4,uVar6) + iVar10 +
            (uint)CARRY4(uVar4 + uVar6,uVar7)) * uVar2;
    uVar4 = uVar2 % 100;
    lVar9 = (ulong)uVar4 * 0x28f5c28 + CONCAT44(uVar2 / 100,uVar1 / 100) +
            CONCAT44(*(int *)(param_1 + 0x9c),(uVar1 % 100 + uVar4 * 0x60) / 100) + (ulong)uVar6;
  }
  uVar2 = (uint)((ulong)lVar9 >> 0x20);
  lVar8 = *(long *)(param_1 + 0x10);
  if (*(uint *)(param_1 + 0x14) <= uVar2 &&
      (uVar2 != *(uint *)(param_1 + 0x14) || *(uint *)(param_1 + 0x10) <= (uint)lVar9)) {
    lVar8 = lVar9;
  }
  FUN_004027c0(param_1 + 0x48,lVar8);
  FUN_004027a0(param_1 + 0x80);
  lVar9 = lVar8;
  FUN_004027a0(param_1 + 0x90);
  uVar11 = (undefined4)((ulong)lVar9 >> 0x20);
  dVar5 = DAT_00550c80 * DAT_00550c60 * *(double *)(param_1 + 0x20);
  FUN_00464b10(lVar9 + lVar8 + *(long *)(param_1 + 0x78));
  FUN_004649f0(dVar5 * (double)CONCAT44(uStack_3c,uVar11));
  FUN_004027c0(param_1 + 0x18,uVar11,uStack_3c);
  return;
}



/* Function: FUN_00423440 */

void FUN_00423440(int param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  int in_FS_OFFSET;
  undefined4 in_stack_fffffff4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  thunk_FUN_00402510(param_1);
  if ((int)param_2 < 0) {
    param_2 = 0xffffffff;
  }
  uVar2 = ((int)param_2 >> 0x1f) << 0x16 | param_2 >> 10;
  uVar1 = uVar2 % 100;
  *(ulong *)(param_1 + 0x10) =
       (ulong)uVar1 * 0x28f5c28 + CONCAT44(uVar2 / 100,(param_2 * 0x400000) / 100) +
       (ulong)((uVar1 * 0x60 + (param_2 * 0x400000) % 100) / 100);
  thunk_FUN_00402770(param_1,param_2,in_stack_fffffff4);
  return;
}



/* Function: FUN_00423520 */

void FUN_00423520(void)

{
  int in_FS_OFFSET;
  short *local_c;
  int local_8;
  char local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = -0x4c;
    FUN_0046d980();
  }
  FUN_0040b030(&DAT_004c2b15,4);
  if (((local_8 == 3) && (*local_c == 0x666f)) && ((char)local_c[1] == 'f')) {
    return;
  }
  FUN_00452580(local_c,local_8);
  if ((local_8 == (int)local_c >> 0x1f) && (local_4 != '\0')) {
    return;
  }
  return;
}



/* Function: FUN_004235c0 */

void FUN_004235c0(int param_1,undefined4 param_2,int param_3)

{
  int in_FS_OFFSET;
  undefined4 in_stack_ffffffec;
  undefined4 in_stack_fffffff0;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  thunk_FUN_004027a0(param_1 + 8);
  if (-1 < param_3) {
    thunk_FUN_004027c0(param_1 + 8,param_2,param_3,in_stack_ffffffec,in_stack_fffffff0);
  }
  return;
}



/* Function: FUN_00423650 */

void FUN_00423650(void)

{
  int iVar1;
  short *psVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x1c);
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c367f;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 10;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42367d;
      FUN_0040b030();
      iVar1 = *(int *)((int)register0x00000010 + -0x10);
      if ((iVar1 == 0) ||
         (((psVar2 = *(short **)((int)register0x00000010 + -0x14), iVar1 == 3 && (*psVar2 == 0x666f)
           ) && ((char)psVar2[1] == 'f')))) {
        *(undefined4 *)((int)register0x00000010 + 4) = 0xffffffff;
        *(undefined4 *)((int)register0x00000010 + 8) = 0x7fffffff;
        return;
      }
      *(short **)((int)register0x00000010 + -4) = psVar2;
      *(int *)((int)register0x00000010 + -8) = iVar1;
      *(short **)((int)register0x00000010 + -0x1c) = psVar2;
      *(int *)((int)register0x00000010 + -0x18) = iVar1;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4236c3;
      FUN_00452770();
      if (*(char *)((int)register0x00000010 + -0xc) != '\0') {
        *(undefined4 *)((int)register0x00000010 + 4) =
             *(undefined4 *)((int)register0x00000010 + -0x14);
        *(undefined4 *)((int)register0x00000010 + 8) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4236e5;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c3a8b;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0xb;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4236fb;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42370f;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x423714;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x423719;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x1c) =
           "malformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x3f;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42372f;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x423735;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00423740 */

void FUN_00423740(int param_1)

{
  code *pcVar1;
  int in_stack_ffffffdc;
  int local_20;
  char local_14;
  
  while( true ) {
    FUN_004027a0(param_1 + 0xf0);
    if (local_20 <= in_stack_ffffffdc) {
      return;
    }
    if (in_stack_ffffffdc < 0) break;
    FUN_00402640(param_1 + 0xf0);
    if (local_14 != '\0') {
      return;
    }
  }
  FUN_0043a810();
  FUN_0043b060(&DAT_004c2950,2);
  FUN_0043ae80(in_stack_ffffffdc,in_stack_ffffffdc >> 0x1f);
  FUN_0043b060(&DAT_004c2c5a,5);
  FUN_0043ae80(local_20,local_20 >> 0x1f);
  FUN_0043aa10();
  FUN_0043a870();
  FUN_00469a20(&DAT_004c8c18,0x1a);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



/* Function: FUN_00423830 */

void FUN_00423830(int param_1)

{
  FUN_004027a0(param_1 + 0xf0);
  return;
}



/* Function: FUN_00423860 */

void FUN_00423860(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x28);
      while( true ) {
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0xf0;
        *(int *)((int)register0x00000010 + -0x28) = *(int *)((int)register0x00000010 + 4) + 0xf0;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x42388e;
        FUN_004027a0();
        iVar1 = *(int *)((int)register0x00000010 + -0x24) + -1;
        if (iVar1 < 0) break;
        *(undefined4 *)((int)register0x00000010 + -0x28) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(int *)((int)register0x00000010 + -0x1c) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4238b1;
        FUN_00402640();
        if (*(char *)((int)register0x00000010 + -0x14) != '\0') {
          return;
        }
      }
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(int *)((int)register0x00000010 + -0x10) = *(int *)((int)register0x00000010 + -0x24);
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4238cb;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c2950;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4238e1;
      FUN_0043b060();
      *(int *)((int)register0x00000010 + -0x28) = *(int *)((int)register0x00000010 + -0x10);
      *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + -0xc) >> 0x1f;
      *(int *)((int)register0x00000010 + -0x24) = *(int *)((int)register0x00000010 + -0x10) >> 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4238ff;
      FUN_0043ae80();
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c2c5a;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 5;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x423915;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x24) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x423929;
      FUN_0043ae80();
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x42392e;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x423933;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004c8c18;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x1a;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x423949;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x42394f;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00423960 */

void FUN_00423960(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x24);
      while( true ) {
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0xf0;
        *(int *)((int)register0x00000010 + -0x24) = *(int *)((int)register0x00000010 + 4) + 0xf0;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42398e;
        FUN_004027a0();
        iVar1 = *(int *)((int)register0x00000010 + -0x20);
        if (iVar1 < 0) break;
        *(undefined4 *)((int)register0x00000010 + -0x24) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(int *)((int)register0x00000010 + -0x18) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x4239ae;
        FUN_00402640();
        if (*(char *)((int)register0x00000010 + -0x10) != '\0') {
          return;
        }
      }
      *(int *)((int)register0x00000010 + -0xc) = iVar1;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x4239c4;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c2950;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x4239da;
      FUN_0043b060();
      *(int *)((int)register0x00000010 + -0x24) = *(int *)((int)register0x00000010 + -0xc);
      *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + 8) >> 0x1f;
      *(int *)((int)register0x00000010 + -0x20) = *(int *)((int)register0x00000010 + -0xc) >> 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x4239f8;
      FUN_0043ae80();
      *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c2c5a;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 5;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x423a0e;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x24) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x423a22;
      FUN_0043ae80();
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x423a27;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x423a2c;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c8c18;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x1a;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x423a42;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x423a48;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00423b80 */

void FUN_00423b80(void)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004027a0(&DAT_005f6890);
  FUN_004027a0(&DAT_005f68a0);
  return;
}



/* Function: FUN_00423bf0 */

void FUN_00423bf0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 int param_5,int param_6)

{
  double dVar1;
  long lVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  int in_FS_OFFSET;
  double dVar9;
  uint uVar10;
  uint uVar11;
  uint in_stack_ffffffc0;
  uint uVar12;
  uint uStack_3c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00464a40(param_1,param_2);
  dVar9 = DAT_00550c68 * (double)CONCAT44(uStack_3c,in_stack_ffffffc0);
  FUN_004649f0(dVar9);
  uVar8 = (uint)((ulong)dVar9 >> 0x20);
  uVar12 = in_stack_ffffffc0;
  FUN_004027a0();
  if ((in_stack_ffffffc0 < uVar8 || uVar12 != uStack_3c) && uStack_3c <= uVar12) {
    uVar12 = uStack_3c;
    FUN_004027c0(&DAT_005f60a8,in_stack_ffffffc0);
  }
  else {
    uVar12 = 0xffffffff;
    FUN_004027c0(&DAT_005f60a8,0xffffffff);
  }
  if (param_6 != 0 || param_5 != 0) {
    FUN_00464b10(param_3,param_4);
    dVar9 = (double)CONCAT44(uStack_3c,uVar12);
    FUN_00464b10(param_5,param_6);
    dVar1 = (double)CONCAT44(uStack_3c,uVar12);
    FUN_00464b10(DAT_005f9528,DAT_005f952c);
    dVar9 = (dVar9 / dVar1) * (double)CONCAT44(uStack_3c,uVar12);
    FUN_004649f0();
    uVar8 = DAT_005f5de0;
    uVar3 = (uVar12 % 10 + (uStack_3c % 10) * 6) / 10;
    FUN_00423b80();
    uVar10 = SUB84(dVar9,0);
    uVar11 = (uint)((ulong)dVar9 >> 0x20);
    lVar2 = (ulong)(uStack_3c % 10) * 0x19999999 + CONCAT44(uStack_3c / 10,uVar12 / 10);
    uVar5 = (uint)lVar2;
    uVar4 = uVar3 + uVar5;
    uVar6 = uVar12 + uVar4;
    iVar7 = uVar6 + uVar8;
    uVar12 = -(uint)(uVar8 != 0) &
             (int)((ulong)lVar2 >> 0x20) + (uint)CARRY4(uVar3,uVar5) + uStack_3c +
             (uint)CARRY4(uVar12,uVar4) + (uint)CARRY4(uVar6,uVar8) + -1 + (uint)(iVar7 != 0);
    uVar8 = iVar7 - 1U & -uVar8;
    if (((uVar8 < uVar10 || uVar11 != uVar12) && uVar12 <= uVar11) &&
       (DAT_005f5de0 <= uVar10 - uVar8 || uVar11 - uVar12 != (uint)(uVar10 < uVar8))) {
      FUN_004027c0(&DAT_005f60a0,uVar8,uVar12);
    }
    else {
      FUN_004027c0(&DAT_005f60a0,0xffffffff,0xffffffff);
    }
    return;
  }
  FUN_004027c0(&DAT_005f60a0,0xffffffff,0xffffffff);
  return;
}



/* Function: FUN_00423eb0 */

void FUN_00423eb0(void)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  undefined1 *puVar5;
  int *in_EDI;
  undefined4 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -8);
      iVar1 = *(int *)((int)register0x00000010 + 4);
      if (*(int *)(iVar1 + 4) == 0) {
        iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
        if (DAT_005f5fd0 != 0) {
          *(undefined4 *)((int)register0x00000010 + -0xc) = 0x423ef0;
          FUN_0046ed80();
          *in_EDI = iVar2;
          in_EDI[1] = *(int *)(iVar1 + 4);
        }
        *(int *)(iVar1 + 4) = iVar2;
        *(undefined **)((int)register0x00000010 + -8) = &DAT_004be520;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x423f09;
        FUN_00411710();
        iVar1 = *(int *)((int)register0x00000010 + -4);
        if (DAT_005f5fd0 == 0) {
          iVar2 = *(int *)((int)register0x00000010 + 4);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0xc) = 0x423f22;
          FUN_0046ed80();
          *in_EDI = iVar1;
          iVar2 = *(int *)((int)register0x00000010 + 4);
          in_EDI[1] = *(int *)(iVar2 + 8);
        }
        *(int *)(iVar2 + 8) = iVar1;
        if (DAT_005f5fd0 != 0) {
          iVar4 = *(int *)(iVar1 + 0x1c);
          *(undefined4 *)((int)register0x00000010 + -0xc) = 0x423f46;
          FUN_0046ed90();
          *in_EDI = iVar4;
          in_EDI[1] = iVar2;
          in_EDI[2] = *(int *)(iVar1 + 0x24);
        }
        *(undefined ***)(iVar1 + 0x1c) = &PTR_LAB_00536a80;
        *(undefined **)(iVar1 + 0x20) = &DAT_004bcac0;
        *(int *)(iVar1 + 0x24) = iVar2;
        puVar6 = (undefined4 *)(iVar2 + 0x24);
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x423f74;
        FUN_0046f3de();
        *(undefined8 *)(iVar2 + 0x1c) = DAT_00550c38;
        if (*(int *)(iVar2 + 100) == 0) {
          if (DAT_005f5fd0 != 0) {
            uVar3 = *(undefined4 *)(iVar2 + 100);
            *(undefined4 *)((int)register0x00000010 + -0xc) = 0x423f9a;
            FUN_0046ed70();
            *puVar6 = uVar3;
          }
          *(undefined ***)(iVar2 + 100) = &PTR_LAB_00536a84;
        }
        if (*(int *)(iVar2 + 0x68) == 0) {
          if (DAT_005f5fd0 != 0) {
            uVar3 = *(undefined4 *)(iVar2 + 0x68);
            *(undefined4 *)((int)register0x00000010 + -0xc) = 0x423fbe;
            FUN_0046ed70();
            *puVar6 = uVar3;
          }
          *(undefined ***)(iVar2 + 0x68) = &PTR_LAB_00536a88;
        }
        if (*(int *)(iVar2 + 0x6c) == 0) {
          if (DAT_005f5fd0 != 0) {
            uVar3 = *(undefined4 *)(iVar2 + 0x6c);
            *(undefined4 *)((int)register0x00000010 + -0xc) = 0x423fe2;
            FUN_0046ed70();
            *puVar6 = uVar3;
          }
          *(undefined ***)(iVar2 + 0x6c) = &PTR_LAB_00536a8c;
        }
        return;
      }
      *(char **)((int)register0x00000010 + -8) =
           "scavenger state is already wiredsweep increased allocation countremovespecial on invalid pointergetWeakHandle on invalid pointerruntime: root level max pages = NtAssociateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x20;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x424007;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x42400d;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00424020 */

void FUN_00424020(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x424042;
      FUN_0040ecf0();
      iVar1 = *(int *)((int)register0x00000010 + 4);
      if (*(int *)(iVar1 + 4) == **(int **)(in_FS_OFFSET + DAT_005f5ed0)) {
        *(undefined1 *)(iVar1 + 0x10) = 1;
        *(undefined ***)((int)register0x00000010 + -0x10) = &PTR_LAB_00536c38;
        *(int *)((int)register0x00000010 + -0xc) = iVar1;
        *(undefined2 *)((int)register0x00000010 + -8) = 0xa0d;
        *(undefined4 *)((int)register0x00000010 + -4) = 2;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x42407c;
        FUN_00469a60();
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x10) = &DAT_004ccb34;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x2e;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x424096;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x42409c;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_004240a0 */

void FUN_004240a0(int param_1)

{
  int in_FS_OFFSET;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x424124;
    FUN_0046d980();
  }
  FUN_0040ecf0(param_1);
  if (*(char *)(param_1 + 0x10) != '\0') {
    FUN_00402770(param_1 + 0xc,0);
    *(undefined1 *)(param_1 + 0x10) = 0;
    local_4 = *(int *)(param_1 + 4);
    *(undefined4 *)(local_4 + 0x5c) = 0;
    FUN_00442aa0(&local_4);
  }
  FUN_0040f0e0(param_1);
  return;
}



/* Function: FUN_00424130 */

void FUN_00424130(void)

{
  char cVar1;
  code *pcVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  undefined1 *puVar8;
  uint uVar9;
  int in_FS_OFFSET;
  double dVar10;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x60);
      *(undefined4 *)((int)register0x00000010 + -0x60) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -100) = 0x424156;
      FUN_0040ecf0();
      if (*(int *)(*(int *)((int)register0x00000010 + 4) + 4) ==
          **(int **)(in_FS_OFFSET + DAT_005f5ed0)) {
        dVar10 = *(double *)((int)register0x00000010 + 8);
        if (*(double *)((int)register0x00000010 + 8) < DAT_00550cb0) {
          dVar10 = DAT_00550cb0;
        }
        *(double *)((int)register0x00000010 + -8) = dVar10;
        *(double *)((int)register0x00000010 + -0x60) =
             dVar10 / *(double *)(*(int *)((int)register0x00000010 + 4) + 0x1c);
        *(undefined4 *)((int)register0x00000010 + -100) = 0x4241a3;
        FUN_004649a0();
        iVar5 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x60);
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + -0x58);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -0x54);
        if (iVar5 == 0) {
          *(undefined4 *)((int)register0x00000010 + -100) = 0x4241f5;
          FUN_0046fa70();
          uVar3 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 8);
          uVar4 = *(uint *)((int)register0x00000010 + -0x60);
          *(uint *)((int)register0x00000010 + -0x34) = uVar4;
          iVar5 = *(int *)((int)register0x00000010 + -0x5c);
          *(int *)((int)register0x00000010 + -0x2c) = iVar5;
          *(undefined4 *)((int)register0x00000010 + -0x60) = uVar3;
          *(uint *)((int)register0x00000010 + -0x5c) =
               *(uint *)((int)register0x00000010 + -0x1c) + uVar4;
          *(uint *)((int)register0x00000010 + -0x58) =
               *(int *)((int)register0x00000010 + -0x18) + iVar5 +
               (uint)CARRY4(*(uint *)((int)register0x00000010 + -0x1c),uVar4);
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x50) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x4c) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
          *(undefined4 *)((int)register0x00000010 + -100) = 0x424257;
          FUN_00455aa0();
          iVar5 = *(int *)((int)register0x00000010 + 4);
          *(undefined1 *)(iVar5 + 0x10) = 1;
          *(undefined ***)((int)register0x00000010 + -0x60) = &PTR_LAB_00536c38;
          *(int *)((int)register0x00000010 + -0x5c) = iVar5;
          *(undefined2 *)((int)register0x00000010 + -0x58) = 0xe13;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 2;
          *(undefined4 *)((int)register0x00000010 + -100) = 0x424281;
          FUN_00469a60();
          *(undefined4 *)((int)register0x00000010 + -100) = 0x424286;
          FUN_0046fa70();
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + -0x60);
          *(undefined4 *)((int)register0x00000010 + -0x30) =
               *(undefined4 *)((int)register0x00000010 + -0x5c);
          *(undefined4 *)((int)register0x00000010 + -0x60) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -100) = 0x4242a3;
          FUN_0040ecf0();
          *(undefined4 *)((int)register0x00000010 + -0x60) =
               *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 8);
          *(undefined4 *)((int)register0x00000010 + -100) = 0x4242b2;
          FUN_00455760();
          *(undefined4 *)((int)register0x00000010 + -0x60) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -100) = 0x4242c0;
          FUN_0040f0e0();
          iVar5 = *(uint *)((int)register0x00000010 + -0x38) -
                  *(uint *)((int)register0x00000010 + -0x34);
          iVar7 = (*(int *)((int)register0x00000010 + -0x30) -
                  *(int *)((int)register0x00000010 + -0x2c)) -
                  (uint)(*(uint *)((int)register0x00000010 + -0x38) <
                        *(uint *)((int)register0x00000010 + -0x34));
        }
        else {
          *(int *)((int)register0x00000010 + -0x60) = *(int *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -100) = 0x4241c8;
          FUN_0040f0e0();
          pcVar2 = (code *)**(undefined4 **)(*(int *)((int)register0x00000010 + 4) + 0x60);
          *(undefined4 *)((int)register0x00000010 + -0x60) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x5c) =
               *(undefined4 *)((int)register0x00000010 + -0x18);
          *(undefined4 *)((int)register0x00000010 + -100) = 0x4241e2;
          (*pcVar2)();
          iVar5 = *(int *)((int)register0x00000010 + -0x58);
          iVar7 = *(int *)((int)register0x00000010 + -0x54);
        }
        *(int *)((int)register0x00000010 + -0x20) = iVar7;
        *(int *)((int)register0x00000010 + -0x24) = iVar5;
        iVar5 = *(int *)((int)register0x00000010 + 4);
        if (0 < *(int *)(iVar5 + 0x5c) || *(int *)(iVar5 + 0x5c) == 0 && *(int *)(iVar5 + 0x58) != 0
           ) {
          *(undefined8 *)((int)register0x00000010 + -0x60) =
               *(undefined8 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -100) = 0x424319;
          FUN_004649a0();
          iVar5 = *(int *)((int)register0x00000010 + 4);
          uVar4 = *(uint *)(iVar5 + 0x58);
          iVar7 = *(int *)(iVar5 + 0x5c);
          uVar9 = *(uint *)((int)register0x00000010 + -0x24) +
                  *(uint *)((int)register0x00000010 + -0x58);
          iVar6 = *(int *)((int)register0x00000010 + -0x20) +
                  *(int *)((int)register0x00000010 + -0x54) +
                  (uint)CARRY4(*(uint *)((int)register0x00000010 + -0x24),
                               *(uint *)((int)register0x00000010 + -0x58));
          *(int *)((int)register0x00000010 + -0x28) = iVar6;
          if (iVar7 < iVar6 || uVar4 < uVar9 && iVar7 == iVar6) {
            *(undefined4 *)(iVar5 + 0x58) = 0;
            *(undefined4 *)(iVar5 + 0x5c) = 0;
          }
          else {
            *(uint *)(iVar5 + 0x58) = uVar4 - uVar9;
            *(uint *)(iVar5 + 0x5c) =
                 (iVar7 - *(int *)((int)register0x00000010 + -0x28)) - (uint)(uVar4 < uVar9);
          }
          return;
        }
        pcVar2 = (code *)**(undefined4 **)(iVar5 + 0x6c);
        *(undefined4 *)((int)register0x00000010 + -100) = 0x42437d;
        (*pcVar2)();
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + -0x60);
        *(undefined4 *)((int)register0x00000010 + -0x60) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x5c) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(undefined4 *)((int)register0x00000010 + -100) = 0x424398;
        FUN_00464a40();
        *(undefined8 *)((int)register0x00000010 + -0x14) =
             *(undefined8 *)((int)register0x00000010 + -0x58);
        *(undefined4 *)((int)register0x00000010 + -0x60) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x5c) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(undefined4 *)((int)register0x00000010 + -100) = 0x4243b8;
        FUN_00464a40();
        dVar10 = *(double *)((int)register0x00000010 + -8);
        *(int *)((int)register0x00000010 + -0x60) = *(int *)((int)register0x00000010 + 4) + 0x24;
        *(double *)((int)register0x00000010 + -0x5c) =
             dVar10 / ((*(double *)((int)register0x00000010 + -0x14) + dVar10) *
                      (double)*(int *)((int)register0x00000010 + -0xc));
        *(undefined8 *)((int)register0x00000010 + -0x54) = DAT_00550c40;
        *(double *)((int)register0x00000010 + -0x4c) =
             *(double *)((int)register0x00000010 + -0x58) + dVar10;
        *(undefined4 *)((int)register0x00000010 + -100) = 0x42440f;
        FUN_00425ea0();
        cVar1 = *(char *)((int)register0x00000010 + -0x3c);
        iVar5 = *(int *)((int)register0x00000010 + 4);
        *(undefined8 *)(iVar5 + 0x1c) = *(undefined8 *)((int)register0x00000010 + -0x44);
        if (cVar1 == '\0') {
          *(undefined8 *)(iVar5 + 0x1c) = DAT_00550c38;
          *(undefined4 *)(iVar5 + 0x58) = 0x2a05f200;
          *(undefined4 *)(iVar5 + 0x5c) = 1;
          *(int *)((int)register0x00000010 + -0x60) = iVar5;
          *(undefined4 *)((int)register0x00000010 + -100) = 0x42444a;
          FUN_00424470();
        }
        return;
      }
      *(char **)((int)register0x00000010 + -0x60) =
           "tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: Nt..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x5c) = 0x2f;
      *(undefined4 *)((int)register0x00000010 + -100) = 0x424464;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x42446a;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_00424470 */

void FUN_00424470(int param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040ecf0(param_1);
  *(undefined1 *)(param_1 + 0x11) = 1;
  FUN_0040f0e0(param_1);
  return;
}



/* Function: FUN_004244b0 */

void FUN_004244b0(void)

{
  code *pcVar1;
  uint uVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  double dVar4;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4244d6;
      FUN_0040ecf0();
      if (*(int *)(*(int *)((int)register0x00000010 + 4) + 4) ==
          **(int **)(in_FS_OFFSET + DAT_005f5ed0)) {
        *(int *)((int)register0x00000010 + -0x20) = *(int *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4244f7;
        FUN_0040f0e0();
        dVar4 = 0.0;
        uVar2 = 0;
        while (dVar4 < DAT_00550cb0) {
          *(double *)((int)register0x00000010 + -8) = dVar4;
          *(uint *)((int)register0x00000010 + -0xc) = uVar2;
          pcVar1 = (code *)**(undefined4 **)(*(int *)((int)register0x00000010 + 4) + 0x68);
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x424527;
          (*pcVar1)();
          if (*(char *)((int)register0x00000010 + -0x20) != '\0') {
            uVar2 = *(uint *)((int)register0x00000010 + -0xc);
            dVar4 = *(double *)((int)register0x00000010 + -8);
            break;
          }
          pcVar1 = (code *)**(undefined4 **)(*(int *)((int)register0x00000010 + 4) + 100);
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x10000;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x424545;
          (*pcVar1)();
          *(uint *)((int)register0x00000010 + -0x10) = *(uint *)((int)register0x00000010 + -0x1c);
          if (*(int *)((int)register0x00000010 + -0x14) == 0 &&
              *(int *)((int)register0x00000010 + -0x18) == 0) {
            if (DAT_005f5de0 == 0) goto LAB_0042463e;
            *(uint *)((int)register0x00000010 + -0x20) =
                 *(uint *)((int)register0x00000010 + -0x1c) / DAT_005f5de0;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42458b;
            FUN_0046ed20();
            dVar4 = *(double *)((int)register0x00000010 + -0x1c) * DAT_00550ca0 +
                    *(double *)((int)register0x00000010 + -8);
          }
          else {
            *(int *)((int)register0x00000010 + -0x20) = *(int *)((int)register0x00000010 + -0x18);
            *(int *)((int)register0x00000010 + -0x1c) = *(int *)((int)register0x00000010 + -0x14);
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4245b5;
            FUN_00464a40();
            dVar4 = *(double *)((int)register0x00000010 + -0x18) +
                    *(double *)((int)register0x00000010 + -8);
          }
          uVar2 = *(int *)((int)register0x00000010 + -0xc) +
                  *(uint *)((int)register0x00000010 + -0x10);
          if ((*(uint *)((int)register0x00000010 + -0x10) < 0x10000) ||
             (DAT_005f5f44 != 0 || DAT_005f5f40 != 0)) break;
        }
        if ((uVar2 == 0) || (DAT_005f5de0 <= uVar2)) {
          *(uint *)((int)register0x00000010 + 8) = uVar2;
          *(double *)((int)register0x00000010 + 0xc) = dVar4;
          return;
        }
        *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004ccb62;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x2e;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42463e;
        FUN_00469a20();
LAB_0042463e:
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x424643;
        FUN_00438080();
      }
      *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004cc99c;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x2d;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x424659;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x42465f;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00424670 */

void FUN_00424670(undefined4 param_1)

{
  int in_FS_OFFSET;
  undefined *local_14;
  undefined *puStack_10;
  undefined *puStack_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00423eb0(&DAT_005d72e0);
  local_14 = &DAT_00550424;
  FUN_00409890(param_1);
  FUN_00424020(&DAT_005d72e0);
  do {
    while( true ) {
      FUN_004244b0(&DAT_005d72e0);
      if (local_14 != (undefined *)0x0) break;
      FUN_00424020(&DAT_005d72e0);
    }
    thunk_FUN_00402690(&DAT_005dde78);
    local_14 = puStack_10;
    puStack_10 = puStack_c;
    FUN_00424130(&DAT_005d72e0);
  } while( true );
}



/* Function: FUN_00424720 */

void FUN_00424720(int param_1,uint param_2,undefined4 *param_3,undefined1 param_4)

{
  char cVar1;
  int in_FS_OFFSET;
  int local_24;
  uint local_1c;
  undefined1 *local_18;
  uint *local_14;
  int local_10;
  uint local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x4247d6;
    FUN_0046d980();
  }
  local_1c = 0;
  while( true ) {
    if (param_2 <= local_1c) {
      return;
    }
    FUN_004256e0(param_1 + 0x58,param_4);
    if (local_24 == 0) break;
    local_18 = &LAB_004247e0;
    local_14 = &local_1c;
    local_10 = param_1;
    local_4 = param_2;
    cVar1 = (char)&local_18;
    FUN_0046d890();
    if (param_3 == (undefined4 *)0x0) {
      cVar1 = '\0';
    }
    else {
      (*(code *)*param_3)();
    }
    if (cVar1 != '\0') {
      return;
    }
  }
  return;
}



/* Function: FUN_00424840 */

void FUN_00424840(uint param_1,uint param_2,char param_3)

{
  char cVar1;
  int iVar2;
  ulong uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int in_FS_OFFSET;
  undefined *puVar7;
  uint in_stack_ffffffd0;
  uint in_stack_ffffffd4;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_18;
  int local_14;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0043a810();
  FUN_004027a0(&DAT_005f6898);
  uVar4 = in_stack_ffffffd0 >> 10;
  uVar5 = in_stack_ffffffd4 >> 10;
  uVar6 = in_stack_ffffffd4 << 0x16;
  puVar7 = &DAT_005f6890;
  FUN_004027a0(&DAT_005f6890);
  uVar3 = (ulong)in_stack_ffffffd0;
  FUN_00423b80();
  local_14 = (int)(uVar3 * 100 >> 0x20);
  local_18 = (undefined4)(uVar3 * 100);
  FUN_00464c70(local_18,in_stack_ffffffd4 * 100 + local_14,puVar7,in_stack_ffffffd0);
  FUN_0043a810();
  FUN_0043b060(&DAT_004c2c5f,5);
  FUN_0043ad50(param_1 >> 10,0);
  FUN_0043b060(" KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
               ,0x10);
  FUN_0043ad50(param_2 >> 10,0);
  FUN_0043b060(&DAT_004c6215,0x13);
  FUN_0043ad50(uVar4 | uVar6,uVar5);
  FUN_0043b060(&DAT_004c3689,10);
  FUN_0043ad50(local_24,local_20);
  FUN_0043b060(&DAT_004c2d74,6);
  FUN_0043a870();
  if (param_3 == '\0') {
    if (DAT_005d72f1 != '\0') {
      FUN_0043a810();
      FUN_0043b060(&DAT_004c6228,0x13);
      FUN_0043a870();
      DAT_005d72f1 = '\0';
    }
  }
  else {
    FUN_0043a810();
    FUN_0043b060(&DAT_004c334b,9);
    FUN_0043a870();
  }
  FUN_0043a810();
  FUN_0043aa10();
  FUN_0043a870();
  iVar2 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  cVar1 = *(char *)(iVar2 + 0x8b);
  *(char *)(iVar2 + 0x8b) = cVar1 + -1;
  if (cVar1 == '\x01') {
    FUN_0040f0e0(&DAT_005f5e5c);
  }
  return;
}



/* Function: FUN_00424a80 */

void FUN_00424a80(void)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x44);
      uVar3 = *(uint *)((int)register0x00000010 + 0x10) >> 0xd;
      if ((*(uint *)((int)register0x00000010 + 0x10) & 0x1fff) != 0) {
        uVar3 = uVar3 + 1;
      }
      *(uint *)((int)register0x00000010 + -0x24) = uVar3;
      uVar3 = DAT_005f5de0 >> 0xd;
      if (uVar3 == 0) {
        uVar3 = 1;
      }
      *(uint *)((int)register0x00000010 + -0x28) = uVar3;
      *(undefined4 *)((int)register0x00000010 + -0x44) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x98);
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424ad6;
      FUN_0040ecf0();
      iVar4 = *(int *)((int)register0x00000010 + 4);
      uVar3 = *(uint *)((int)register0x00000010 + 8);
      if (uVar3 < *(uint *)(iVar4 + 0x28)) {
        puVar1 = (uint *)(*(int *)(iVar4 + 0x24) + uVar3 * 8);
        uVar5 = puVar1[1];
        if ((uVar5 & 0x80000000) == 0) {
          uVar5 = *puVar1 >> 0x12 | (uVar5 & 0xf) << 0xe;
        }
        else {
          uVar5 = 0x40000;
        }
        if (uVar5 < *(uint *)((int)register0x00000010 + -0x28)) goto LAB_00424d6f;
        if (uVar3 < 0x400) {
          iVar4 = *(int *)(iVar4 + 0x30);
          *(uint *)((int)register0x00000010 + -8) = uVar3 * 0x80;
          *(uint *)((int)register0x00000010 + -0x44) = iVar4 + uVar3 * 0x80;
          *(undefined4 *)((int)register0x00000010 + -0x40) =
               *(undefined4 *)((int)register0x00000010 + 0xc);
          *(uint *)((int)register0x00000010 + -0x3c) = *(uint *)((int)register0x00000010 + -0x28);
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + -0x24);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424b53;
          FUN_00425030();
          iVar4 = *(int *)((int)register0x00000010 + -0x30);
          if (iVar4 != 0) {
            *(int *)((int)register0x00000010 + -0x2c) = iVar4;
            iVar2 = *(int *)((int)register0x00000010 + -0x34);
            *(int *)((int)register0x00000010 + -0x20) = iVar2;
            *(int *)((int)register0x00000010 + -0x1c) =
                 iVar2 * 0x2000 + *(int *)((int)register0x00000010 + 8) * 0x400000;
            *(int *)((int)register0x00000010 + -0x44) =
                 *(int *)(*(int *)((int)register0x00000010 + 4) + 0x30) +
                 *(int *)((int)register0x00000010 + -8);
            *(int *)((int)register0x00000010 + -0x40) = iVar2;
            *(int *)((int)register0x00000010 + -0x3c) = iVar4;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424ba5;
            FUN_00430c30();
            *(undefined4 *)((int)register0x00000010 + -0x44) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x40) =
                 *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(undefined4 *)((int)register0x00000010 + -0x3c) =
                 *(undefined4 *)((int)register0x00000010 + -0x2c);
            *(undefined2 *)((int)register0x00000010 + -0x38) = 0x101;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424bc8;
            FUN_0042cb80();
            *(undefined4 *)((int)register0x00000010 + -0x44) =
                 *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x98);
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424bdb;
            FUN_0040f0e0();
            iVar4 = *(int *)((int)register0x00000010 + 4);
            if (*(char *)(iVar4 + 0xa5) == '\0') {
              *(undefined4 *)((int)register0x00000010 + -0x44) =
                   *(undefined4 *)((int)register0x00000010 + -0x1c);
              *(int *)((int)register0x00000010 + -0x40) =
                   *(int *)((int)register0x00000010 + -0x2c) << 0xd;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424c05;
              FUN_00414d90();
              *(int *)((int)register0x00000010 + -0xc) =
                   *(int *)((int)register0x00000010 + -0x2c) << 0xd;
              *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f6898;
              *(int *)((int)register0x00000010 + -0x40) =
                   *(int *)((int)register0x00000010 + -0x2c) << 0xd;
              *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424c2a;
              FUN_00433860();
              *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f68a0;
              iVar4 = -*(int *)((int)register0x00000010 + -0xc);
              *(int *)((int)register0x00000010 + -0x10) = iVar4;
              *(int *)((int)register0x00000010 + -0x40) = iVar4;
              iVar4 = -(uint)(*(int *)((int)register0x00000010 + -0xc) != 0);
              *(int *)((int)register0x00000010 + -0x14) = iVar4;
              *(int *)((int)register0x00000010 + -0x3c) = iVar4;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424c58;
              FUN_00433860();
              *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f7700;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424c66;
              FUN_00433980();
              *(undefined4 *)((int)register0x00000010 + -4) =
                   *(undefined4 *)((int)register0x00000010 + -0x40);
              *(undefined4 *)((int)register0x00000010 + -0x44) =
                   *(undefined4 *)((int)register0x00000010 + -0x40);
              *(undefined4 *)((int)register0x00000010 + -0x40) =
                   *(undefined4 *)((int)register0x00000010 + -0x10);
              *(undefined4 *)((int)register0x00000010 + -0x3c) =
                   *(undefined4 *)((int)register0x00000010 + -0x14);
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424c88;
              thunk_FUN_004026b0();
              *(int *)((int)register0x00000010 + -0x44) = *(int *)((int)register0x00000010 + -4) + 8
              ;
              *(undefined4 *)((int)register0x00000010 + -0x40) =
                   *(undefined4 *)((int)register0x00000010 + -0xc);
              *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424ca7;
              thunk_FUN_004026b0();
              *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f7700;
              *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424cb5;
              FUN_00433a70();
              iVar4 = *(int *)((int)register0x00000010 + 4);
            }
            *(undefined4 *)((int)register0x00000010 + -0x44) = *(undefined4 *)(iVar4 + 0x98);
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424cc8;
            FUN_0040ecf0();
            iVar4 = *(int *)((int)register0x00000010 + 4);
            if (*(uint *)((int)register0x00000010 + -0x1c) < *(uint *)(iVar4 + 0x34)) {
              *(uint *)(iVar4 + 0x34) = *(uint *)((int)register0x00000010 + -0x1c);
            }
            *(int *)((int)register0x00000010 + -0x18) =
                 *(int *)((int)register0x00000010 + -0x2c) << 0xd;
            *(int *)((int)register0x00000010 + -0x44) =
                 *(int *)(iVar4 + 0x30) + *(int *)((int)register0x00000010 + -8);
            *(undefined4 *)((int)register0x00000010 + -0x40) =
                 *(undefined4 *)((int)register0x00000010 + -0x20);
            *(int *)((int)register0x00000010 + -0x3c) = *(int *)((int)register0x00000010 + -0x2c);
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424d04;
            FUN_0042f7f0();
            *(undefined4 *)((int)register0x00000010 + -0x44) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x40) =
                 *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(undefined4 *)((int)register0x00000010 + -0x3c) =
                 *(undefined4 *)((int)register0x00000010 + -0x2c);
            *(undefined2 *)((int)register0x00000010 + -0x38) = 1;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424d27;
            FUN_0042cb80();
            *(int *)((int)register0x00000010 + -0x44) =
                 *(int *)(*(int *)((int)register0x00000010 + 4) + 0x30) + 0x40 +
                 *(int *)((int)register0x00000010 + -8);
            *(undefined4 *)((int)register0x00000010 + -0x40) =
                 *(undefined4 *)((int)register0x00000010 + -0x20);
            *(undefined4 *)((int)register0x00000010 + -0x3c) =
                 *(undefined4 *)((int)register0x00000010 + -0x2c);
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424d50;
            FUN_0042f5a0();
            *(undefined4 *)((int)register0x00000010 + -0x44) =
                 *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x98);
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424d63;
            FUN_0040f0e0();
            *(undefined4 *)((int)register0x00000010 + 0x14) =
                 *(undefined4 *)((int)register0x00000010 + -0x18);
            return;
          }
          iVar4 = *(int *)((int)register0x00000010 + 4);
          uVar3 = *(uint *)((int)register0x00000010 + 8);
LAB_00424d6f:
          *(int *)((int)register0x00000010 + -0x44) = iVar4 + 0x58;
          *(uint *)((int)register0x00000010 + -0x40) = uVar3;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424d7e;
          FUN_00425b50();
          *(undefined4 *)((int)register0x00000010 + -0x44) =
               *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x98);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424d91;
          FUN_0040f0e0();
          *(undefined4 *)((int)register0x00000010 + 0x14) = 0;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424da9;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x424db0;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar6 + -4) = 0x424db6;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_00424dc0 */

void FUN_00424dc0(void)

{
  uint uVar1;
  uint uVar2;
  byte bVar3;
  uint uVar4;
  undefined1 *puVar5;
  uint uVar6;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x14);
      uVar2 = *(uint *)((int)register0x00000010 + 0xc);
      if (uVar2 < 5) {
        if (uVar2 == 1) {
          *(undefined4 *)((int)register0x00000010 + 0x10) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + 0x14) =
               *(undefined4 *)((int)register0x00000010 + 8);
          return;
        }
        if (uVar2 == 2) {
          uVar6 = *(uint *)((int)register0x00000010 + 4) & 0x55555555;
          uVar4 = ~((*(uint *)((int)register0x00000010 + 8) & 0x55555555) + 0x55555555 +
                    (uint)(0xaaaaaaaa < uVar6) | *(uint *)((int)register0x00000010 + 8) | 0x55555555
                   );
          uVar6 = ~(uVar6 + 0x55555555 | *(uint *)((int)register0x00000010 + 4) | 0x55555555);
          goto LAB_00424f99;
        }
        if (uVar2 == 4) {
          uVar6 = *(uint *)((int)register0x00000010 + 4) & 0x77777777;
          uVar4 = ~(*(uint *)((int)register0x00000010 + 8) |
                    (*(uint *)((int)register0x00000010 + 8) & 0x77777777) + 0x77777777 +
                    (uint)(0x88888888 < uVar6) | 0x77777777);
          uVar6 = ~(*(uint *)((int)register0x00000010 + 4) | uVar6 + 0x77777777 | 0x77777777);
LAB_00424f99:
          *(uint *)((int)register0x00000010 + -4) = uVar4;
          *(uint *)((int)register0x00000010 + -8) = uVar6;
          uVar1 = uVar2 - 0x21;
          bVar3 = (byte)(uVar2 - 1);
          *(uint *)((int)register0x00000010 + -0xc) = uVar6 >> (bVar3 & 0x1f);
          uVar6 = -(uint)(uVar2 - 1 < 0x20);
          uVar4 = uVar4 << ((byte)-uVar1 & 0x1f) & -(uint)(-uVar1 < 0x20) |
                  *(uint *)((int)register0x00000010 + -0xc) & uVar6 |
                  uVar4 >> ((byte)uVar1 & 0x1f) & -(uint)(uVar1 < 0x20);
          uVar2 = *(uint *)((int)register0x00000010 + -8);
          *(uint *)((int)register0x00000010 + 0x10) = ~(uVar2 - uVar4 | uVar2);
          *(uint *)((int)register0x00000010 + 0x14) =
               ~((*(uint *)((int)register0x00000010 + -4) -
                 (*(uint *)((int)register0x00000010 + -4) >> (bVar3 & 0x1f) & uVar6)) -
                 (uint)(uVar2 < uVar4) | *(uint *)((int)register0x00000010 + -4));
          return;
        }
      }
      else if (uVar2 < 0x11) {
        if (uVar2 == 8) {
          uVar6 = *(uint *)((int)register0x00000010 + 4) & 0x7f7f7f7f;
          uVar4 = ~(*(uint *)((int)register0x00000010 + 8) |
                    (*(uint *)((int)register0x00000010 + 8) & 0x7f7f7f7f) + 0x7f7f7f7f +
                    (uint)(0x80808080 < uVar6) | 0x7f7f7f7f);
          uVar6 = ~(*(uint *)((int)register0x00000010 + 4) | uVar6 + 0x7f7f7f7f | 0x7f7f7f7f);
          goto LAB_00424f99;
        }
        if (uVar2 == 0x10) {
          uVar6 = *(uint *)((int)register0x00000010 + 4) & 0x7fff7fff;
          uVar4 = ~(*(uint *)((int)register0x00000010 + 8) |
                    (*(uint *)((int)register0x00000010 + 8) & 0x7fff7fff) + 0x7fff7fff +
                    (uint)(0x80008000 < uVar6) | 0x7fff7fff);
          uVar6 = ~(*(uint *)((int)register0x00000010 + 4) | uVar6 + 0x7fff7fff | 0x7fff7fff);
          goto LAB_00424f99;
        }
      }
      else {
        if (uVar2 == 0x20) {
          uVar6 = *(uint *)((int)register0x00000010 + 4) & 0x7fffffff;
          uVar4 = ~(*(uint *)((int)register0x00000010 + 8) |
                    (*(uint *)((int)register0x00000010 + 8) & 0x7fffffff) + 0x7fffffff +
                    (uint)(0x80000000 < uVar6) | 0x7fffffff);
          uVar6 = ~(*(uint *)((int)register0x00000010 + 4) | uVar6 + 0x7fffffff | 0x7fffffff);
          goto LAB_00424f99;
        }
        if (uVar2 == 0x40) {
          uVar4 = ~(*(uint *)((int)register0x00000010 + 8) |
                    (*(uint *)((int)register0x00000010 + 8) & 0x7fffffff) + 0x7fffffff +
                    (uint)(*(int *)((int)register0x00000010 + 4) != 0) | 0x7fffffff);
          uVar6 = 0;
          goto LAB_00424f99;
        }
      }
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c3a96;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0xb;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42501e;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x425024;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00425030 */

void FUN_00425030(void)

{
  int iVar1;
  uint *puVar2;
  uint *puVar3;
  byte bVar4;
  int iVar5;
  uint uVar6;
  uint3 uVar7;
  uint uVar8;
  uint uVar9;
  undefined1 *puVar10;
  int iVar11;
  uint uVar12;
  undefined4 uVar13;
  int in_FS_OFFSET;
  bool bVar14;
  
  do {
    puVar10 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar10 = (undefined1 *)((int)register0x00000010 + -0x40);
      uVar6 = *(uint *)((int)register0x00000010 + 0xc);
      if (((uVar6 & uVar6 - 1) == 0) && (uVar6 != 0)) {
        if (uVar6 < 0x41) {
          uVar8 = uVar6;
          if (*(int *)((int)register0x00000010 + 0x10) != 0) {
            uVar8 = *(int *)((int)register0x00000010 + 0x10) + -1 + uVar6 & -uVar6;
          }
          *(uint *)((int)register0x00000010 + -4) = uVar8;
          uVar8 = *(uint *)((int)register0x00000010 + 8) >> 6;
          iVar11 = *(int *)((int)register0x00000010 + 4);
          while( true ) {
            *(uint *)((int)register0x00000010 + -0x20) = uVar8;
            bVar14 = (int)uVar8 < 0;
            if (bVar14) break;
            if (7 < uVar8) goto LAB_00425555;
            puVar2 = (uint *)(iVar11 + 0x40 + uVar8 * 8);
            puVar3 = (uint *)(iVar11 + uVar8 * 8);
            uVar8 = puVar3[1];
            uVar9 = puVar2[1];
            *(uint *)((int)register0x00000010 + -0x40) = *puVar3 | *puVar2;
            *(uint *)((int)register0x00000010 + -0x3c) = uVar8 | uVar9;
            *(uint *)((int)register0x00000010 + -0x38) = uVar6;
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4250dc;
            FUN_00424dc0();
            if (*(int *)((int)register0x00000010 + -0x30) != -1 ||
                *(int *)((int)register0x00000010 + -0x34) != -1) {
              bVar14 = *(int *)((int)register0x00000010 + -0x20) < 0;
              uVar6 = *(uint *)((int)register0x00000010 + 0xc);
              uVar8 = *(uint *)((int)register0x00000010 + -0x20);
              iVar11 = *(int *)((int)register0x00000010 + 4);
              break;
            }
            uVar8 = *(int *)((int)register0x00000010 + -0x20) - 1;
            uVar6 = *(uint *)((int)register0x00000010 + 0xc);
            iVar11 = *(int *)((int)register0x00000010 + 4);
          }
          if (bVar14) {
            *(undefined4 *)((int)register0x00000010 + 0x14) = 0;
            *(undefined4 *)((int)register0x00000010 + 0x18) = 0;
            return;
          }
          if (uVar8 < 8) {
            puVar2 = (uint *)(iVar11 + 0x40 + uVar8 * 8);
            puVar3 = (uint *)(iVar11 + uVar8 * 8);
            uVar8 = puVar3[1];
            uVar9 = puVar2[1];
            *(uint *)((int)register0x00000010 + -0x40) = *puVar3 | *puVar2;
            *(uint *)((int)register0x00000010 + -0x3c) = uVar8 | uVar9;
            *(uint *)((int)register0x00000010 + -0x38) = uVar6;
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42513c;
            FUN_00424dc0();
            uVar8 = ~*(uint *)((int)register0x00000010 + -0x30);
            uVar6 = ~*(uint *)((int)register0x00000010 + -0x34);
            if (uVar8 == 0) {
              iVar11 = 0;
            }
            else {
              iVar11 = 0x20;
              uVar6 = uVar8;
            }
            *(uint *)((int)register0x00000010 + -8) = *(uint *)((int)register0x00000010 + -0x34);
            if (0xffff < uVar6) {
              uVar6 = uVar6 >> 0x10;
              iVar11 = iVar11 + 0x10;
            }
            if (0xff < uVar6) {
              uVar6 = uVar6 >> 8;
              iVar11 = iVar11 + 8;
            }
            if (uVar6 < 0x100) {
              bVar4 = "lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                      [uVar6 + 0x1510];
              *(uint *)((int)register0x00000010 + -0xc) = (uint)bVar4;
              uVar9 = -(iVar11 + -0x40 + (uint)bVar4);
              *(uint *)((int)register0x00000010 + -0x10) =
                   *(uint *)((int)register0x00000010 + -0x30) << ((byte)uVar9 & 0x1f);
              iVar5 = *(int *)((int)register0x00000010 + -8);
              iVar1 = uVar9 - 0x20;
              *(int *)((int)register0x00000010 + -0x14) = iVar1;
              *(int *)((int)register0x00000010 + -0x18) =
                   *(int *)((int)register0x00000010 + -8) << ((byte)iVar1 & 0x1f);
              *(uint *)((int)register0x00000010 + -8) =
                   *(uint *)((int)register0x00000010 + -8) >> ((byte)-iVar1 & 0x1f);
              *(int *)((int)register0x00000010 + -0x1c) =
                   *(int *)((int)register0x00000010 + -0x20) * 0x40 +
                   *(int *)((int)register0x00000010 + -0xc) + iVar11;
              *(int *)((int)register0x00000010 + -0xc) =
                   *(int *)((int)register0x00000010 + -0xc) + iVar11 +
                   *(int *)((int)register0x00000010 + -0x20) * 0x40;
              uVar6 = iVar5 << ((byte)uVar9 & 0x1f) & -(uint)(uVar9 < 0x20);
              uVar12 = *(uint *)((int)register0x00000010 + -0x10) & -(uint)(uVar9 < 0x20);
              uVar8 = *(uint *)((int)register0x00000010 + -8) & -(uint)((uint)-iVar1 < 0x20) |
                      uVar12 | *(uint *)((int)register0x00000010 + -0x18) &
                               -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20);
              uVar7 = (uint3)((*(uint *)((int)register0x00000010 + -0x18) &
                              -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20)) >> 8);
              if (uVar6 != 0 || uVar8 != 0) {
                if (uVar8 == 0) {
                  iVar11 = 0;
                  uVar8 = uVar6;
                }
                else {
                  iVar11 = 0x20;
                  uVar6 = (uint)uVar7 << 8;
                }
                if (0xffff < uVar8) {
                  uVar8 = uVar8 >> 0x10;
                  iVar11 = iVar11 + 0x10;
                }
                uVar6 = CONCAT31((uint3)(uVar12 >> 8) & uVar7 | (uint3)(uVar6 >> 8),0xff < uVar8) &
                        CONCAT31(uVar7,1);
                if ((char)uVar6 != '\0') {
                  uVar8 = uVar8 >> 8;
                  iVar11 = iVar11 + 8;
                }
                if (0xff < uVar8) {
                  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4253d4;
                  FUN_0046ee00();
                  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4253e2;
                  FUN_0046ee90();
                  goto LAB_004253e2;
                }
                uVar6 = -(iVar11 + -0x40 +
                         (uint)(byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                                     [uVar8 + 0x1510]);
LAB_00425363:
                uVar8 = *(uint *)((int)register0x00000010 + -4);
                if (uVar6 <= *(uint *)((int)register0x00000010 + -4)) {
                  uVar8 = uVar6;
                }
                uVar9 = *(int *)((int)register0x00000010 + -0xc) - uVar8;
                if ((((0x2000 < DAT_005f5de4) && (DAT_005f5de0 < DAT_005f5de4)) &&
                    (uVar12 = -(DAT_005f5de4 >> 0xd),
                    (((DAT_005f5de4 >> 0xd) - 1) + uVar9 & uVar12) <=
                    *(uint *)((int)register0x00000010 + -0x1c))) &&
                   (uVar12 = uVar12 & uVar9,
                   *(int *)((int)register0x00000010 + -0xc) - uVar6 <= uVar12)) {
                  uVar8 = uVar8 + (uVar9 - uVar12);
                  uVar9 = uVar12;
                }
                *(uint *)((int)register0x00000010 + 0x14) = uVar9;
                *(uint *)((int)register0x00000010 + 0x18) = uVar8;
                return;
              }
              uVar6 = -(uVar9 - 0x40);
              iVar1 = *(int *)((int)register0x00000010 + -0x20);
              iVar11 = *(int *)((int)register0x00000010 + 4);
              uVar13 = *(undefined4 *)((int)register0x00000010 + 0xc);
              while( true ) {
                uVar8 = iVar1 - 1;
                if ((int)uVar8 < 0) goto LAB_00425363;
                if (7 < uVar8) goto LAB_00425523;
                *(uint *)((int)register0x00000010 + -0x24) = uVar8;
                *(uint *)((int)register0x00000010 + -0x28) = uVar6;
                puVar2 = (uint *)(iVar11 + 0x40 + uVar8 * 8);
                puVar3 = (uint *)(iVar11 + uVar8 * 8);
                uVar6 = puVar3[1];
                uVar8 = puVar2[1];
                *(uint *)((int)register0x00000010 + -0x40) = *puVar3 | *puVar2;
                *(uint *)((int)register0x00000010 + -0x3c) = uVar6 | uVar8;
                *(undefined4 *)((int)register0x00000010 + -0x38) = uVar13;
                *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425430;
                FUN_00424dc0();
                uVar8 = *(uint *)((int)register0x00000010 + -0x30);
                if (uVar8 == 0) {
                  iVar11 = 0;
                  uVar6 = *(uint *)((int)register0x00000010 + -0x34);
                }
                else {
                  iVar11 = 0x20;
                  uVar6 = uVar8;
                }
                *(uint *)((int)register0x00000010 + -0x2c) =
                     *(uint *)((int)register0x00000010 + -0x34);
                if (0xffff < uVar6) {
                  uVar6 = uVar6 >> 0x10;
                  iVar11 = iVar11 + 0x10;
                }
                if (0xff < uVar6) {
                  uVar6 = uVar6 >> 8;
                  iVar11 = iVar11 + 8;
                }
                if (0xff < uVar6) break;
                uVar6 = (*(int *)((int)register0x00000010 + -0x28) -
                        (iVar11 + (uint)(byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                                              [uVar6 + 0x1510])) + 0x40;
                if (*(int *)((int)register0x00000010 + -0x2c) != 0 || uVar8 != 0) goto LAB_00425363;
LAB_004253e2:
                iVar1 = *(int *)((int)register0x00000010 + -0x24);
                iVar11 = *(int *)((int)register0x00000010 + 4);
                uVar13 = *(undefined4 *)((int)register0x00000010 + 0xc);
              }
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425517;
              FUN_0046ee00();
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425523;
              FUN_0046ee90();
LAB_00425523:
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42552f;
              FUN_0046edf0();
            }
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42553b;
            FUN_0046ee00();
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425549;
            FUN_0046ee90();
          }
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425555;
          FUN_0046edf0();
LAB_00425555:
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425561;
          FUN_0046edf0();
        }
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425566;
        FUN_0043a810();
        *(char **)((int)register0x00000010 + -0x40) =
             "runtime: min = runtime: inUse=runtime: max = requested skip=bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0xf;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42557c;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425590;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425595;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42559a;
        FUN_0043a870();
        *(char **)((int)register0x00000010 + -0x40) =
             "min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0xd;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4255b0;
        FUN_00469a20();
      }
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4255b5;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x40) =
           "runtime: min = runtime: inUse=runtime: max = requested skip=bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0xf;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4255cb;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x40) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4255df;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4255e4;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4255e9;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x40) =
           "min must be a non-zero power of 2runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:s..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x21;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4255ff;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar10 + -4) = 0x425605;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar10;
  } while( true );
}



/* Function: FUN_00425610 */

void FUN_00425610(int param_1,undefined1 param_2,undefined4 param_3)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00432890(param_1 + 0x18);
  FUN_00432890(param_1 + 0x20);
  *(undefined4 *)(param_1 + 0x28) = DAT_005f5e20;
  *(undefined1 *)(param_1 + 0x30) = param_2;
  FUN_0042ea50(param_1,param_2,param_3);
  return;
}



/* Function: FUN_00425680 */

void FUN_00425680(int param_1,uint param_2)

{
  int in_FS_OFFSET;
  uint in_stack_fffffff8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  thunk_FUN_00402510(param_1 + 0x14);
  if ((in_stack_fffffff8 == 0) || (param_2 >> 0x16 < in_stack_fffffff8)) {
    thunk_FUN_00402770(param_1 + 0x14,param_2 >> 0x16);
  }
  return;
}



/* Function: FUN_004256e0 */

void FUN_004256e0(void)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  bool bVar6;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x40);
      iVar2 = *(int *)((int)register0x00000010 + 4) + 0x18;
      if (*(char *)((int)register0x00000010 + 8) != '\0') {
        iVar2 = *(int *)((int)register0x00000010 + 4) + 0x20;
      }
      *(int *)((int)register0x00000010 + -4) = iVar2;
      *(int *)((int)register0x00000010 + -0x40) = iVar2;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425718;
      FUN_00432960();
      if (DAT_005f5e20 == *(int *)((int)register0x00000010 + -0x3c)) {
        *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
        return;
      }
      *(int *)((int)register0x00000010 + -0x20) = *(int *)((int)register0x00000010 + -0x3c);
      *(undefined1 *)((int)register0x00000010 + -0x25) =
           *(undefined1 *)((int)register0x00000010 + -0x38);
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x2c);
      *(int *)((int)register0x00000010 + -0x40) = *(int *)((int)register0x00000010 + 4) + 0x14;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425748;
      thunk_FUN_00402510();
      uVar1 = *(uint *)((int)register0x00000010 + -0x3c);
      *(uint *)((int)register0x00000010 + -0x24) = uVar1;
      uVar3 = *(uint *)((int)register0x00000010 + -0x20) >> 0x16;
      *(uint *)((int)register0x00000010 + -8) = uVar3;
      piVar4 = *(int **)((int)register0x00000010 + 4);
      while( true ) {
        if (uVar3 < uVar1) {
          *(undefined4 *)((int)register0x00000010 + -0x40) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4258c1;
          FUN_00432890();
          *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
          *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
          return;
        }
        if ((uint)piVar4[1] <= uVar3) break;
        *(uint *)((int)register0x00000010 + -0x10) = uVar3;
        *(uint *)((int)register0x00000010 + -0x40) = *piVar4 + uVar3 * 8;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4257b7;
        FUN_00425bf0();
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + -0x3c);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -0x38);
        *(byte *)((int)register0x00000010 + -0x14) = *(byte *)((int)register0x00000010 + -0x34);
        if ((*(byte *)((int)register0x00000010 + -0x34) & 1) != 0) {
          if (*(char *)((int)register0x00000010 + 8) != '\0') {
LAB_00425828:
            iVar2 = *(int *)((int)register0x00000010 + -0x10);
            if (iVar2 == *(int *)((int)register0x00000010 + -8)) {
              *(int *)((int)register0x00000010 + 0xc) = iVar2;
              *(uint *)((int)register0x00000010 + 0x10) =
                   (*(uint *)((int)register0x00000010 + -0x20) & 0x3fffff) >> 0xd;
              return;
            }
            iVar2 = iVar2 * 0x400000 + 0x3fe000;
            if (*(char *)((int)register0x00000010 + -0x25) == '\0') {
              *(undefined4 *)((int)register0x00000010 + -0x40) =
                   *(undefined4 *)((int)register0x00000010 + -4);
              *(int *)((int)register0x00000010 + -0x3c) = iVar2;
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425888;
              FUN_004328f0();
            }
            else {
              *(undefined4 *)((int)register0x00000010 + -0x40) =
                   *(undefined4 *)((int)register0x00000010 + -4);
              *(int *)((int)register0x00000010 + -0x3c) = -*(int *)((int)register0x00000010 + -0x20)
              ;
              *(uint *)((int)register0x00000010 + -0x38) =
                   -(uint)(*(int *)((int)register0x00000010 + -0x20) != 0);
              *(int *)((int)register0x00000010 + -0x34) = iVar2;
              *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x425876;
              thunk_FUN_00402640();
            }
            *(undefined4 *)((int)register0x00000010 + 0xc) =
                 *(undefined4 *)((int)register0x00000010 + -0x10);
            *(undefined4 *)((int)register0x00000010 + 0x10) = 0x1ff;
            return;
          }
          if (*(int *)((int)register0x00000010 + -0x18) == *(int *)((int)register0x00000010 + -0xc))
          {
            if (*(ushort *)((int)register0x00000010 + -0x1c) < 0x1f0) {
              bVar6 = *(ushort *)((int)register0x00000010 + -0x1a) < 0x1f0;
            }
            else {
              bVar6 = false;
            }
          }
          else {
            bVar6 = *(ushort *)((int)register0x00000010 + -0x1c) < 0x1f0;
          }
          if (bVar6) goto LAB_00425828;
        }
        uVar3 = *(int *)((int)register0x00000010 + -0x10) - 1;
        uVar1 = *(uint *)((int)register0x00000010 + -0x24);
        piVar4 = *(int **)((int)register0x00000010 + 4);
      }
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4258de;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar5 + -4) = 0x4258e4;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_004258f0 */

void FUN_004258f0(void)

{
  undefined4 uVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x1c);
      if (*(uint *)((int)register0x00000010 + 8) < (uint)(*(int **)((int)register0x00000010 + 4))[1]
         ) {
        *(uint *)((int)register0x00000010 + -0x1c) =
             **(int **)((int)register0x00000010 + 4) + *(uint *)((int)register0x00000010 + 8) * 8;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x425927;
        FUN_00425bf0();
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + -0x18);
        *(undefined4 *)((int)register0x00000010 + -8) =
             *(undefined4 *)((int)register0x00000010 + -0x14);
        *(undefined1 *)((int)register0x00000010 + -4) =
             *(undefined1 *)((int)register0x00000010 + -0x10);
        uVar1 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x2c);
        *(undefined1 **)((int)register0x00000010 + -0x1c) =
             (undefined1 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x14) = uVar1;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42595f;
        FUN_00425cd0();
        if (*(uint *)((int)register0x00000010 + 8) <
            (uint)(*(int **)((int)register0x00000010 + 4))[1]) {
          *(uint *)((int)register0x00000010 + -0x1c) =
               **(int **)((int)register0x00000010 + 4) + *(uint *)((int)register0x00000010 + 8) * 8;
          *(undefined4 *)((int)register0x00000010 + -0x18) =
               *(undefined4 *)((int)register0x00000010 + -0xc);
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined1 *)((int)register0x00000010 + -0x10) =
               *(undefined1 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x425994;
          FUN_00425c60();
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42599f;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4259a4;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar2 + -4) = 0x4259aa;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_004259b0 */

void FUN_004259b0(void)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x20);
      if (*(uint *)((int)register0x00000010 + 8) < (uint)(*(int **)((int)register0x00000010 + 4))[1]
         ) {
        *(uint *)((int)register0x00000010 + -0x20) =
             **(int **)((int)register0x00000010 + 4) + *(uint *)((int)register0x00000010 + 8) * 8;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4259e7;
        FUN_00425bf0();
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + -0x1c);
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + -0x18);
        *(undefined1 *)((int)register0x00000010 + -8) =
             *(undefined1 *)((int)register0x00000010 + -0x14);
        uVar1 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x2c);
        *(undefined1 **)((int)register0x00000010 + -0x20) =
             (undefined1 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0x18) = uVar1;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x425a1f;
        FUN_00425dc0();
        if (*(uint *)((int)register0x00000010 + 8) <
            (uint)(*(int **)((int)register0x00000010 + 4))[1]) {
          *(uint *)((int)register0x00000010 + -0x20) =
               **(int **)((int)register0x00000010 + 4) + *(uint *)((int)register0x00000010 + 8) * 8;
          *(undefined4 *)((int)register0x00000010 + -0x1c) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x18) =
               *(undefined4 *)((int)register0x00000010 + -0xc);
          *(undefined1 *)((int)register0x00000010 + -0x14) =
               *(undefined1 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x425a58;
          FUN_00425c60();
          uVar3 = (*(int *)((int)register0x00000010 + 0x10) + -1 +
                  *(int *)((int)register0x00000010 + 0xc)) * 0x2000 +
                  *(int *)((int)register0x00000010 + 8) * 0x400000;
          *(uint *)((int)register0x00000010 + -4) = uVar3;
          iVar2 = *(int *)((int)register0x00000010 + 4);
          if (*(uint *)(iVar2 + 0x28) < uVar3) {
            *(uint *)(iVar2 + 0x28) = uVar3;
          }
          *(int *)((int)register0x00000010 + -0x20) = iVar2 + 0x20;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x425a8b;
          FUN_00432960();
          uVar3 = *(uint *)((int)register0x00000010 + -4);
          if (*(uint *)((int)register0x00000010 + -0x1c) < uVar3) {
            *(int *)((int)register0x00000010 + -0x20) = *(int *)((int)register0x00000010 + 4) + 0x20
            ;
            *(uint *)((int)register0x00000010 + -0x1c) = -uVar3;
            *(uint *)((int)register0x00000010 + -0x18) = -(uint)(uVar3 != 0);
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x425ab9;
            thunk_FUN_004027c0();
          }
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x425ac4;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x425ac9;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar4 + -4) = 0x425acf;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_00425ae0 */

void FUN_00425ae0(int param_1)

{
  uint uVar1;
  int in_FS_OFFSET;
  uint in_stack_fffffff8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  *(int *)(param_1 + 0x2c) = *(int *)(param_1 + 0x2c) + 1;
  FUN_00432960(param_1 + 0x18);
  uVar1 = *(uint *)(param_1 + 0x28);
  if (in_stack_fffffff8 < uVar1) {
    thunk_FUN_004027c0(param_1 + 0x18,-uVar1,-(uint)(uVar1 != 0));
  }
  *(undefined4 *)(param_1 + 0x28) = DAT_005f5e20;
  return;
}



/* Function: FUN_00425b50 */

void FUN_00425b50(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x1c);
      if (*(uint *)((int)register0x00000010 + 8) < (uint)(*(int **)((int)register0x00000010 + 4))[1]
         ) {
        *(uint *)((int)register0x00000010 + -0x1c) =
             **(int **)((int)register0x00000010 + 4) + *(uint *)((int)register0x00000010 + 8) * 8;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x425b7f;
        FUN_00425bf0();
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + -0x18);
        *(undefined4 *)((int)register0x00000010 + -8) =
             *(undefined4 *)((int)register0x00000010 + -0x14);
        *(byte *)((int)register0x00000010 + -4) = *(byte *)((int)register0x00000010 + -0x10) & 0xfe;
        if (*(uint *)((int)register0x00000010 + 8) <
            (uint)(*(int **)((int)register0x00000010 + 4))[1]) {
          *(uint *)((int)register0x00000010 + -0x1c) =
               **(int **)((int)register0x00000010 + 4) + *(uint *)((int)register0x00000010 + 8) * 8;
          *(undefined4 *)((int)register0x00000010 + -0x18) =
               *(undefined4 *)((int)register0x00000010 + -0xc);
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(byte *)((int)register0x00000010 + -0x10) =
               *(byte *)((int)register0x00000010 + -0x10) & 0xfe;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x425bcc;
          FUN_00425c60();
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x425bd7;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x425bdc;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar1 + -4) = 0x425be2;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00425bf0 */

void FUN_00425bf0(undefined4 param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004027a0(param_1);
  return;
}



/* Function: FUN_00425c60 */

void FUN_00425c60(undefined4 param_1,uint param_2,uint param_3,byte param_4)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004027c0(param_1,(uint)param_4 << 0x1a | param_2,param_3 | param_4 >> 6);
  return;
}



/* Function: FUN_00425cd0 */

void FUN_00425cd0(void)

{
  ushort *puVar1;
  int iVar2;
  int iVar3;
  ushort uVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0xc);
      puVar1 = *(ushort **)((int)register0x00000010 + 4);
      uVar4 = *puVar1;
      iVar2 = *(int *)((int)register0x00000010 + 8);
      if ((uint)uVar4 + iVar2 < 0x201) {
        iVar3 = *(int *)((int)register0x00000010 + 0xc);
        if (*(int *)(puVar1 + 2) != iVar3) {
          puVar1[1] = uVar4;
          *(int *)(puVar1 + 2) = iVar3;
        }
        uVar4 = *puVar1 + (short)iVar2;
        *puVar1 = uVar4;
        if (uVar4 == 0x200) {
          *(byte *)(puVar1 + 4) = (byte)puVar1[4] & 0xfe;
        }
        return;
      }
      *(ushort *)((int)register0x00000010 + -2) = uVar4;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425d37;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0xc) =
           "runtime: inUse=runtime: max = requested skip=bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = 0xf;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425d4d;
      FUN_0043b060();
      *(uint *)((int)register0x00000010 + -0xc) = (uint)*(ushort *)((int)register0x00000010 + -2);
      *(undefined4 *)((int)register0x00000010 + -8) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425d65;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0xc) = &DAT_004c314a;
      *(undefined4 *)((int)register0x00000010 + -8) = 8;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425d7b;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)((int)register0x00000010 + 8)
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425d8f;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425d94;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425d99;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0xc) =
           "too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile ..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = 0x22;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425daf;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x425db5;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00425dc0 */

void FUN_00425dc0(void)

{
  ushort uVar1;
  ushort *puVar2;
  uint uVar3;
  int iVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0xc);
      puVar2 = *(ushort **)((int)register0x00000010 + 4);
      uVar1 = *puVar2;
      uVar3 = *(uint *)((int)register0x00000010 + 8);
      if (uVar3 <= uVar1) {
        iVar4 = *(int *)((int)register0x00000010 + 0xc);
        if (*(int *)(puVar2 + 2) != iVar4) {
          puVar2[1] = uVar1;
          *(int *)(puVar2 + 2) = iVar4;
        }
        *puVar2 = *puVar2 - (short)uVar3;
        *(byte *)(puVar2 + 4) = (byte)puVar2[4] | 1;
        return;
      }
      *(ushort *)((int)register0x00000010 + -2) = uVar1;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425e1a;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0xc) =
           "runtime: inUse=runtime: max = requested skip=bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = 0xf;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425e30;
      FUN_0043b060();
      *(uint *)((int)register0x00000010 + -0xc) = (uint)*(ushort *)((int)register0x00000010 + -2);
      *(undefined4 *)((int)register0x00000010 + -8) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425e48;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0xc) = &DAT_004c314a;
      *(undefined4 *)((int)register0x00000010 + -8) = 8;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425e5e;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)((int)register0x00000010 + 8)
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425e72;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425e77;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425e7c;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0xc) =
           "allocated pages below zero?address not a stack addressmspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttribu..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = 0x1b;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x425e92;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x425e98;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00425ea0 */

void FUN_00425ea0(double *param_1,double param_2,double param_3,double param_4)

{
  double dVar1;
  double dVar2;
  int in_FS_OFFSET;
  double dVar3;
  double dVar4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  dVar3 = (param_3 - param_2) * *param_1 + param_1[5];
  if (((!NAN(dVar3)) && (!NAN(dVar3 - dVar3))) && (!NAN(dVar3))) {
    dVar4 = param_1[3];
    if ((param_1[3] <= dVar3) && (dVar4 = param_1[4], dVar3 <= param_1[4])) {
      dVar4 = dVar3;
    }
    dVar1 = param_1[1];
    if ((dVar1 != 0.0) || (NAN(dVar1))) {
      dVar2 = param_1[2];
      if ((dVar2 != 0.0) || (NAN(dVar2))) {
        dVar3 = param_1[5] +
                ((*param_1 * param_4) / dVar1) * (param_3 - param_2) +
                (dVar4 - dVar3) * (param_4 / dVar2);
        param_1[5] = dVar3;
        if (((NAN(dVar3)) || (NAN(dVar3 - dVar3))) || (NAN(dVar3))) {
          param_1[5] = 0.0;
          *(undefined1 *)(param_1 + 6) = 1;
          return;
        }
      }
    }
    return;
  }
  param_1[5] = 0.0;
  *(undefined1 *)((int)param_1 + 0x31) = 1;
  return;
}



/* Function: FUN_00426000 */

void FUN_00426000(void)

{
  uint *puVar1;
  uint uVar2;
  undefined1 *puVar3;
  uint *puVar4;
  uint uVar5;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0xc);
      uVar2 = *(uint *)((int)register0x00000010 + 8);
      puVar1 = *(uint **)((int)register0x00000010 + 4);
      if ((*puVar1 <= uVar2) && (uVar2 < puVar1[1])) {
        puVar4 = puVar1 + 3;
        if (*(char *)((int)register0x00000010 + 0xc) != '\0') {
          puVar4 = puVar1 + 5;
        }
        *(uint **)((int)register0x00000010 + -4) = puVar4;
        uVar5 = *puVar4;
        if (uVar5 == 0) {
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0x42608c;
          FUN_00428b20();
          uVar5 = *(uint *)((int)register0x00000010 + -0xc);
          *(undefined4 *)(uVar5 + 0xc) = 0;
          *(undefined4 *)(uVar5 + 0x10) = 0;
          **(uint **)((int)register0x00000010 + -4) = uVar5;
          uVar2 = *(uint *)((int)register0x00000010 + 8);
        }
        else if (*(int *)(uVar5 + 0xc) == 0x1fb) {
          uVar5 = puVar1[4];
          if (uVar5 == 0) {
            *(undefined4 *)((int)register0x00000010 + -0x10) = 0x42606a;
            FUN_00428b20();
            uVar5 = *(uint *)((int)register0x00000010 + -0xc);
            uVar2 = *(uint *)((int)register0x00000010 + 8);
            puVar4 = *(uint **)((int)register0x00000010 + -4);
          }
          else {
            puVar1[4] = 0;
          }
          *(undefined4 *)(uVar5 + 0xc) = 0;
          *(uint *)(uVar5 + 0x10) = *puVar4;
          *puVar4 = uVar5;
        }
        if (*(uint *)(uVar5 + 0xc) < 0x1fb) {
          *(uint *)(uVar5 + 0x14 + *(uint *)(uVar5 + 0xc) * 4) = uVar2;
          *(int *)(uVar5 + 0xc) = *(int *)(uVar5 + 0xc) + 1;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x4260c6;
        FUN_0046edf0();
      }
      *(char **)((int)register0x00000010 + -0xc) =
           "address not a stack addressmspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUIL..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = 0x1b;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x4260dc;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x4260e2;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_004260f0 */

void FUN_004260f0(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int *piVar5;
  undefined1 *puVar6;
  int *piVar7;
  int iVar8;
  int in_FS_OFFSET;
  
code_r0x004260f0:
  puVar6 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar6 = (undefined1 *)((int)register0x00000010 + -0x20);
    *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
    *(undefined4 *)((int)register0x00000010 + -8) = 0;
    iVar4 = *(int *)((int)register0x00000010 + 4);
    *(int *)((int)register0x00000010 + -0xc) = iVar4 + 0xc;
    piVar5 = (int *)(iVar4 + 0x14);
    *(int **)((int)register0x00000010 + -4) = piVar5;
    *(int **)((int)register0x00000010 + -8) = piVar5;
    iVar3 = 0;
    do {
      if (1 < iVar3) {
        if (*(int *)(iVar4 + 0x10) != 0) {
          *(int *)((int)register0x00000010 + -0x20) = *(int *)(iVar4 + 0x10);
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4261bb;
          FUN_00428d50();
          *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x10) = 0;
        }
        *(undefined4 *)((int)register0x00000010 + 8) = 0;
        *(undefined1 *)((int)register0x00000010 + 0xc) = 0;
        return;
      }
      piVar7 = *(int **)((int)register0x00000010 + iVar3 * 4 + -0xc);
      iVar8 = *piVar7;
      if (iVar8 != 0) {
        if (*(int *)(iVar8 + 0xc) != 0) goto LAB_00426187;
        iVar2 = *(int *)(iVar4 + 0x10);
        if (iVar2 != 0) {
          *(int *)((int)register0x00000010 + -0x14) = iVar3;
          *(int **)((int)register0x00000010 + -0x10) = piVar7;
          *(int *)((int)register0x00000010 + -0x18) = iVar8;
          *(int *)((int)register0x00000010 + -0x20) = iVar2;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x426166;
          FUN_00428d50();
          iVar3 = *(int *)((int)register0x00000010 + -0x14);
          iVar4 = *(int *)((int)register0x00000010 + 4);
          piVar5 = *(int **)((int)register0x00000010 + -4);
          piVar7 = *(int **)((int)register0x00000010 + -0x10);
          iVar8 = *(int *)((int)register0x00000010 + -0x18);
        }
        *(int *)(iVar4 + 0x10) = iVar8;
        iVar8 = *(int *)(iVar8 + 0x10);
        *piVar7 = iVar8;
        if (iVar8 != 0) goto LAB_00426187;
      }
      iVar3 = iVar3 + 1;
    } while( true );
  }
  goto LAB_004261e2;
LAB_00426187:
  iVar3 = *(int *)(iVar8 + 0xc);
  uVar1 = iVar3 - 1;
  *(uint *)(iVar8 + 0xc) = uVar1;
  if (uVar1 < 0x1fb) {
    *(undefined4 *)((int)register0x00000010 + 8) = *(undefined4 *)(iVar8 + 0x10 + iVar3 * 4);
    *(bool *)((int)register0x00000010 + 0xc) = piVar7 == piVar5;
    return;
  }
  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4261e1;
  FUN_0046edf0();
LAB_004261e2:
  *(undefined4 *)(puVar6 + -4) = 0x4261e7;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar6;
  goto code_r0x004260f0;
}



/* Function: FUN_004261f0 */

void FUN_004261f0(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int *piVar4;
  int iVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0xc);
      piVar4 = *(int **)((int)register0x00000010 + 4);
      iVar5 = piVar4[7];
      if (iVar5 == 0) {
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x426217;
        FUN_00428b20();
        iVar5 = *(int *)((int)register0x00000010 + -0xc);
        *(undefined4 *)(iVar5 + 0x10) = 0;
        piVar4 = *(int **)((int)register0x00000010 + 4);
        piVar4[6] = iVar5;
        piVar4[7] = iVar5;
      }
      iVar1 = *(int *)(iVar5 + 0xc);
      if (iVar1 < 1) {
        iVar3 = *(int *)((int)register0x00000010 + 8);
LAB_0042628b:
        uVar2 = *(uint *)(iVar5 + 0xc);
        if (uVar2 < 0x65) {
          *(uint *)(iVar5 + 0xc) = uVar2 + 1;
          *(int *)(iVar5 + 0x14 + uVar2 * 0x14) = iVar3 - *piVar4;
          iVar1 = *(int *)((int)register0x00000010 + 0xc);
          *(undefined4 *)(iVar5 + 0x18 + uVar2 * 0x14) = *(undefined4 *)(iVar1 + 4);
          *(int *)(iVar5 + 0x1c + uVar2 * 0x14) = iVar1;
          piVar4[8] = piVar4[8] + 1;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x4262c3;
        FUN_0046edf0();
LAB_004262c3:
        *(undefined **)((int)register0x00000010 + -0xc) = &DAT_004cc0ec;
        *(undefined4 *)((int)register0x00000010 + -8) = 0x29;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x4262d9;
        FUN_00469a20();
      }
      else {
        iVar3 = *(int *)((int)register0x00000010 + 8);
        if (iVar1 - 1U < 0x65) {
          if ((uint)(*(int *)(iVar5 + iVar1 * 0x14) + *(int *)(iVar5 + 4 + iVar1 * 0x14)) <=
              (uint)(iVar3 - *piVar4)) {
            if (iVar1 == 0x65) {
              *(int *)((int)register0x00000010 + -4) = iVar5;
              *(undefined4 *)((int)register0x00000010 + -0x10) = 0x426267;
              FUN_00428b20();
              iVar5 = *(int *)((int)register0x00000010 + -0xc);
              *(undefined4 *)(iVar5 + 0x10) = 0;
              *(int *)(*(int *)((int)register0x00000010 + -4) + 0x10) = iVar5;
              piVar4 = *(int **)((int)register0x00000010 + 4);
              piVar4[7] = iVar5;
              iVar3 = *(int *)((int)register0x00000010 + 8);
            }
            goto LAB_0042628b;
          }
          goto LAB_004262c3;
        }
      }
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x4262e3;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar6 + -4) = 0x4262e9;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_004262f0 */

void FUN_004262f0(void)

{
  uint uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  undefined1 *puVar7;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x2c);
      if (*(int *)((int)register0x00000010 + 0xc) == 0) {
        *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + 0x18) =
             *(undefined4 *)((int)register0x00000010 + 8);
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x2c) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + 8);
      iVar5 = *(int *)((int)register0x00000010 + 0xc) / 2;
      *(int *)((int)register0x00000010 + -4) = iVar5;
      *(int *)((int)register0x00000010 + -0x24) = iVar5;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x426338;
      FUN_004262f0();
      uVar1 = *(uint *)((int)register0x00000010 + -0x18);
      if (uVar1 < 0x65) {
        iVar6 = *(int *)((int)register0x00000010 + -0x1c);
        *(int *)((int)register0x00000010 + -8) = iVar6;
        *(uint *)((int)register0x00000010 + -0xc) = uVar1 * 5;
        *(uint *)((int)register0x00000010 + -0x10) = iVar6 + 0x14 + uVar1 * 0x14;
        iVar5 = uVar1 + 1;
        if (uVar1 == 100) {
          iVar6 = *(int *)(iVar6 + 0x10);
          iVar5 = 0;
        }
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(int *)((int)register0x00000010 + -0x2c) = iVar6;
        *(int *)((int)register0x00000010 + -0x28) = iVar5;
        *(int *)((int)register0x00000010 + -0x24) =
             (*(int *)((int)register0x00000010 + 0xc) - *(int *)((int)register0x00000010 + -4)) + -1
        ;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x426392;
        FUN_004262f0();
        uVar2 = *(undefined4 *)((int)register0x00000010 + -0x20);
        uVar3 = *(undefined4 *)((int)register0x00000010 + -0x1c);
        uVar4 = *(undefined4 *)((int)register0x00000010 + -0x18);
        iVar5 = *(int *)((int)register0x00000010 + -0xc);
        iVar6 = *(int *)((int)register0x00000010 + -8);
        *(undefined4 *)(iVar6 + 0x20 + iVar5 * 4) = *(undefined4 *)((int)register0x00000010 + -0x14)
        ;
        *(undefined4 *)(iVar6 + 0x24 + iVar5 * 4) = uVar2;
        *(undefined4 *)((int)register0x00000010 + 0x10) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + 0x14) = uVar3;
        *(undefined4 *)((int)register0x00000010 + 0x18) = uVar4;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x4263ec;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar7 + -4) = 0x4263f2;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_00426400 */

void FUN_00426400(undefined4 param_1,uint param_2)

{
  int in_FS_OFFSET;
  uint in_stack_fffffff4;
  char local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 'e';
    FUN_0046d980();
  }
  FUN_00402510(param_1);
  while( true ) {
    if (param_2 <= in_stack_fffffff4) {
      return;
    }
    FUN_00402540(param_1,in_stack_fffffff4,param_2);
    if (local_4 != '\0') break;
    FUN_00402510(param_1);
  }
  return;
}



/* Function: FUN_00426470 */

void FUN_00426470(void)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0xb0);
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005d7170;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4264a3;
      FUN_00402510();
      uVar1 = *(uint *)((int)register0x00000010 + -0x10);
      iVar4 = *(int *)((int)register0x00000010 + 4);
      uVar5 = *(uint *)((int)register0x00000010 + -0xc);
      while( true ) {
        if (0x10f < uVar1) {
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005d7170;
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0xffffffff;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x426579;
          FUN_00426400();
          *(undefined4 *)((int)register0x00000010 + 8) = 0;
          return;
        }
        uVar2 = uVar1 >> 1 & 0xff;
        if (0x87 < uVar2) break;
        *(uint *)((int)register0x00000010 + -4) = uVar1;
        iVar3 = uVar2 * 0x80;
        if ((uVar1 & 1) == 0) {
          *(uint *)((int)register0x00000010 + -0x14) =
               iVar4 + 0x1c8 + iVar3 + ((uVar5 >> 1 & 1) - 1) * -0x18;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42650c;
          FUN_004332d0();
          iVar4 = *(int *)((int)register0x00000010 + -0x10);
        }
        else {
          *(uint *)((int)register0x00000010 + -0x14) =
               iVar4 + 0x198 + iVar3 + ((uVar5 >> 1 & 1) - 1) * -0x18;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x426531;
          FUN_004332d0();
          iVar4 = *(int *)((int)register0x00000010 + -0x10);
        }
        if (iVar4 != 0) {
          *(int *)((int)register0x00000010 + -8) = iVar4;
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005d7170;
          *(undefined4 *)((int)register0x00000010 + -0x10) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x426557;
          FUN_00426400();
          *(undefined4 *)((int)register0x00000010 + 8) =
               *(undefined4 *)((int)register0x00000010 + -8);
          return;
        }
        uVar1 = *(int *)((int)register0x00000010 + -4) + 1;
        iVar4 = *(int *)((int)register0x00000010 + 4);
        uVar5 = *(uint *)((int)register0x00000010 + -0xc);
      }
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42658f;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar6 + -4) = 0x426595;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_004265a0 */

void FUN_004265a0(undefined4 param_1)

{
  int in_FS_OFFSET;
  undefined4 local_c;
  undefined1 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = '\x11';
    FUN_0046d980();
  }
  do {
    FUN_00402510(param_1);
    if ((local_c & 0x80000000) != 0) {
      return;
    }
    FUN_00402540(param_1);
  } while (local_4 == '\0');
  return;
}



/* Function: FUN_00426620 */

void FUN_00426620(void)

{
  uint uVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x38);
      if (DAT_005dde90 == *(int *)((int)register0x00000010 + 8)) {
        while( true ) {
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x426655;
          FUN_00402510();
          uVar1 = *(uint *)((int)register0x00000010 + -0x34);
          if (0x7fffffff < (uVar1 & 0x7fffffff) - 1) break;
          *(uint *)((int)register0x00000010 + -4) = uVar1;
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(uint *)((int)register0x00000010 + -0x30) = uVar1 - 1;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x426683;
          FUN_00402540();
          if (*(char *)((int)register0x00000010 + -0x2c) != '\0') {
            if (*(int *)((int)register0x00000010 + -4) == -0x80000000) {
              if (0 < DAT_005f6218) {
                *(undefined **)((int)register0x00000010 + -0x38) = &DAT_005f67e8;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4266b8;
                FUN_004027a0();
                *(uint *)((int)register0x00000010 + -0x24) =
                     *(uint *)((int)register0x00000010 + -0x34);
                uVar1 = *(uint *)((int)register0x00000010 + -0x30);
                *(uint *)((int)register0x00000010 + -0x1c) = uVar1;
                *(uint *)((int)register0x00000010 + -4) =
                     *(uint *)((int)register0x00000010 + -0x34) >> 0x14 | uVar1 << 0xc;
                *(uint *)((int)register0x00000010 + -8) = uVar1 >> 0x14;
                *(undefined **)((int)register0x00000010 + -0x38) = &DAT_005ddea8;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4266eb;
                FUN_004027a0();
                *(undefined4 *)((int)register0x00000010 + -0xc) = DAT_005ddeb8;
                *(undefined4 *)((int)register0x00000010 + -0x10) = DAT_005ddebc;
                *(undefined8 *)((int)register0x00000010 + -0x18) = DAT_005ddec0;
                *(undefined4 *)((int)register0x00000010 + -0x28) =
                     *(undefined4 *)((int)register0x00000010 + -0x34);
                *(undefined4 *)((int)register0x00000010 + -0x20) =
                     *(undefined4 *)((int)register0x00000010 + -0x30);
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x426722;
                FUN_0043a810();
                *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004ca4b8;
                *(undefined4 *)((int)register0x00000010 + -0x34) = 0x1f;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x426738;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x38) =
                     *(undefined4 *)((int)register0x00000010 + -4);
                *(undefined4 *)((int)register0x00000010 + -0x34) =
                     *(undefined4 *)((int)register0x00000010 + -8);
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42674c;
                FUN_0043ad50();
                *(char **)((int)register0x00000010 + -0x38) = "MB; allocated RtlGetVersion";
                *(undefined4 *)((int)register0x00000010 + -0x34) = 0xe;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x426762;
                FUN_0043b060();
                uVar1 = (*(int *)((int)register0x00000010 + -0x1c) -
                        *(int *)((int)register0x00000010 + -0x10)) -
                        (uint)(*(uint *)((int)register0x00000010 + -0x24) <
                              *(uint *)((int)register0x00000010 + -0xc));
                *(uint *)((int)register0x00000010 + -0x38) =
                     uVar1 * 0x1000 |
                     *(uint *)((int)register0x00000010 + -0x24) -
                     *(uint *)((int)register0x00000010 + -0xc) >> 0x14;
                *(uint *)((int)register0x00000010 + -0x34) = uVar1 >> 0x14;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42678f;
                FUN_0043ad50();
                *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c7a88;
                *(undefined4 *)((int)register0x00000010 + -0x34) = 0x17;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4267a5;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x38) =
                     *(undefined4 *)((int)register0x00000010 + -0x28);
                *(undefined4 *)((int)register0x00000010 + -0x34) =
                     *(undefined4 *)((int)register0x00000010 + -0x20);
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4267b9;
                FUN_0043ad50();
                *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c3693;
                *(undefined4 *)((int)register0x00000010 + -0x34) = 10;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4267cf;
                FUN_0043b060();
                *(undefined8 *)((int)register0x00000010 + -0x38) =
                     *(undefined8 *)((int)register0x00000010 + -0x18);
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4267df;
                FUN_0043aab0();
                *(char **)((int)register0x00000010 + -0x38) =
                     " pages/byte\n s.sweepgen= allocCount ProcessPrng";
                *(undefined4 *)((int)register0x00000010 + -0x34) = 0xc;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4267f5;
                FUN_0043b060();
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4267fa;
                FUN_0043a870();
              }
              return;
            }
            return;
          }
        }
        *(char **)((int)register0x00000010 + -0x38) =
             "mismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable metho..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x23;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x426818;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x38) =
           "sweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: ill..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x31;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42682e;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x426834;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00426840 */

void FUN_00426840(undefined4 param_1)

{
  int in_FS_OFFSET;
  undefined4 local_c;
  undefined1 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = -0x5f;
    FUN_0046d980();
  }
  do {
    FUN_00402510(param_1);
    if ((local_c & 0x80000000) != 0) {
      return;
    }
    FUN_00402540(param_1);
  } while (local_4 == '\0');
  return;
}



/* Function: FUN_004268b0 */

void FUN_004268b0(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x14);
      do {
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4268cc;
        FUN_00426bd0();
      } while (*(int *)((int)register0x00000010 + -0x14) != -1);
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005d716c;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4268e1;
      FUN_00402510();
      if ((*(uint *)((int)register0x00000010 + -0x10) & 0x7fffffff) == 0) {
        *(uint *)((int)register0x00000010 + -0xc) = DAT_005dde90;
        iVar3 = 0;
        uVar2 = DAT_005dde90;
        while (iVar3 < 0x88) {
          iVar1 = (uVar2 >> 1 & 1) - 1;
          *(undefined **)((int)register0x00000010 + -4) =
               &DAT_005ddfa8 + iVar1 * -0x18 + iVar3 * 0x80;
          *(int *)((int)register0x00000010 + -8) = iVar3 + 1;
          *(undefined **)((int)register0x00000010 + -0x14) =
               &DAT_005ddf78 + iVar1 * -0x18 + iVar3 * 0x80;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x426932;
          FUN_004334b0();
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42693e;
          FUN_004334b0();
          uVar2 = *(uint *)((int)register0x00000010 + -0xc);
          iVar3 = *(int *)((int)register0x00000010 + -8);
        }
        *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005d72e0;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42695c;
        FUN_004240a0();
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x426961;
        FUN_0042c5d0();
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004cc80c;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x2c;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42697b;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x426981;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_00426990 */

void FUN_00426990(undefined4 param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined **ppuVar5;
  undefined *puVar6;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar4 = **(undefined4 **)(in_FS_OFFSET + DAT_005f5ed0);
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = uVar4;
    in_EDI[1] = DAT_005d7164;
  }
  DAT_005d7164 = uVar4;
  FUN_0040ecf0(&DAT_005d7160);
  DAT_005d7168 = 1;
  FUN_00409890(param_1,&DAT_00550424);
  ppuVar5 = &PTR_LAB_00536c38;
  puVar6 = &DAT_005d7160;
  FUN_00469a60(&PTR_LAB_00536c38,&DAT_005d7160,0x90c,1);
  do {
    iVar3 = 0;
    while (FUN_00426bd0(), ppuVar5 != (undefined **)0xffffffff) {
      iVar1 = iVar3 + 1;
      iVar2 = iVar3 + 1;
      iVar3 = iVar1;
      if (((iVar2 + (int)((ulong)((long)iVar1 * -0x33333333) >> 0x20) >> 3) - (iVar1 >> 0x1f)) * 10
          == iVar1) {
        FUN_0043ba50();
      }
    }
    while( true ) {
      FUN_00429020(1);
      if ((char)puVar6 == '\0') break;
      FUN_0043ba50();
    }
    FUN_0040ecf0(&DAT_005d7160);
    FUN_00402510(&DAT_005d716c);
    if (puVar6 == (undefined *)0x80000000) {
      DAT_005d7168 = 1;
      ppuVar5 = &PTR_LAB_00536c38;
      puVar6 = &DAT_005d7160;
      FUN_00469a60(&PTR_LAB_00536c38,&DAT_005d7160,0x90c,1);
    }
    else {
      ppuVar5 = (undefined **)&DAT_005d7160;
      FUN_0040f0e0();
    }
  } while( true );
}



/* Function: FUN_00426b10 */

void FUN_00426b10(void)

{
  int iVar1;
  int iVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x14);
      if (*(char *)(*(int *)((int)register0x00000010 + 4) + 4) != '\0') {
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 8) + 0x34;
        *(int *)((int)register0x00000010 + -0x14) = *(int *)((int)register0x00000010 + 8) + 0x34;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x426b48;
        FUN_00402510();
        iVar2 = **(int **)((int)register0x00000010 + 4);
        iVar1 = iVar2 + -2;
        if (*(int *)((int)register0x00000010 + -0x10) != iVar1) {
          *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
          *(undefined1 *)((int)register0x00000010 + 0x10) = 0;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(int *)((int)register0x00000010 + -0x10) = iVar1;
        *(int *)((int)register0x00000010 + -0xc) = iVar2 + -1;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x426b6c;
        FUN_00402540();
        if (*(char *)((int)register0x00000010 + -8) != '\0') {
          *(undefined4 *)((int)register0x00000010 + 0xc) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
        *(undefined1 *)((int)register0x00000010 + 0x10) = 0;
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c8c32;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x1a;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x426bbe;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x426bc4;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00426bd0 */

void FUN_00426bd0(void)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  undefined1 uVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x34);
      iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      *(int *)((int)register0x00000010 + -4) = iVar2;
      piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
      *piVar1 = *piVar1 + 1;
      *(undefined **)((int)register0x00000010 + -0x34) = &DAT_005d716c;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426c0a;
      FUN_004265a0();
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + -0x30);
      *(char *)((int)register0x00000010 + -0x1c) = *(char *)((int)register0x00000010 + -0x2c);
      if (*(char *)((int)register0x00000010 + -0x2c) == '\0') {
        *(int *)(*(int *)(*(int *)((int)register0x00000010 + -4) + 0x18) + 0x7c) =
             *(int *)(*(int *)(*(int *)((int)register0x00000010 + -4) + 0x18) + 0x7c) + -1;
        *(undefined4 *)((int)register0x00000010 + 4) = 0xffffffff;
        return;
      }
LAB_00426c35:
      do {
        *(undefined **)((int)register0x00000010 + -0x34) = &DAT_005ddde0;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426c43;
        FUN_00426470();
        iVar2 = *(int *)((int)register0x00000010 + -0x30);
        if (iVar2 == 0) {
          *(undefined **)((int)register0x00000010 + -0x34) = &DAT_005d716c;
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426cfb;
          FUN_00426840();
          uVar5 = *(undefined1 *)((int)register0x00000010 + -0x30);
          uVar4 = 0xffffffff;
LAB_00426d07:
          *(undefined1 *)((int)register0x00000010 + -0x21) = uVar5;
          *(undefined4 *)((int)register0x00000010 + -0x10) = uVar4;
          *(undefined **)((int)register0x00000010 + -0x34) = &DAT_005d716c;
          *(undefined4 *)((int)register0x00000010 + -0x30) =
               *(undefined4 *)((int)register0x00000010 + -0x20);
          *(undefined1 *)((int)register0x00000010 + -0x2c) =
               *(undefined1 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426d2e;
          FUN_00426620();
          if (*(char *)((int)register0x00000010 + -0x21) != '\0') {
            if (0 < DAT_005f6234) {
              *(undefined ***)((int)register0x00000010 + -0x34) = &PTR_LAB_00536c84;
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426d4f;
              FUN_0046d890();
            }
            *(undefined **)((int)register0x00000010 + -0x34) = &DAT_005d72ec;
            *(undefined4 *)((int)register0x00000010 + -0x30) = 1;
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426d67;
            FUN_00402770();
          }
          *(int *)(*(int *)(*(int *)((int)register0x00000010 + -4) + 0x18) + 0x7c) =
               *(int *)(*(int *)(*(int *)((int)register0x00000010 + -4) + 0x18) + 0x7c) + -1;
          *(undefined4 *)((int)register0x00000010 + 4) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          return;
        }
        *(int *)((int)register0x00000010 + -0x14) = iVar2;
        *(int *)((int)register0x00000010 + -0x34) = iVar2 + 0x3f;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426c5f;
        FUN_00402470();
        if (*(char *)((int)register0x00000010 + -0x30) == '\x01') {
          *(undefined1 **)((int)register0x00000010 + -0x34) =
               (undefined1 *)((int)register0x00000010 + -0x20);
          *(undefined4 *)((int)register0x00000010 + -0x30) =
               *(undefined4 *)((int)register0x00000010 + -0x14);
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426c98;
          FUN_00426b10();
          *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + -0x2c);
          if (*(char *)((int)register0x00000010 + -0x28) != '\0') {
            *(undefined4 *)((int)register0x00000010 + -0x10) =
                 *(undefined4 *)(*(int *)((int)register0x00000010 + -0x2c) + 0x10);
            *(undefined1 **)((int)register0x00000010 + -0x34) =
                 (undefined1 *)((int)register0x00000010 + -0x18);
            *(undefined1 *)((int)register0x00000010 + -0x30) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426cc1;
            FUN_00426f80();
            if (*(char *)((int)register0x00000010 + -0x2c) == '\0') {
              uVar4 = 0;
            }
            else {
              *(undefined **)((int)register0x00000010 + -0x34) = &DAT_005dded0;
              *(undefined4 *)((int)register0x00000010 + -0x30) =
                   *(undefined4 *)((int)register0x00000010 + -0x10);
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426ce5;
              thunk_FUN_00402690();
              uVar4 = *(undefined4 *)((int)register0x00000010 + -0x10);
            }
            uVar5 = 0;
            goto LAB_00426d07;
          }
          goto LAB_00426c35;
        }
        iVar2 = *(int *)(*(int *)((int)register0x00000010 + -0x14) + 0x34);
        iVar3 = *(int *)((int)register0x00000010 + -0x20);
      } while ((iVar3 == iVar2) || (iVar2 == iVar3 + 3));
      *(char *)((int)register0x00000010 + -0x22) = *(char *)((int)register0x00000010 + -0x30);
      *(int *)((int)register0x00000010 + -8) = iVar2;
      *(int *)((int)register0x00000010 + -0xc) = iVar3;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426d8e;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004c8c4c;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x1a;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426da4;
      FUN_0043b060();
      *(uint *)((int)register0x00000010 + -0x34) = (uint)*(byte *)((int)register0x00000010 + -0x22);
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426dbc;
      FUN_0043ad50();
      *(char **)((int)register0x00000010 + -0x34) = " s.sweepgen= allocCount ProcessPrng";
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0xc;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426dd2;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x34) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426de6;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004c369d;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 10;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426dfc;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x34) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426e10;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426e15;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426e1a;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004ca4d7;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x426e30;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x426e36;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_00426e40 */

void FUN_00426e40(void)

{
  int *piVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x1c);
      piVar1 = *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
      if (((piVar1[0x1f] != 0) || (piVar1[0x1b] != 0)) ||
         (*piVar1 == **(int **)(in_FS_OFFSET + DAT_005f5ed0))) {
        *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_005d716c;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x426e89;
        FUN_004265a0();
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + -0x18);
        *(char *)((int)register0x00000010 + -8) = *(char *)((int)register0x00000010 + -0x14);
        if (*(char *)((int)register0x00000010 + -0x14) != '\0') {
          *(undefined1 **)((int)register0x00000010 + -0x1c) =
               (undefined1 *)((int)register0x00000010 + -0xc);
          *(undefined4 *)((int)register0x00000010 + -0x18) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x426eb6;
          FUN_00426b10();
          *(undefined4 *)((int)register0x00000010 + -4) =
               *(undefined4 *)((int)register0x00000010 + -0x14);
          if (*(char *)((int)register0x00000010 + -0x10) != '\0') {
            *(undefined1 **)((int)register0x00000010 + -0x1c) =
                 (undefined1 *)((int)register0x00000010 + -4);
            *(undefined1 *)((int)register0x00000010 + -0x18) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x426ef9;
            FUN_00426f80();
            *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_005d716c;
            *(undefined4 *)((int)register0x00000010 + -0x18) =
                 *(undefined4 *)((int)register0x00000010 + -0xc);
            *(undefined1 *)((int)register0x00000010 + -0x14) =
                 *(undefined1 *)((int)register0x00000010 + -8);
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x426f18;
            FUN_00426620();
            return;
          }
          *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_005d716c;
          *(undefined4 *)((int)register0x00000010 + -0x18) =
               *(undefined4 *)((int)register0x00000010 + -0xc);
          *(undefined1 *)((int)register0x00000010 + -0x14) =
               *(undefined1 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x426ee6;
          FUN_00426620();
        }
        while( true ) {
          *(int *)((int)register0x00000010 + -0x1c) = *(int *)((int)register0x00000010 + 4) + 0x34;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x426f3c;
          FUN_00402510();
          if ((*(int *)((int)register0x00000010 + -0xc) == *(int *)((int)register0x00000010 + -0x18)
              ) || (*(int *)((int)register0x00000010 + -0x18) ==
                    *(int *)((int)register0x00000010 + -0xc) + 3)) break;
          *(undefined ***)((int)register0x00000010 + -0x1c) = &PTR_LAB_00536a7c;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x426f2b;
          FUN_0046d890();
        }
        return;
      }
      *(char **)((int)register0x00000010 + -0x1c) =
           "mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page ..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x22;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x426f69;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x426f6f;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00426f80 */

void FUN_00426f80(void)

{
  char cVar1;
  ushort uVar2;
  int *piVar3;
  bool bVar4;
  char *pcVar5;
  int iVar6;
  uint uVar7;
  byte bVar8;
  undefined1 *puVar9;
  undefined4 uVar10;
  undefined4 *puVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  int in_FS_OFFSET;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) <
        (undefined1 *)((int)register0x00000010 + -0x30)) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0xb0);
      piVar3 = *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
      if (((piVar3[0x1f] != 0) || (piVar3[0x1b] != 0)) ||
         (*piVar3 == **(int **)(in_FS_OFFSET + DAT_005f5ed0))) break;
      *(char **)((int)register0x00000010 + -0xb0) =
           "mspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0xac) = 0x1c;
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427d01;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar9 + -4) = 0x427d07;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
  iVar6 = **(int **)((int)register0x00000010 + 4);
  if (*(char *)((int)register0x00000010 + 8) == '\0') {
    **(int **)((int)register0x00000010 + 4) = 0;
  }
  *(int *)((int)register0x00000010 + -0x80) = iVar6;
  iVar6 = iVar6 + 0x3f;
  *(int *)((int)register0x00000010 + -4) = iVar6;
  *(undefined4 *)((int)register0x00000010 + -0x88) = DAT_005dde90;
  *(int *)((int)register0x00000010 + -0xb0) = iVar6;
  *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427000;
  FUN_00402470();
  pcVar5 = (char *)(uint)*(byte *)((int)register0x00000010 + -0xac);
  if (*(byte *)((int)register0x00000010 + -0xac) != 1) goto LAB_00427ce2;
  uVar12 = *(uint *)((int)register0x00000010 + -0x80);
  if (*(int *)(uVar12 + 0x34) != *(int *)((int)register0x00000010 + -0x88) + -1) {
LAB_00427c31:
    do {
      *(uint *)((int)register0x00000010 + -0x4c) = (uint)pcVar5 & 0xff;
      *(undefined4 *)((int)register0x00000010 + -0x58) = *(undefined4 *)(uVar12 + 0x34);
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427c44;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_004c623b;
      *(undefined4 *)((int)register0x00000010 + -0xac) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427c5a;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0xb0) =
           *(undefined4 *)((int)register0x00000010 + -0x4c);
      *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427c6e;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_004c369d;
      *(undefined4 *)((int)register0x00000010 + -0xac) = 10;
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427c84;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0xb0) =
           *(undefined4 *)((int)register0x00000010 + -0x58);
      *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427c98;
      FUN_0043ad50();
      *(char **)((int)register0x00000010 + -0xb0) =
           " mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -0xac) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427cae;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0xb0) =
           *(undefined4 *)((int)register0x00000010 + -0x88);
      *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427cc2;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427cc7;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427ccc;
      FUN_0043a870();
      pcVar5 = 
      "mspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredU..." /* TRUNCATED STRING LITERAL */
      ;
      *(char **)((int)register0x00000010 + -0xb0) =
           "mspan.sweep: bad span stateinvalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredU..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0xac) = 0x1b;
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427ce2;
      FUN_00469a20();
LAB_00427ce2:
      uVar12 = *(uint *)((int)register0x00000010 + -0x80);
    } while( true );
  }
  *(int *)((int)register0x00000010 + -0x4c) = *(int *)((int)register0x00000010 + -0x88) + -1;
  if (DAT_005d7d30 == '\0') {
    iVar6 = 0;
    uVar10 = 0;
  }
  else {
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42703c;
    FUN_0045e520();
    uVar10 = *(undefined4 *)((int)register0x00000010 + -0xb0);
    iVar6 = *(int *)((int)register0x00000010 + -0xac);
    uVar12 = *(uint *)((int)register0x00000010 + -0x80);
  }
  if (iVar6 != 0) {
    *(int *)((int)register0x00000010 + -0x94) = iVar6;
    *(undefined4 *)((int)register0x00000010 + -0x34) = uVar10;
    iVar13 = *(int *)(uVar12 + 0x10);
    *(undefined4 *)((int)register0x00000010 + -0xb0) = uVar10;
    *(int *)((int)register0x00000010 + -0xac) = iVar6;
    *(int *)((int)register0x00000010 + -0xa8) = iVar13 << 0xd;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427075;
    FUN_0045ed50();
    *(undefined4 *)((int)register0x00000010 + -0xb0) =
         *(undefined4 *)((int)register0x00000010 + -0x34);
    *(undefined4 *)((int)register0x00000010 + -0xac) =
         *(undefined4 *)((int)register0x00000010 + -0x94);
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427089;
    FUN_0045e630();
    uVar12 = *(uint *)((int)register0x00000010 + -0x80);
  }
  uVar10 = *(undefined4 *)(uVar12 + 0x10);
  *(uint *)((int)register0x00000010 + -8) = uVar12 + 0x50;
  *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_005ddea8;
  *(undefined4 *)((int)register0x00000010 + -0xac) = uVar10;
  *(undefined4 *)((int)register0x00000010 + -0xa8) = 0;
  *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4270b4;
  FUN_004026b0();
  pcVar5 = *(char **)((int)register0x00000010 + -0x80);
  iVar6 = *(int *)(pcVar5 + 0x50);
  *(int *)((int)register0x00000010 + -0x50) = iVar6;
  *(char *)((int)register0x00000010 + -0x99) = pcVar5[0x3e];
  uVar12 = *(uint *)(pcVar5 + 0x44);
  *(uint *)((int)register0x00000010 + -0x84) = uVar12;
  *(undefined4 *)((int)register0x00000010 + -0x28) = *(undefined4 *)((int)register0x00000010 + -8);
  *(int *)((int)register0x00000010 + -0x24) = iVar6;
  while (puVar11 = *(undefined4 **)((int)register0x00000010 + -0x24), puVar11 != (undefined4 *)0x0)
  {
    if (uVar12 == 0) {
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427c31;
      FUN_00438080();
      goto LAB_00427c31;
    }
    uVar7 = (uint)puVar11[1] / uVar12;
    *(uint *)((int)register0x00000010 + -0x7c) = uVar7;
    iVar6 = *(int *)(pcVar5 + 0xc);
    iVar13 = *(int *)(pcVar5 + 0x2c);
    *(int *)((int)register0x00000010 + -100) = iVar13;
    *(uint *)((int)register0x00000010 + -0x78) = uVar7 >> 3;
    *(undefined1 *)((int)register0x00000010 + -0x97) = *(undefined1 *)(iVar13 + (uVar7 >> 3));
    bVar8 = (byte)(1 << ((byte)*(undefined4 *)((int)register0x00000010 + -0x7c) & 7));
    if ((bVar8 & *(byte *)((int)register0x00000010 + -0x97)) == 0) {
      uVar7 = uVar7 * uVar12 + uVar12;
      for (; puVar11 != (undefined4 *)0x0; puVar11 = (undefined4 *)*puVar11) {
        if (uVar7 <= (uint)puVar11[1]) {
          bVar4 = false;
          goto LAB_004271cd;
        }
        if (*(char *)(puVar11 + 2) == '\x01') {
          *(byte *)(*(int *)((int)register0x00000010 + -100) +
                   *(int *)((int)register0x00000010 + -0x78)) =
               *(byte *)((int)register0x00000010 + -0x97) | bVar8;
          bVar4 = true;
          goto LAB_004271cd;
        }
      }
      bVar4 = false;
LAB_004271cd:
      *(uint *)((int)register0x00000010 + -0x68) = uVar7;
      if (bVar4) {
        pcVar5 = *(char **)((int)register0x00000010 + -0x80);
        while ((puVar11 = *(undefined4 **)((int)register0x00000010 + -0x24),
               puVar11 != (undefined4 *)0x0 && (uVar14 = puVar11[1], uVar14 < uVar7))) {
          iVar6 = *(int *)(pcVar5 + 0xc);
          if ((*(char *)(puVar11 + 2) == '\x01') || (*(char *)(puVar11 + 2) == '\x02')) {
            uVar10 = *puVar11;
            *(undefined4 *)((int)register0x00000010 + -0x24) = uVar10;
            **(undefined4 **)((int)register0x00000010 + -0x28) = uVar10;
            *(undefined4 **)((int)register0x00000010 + -0xb0) = puVar11;
            *(uint *)((int)register0x00000010 + -0xac) = uVar14 + iVar6;
            *(uint *)((int)register0x00000010 + -0xa8) = uVar12;
            *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427c1e;
            FUN_0042c130();
            uVar7 = *(uint *)((int)register0x00000010 + -0x68);
            uVar12 = *(uint *)((int)register0x00000010 + -0x84);
            pcVar5 = *(char **)((int)register0x00000010 + -0x80);
          }
          else {
            *(undefined4 **)((int)register0x00000010 + -0x28) = puVar11;
            *(undefined4 *)((int)register0x00000010 + -0x24) = *puVar11;
          }
        }
      }
      else {
        pcVar5 = *(char **)((int)register0x00000010 + -0x80);
        while ((puVar11 = *(undefined4 **)((int)register0x00000010 + -0x24),
               puVar11 != (undefined4 *)0x0 && (uVar14 = puVar11[1], uVar14 < uVar7))) {
          iVar6 = *(int *)(pcVar5 + 0xc);
          uVar10 = *puVar11;
          *(undefined4 *)((int)register0x00000010 + -0x24) = uVar10;
          **(undefined4 **)((int)register0x00000010 + -0x28) = uVar10;
          *(undefined4 **)((int)register0x00000010 + -0xb0) = puVar11;
          *(uint *)((int)register0x00000010 + -0xac) = iVar6 + uVar14;
          *(uint *)((int)register0x00000010 + -0xa8) = uVar12;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427b90;
          FUN_0042c130();
          uVar12 = *(uint *)((int)register0x00000010 + -0x84);
          pcVar5 = *(char **)((int)register0x00000010 + -0x80);
          uVar7 = *(uint *)((int)register0x00000010 + -0x68);
        }
      }
    }
    else {
      if (*(char *)(puVar11 + 2) == '\x04') {
        uVar10 = *puVar11;
        *(undefined4 *)((int)register0x00000010 + -0x24) = uVar10;
        **(undefined4 **)((int)register0x00000010 + -0x28) = uVar10;
        *(undefined1 *)((int)puVar11 + 0xd) = 1;
        *(undefined4 **)((int)register0x00000010 + -0xb0) = puVar11;
        *(uint *)((int)register0x00000010 + -0xac) = uVar7 * uVar12 + iVar6;
        *(uint *)((int)register0x00000010 + -0xa8) = uVar12;
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42719b;
        FUN_0042c130();
        uVar12 = *(uint *)((int)register0x00000010 + -0x84);
      }
      else {
        *(undefined4 **)((int)register0x00000010 + -0x28) = puVar11;
        *(undefined4 *)((int)register0x00000010 + -0x24) = *puVar11;
      }
      pcVar5 = *(char **)((int)register0x00000010 + -0x80);
    }
    iVar6 = *(int *)((int)register0x00000010 + -0x50);
  }
  if ((iVar6 != 0) && (*(int *)(pcVar5 + 0x50) == 0)) {
    *(char **)((int)register0x00000010 + -0xb0) = pcVar5;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4271fa;
    FUN_0042b620();
    pcVar5 = *(char **)((int)register0x00000010 + -0x80);
    uVar12 = *(uint *)((int)register0x00000010 + -0x84);
  }
  if ((DAT_005d7d31 != '\0') || (DAT_005f6204 != 0)) {
    *(undefined4 *)((int)register0x00000010 + -0x20) = *(undefined4 *)(pcVar5 + 0x2c);
    *(undefined1 *)((int)register0x00000010 + -0x1c) = 1;
    *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x14) = *(undefined4 *)(pcVar5 + 0x28);
    *(undefined1 *)((int)register0x00000010 + -0x10) = 1;
    *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
    for (uVar7 = 0; uVar7 < *(ushort *)(pcVar5 + 0x1a); uVar7 = uVar7 + 1) {
      if (((**(byte **)((int)register0x00000010 + -0x20) &
           *(byte *)((int)register0x00000010 + -0x1c)) == 0) &&
         ((*(uint *)((int)register0x00000010 + -0xc) < (uint)*(ushort *)(pcVar5 + 0x18) ||
          ((**(byte **)((int)register0x00000010 + -0x14) &
           *(byte *)((int)register0x00000010 + -0x10)) != 0)))) {
        iVar6 = *(int *)(pcVar5 + 0x44) * uVar7 + *(int *)(pcVar5 + 0xc);
        if (DAT_005d7d31 != '\0') {
          *(uint *)((int)register0x00000010 + -0x6c) = uVar7;
          *(int *)((int)register0x00000010 + -0x90) = iVar6;
          if (DAT_005d7d30 == '\0') {
            iVar13 = 0;
            uVar10 = 0;
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427a58;
            FUN_0045e520();
            uVar10 = *(undefined4 *)((int)register0x00000010 + -0xb0);
            iVar13 = *(int *)((int)register0x00000010 + -0xac);
            uVar12 = *(uint *)((int)register0x00000010 + -0x84);
            iVar6 = *(int *)((int)register0x00000010 + -0x90);
            pcVar5 = *(char **)((int)register0x00000010 + -0x80);
            uVar7 = *(uint *)((int)register0x00000010 + -0x6c);
          }
          if (iVar13 != 0) {
            *(int *)((int)register0x00000010 + -0x8c) = iVar13;
            *(undefined4 *)((int)register0x00000010 + -0x30) = uVar10;
            *(undefined4 *)((int)register0x00000010 + -0xb0) = uVar10;
            *(int *)((int)register0x00000010 + -0xac) = iVar13;
            *(int *)((int)register0x00000010 + -0xa8) = iVar6;
            *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427a97;
            FUN_00458880();
            *(undefined4 *)((int)register0x00000010 + -0xb0) =
                 *(undefined4 *)((int)register0x00000010 + -0x30);
            *(undefined4 *)((int)register0x00000010 + -0xac) =
                 *(undefined4 *)((int)register0x00000010 + -0x8c);
            *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427aae;
            FUN_0045e630();
            pcVar5 = *(char **)((int)register0x00000010 + -0x80);
            uVar7 = *(uint *)((int)register0x00000010 + -0x6c);
            uVar12 = *(uint *)((int)register0x00000010 + -0x84);
            iVar6 = *(int *)((int)register0x00000010 + -0x90);
          }
        }
        if (DAT_005f6204 != 0) {
          for (uVar14 = 0; uVar14 < uVar12; uVar14 = uVar14 + 4) {
            *(undefined4 *)(iVar6 + uVar14) = 0xdeadbeef;
          }
        }
      }
      if (*(char *)((int)register0x00000010 + -0x1c) == -0x80) {
        *(int *)((int)register0x00000010 + -0x20) = *(int *)((int)register0x00000010 + -0x20) + 1;
        *(undefined1 *)((int)register0x00000010 + -0x1c) = 1;
      }
      else {
        *(char *)((int)register0x00000010 + -0x1c) = *(char *)((int)register0x00000010 + -0x1c) << 1
        ;
      }
      *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + -0x18) + 1;
      if (*(char *)((int)register0x00000010 + -0x10) == -0x80) {
        *(int *)((int)register0x00000010 + -0x14) = *(int *)((int)register0x00000010 + -0x14) + 1;
        *(undefined1 *)((int)register0x00000010 + -0x10) = 1;
      }
      else {
        *(char *)((int)register0x00000010 + -0x10) = *(char *)((int)register0x00000010 + -0x10) << 1
        ;
      }
      *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + -0xc) + 1;
    }
  }
  uVar2 = *(ushort *)(pcVar5 + 0x18);
  if (*(ushort *)(pcVar5 + 0x1a) <= uVar2) goto LAB_004272c6;
  uVar12 = (uint)(uVar2 >> 3);
  if ((byte)((~*(byte *)(*(int *)(pcVar5 + 0x28) + uVar12) &
             *(byte *)(*(int *)(pcVar5 + 0x2c) + uVar12)) >> ((byte)uVar2 & 7)) != 0) {
    *(uint *)((int)register0x00000010 + -0x74) = uVar12;
    *(char **)((int)register0x00000010 + -0xb0) = pcVar5;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4272ad;
    FUN_00427f50();
    pcVar5 = *(char **)((int)register0x00000010 + -0x80);
    uVar12 = *(uint *)((int)register0x00000010 + -0x74);
  }
  while( true ) {
    while (uVar12 = uVar12 + 1, uVar12 < *(ushort *)(pcVar5 + 0x1a) + 7 >> 3) {
      if ((~*(byte *)(uVar12 + *(int *)(pcVar5 + 0x28)) &
          *(byte *)(uVar12 + *(int *)(pcVar5 + 0x2c))) != 0) {
        *(uint *)((int)register0x00000010 + -0x70) = uVar12;
        *(char **)((int)register0x00000010 + -0xb0) = pcVar5;
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4279a8;
        FUN_00427f50();
        pcVar5 = *(char **)((int)register0x00000010 + -0x80);
        uVar12 = *(uint *)((int)register0x00000010 + -0x70);
      }
    }
LAB_004272c6:
    *(char **)((int)register0x00000010 + -0xb0) = pcVar5;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4272ce;
    FUN_00413530();
    uVar7 = *(uint *)((int)register0x00000010 + -0xac);
    uVar12 = *(uint *)((int)register0x00000010 + -0x80);
    uVar2 = *(ushort *)(uVar12 + 0x3c);
    uVar14 = uVar2 - uVar7;
    if ((ushort)uVar7 <= uVar2) break;
    *(uint *)((int)register0x00000010 + -0x4c) = uVar14 & 0xffff;
    *(uint *)((int)register0x00000010 + -0x58) = (uint)uVar2;
    *(uint *)((int)register0x00000010 + -0x5c) = uVar7 & 0xffff;
    *(uint *)((int)register0x00000010 + -0x60) = (uint)*(ushort *)(uVar12 + 0x1a);
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42789e;
    FUN_0043a810();
    *(char **)((int)register0x00000010 + -0xb0) =
         "runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
    ;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0x10;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4278b4;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0xb0) =
         *(undefined4 *)((int)register0x00000010 + -0x60);
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4278c8;
    FUN_0043ad50();
    *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_004c3152;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 8;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4278de;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0xb0) =
         *(undefined4 *)((int)register0x00000010 + -0x5c);
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4278f2;
    FUN_0043ad50();
    *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_004c6d8f;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0x15;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427908;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0xb0) =
         *(undefined4 *)((int)register0x00000010 + -0x58);
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42791c;
    FUN_0043ad50();
    *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_004c315a;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 8;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427932;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0xb0) =
         *(undefined4 *)((int)register0x00000010 + -0x4c);
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427946;
    FUN_0043ad50();
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42794b;
    FUN_0043aa10();
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427950;
    FUN_0043a870();
    pcVar5 = 
    "sweep increased allocation countremovespecial on invalid pointergetWeakHandle on invalid pointerruntime: root level max pages = NtAssociateWaitCompletionPacket"
    ;
    *(char **)((int)register0x00000010 + -0xb0) =
         "sweep increased allocation countremovespecial on invalid pointergetWeakHandle on invalid pointerruntime: root level max pages = NtAssociateWaitCompletionPacket"
    ;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0x20;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427966;
    FUN_00469a20();
  }
  *(uint *)((int)register0x00000010 + -0x54) = uVar7;
  *(short *)((int)register0x00000010 + -0x96) = (short)uVar14;
  *(ushort *)(uVar12 + 0x3c) = (ushort)uVar7;
  *(undefined2 *)(uVar12 + 0x18) = 0;
  *(undefined2 *)(uVar12 + 0x1c) = 0;
  if (DAT_005d7d30 != '\0') {
    piVar3 = (int *)(*(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58) +
                    0x93c);
    *piVar3 = *piVar3 + (uVar14 & 0xffff) * *(int *)(uVar12 + 0x44);
  }
  *(undefined4 *)(uVar12 + 0x28) = *(undefined4 *)(uVar12 + 0x2c);
  *(uint *)((int)register0x00000010 + -0xb0) = (uint)*(ushort *)(uVar12 + 0x1a);
  *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42733b;
  FUN_0042c440();
  iVar6 = *(int *)((int)register0x00000010 + -0x80);
  *(undefined4 *)(iVar6 + 0x2c) = *(undefined4 *)((int)register0x00000010 + -0xac);
  if (*(int *)(iVar6 + 0x30) != 0) {
    *(int *)((int)register0x00000010 + -0xb0) = iVar6;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427355;
    FUN_00439b00();
    iVar6 = *(int *)((int)register0x00000010 + -0x80);
  }
  *(int *)((int)register0x00000010 + -0xb0) = iVar6;
  *(undefined2 *)((int)register0x00000010 + -0xac) = 0;
  *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427368;
  FUN_00412d40();
  *(undefined4 *)((int)register0x00000010 + -0xb0) = *(undefined4 *)((int)register0x00000010 + -4);
  *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427378;
  FUN_00402470();
  pcVar5 = (char *)(uint)*(byte *)((int)register0x00000010 + -0xac);
  if (*(byte *)((int)register0x00000010 + -0xac) != 1) goto LAB_00427873;
  uVar12 = *(uint *)((int)register0x00000010 + -0x80);
  iVar6 = *(int *)(uVar12 + 0x34);
  if (iVar6 != *(int *)((int)register0x00000010 + -0x4c)) goto LAB_004277c2;
  iVar13 = *(int *)((int)register0x00000010 + -0x88);
  if ((iVar6 != iVar13 + 1) && (iVar6 != iVar13 + 3)) {
    *(uint *)((int)register0x00000010 + -0xb0) = uVar12 + 0x34;
    *(int *)((int)register0x00000010 + -0xac) = iVar13;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4273c2;
    FUN_00402770();
    iVar6 = *(int *)((int)register0x00000010 + -0x80);
    uVar12 = (uint)*(byte *)(iVar6 + 0x41);
    if (*(byte *)(iVar6 + 0x41) == 0) {
      bVar8 = *(byte *)((int)register0x00000010 + -0x99);
      if (bVar8 >> 1 == 0) {
        if (*(char *)((int)register0x00000010 + 8) != '\0') goto LAB_00427662;
        if (*(short *)((int)register0x00000010 + -0x96) != 0) {
          *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_005f7700;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42767f;
          FUN_00433980();
          *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + -0xac);
          *(int *)((int)register0x00000010 + -0xb0) =
               *(int *)((int)register0x00000010 + -0xac) + 0x270;
          *(undefined4 *)((int)register0x00000010 + -0xac) = 1;
          *(undefined4 *)((int)register0x00000010 + -0xa8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4276a9;
          FUN_004026b0();
          *(int *)((int)register0x00000010 + -0xb0) =
               *(int *)((int)register0x00000010 + -0x2c) + 0x268;
          *(undefined4 *)((int)register0x00000010 + -0xac) =
               *(undefined4 *)((int)register0x00000010 + -0x84);
          *(undefined4 *)((int)register0x00000010 + -0xa8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4276cd;
          FUN_004026b0();
          *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_005f7700;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4276db;
          FUN_00433a70();
          *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_005f68b0;
          *(undefined4 *)((int)register0x00000010 + -0xac) =
               *(undefined4 *)((int)register0x00000010 + -0x84);
          *(undefined4 *)((int)register0x00000010 + -0xa8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4276fa;
          FUN_004026b0();
          if (DAT_005f6210 < 1) {
            *(undefined1 **)((int)register0x00000010 + -0x48) = &LAB_00427d10;
            *(undefined4 *)((int)register0x00000010 + -0x44) =
                 *(undefined4 *)((int)register0x00000010 + -0x80);
            *(undefined **)((int)register0x00000010 + -0x40) = &DAT_005ddde0;
            *(undefined1 **)((int)register0x00000010 + -0xb0) =
                 (undefined1 *)((int)register0x00000010 + -0x48);
            *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42774d;
            FUN_0046d890();
          }
          else {
            iVar6 = *(int *)((int)register0x00000010 + -0x80);
            *(undefined4 *)(iVar6 + 0x48) = 0;
            *(undefined4 *)((int)register0x00000010 + -0xb0) = *(undefined4 *)(iVar6 + 0xc);
            *(undefined4 *)((int)register0x00000010 + -0xac) =
                 *(undefined4 *)((int)register0x00000010 + -0x84);
            *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427722;
            FUN_00414ec0();
          }
          *(undefined1 *)((int)register0x00000010 + 0xc) = 1;
          return;
        }
        if (bVar8 < 0x88) {
          *(undefined **)((int)register0x00000010 + -0xb0) =
               &DAT_005ddfa8 +
               (*(uint *)((int)register0x00000010 + -0x88) >> 1 & 1) * 0x18 + (uint)bVar8 * 0x80;
          *(int *)((int)register0x00000010 + -0xac) = iVar6;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427662;
          FUN_004330d0();
          goto LAB_00427662;
        }
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427768;
        FUN_0046edf0();
LAB_00427768:
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427774;
        FUN_0046edf0();
LAB_00427774:
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427780;
        FUN_0046edf0();
      }
      else {
        if (*(short *)((int)register0x00000010 + -0x96) == 0) {
          cVar1 = *(char *)((int)register0x00000010 + 8);
LAB_00427554:
          if (cVar1 != '\0') {
LAB_00427662:
            *(undefined1 *)((int)register0x00000010 + 0xc) = 0;
            return;
          }
          if ((short)*(undefined4 *)((int)register0x00000010 + -0x54) == 0) {
            *(undefined1 **)((int)register0x00000010 + -0x48) = &LAB_00427de0;
            *(int *)((int)register0x00000010 + -0x44) = iVar6;
            *(undefined **)((int)register0x00000010 + -0x40) = &DAT_005ddde0;
            *(undefined1 **)((int)register0x00000010 + -0xb0) =
                 (undefined1 *)((int)register0x00000010 + -0x48);
            *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427606;
            FUN_0046d890();
            *(undefined1 *)((int)register0x00000010 + 0xc) = 1;
            return;
          }
          if (*(short *)(iVar6 + 0x1a) != (short)*(undefined4 *)((int)register0x00000010 + -0x54)) {
            if (bVar8 < 0x88) {
              *(undefined **)((int)register0x00000010 + -0xb0) =
                   &DAT_005ddf78 +
                   (*(uint *)((int)register0x00000010 + -0x88) >> 1 & 1) * 0x18 + (uint)bVar8 * 0x80
              ;
              *(int *)((int)register0x00000010 + -0xac) = iVar6;
              *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4275dc;
              FUN_004330d0();
              goto LAB_00427662;
            }
            goto LAB_00427768;
          }
          if (bVar8 < 0x88) {
            *(undefined **)((int)register0x00000010 + -0xb0) =
                 &DAT_005ddfa8 +
                 (*(uint *)((int)register0x00000010 + -0x88) >> 1 & 1) * 0x18 + (uint)bVar8 * 0x80;
            *(int *)((int)register0x00000010 + -0xac) = iVar6;
            *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4275a0;
            FUN_004330d0();
            goto LAB_00427662;
          }
          goto LAB_00427774;
        }
        *(byte *)((int)register0x00000010 + -0x98) = bVar8 >> 1;
        *(undefined1 *)(iVar6 + 0x40) = 1;
        *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_005f7700;
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4274d0;
        FUN_00433980();
        if ((uint)(int)*(char *)((int)register0x00000010 + -0x98) < 0x44) {
          *(int *)((int)register0x00000010 + -0xb0) =
               *(int *)((int)register0x00000010 + -0xac) + 0x278 +
               *(char *)((int)register0x00000010 + -0x98) * 8;
          *(uint *)((int)register0x00000010 + -0x4c) =
               (uint)*(ushort *)((int)register0x00000010 + -0x96);
          *(uint *)((int)register0x00000010 + -0xac) =
               (uint)*(ushort *)((int)register0x00000010 + -0x96);
          *(undefined4 *)((int)register0x00000010 + -0xa8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42750e;
          FUN_004026b0();
          *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_005f7700;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42751c;
          FUN_00433a70();
          uVar12 = *(uint *)(*(int *)((int)register0x00000010 + -0x80) + 0x44);
          *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_005f68b0;
          *(ulong *)((int)register0x00000010 + -0xac) =
               (ulong)*(uint *)((int)register0x00000010 + -0x4c) * (ulong)uVar12;
          *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427541;
          FUN_004026b0();
          cVar1 = *(char *)((int)register0x00000010 + 8);
          iVar6 = *(int *)((int)register0x00000010 + -0x80);
          bVar8 = *(byte *)((int)register0x00000010 + -0x99);
          goto LAB_00427554;
        }
      }
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42778a;
      FUN_0046edf0();
LAB_0042778a:
      uVar12 = 0x88;
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427796;
      FUN_0046edf0();
    }
    else if (*(char *)((int)register0x00000010 + 8) == '\0') {
      if ((short)*(undefined4 *)((int)register0x00000010 + -0x54) == 0) {
        iVar6 = *(int *)(iVar6 + 0x10);
        *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_005ddea0;
        *(int *)((int)register0x00000010 + -0xac) = -iVar6;
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42744d;
        thunk_FUN_00402690();
        *(undefined4 *)((int)register0x00000010 + -0xb0) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined1 *)((int)register0x00000010 + -0xac) = 0;
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427463;
        FUN_00402810();
        *(undefined1 **)((int)register0x00000010 + -0x3c) = &LAB_00427eb0;
        *(undefined4 *)((int)register0x00000010 + -0x38) =
             *(undefined4 *)((int)register0x00000010 + -0x80);
        *(undefined1 **)((int)register0x00000010 + -0xb0) =
             (undefined1 *)((int)register0x00000010 + -0x3c);
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427481;
        FUN_0046d890();
        *(undefined1 *)((int)register0x00000010 + 0xc) = 0;
        return;
      }
      if (*(byte *)((int)register0x00000010 + -0x99) < 0x88) {
        *(undefined **)((int)register0x00000010 + -0xb0) =
             &DAT_005ddfa8 +
             (*(uint *)((int)register0x00000010 + -0x88) >> 1 & 1) * 0x18 +
             (uint)*(byte *)((int)register0x00000010 + -0x99) * 0x80;
        *(int *)((int)register0x00000010 + -0xac) = iVar6;
        *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427427;
        FUN_004330d0();
        *(undefined1 *)((int)register0x00000010 + 0xc) = 0;
        return;
      }
      goto LAB_0042778a;
    }
    *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_004cc35a;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0x2a;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4277ac;
    FUN_00469a20();
  }
  pcVar5 = 
  "swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
  ;
  *(char **)((int)register0x00000010 + -0xb0) =
       "swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
  ;
  *(undefined4 *)((int)register0x00000010 + -0xac) = 0x11;
  *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4277c2;
  FUN_00469a20();
LAB_004277c2:
  do {
    *(uint *)((int)register0x00000010 + -0x4c) = (uint)pcVar5 & 0xff;
    *(undefined4 *)((int)register0x00000010 + -0x58) = *(undefined4 *)(uVar12 + 0x34);
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4277d5;
    FUN_0043a810();
    *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_004c623b;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0x13;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4277eb;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0xb0) =
         *(undefined4 *)((int)register0x00000010 + -0x4c);
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x4277ff;
    FUN_0043ad50();
    *(undefined **)((int)register0x00000010 + -0xb0) = &DAT_004c369d;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 10;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427815;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0xb0) =
         *(undefined4 *)((int)register0x00000010 + -0x58);
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427829;
    FUN_0043ad50();
    *(char **)((int)register0x00000010 + -0xb0) =
         " mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
    ;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0x10;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42783f;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0xb0) =
         *(undefined4 *)((int)register0x00000010 + -0x88);
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427853;
    FUN_0043ad50();
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427858;
    FUN_0043aa10();
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x42785d;
    FUN_0043a870();
    pcVar5 = 
    "mspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
    ;
    *(char **)((int)register0x00000010 + -0xb0) =
         "mspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
    ;
    *(undefined4 *)((int)register0x00000010 + -0xac) = 0x27;
    *(undefined4 *)((int)register0x00000010 + -0xb4) = 0x427873;
    FUN_00469a20();
LAB_00427873:
    uVar12 = *(uint *)((int)register0x00000010 + -0x80);
  } while( true );
}



/* Function: FUN_00427f50 */

void FUN_00427f50(void)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  bool bVar5;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x38);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x427f6c;
      FUN_0043a810();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x44);
      *(uint *)((int)register0x00000010 + -0x20) =
           (uint)*(ushort *)(*(int *)((int)register0x00000010 + 4) + 0x18);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x427f84;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x38) =
           "runtime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sw..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x24;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x427f9a;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x38) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x427fa6;
      FUN_0043b020();
      *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c3aa1;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0xb;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x427fbc;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x38) =
           *(undefined4 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x427fd0;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c3aac;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0xb;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x427fe6;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x38) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x427ffa;
      FUN_0043ad50();
      *(char **)((int)register0x00000010 + -0x38) =
           " (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
      ;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x51;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428010;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428015;
      FUN_0043a870();
      iVar2 = *(int *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x18) = *(undefined4 *)(iVar2 + 0x2c);
      *(undefined1 *)((int)register0x00000010 + -0x14) = 1;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)(iVar2 + 0x28);
      *(undefined1 *)((int)register0x00000010 + -8) = 1;
      *(undefined4 *)((int)register0x00000010 + -4) = 0;
      uVar3 = 0;
      while (uVar3 < *(ushort *)(iVar2 + 0x1a)) {
        *(uint *)((int)register0x00000010 + -0x28) = uVar3;
        *(uint *)((int)register0x00000010 + -0x24) =
             *(int *)(iVar2 + 0x44) * uVar3 + *(int *)(iVar2 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42807b;
        FUN_0043a810();
        *(undefined4 *)((int)register0x00000010 + -0x38) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42808f;
        FUN_0043aef0();
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428094;
        FUN_0043a870();
        if (*(uint *)((int)register0x00000010 + -0x28) <
            (uint)*(ushort *)(*(int *)((int)register0x00000010 + 4) + 0x18)) {
          bVar5 = true;
        }
        else {
          bVar5 = (**(byte **)((int)register0x00000010 + -0xc) &
                  *(byte *)((int)register0x00000010 + -8)) != 0;
        }
        *(bool *)((int)register0x00000010 + -0x29) = bVar5;
        if (bVar5 == false) {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4280eb;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c2d80;
          *(undefined4 *)((int)register0x00000010 + -0x34) = 6;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428101;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428106;
          FUN_0043a870();
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4280c9;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c2d7a;
          *(undefined4 *)((int)register0x00000010 + -0x34) = 6;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4280df;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4280e4;
          FUN_0043a870();
        }
        if ((**(byte **)((int)register0x00000010 + -0x18) &
            *(byte *)((int)register0x00000010 + -0x14)) == 0) {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42813d;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c3393;
          *(undefined4 *)((int)register0x00000010 + -0x34) = 9;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428153;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428158;
          FUN_0043a870();
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42811b;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c338a;
          *(undefined4 *)((int)register0x00000010 + -0x34) = 9;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428131;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428136;
          FUN_0043a870();
        }
        if ((*(byte *)((int)register0x00000010 + -0x14) &
            **(byte **)((int)register0x00000010 + -0x18)) == 0) {
          bVar1 = 0;
        }
        else {
          bVar1 = *(byte *)((int)register0x00000010 + -0x29) ^ 1;
        }
        *(byte *)((int)register0x00000010 + -0x2a) = bVar1;
        if (bVar1 != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428181;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004c2f1c;
          *(undefined4 *)((int)register0x00000010 + -0x34) = 7;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x428197;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42819c;
          FUN_0043a870();
        }
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4281a1;
        FUN_0043a810();
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4281a6;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4281ab;
        FUN_0043a870();
        if (*(char *)((int)register0x00000010 + -0x2a) != '\0') {
          uVar3 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x44);
          if (0x400 < uVar3) {
            uVar3 = 0x400;
          }
          *(int *)((int)register0x00000010 + -0x38) = *(int *)((int)register0x00000010 + -0x24);
          *(uint *)((int)register0x00000010 + -0x34) =
               *(int *)((int)register0x00000010 + -0x24) + uVar3;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4281e2;
          FUN_0043b1b0();
        }
        if (*(char *)((int)register0x00000010 + -0x14) == -0x80) {
          *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + -0x18) + 1;
          *(undefined1 *)((int)register0x00000010 + -0x14) = 1;
        }
        else {
          *(char *)((int)register0x00000010 + -0x14) =
               *(char *)((int)register0x00000010 + -0x14) << 1;
        }
        *(int *)((int)register0x00000010 + -0x10) = *(int *)((int)register0x00000010 + -0x10) + 1;
        if (*(char *)((int)register0x00000010 + -8) == -0x80) {
          *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + -0xc) + 1;
          *(undefined1 *)((int)register0x00000010 + -8) = 1;
        }
        else {
          *(char *)((int)register0x00000010 + -8) = *(char *)((int)register0x00000010 + -8) << 1;
        }
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + -4) + 1;
        iVar2 = *(int *)((int)register0x00000010 + 4);
        uVar3 = *(int *)((int)register0x00000010 + -0x28) + 1;
      }
      *(char **)((int)register0x00000010 + -0x38) =
           "found pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x1c;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42823c;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x428242;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_00428250 */

void FUN_00428250(int param_1,uint param_2)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int in_FS_OFFSET;
  double dVar4;
  undefined4 in_stack_ffffffd0;
  undefined *puVar5;
  uint in_stack_ffffffd4;
  uint uVar6;
  uint uStack_28;
  int local_24;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if ((DAT_005ddec0 == 0.0) && (!NAN(DAT_005ddec0))) {
    return;
  }
  if (DAT_005d7d30 == '\0') {
    uVar2 = 0;
    in_stack_ffffffd0 = 0;
  }
  else {
    uVar2 = in_stack_ffffffd4;
    FUN_0045e520();
    in_stack_ffffffd4 = uVar2;
  }
  if (uVar2 != 0) {
    FUN_0045ece0(in_stack_ffffffd0,uVar2);
    FUN_0045e630(in_stack_ffffffd0);
    in_stack_ffffffd4 = uVar2;
  }
  do {
    uVar6 = in_stack_ffffffd4;
    FUN_004027a0(&DAT_005ddeb0);
    uVar2 = uVar6;
    FUN_004027a0(&DAT_005f67e8);
    dVar4 = DAT_005ddec0;
    iVar3 = param_1;
    if (uStack_28 == DAT_005ddebc && DAT_005ddeb8 < uVar2 || DAT_005ddebc < uStack_28) {
      iVar3 = param_1 + (uVar2 - DAT_005ddeb8);
    }
    FUN_0046ed20(iVar3);
    dVar4 = dVar4 * (double)CONCAT44(uStack_28,uVar2);
    in_stack_ffffffd4 = (uint)((ulong)dVar4 >> 0x20);
    FUN_004649a0(SUB84(dVar4,0));
    iVar3 = local_24 - (uint)(uStack_28 < param_2);
    do {
      puVar5 = &DAT_005ddea8;
      FUN_004027a0();
      iVar1 = -(uint)(in_stack_ffffffd4 < uVar6);
      if ((uStack_28 - param_2 <= in_stack_ffffffd4 - uVar6 || iVar3 != iVar1) &&
          (iVar3 == iVar1 || iVar3 < iVar1)) {
LAB_00428406:
        if (DAT_005d7d30 == '\0') {
          in_stack_ffffffd4 = 0;
          puVar5 = (undefined *)0x0;
        }
        else {
          FUN_0045e520();
        }
        if (in_stack_ffffffd4 != 0) {
          FUN_0045ee40(puVar5,in_stack_ffffffd4);
          FUN_0045e630(puVar5,in_stack_ffffffd4);
        }
        return;
      }
      FUN_00426bd0();
      if (puVar5 == (undefined *)0xffffffff) {
        DAT_005ddec0 = 0.0;
        puVar5 = (undefined *)0xffffffff;
        goto LAB_00428406;
      }
      FUN_004027a0(&DAT_005ddeb0);
    } while (in_stack_ffffffd4 == uVar6);
  } while( true );
}



/* Function: FUN_00428460 */

void FUN_00428460(uint param_1,int param_2)

{
  double dVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int in_FS_OFFSET;
  uint in_stack_ffffffd4;
  uint uVar5;
  uint uVar6;
  int in_stack_ffffffd8;
  int iVar7;
  int iVar8;
  undefined4 uStack_24;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00402510(&DAT_005d716c);
  if (in_stack_ffffffd4 == 0x80000000) {
    DAT_005ddec0 = 0.0;
  }
  else {
    FUN_004027a0(&DAT_005f67e8);
    uVar2 = (param_1 - in_stack_ffffffd4) - 0x100000;
    iVar4 = ((param_2 - in_stack_ffffffd8) - (uint)(param_1 < in_stack_ffffffd4)) + -1 +
            (uint)(0xfffff < param_1 - in_stack_ffffffd4);
    if (uVar2 < 0x2000 && iVar4 == 0 || iVar4 < 0) {
      iVar4 = 0;
      uVar2 = 0x2000;
    }
    uVar5 = in_stack_ffffffd4;
    iVar7 = in_stack_ffffffd8;
    FUN_004027a0(&DAT_005ddea8);
    uVar6 = uVar5;
    iVar8 = iVar7;
    thunk_FUN_00402510(&DAT_005ddea0);
    iVar3 = -(uint)(uVar6 < uVar5) - iVar7;
    if (iVar3 == 0 && uVar6 - uVar5 == 0 || iVar3 < 0) {
      DAT_005ddec0 = 0.0;
    }
    else {
      FUN_00464a40(uVar6 - uVar5,iVar3);
      dVar1 = (double)CONCAT44(uStack_24,iVar8);
      FUN_00464a40(uVar2,iVar4);
      DAT_005ddec0 = dVar1 / (double)CONCAT44(uStack_24,iVar8);
      DAT_005ddeb8 = in_stack_ffffffd4;
      DAT_005ddebc = in_stack_ffffffd8;
      FUN_004027c0(&DAT_005ddeb0,uVar5,iVar7);
    }
  }
  return;
}



/* Function: FUN_00428600 */

void FUN_00428600(int *param_1)

{
  int in_FS_OFFSET;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x428645;
    FUN_0046d980();
  }
  FUN_00428b20();
  *param_1 = local_4;
  FUN_00428e10();
  if (local_4 == 0) {
    FUN_00428b20();
  }
  param_1[1] = local_4;
  return;
}



/* Function: FUN_00428650 */

void FUN_00428650(void)

{
  int *piVar1;
  int iVar2;
  undefined1 *puVar3;
  int iVar4;
  int in_FS_OFFSET;
  bool bVar5;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0xc);
      piVar1 = *(int **)((int)register0x00000010 + 4);
      iVar2 = *piVar1;
      if (iVar2 == 0) {
        *(int **)((int)register0x00000010 + -0xc) = piVar1;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x4286cb;
        FUN_00428600();
        iVar4 = **(int **)((int)register0x00000010 + 4);
        bVar5 = false;
      }
      else if (*(int *)(iVar2 + 0xc) == 0x1fc) {
        iVar4 = piVar1[1];
        *piVar1 = iVar4;
        piVar1[1] = iVar2;
        bVar5 = *(int *)(iVar4 + 0xc) == 0x1fc;
        if (bVar5) {
          *(undefined4 *)((int)register0x00000010 + -4) = 0x1fc;
          *(int *)((int)register0x00000010 + -0xc) = iVar4;
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0x428699;
          FUN_00428db0();
          *(undefined1 *)(*(int *)((int)register0x00000010 + 4) + 0x18) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0x4286a6;
          FUN_00428b20();
          iVar4 = *(int *)((int)register0x00000010 + -0xc);
          **(int **)((int)register0x00000010 + 4) = iVar4;
          bVar5 = *(int *)((int)register0x00000010 + -4) == 0x1fc;
        }
      }
      else {
        bVar5 = false;
        iVar4 = iVar2;
      }
      if (*(uint *)(iVar4 + 0xc) < 0x1fc) {
        *(undefined4 *)(iVar4 + 0x10 + *(uint *)(iVar4 + 0xc) * 4) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(int *)(iVar4 + 0xc) = *(int *)(iVar4 + 0xc) + 1;
        if ((bVar5) && (DAT_005f5e04 == 1)) {
          *(undefined **)((int)register0x00000010 + -0xc) = &DAT_005f6780;
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0x428703;
          FUN_00422030();
        }
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x428711;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar3 + -4) = 0x428717;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00428720 */

void FUN_00428720(void)

{
  int iVar1;
  int *piVar2;
  uint uVar3;
  char cVar4;
  int iVar5;
  int iVar6;
  undefined1 *puVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x28);
      iVar9 = *(int *)((int)register0x00000010 + 0xc);
      if (iVar9 == 0) {
        return;
      }
      iVar8 = **(int **)((int)register0x00000010 + 4);
      if (iVar8 == 0) {
        *(int **)((int)register0x00000010 + -0x28) = *(int **)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x428751;
        FUN_00428600();
        iVar8 = **(int **)((int)register0x00000010 + 4);
        iVar9 = *(int *)((int)register0x00000010 + 0xc);
      }
      iVar5 = *(int *)((int)register0x00000010 + 0x10);
      iVar10 = *(int *)((int)register0x00000010 + 8);
      cVar4 = '\0';
      while( true ) {
        if (iVar9 == 0) {
          if ((cVar4 != '\0') && (DAT_005f5e04 == 1)) {
            *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f6780;
            *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x428837;
            FUN_00422030();
          }
          return;
        }
        *(int *)((int)register0x00000010 + -4) = iVar10;
        *(int *)((int)register0x00000010 + -8) = iVar5;
        *(int *)((int)register0x00000010 + -0xc) = iVar9;
        while (uVar3 = *(uint *)(iVar8 + 0xc), uVar3 == 0x1fc) {
          *(int *)((int)register0x00000010 + -0x28) = iVar8;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x428843;
          FUN_00428db0();
          *(undefined1 *)(*(int *)((int)register0x00000010 + 4) + 0x18) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x428850;
          FUN_00428b20();
          piVar2 = *(int **)((int)register0x00000010 + 4);
          iVar8 = piVar2[1];
          iVar9 = *(int *)((int)register0x00000010 + -0x28);
          *piVar2 = iVar8;
          piVar2[1] = iVar9;
          iVar9 = *(int *)((int)register0x00000010 + -0xc);
          iVar5 = *(int *)((int)register0x00000010 + -8);
          iVar10 = *(int *)((int)register0x00000010 + -4);
          cVar4 = '\x01';
        }
        if (0x1fc < uVar3) break;
        *(uint *)((int)register0x00000010 + -0x10) = -(uVar3 - 0x1fc);
        iVar1 = iVar8 + 0x10 + ((int)(uVar3 - 0x1fc) >> 0x1f & uVar3 << 2);
        iVar6 = iVar9;
        if (*(int *)((int)register0x00000010 + -0x10) <= iVar9) {
          iVar6 = *(int *)((int)register0x00000010 + -0x10);
        }
        *(int *)((int)register0x00000010 + -0x14) = iVar6;
        if (iVar10 != iVar1) {
          *(int *)((int)register0x00000010 + -0x18) = iVar8;
          *(char *)((int)register0x00000010 + -0x19) = cVar4;
          *(int *)((int)register0x00000010 + -0x28) = iVar1;
          *(int *)((int)register0x00000010 + -0x24) = iVar10;
          *(int *)((int)register0x00000010 + -0x20) = iVar6 << 2;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x4287fe;
          FUN_0046f640();
          cVar4 = *(char *)((int)register0x00000010 + -0x19);
          iVar5 = *(int *)((int)register0x00000010 + -8);
          iVar6 = *(int *)((int)register0x00000010 + -0x14);
          iVar8 = *(int *)((int)register0x00000010 + -0x18);
          iVar9 = *(int *)((int)register0x00000010 + -0xc);
          iVar10 = *(int *)((int)register0x00000010 + -4);
        }
        *(int *)(iVar8 + 0xc) = *(int *)(iVar8 + 0xc) + iVar6;
        iVar5 = iVar5 - iVar6;
        iVar10 = iVar10 + (-iVar5 >> 0x1f & iVar6 << 2);
        iVar9 = iVar9 - *(int *)((int)register0x00000010 + -0x14);
      }
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x42888c;
      FUN_0046ee50();
    }
    *(undefined4 *)(puVar7 + -4) = 0x428892;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_004288a0 */

void FUN_004288a0(void)

{
  uint uVar1;
  int iVar2;
  int *piVar3;
  int iVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x10);
      piVar3 = *(int **)((int)register0x00000010 + 4);
      iVar4 = *piVar3;
      if (iVar4 == 0) {
        *(int **)((int)register0x00000010 + -0x10) = piVar3;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4288c9;
        FUN_00428600();
        piVar3 = *(int **)((int)register0x00000010 + 4);
        iVar4 = *piVar3;
      }
      if (*(int *)(iVar4 + 0xc) == 0) {
        iVar4 = piVar3[1];
        iVar2 = *piVar3;
        *piVar3 = iVar4;
        piVar3[1] = iVar2;
        if (*(int *)(iVar4 + 0xc) == 0) {
          *(int *)((int)register0x00000010 + -4) = iVar4;
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4288f2;
          FUN_00428e10();
          if (*(int *)((int)register0x00000010 + -0x10) == 0) {
            *(undefined4 *)((int)register0x00000010 + 8) = 0;
            return;
          }
          *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x10) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0x428909;
          FUN_00428d50();
          iVar4 = *(int *)((int)register0x00000010 + -8);
          **(int **)((int)register0x00000010 + 4) = iVar4;
        }
      }
      iVar2 = *(int *)(iVar4 + 0xc);
      uVar1 = iVar2 - 1;
      *(uint *)(iVar4 + 0xc) = uVar1;
      if (uVar1 < 0x1fc) {
        *(undefined4 *)((int)register0x00000010 + 8) = *(undefined4 *)(iVar4 + 0xc + iVar2 * 4);
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x428947;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar5 + -4) = 0x42894d;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00428960 */

void FUN_00428960(int *param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar1 = *param_1;
  if (iVar1 != 0) {
    if (*(int *)(iVar1 + 0xc) == 0) {
      FUN_00428d50(iVar1);
    }
    else {
      FUN_00428db0(iVar1);
      *(undefined1 *)(param_1 + 6) = 1;
    }
    *param_1 = 0;
    iVar1 = param_1[1];
    if (*(int *)(iVar1 + 0xc) == 0) {
      FUN_00428d50(iVar1);
    }
    else {
      FUN_00428db0(iVar1);
      *(undefined1 *)(param_1 + 6) = 1;
    }
    param_1[1] = 0;
  }
  if (param_1[2] != 0 || param_1[3] != 0) {
    FUN_004026b0(&DAT_005d7648,param_1[2],param_1[3]);
    param_1[2] = 0;
    param_1[3] = 0;
  }
  if (param_1[4] != 0 || param_1[5] != 0) {
    thunk_FUN_004026b0(&DAT_005f6820,param_1[4],param_1[5]);
    param_1[4] = 0;
    param_1[5] = 0;
  }
  return;
}



/* Function: FUN_00428a80 */

void FUN_00428a80(int *param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  int iVar2;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x428b0c;
    FUN_0046d980();
  }
  iVar1 = *param_1;
  if (iVar1 != 0) {
    iVar2 = param_1[1];
    if (*(int *)(iVar2 + 0xc) == 0) {
      if (*(int *)(iVar1 + 0xc) < 5) {
        return;
      }
      FUN_00428e80(iVar1);
      *param_1 = local_4;
      *(undefined1 *)(param_1 + 6) = 1;
    }
    else {
      FUN_00428db0();
      *(undefined1 *)(param_1 + 6) = 1;
      FUN_00428b20();
      param_1[1] = iVar2;
    }
    if (DAT_005f5e04 == 1) {
      FUN_00422030(&DAT_005f6780);
    }
    return;
  }
  return;
}



/* Function: FUN_00428b20 */

void FUN_00428b20(void)

{
  int iVar1;
  int iVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x24);
      if (DAT_005d75ec == 0 && DAT_005d75e8 == 0) {
        iVar1 = 0;
LAB_00428b79:
        if (iVar1 != 0) goto LAB_00428c57;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
        if (DAT_005d7634 != 0) {
          *(undefined **)((int)register0x00000010 + -0x24) = &DAT_005d7630;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428ba3;
          FUN_0040ecf0();
          *(int *)((int)register0x00000010 + -0x1c) = DAT_005d7634;
          if (DAT_005d7634 != 0) {
            *(int **)((int)register0x00000010 + -0x24) = &DAT_005d7634;
            *(int *)((int)register0x00000010 + -0x20) = DAT_005d7634;
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428bc3;
            FUN_0042b350();
            *(undefined4 **)((int)register0x00000010 + -0x24) = &DAT_005d763c;
            *(undefined4 *)((int)register0x00000010 + -0x20) =
                 *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428bd9;
            FUN_0042b4b0();
          }
          *(undefined **)((int)register0x00000010 + -0x24) = &DAT_005d7630;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428be9;
          FUN_0040f0e0();
        }
        if (*(int *)((int)register0x00000010 + -0x1c) != 0) goto LAB_00428c51;
        *(undefined1 **)((int)register0x00000010 + -8) = &LAB_00428d00;
        *(undefined1 **)((int)register0x00000010 + -4) =
             (undefined1 *)((int)register0x00000010 + -0x1c);
        *(undefined1 **)((int)register0x00000010 + -0x24) =
             (undefined1 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428c0f;
        FUN_0046d890();
        if (*(int *)((int)register0x00000010 + -0x1c) != 0) {
          *(undefined **)((int)register0x00000010 + -0x24) = &DAT_005d7630;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428c2b;
          FUN_0040ecf0();
          *(undefined4 **)((int)register0x00000010 + -0x24) = &DAT_005d763c;
          *(undefined4 *)((int)register0x00000010 + -0x20) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428c41;
          FUN_0042b4b0();
          *(undefined **)((int)register0x00000010 + -0x24) = &DAT_005d7630;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428c51;
          FUN_0040f0e0();
LAB_00428c51:
          iVar1 = 0;
          iVar2 = 0;
          while (iVar2 + 0x800U < 0x8001) {
            *(int *)((int)register0x00000010 + -0x18) = iVar2;
            *(uint *)((int)register0x00000010 + -0x10) = iVar2 + 0x800U;
            *(int *)((int)register0x00000010 + -0x14) = iVar1;
            iVar2 = iVar2 + *(int *)(*(int *)((int)register0x00000010 + -0x1c) + 0xc);
            *(int *)((int)register0x00000010 + -0xc) = iVar2;
            *(undefined4 *)(iVar2 + 0xc) = 0;
            *(int *)((int)register0x00000010 + -0x24) = iVar2;
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428c9b;
            FUN_0040e5d0();
            if (*(int *)((int)register0x00000010 + -0x18) == 0) {
              iVar1 = *(int *)((int)register0x00000010 + -0xc);
            }
            else {
              *(undefined4 *)((int)register0x00000010 + -0x24) =
                   *(undefined4 *)((int)register0x00000010 + -0xc);
              *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428cb5;
              FUN_00428d50();
              iVar1 = *(int *)((int)register0x00000010 + -0x14);
            }
            iVar2 = *(int *)((int)register0x00000010 + -0x10);
          }
LAB_00428c57:
          *(int *)((int)register0x00000010 + 4) = iVar1;
          return;
        }
        *(char **)((int)register0x00000010 + -0x24) =
             "out of memory is nil, not value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0xd;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428cd5;
        FUN_00469a20();
      }
      else {
        *(int **)((int)register0x00000010 + -0x24) = &DAT_005d75e8;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428b65;
        FUN_0040e520();
        iVar1 = *(int *)((int)register0x00000010 + -0x20);
        if ((iVar1 == 0) || (*(int *)(iVar1 + 0xc) == 0)) goto LAB_00428b79;
      }
      *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c6874;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x428ceb;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x428cf1;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00428d50 */

void FUN_00428d50(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -8);
      if (*(int *)(*(int *)((int)register0x00000010 + 4) + 0xc) == 0) {
        *(undefined4 **)((int)register0x00000010 + -8) = &DAT_005d75e8;
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x428d81;
        FUN_0040e4a0();
        return;
      }
      *(undefined **)((int)register0x00000010 + -8) = &DAT_004c6874;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x428d9b;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x428da1;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00428db0 */

void FUN_00428db0(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -8);
      if (*(int *)(*(int *)((int)register0x00000010 + 4) + 0xc) != 0) {
        *(undefined4 **)((int)register0x00000010 + -8) = &DAT_005d75a0;
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x428de1;
        FUN_0040e4a0();
        return;
      }
      *(char **)((int)register0x00000010 + -8) =
           "workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x428dfb;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x428e01;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00428e10 */

void FUN_00428e10(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -8);
      *(undefined4 **)((int)register0x00000010 + -8) = &DAT_005d75a0;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x428e31;
      FUN_0040e520();
      iVar1 = *(int *)((int)register0x00000010 + -4);
      if (iVar1 == 0) {
        *(undefined4 *)((int)register0x00000010 + 4) = 0;
        return;
      }
      if (*(int *)(iVar1 + 0xc) != 0) {
        *(int *)((int)register0x00000010 + 4) = iVar1;
        return;
      }
      *(char **)((int)register0x00000010 + -8) =
           "workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x428e6b;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x428e71;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00428e80 */

void FUN_00428e80(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x428e98;
      FUN_00428b20();
      iVar1 = *(int *)((int)register0x00000010 + -0x10);
      iVar2 = *(int *)((int)register0x00000010 + 4);
      iVar4 = *(int *)(iVar2 + 0xc) / 2;
      *(int *)(iVar2 + 0xc) = *(int *)(iVar2 + 0xc) - iVar4;
      *(int *)(iVar1 + 0xc) = iVar4;
      uVar3 = *(uint *)(iVar2 + 0xc);
      if (uVar3 < 0x1fc) {
        *(int *)((int)register0x00000010 + -4) = iVar1;
        *(int *)((int)register0x00000010 + -0x10) = iVar1 + 0x10;
        *(uint *)((int)register0x00000010 + -0xc) = iVar2 + 0x10 + uVar3 * 4;
        *(int *)((int)register0x00000010 + -8) = iVar4 << 2;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x428edc;
        FUN_0046f640();
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x428ee8;
        FUN_00428db0();
        *(undefined4 *)((int)register0x00000010 + 8) = *(undefined4 *)((int)register0x00000010 + -4)
        ;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x428f00;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar5 + -4) = 0x428f06;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00428f10 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_00428f10(void)

{
  undefined4 *puVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -8);
      *(undefined **)((int)register0x00000010 + -8) = &DAT_005d7630;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x428f37;
      FUN_0040ecf0();
      if (DAT_005d75a4 == 0 && DAT_005d75a0 == 0) {
        DAT_005d75e8 = 0;
        DAT_005d75ec = 0;
        puVar1 = DAT_005d763c;
        if (DAT_005d763c != (undefined4 *)0x0) {
          for (; puVar1 != (undefined4 *)0x0; puVar1 = (undefined4 *)*puVar1) {
            puVar1[2] = &DAT_005d7634;
          }
          if (DAT_005d7634 == (undefined4 *)0x0) {
            DAT_005d7634 = DAT_005d763c;
            _DAT_005d7638 = DAT_005d7640;
          }
          else {
            *DAT_005d7640 = DAT_005d7634;
            DAT_005d7634[1] = DAT_005d7640;
            DAT_005d7634 = DAT_005d763c;
          }
          DAT_005d763c = (undefined4 *)0x0;
          DAT_005d7640 = (undefined4 *)0x0;
        }
        *(undefined **)((int)register0x00000010 + -8) = &DAT_005d7630;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x428f85;
        FUN_0040f0e0();
        return;
      }
      *(undefined **)((int)register0x00000010 + -8) = &DAT_004cbf08;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x28;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x42900b;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x429011;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00429020 */

void FUN_00429020(undefined1 param_1)

{
  int in_FS_OFFSET;
  undefined1 *local_8;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x4290c4;
    FUN_0046d980();
  }
  FUN_0040ecf0(&DAT_005d7630);
  if ((DAT_005f5e04 == 0) && (DAT_005d7634 != 0)) {
    local_8 = &LAB_004290d0;
    local_4 = CONCAT31(local_4._1_3_,param_1);
    FUN_0046d890(&local_8);
    FUN_0040f0e0(&DAT_005d7630,DAT_005d7634);
    return;
  }
  FUN_0040f0e0(&DAT_005d7630);
  return;
}



/* Function: FUN_00429300 */

void FUN_00429300(uint param_1)

{
  int iVar1;
  char local_8;
  
  iVar1 = *(int *)(DAT_005ddf14 + (param_1 >> 0x16) * 4);
  if (iVar1 == 0) {
    iVar1 = 0;
  }
  else {
    iVar1 = *(int *)(iVar1 + (param_1 >> 0xb & 0x7fc));
  }
  if (iVar1 != 0) {
    FUN_00402470(iVar1 + 0x3f);
  }
  if (((iVar1 != 0 && local_8 == '\x01') && (*(uint *)(iVar1 + 0xc) <= param_1)) &&
     (param_1 < *(uint *)(iVar1 + 0x48))) {
    return;
  }
  return;
}



/* Function: FUN_00429380 */

void FUN_00429380(int param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  uint uVar2;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00417f10(param_1 + 0x4590,0x60,&PTR_LAB_00536c50,param_1,&DAT_005f84d8);
  FUN_00417f10(param_1 + 0x45b8,600,0,0,&DAT_005f84e0);
  FUN_00417f10(param_1 + 0x45e0,0x1c,0,0,&DAT_005f84f8);
  FUN_00417f10(param_1 + 0x4608,0x18,0,0,&DAT_005f84f8);
  FUN_00417f10(param_1 + 0x4630,0x10,0,0,&DAT_005f84f8);
  FUN_00417f10(param_1 + 0x4658,0x10,0,0,&DAT_005f84f8);
  FUN_00417f10(param_1 + 0x4680,0x10,0,0,&DAT_005f84f8);
  FUN_00417f10(param_1 + 0x46a8,0x10,0,0,&DAT_005f84f0);
  uVar2 = 0;
  FUN_00417f10(param_1 + 0x46d4,0xc,0,0,&DAT_005f84f8);
  *(undefined1 *)(param_1 + 0x45b4) = 0;
  for (iVar1 = 0; iVar1 < 0x88; iVar1 = iVar1 + 1) {
    *(char *)(param_1 + 400 + iVar1 * 0x80) = (char)iVar1;
  }
  FUN_0042c740(param_1 + 8,param_1,&DAT_005f84f0,uVar2 & 0xffffff00);
  return;
}



/* Function: FUN_004295c0 */

void FUN_004295c0(int param_1,uint param_2)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  bool bVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  int in_FS_OFFSET;
  int iVar10;
  uint in_stack_ffffffb0;
  uint in_stack_ffffffb4;
  int in_stack_ffffffb8;
  uint local_3c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar5 = param_1 + 0xe8;
  iVar9 = iVar5;
  FUN_004027a0(iVar5);
  if (0x7fffffff < in_stack_ffffffb4) {
    return;
  }
  iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
  *piVar1 = *piVar1 + 1;
  iVar2 = *(int *)(iVar2 + 0x18);
  if (DAT_005d7d30 == '\0') {
    uVar7 = 0;
    iVar8 = 0;
  }
  else {
    iVar8 = iVar9;
    uVar7 = in_stack_ffffffb0;
    FUN_0045e520();
    iVar9 = iVar8;
    in_stack_ffffffb0 = uVar7;
  }
  if (uVar7 != 0) {
    FUN_0045ece0(iVar8,uVar7);
    FUN_0045e630(iVar8);
    iVar9 = iVar8;
    in_stack_ffffffb0 = uVar7;
  }
  uVar7 = *(uint *)(param_1 + 0x170);
  uVar3 = *(uint *)(param_1 + 0x16c);
  iVar8 = *(int *)(param_1 + 0x174);
  bVar4 = false;
LAB_004296bc:
  do {
    if (param_2 == 0) {
LAB_00429806:
      if (bVar4) {
        FUN_0040f0e0(param_1);
        iVar9 = param_1;
      }
      if (DAT_005d7d30 == '\0') {
        in_stack_ffffffb0 = 0;
        iVar9 = 0;
      }
      else {
        FUN_0045e520();
      }
      if (in_stack_ffffffb0 != 0) {
        FUN_0045ee40(iVar9,in_stack_ffffffb0);
        FUN_0045e630(iVar9,in_stack_ffffffb0);
      }
      iVar9 = *(int *)(iVar2 + 0x7c);
      iVar5 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      *(int *)(iVar2 + 0x7c) = iVar9 + -1;
      if ((iVar9 == 1) && (*(char *)(iVar5 + 0x69) != '\0')) {
        *(undefined4 *)(iVar5 + 8) = 0xfffffade;
      }
      return;
    }
    iVar9 = param_1 + 0xf0;
    thunk_FUN_00402510(iVar9);
    if (in_stack_ffffffb0 != 0) {
      uVar6 = param_2;
      if (in_stack_ffffffb0 <= param_2) {
        uVar6 = in_stack_ffffffb0;
      }
      thunk_FUN_00402540();
      if ((char)in_stack_ffffffb8 != '\0') {
        param_2 = param_2 - uVar6;
      }
      goto LAB_004296bc;
    }
    FUN_004026b0(iVar5,0x200,0);
    uVar6 = in_stack_ffffffb8 - 0x200;
    if (uVar7 <= uVar6 >> 9) {
      in_stack_ffffffb0 = 0;
      FUN_004027c0(iVar5,0,0x80000000);
      iVar9 = iVar5;
      goto LAB_00429806;
    }
    if (!bVar4) {
      FUN_0040ecf0(param_1);
    }
    iVar10 = param_1;
    in_stack_ffffffb0 = uVar3;
    in_stack_ffffffb8 = iVar8;
    FUN_004298b0(param_1,uVar3,uVar7,iVar8,uVar6,0x200);
    if (param_2 < local_3c) {
      in_stack_ffffffb0 = local_3c - param_2;
      thunk_FUN_00402690();
      param_2 = 0;
    }
    else {
      param_2 = param_2 - local_3c;
      iVar9 = iVar10;
    }
    bVar4 = true;
  } while( true );
}



/* Function: FUN_004298b0 */

void FUN_004298b0(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined1 *puVar5;
  byte bVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  undefined4 uVar10;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -100);
      *(undefined **)((int)register0x00000010 + -100) = &DAT_005d716c;
      *(undefined4 *)((int)register0x00000010 + -0x68) = 0x4298db;
      FUN_004265a0();
      *(undefined4 *)((int)register0x00000010 + -0x4c) =
           *(undefined4 *)((int)register0x00000010 + -0x60);
      *(char *)((int)register0x00000010 + -0x48) = *(char *)((int)register0x00000010 + -0x5c);
      if (*(char *)((int)register0x00000010 + -0x5c) == '\0') {
        *(undefined4 *)((int)register0x00000010 + 0x1c) = 0;
        return;
      }
      uVar3 = *(uint *)((int)register0x00000010 + 0x18);
      iVar8 = *(int *)((int)register0x00000010 + 4);
      iVar7 = *(int *)((int)register0x00000010 + 8);
      uVar1 = *(uint *)((int)register0x00000010 + 0xc);
      uVar9 = *(uint *)((int)register0x00000010 + 0x14);
      uVar10 = 0;
      while( true ) {
        if (uVar3 == 0) {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = uVar10;
          *(undefined **)((int)register0x00000010 + -100) = &DAT_005d716c;
          *(undefined4 *)((int)register0x00000010 + -0x60) =
               *(undefined4 *)((int)register0x00000010 + -0x4c);
          *(undefined1 *)((int)register0x00000010 + -0x5c) =
               *(undefined1 *)((int)register0x00000010 + -0x48);
          *(undefined4 *)((int)register0x00000010 + -0x68) = 0x4299ef;
          FUN_00426620();
          if (DAT_005d7d30 == '\0') {
            iVar8 = 0;
            uVar10 = 0;
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429a05;
            FUN_0045e520();
            uVar10 = *(undefined4 *)((int)register0x00000010 + -100);
            iVar8 = *(int *)((int)register0x00000010 + -0x60);
          }
          if (iVar8 != 0) {
            *(int *)((int)register0x00000010 + -0x50) = iVar8;
            *(undefined4 *)((int)register0x00000010 + -0x10) = uVar10;
            *(int *)((int)register0x00000010 + -0x14) =
                 (*(int *)((int)register0x00000010 + 0x18) -
                 *(int *)((int)register0x00000010 + -0x3c)) * 0x2000;
            *(undefined4 *)((int)register0x00000010 + -100) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429a37;
            FUN_0040f0e0();
            *(undefined4 *)((int)register0x00000010 + -100) =
                 *(undefined4 *)((int)register0x00000010 + -0x10);
            *(undefined4 *)((int)register0x00000010 + -0x60) =
                 *(undefined4 *)((int)register0x00000010 + -0x50);
            *(undefined4 *)((int)register0x00000010 + -0x5c) =
                 *(undefined4 *)((int)register0x00000010 + -0x14);
            *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429a53;
            FUN_0045ed50();
            *(undefined4 *)((int)register0x00000010 + -100) =
                 *(undefined4 *)((int)register0x00000010 + -0x10);
            *(undefined4 *)((int)register0x00000010 + -0x60) =
                 *(undefined4 *)((int)register0x00000010 + -0x50);
            *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429a67;
            FUN_0045e630();
            *(undefined4 *)((int)register0x00000010 + -100) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429a75;
            FUN_0040ecf0();
          }
          *(undefined4 *)((int)register0x00000010 + 0x1c) =
               *(undefined4 *)((int)register0x00000010 + -0x3c);
          return;
        }
        *(uint *)((int)register0x00000010 + -0x14) = uVar9;
        if (uVar1 <= uVar9 >> 9) goto LAB_00429c20;
        uVar9 = *(uint *)(iVar7 + (uVar9 >> 9) * 4);
        if (0x3ff < uVar9) goto LAB_00429c14;
        iVar8 = *(int *)(iVar8 + 0x134);
        *(uint *)((int)register0x00000010 + -0x18) =
             *(uint *)((int)register0x00000010 + -0x14) & 0x1ff;
        uVar4 = (*(uint *)((int)register0x00000010 + -0x14) & 0x1ff) >> 3;
        iVar8 = *(int *)(iVar8 + uVar9 * 4);
        if (0x40 < uVar4) break;
        *(int *)((int)register0x00000010 + -0x30) = iVar8;
        *(uint *)((int)register0x00000010 + -0x38) = -(uVar4 - 0x40);
        uVar4 = uVar4 & (int)(uVar4 - 0x40) >> 0x1f;
        iVar7 = iVar8 + 0x800 + uVar4;
        uVar2 = uVar3 >> 3;
        if (*(uint *)((int)register0x00000010 + -0x38) <= uVar3 >> 3) {
          uVar2 = *(uint *)((int)register0x00000010 + -0x38);
        }
        *(uint *)((int)register0x00000010 + -0x1c) = uVar3;
        *(uint *)((int)register0x00000010 + -0x38) = uVar2;
        *(int *)((int)register0x00000010 + -8) = iVar7;
        *(uint *)((int)register0x00000010 + -0xc) = iVar8 + 0x840 + uVar4;
        iVar8 = 0;
        while (iVar8 < (int)uVar2) {
          *(int *)((int)register0x00000010 + -0x34) = iVar8;
          *(undefined4 *)((int)register0x00000010 + -0x20) = uVar10;
          *(int *)((int)register0x00000010 + -4) = iVar7 + iVar8;
          *(int *)((int)register0x00000010 + -100) = iVar7 + iVar8;
          *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429ab7;
          FUN_00402470();
          uVar9 = *(uint *)((int)register0x00000010 + -0x34);
          if (*(uint *)((int)register0x00000010 + -0x38) <= uVar9) {
LAB_00429c03:
            *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429c08;
            FUN_0046edf0();
            goto LAB_00429c08;
          }
          bVar6 = ~*(byte *)(uVar9 + *(int *)((int)register0x00000010 + -0xc)) &
                  *(byte *)((int)register0x00000010 + -0x60);
          if (bVar6 == 0) {
            uVar10 = *(undefined4 *)((int)register0x00000010 + -0x20);
          }
          else {
            uVar10 = *(undefined4 *)((int)register0x00000010 + -0x20);
            for (uVar3 = 0; uVar3 < 8; uVar3 = uVar3 + 1) {
              if (((byte)(1 << ((byte)uVar3 & 0x1f)) & bVar6) != 0) {
                uVar9 = *(int *)((int)register0x00000010 + -0x18) + uVar9 * 8 + uVar3;
                if (0x1ff < uVar9) {
                  *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429c03;
                  FUN_0046ee00();
                  goto LAB_00429c03;
                }
                *(uint *)((int)register0x00000010 + -0x24) = uVar3;
                *(undefined4 *)((int)register0x00000010 + -0x28) = uVar10;
                *(byte *)((int)register0x00000010 + -0x51) = bVar6;
                uVar10 = *(undefined4 *)(*(int *)((int)register0x00000010 + -0x30) + uVar9 * 4);
                *(undefined1 **)((int)register0x00000010 + -100) =
                     (undefined1 *)((int)register0x00000010 + -0x4c);
                *(undefined4 *)((int)register0x00000010 + -0x60) = uVar10;
                *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429b49;
                FUN_00426b10();
                *(int *)((int)register0x00000010 + -0x44) =
                     *(int *)((int)register0x00000010 + -0x5c);
                if (*(char *)((int)register0x00000010 + -0x58) == '\0') {
                  uVar9 = *(uint *)((int)register0x00000010 + -0x34);
                  bVar6 = *(byte *)((int)register0x00000010 + -0x51);
                  uVar10 = *(undefined4 *)((int)register0x00000010 + -0x28);
                }
                else {
                  *(undefined4 *)((int)register0x00000010 + -0x40) =
                       *(undefined4 *)(*(int *)((int)register0x00000010 + -0x5c) + 0x10);
                  *(undefined4 *)((int)register0x00000010 + -100) =
                       *(undefined4 *)((int)register0x00000010 + 4);
                  *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429b82;
                  FUN_0040f0e0();
                  *(undefined1 **)((int)register0x00000010 + -100) =
                       (undefined1 *)((int)register0x00000010 + -0x44);
                  *(undefined1 *)((int)register0x00000010 + -0x60) = 0;
                  *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429b93;
                  FUN_00426f80();
                  if (*(char *)((int)register0x00000010 + -0x5c) == '\0') {
                    iVar8 = *(int *)((int)register0x00000010 + -0x28);
                  }
                  else {
                    iVar8 = *(int *)((int)register0x00000010 + -0x28) +
                            *(int *)((int)register0x00000010 + -0x40);
                  }
                  *(int *)((int)register0x00000010 + -0x2c) = iVar8;
                  *(undefined4 *)((int)register0x00000010 + -100) =
                       *(undefined4 *)((int)register0x00000010 + 4);
                  *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429bbf;
                  FUN_0040ecf0();
                  *(undefined4 *)((int)register0x00000010 + -100) =
                       *(undefined4 *)((int)register0x00000010 + -4);
                  *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429bcb;
                  FUN_00402470();
                  uVar9 = *(uint *)((int)register0x00000010 + -0x34);
                  bVar6 = *(byte *)((int)register0x00000010 + -0x60) &
                          ~*(byte *)(uVar9 + *(int *)((int)register0x00000010 + -0xc));
                  uVar10 = *(undefined4 *)((int)register0x00000010 + -0x2c);
                }
                uVar3 = *(uint *)((int)register0x00000010 + -0x24);
              }
            }
          }
          uVar3 = *(uint *)((int)register0x00000010 + -0x1c);
          uVar1 = *(uint *)((int)register0x00000010 + 0xc);
          uVar2 = *(uint *)((int)register0x00000010 + -0x38);
          iVar7 = *(int *)((int)register0x00000010 + -8);
          iVar8 = uVar9 + 1;
        }
        uVar9 = *(int *)((int)register0x00000010 + -0x14) + uVar2 * 8;
        uVar3 = uVar3 + uVar2 * -8;
        iVar8 = *(int *)((int)register0x00000010 + 4);
        iVar7 = *(int *)((int)register0x00000010 + 8);
      }
LAB_00429c08:
      *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429c14;
      FUN_0046ee60();
LAB_00429c14:
      *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429c20;
      FUN_0046ee00();
LAB_00429c20:
      *(undefined4 *)((int)register0x00000010 + -0x68) = 0x429c27;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar5 + -4) = 0x429c2d;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00429c40 */

void FUN_00429c40(undefined4 param_1,undefined4 param_2,undefined1 param_3)

{
  int in_FS_OFFSET;
  undefined4 local_18;
  undefined1 *local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 *local_8;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x429cae;
    FUN_0046d980();
  }
  local_18 = 0;
  FUN_0046ef4b();
  local_14 = &LAB_00429cb0;
  local_10 = param_1;
  local_c = param_2;
  local_8 = &local_18;
  local_4 = CONCAT31(local_4._1_3_,param_3);
  FUN_0046d890(&local_14);
  return;
}



/* Function: FUN_00429d50 */

void FUN_00429d50(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x10);
      if (*(char *)((int)register0x00000010 + 0xc) != '\0') {
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(char *)((int)register0x00000010 + -8) = *(char *)((int)register0x00000010 + 0xc);
        *(undefined1 *)((int)register0x00000010 + -7) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x429d89;
        FUN_0042a080();
        *(undefined4 *)((int)register0x00000010 + 0x10) =
             *(undefined4 *)((int)register0x00000010 + -4);
        return;
      }
      *(char **)((int)register0x00000010 + -0x10) =
           "manual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
      ;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x3c;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x429dab;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x429db1;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00429dc0 */

void FUN_00429dc0(int param_1,uint param_2,uint param_3,undefined4 param_4)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar1 = *(int *)(*(int *)(param_1 + 0x134) + (param_2 >> 0x16) * 4);
  for (uVar3 = 0; uVar3 < param_3; uVar3 = uVar3 + 1) {
    uVar2 = (param_2 >> 0xd) + uVar3 & 0x1ff;
    if (uVar2 == 0) {
      iVar1 = *(int *)(*(int *)(param_1 + 0x134) + (uVar3 * 0x2000 + param_2 >> 0x16) * 4);
    }
    *(undefined4 *)(iVar1 + uVar2 * 4) = param_4;
  }
  return;
}



/* Function: FUN_00429e50 */

void FUN_00429e50(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  byte bVar5;
  uint uVar6;
  undefined1 *puVar7;
  int in_FS_OFFSET;
  
  while (puVar7 = (undefined1 *)register0x00000010,
        register0x00000010 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
LAB_00429f8e:
    *(undefined4 *)(puVar7 + -4) = 0x429f93;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  }
  puVar7 = (undefined1 *)((int)register0x00000010 + -0x28);
  iVar2 = *(int *)((int)register0x00000010 + 0xc);
  uVar3 = *(uint *)((int)register0x00000010 + 8);
  bVar5 = 0;
  do {
    if (iVar2 == 0) {
      *(byte *)((int)register0x00000010 + 0x10) = bVar5;
      return;
    }
    *(int *)((int)register0x00000010 + -8) = iVar2;
    *(byte *)((int)register0x00000010 + -0x15) = bVar5;
    *(uint *)((int)register0x00000010 + -0x14) = uVar3;
    iVar1 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x134);
    *(uint *)((int)register0x00000010 + -0xc) = uVar3 & 0x3fffff;
    *(uint *)((int)register0x00000010 + -0x10) = iVar2 * 0x2000 + (uVar3 & 0x3fffff);
    iVar2 = *(int *)(iVar1 + (uVar3 >> 0x16) * 4) + 0x8c4;
    *(int *)((int)register0x00000010 + -4) = iVar2;
    *(int *)((int)register0x00000010 + -0x28) = iVar2;
    *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x429ed6;
    thunk_FUN_00402510();
    uVar3 = *(uint *)((int)register0x00000010 + -0x24);
    uVar4 = *(uint *)((int)register0x00000010 + -0xc);
    bVar5 = uVar4 < uVar3 | *(byte *)((int)register0x00000010 + -0x15);
    uVar6 = *(uint *)((int)register0x00000010 + -0x10);
    if (0x400000 < uVar6) {
      uVar6 = 0x400000;
    }
    *(uint *)((int)register0x00000010 + -0x10) = uVar6;
    *(byte *)((int)register0x00000010 + -0x15) = bVar5;
    while (uVar3 < uVar6) {
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(uint *)((int)register0x00000010 + -0x24) = uVar3;
      *(uint *)((int)register0x00000010 + -0x20) = uVar6;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x429f46;
      thunk_FUN_00402540();
      if (*(char *)((int)register0x00000010 + -0x1c) != '\0') {
        uVar4 = *(uint *)((int)register0x00000010 + -0xc);
        bVar5 = *(byte *)((int)register0x00000010 + -0x15);
        uVar6 = *(uint *)((int)register0x00000010 + -0x10);
        break;
      }
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x429f5b;
      thunk_FUN_00402510();
      uVar3 = *(uint *)((int)register0x00000010 + -0x24);
      if (*(uint *)((int)register0x00000010 + -0x10) < uVar3) {
        uVar4 = *(uint *)((int)register0x00000010 + -0xc);
      }
      else {
        uVar4 = *(uint *)((int)register0x00000010 + -0xc);
        if (uVar4 < uVar3) {
          *(char **)((int)register0x00000010 + -0x28) =
               "potentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x33;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x429f8d;
          FUN_00469a20();
          goto LAB_00429f8e;
        }
      }
      bVar5 = *(byte *)((int)register0x00000010 + -0x15);
      uVar6 = *(uint *)((int)register0x00000010 + -0x10);
    }
    uVar3 = (uVar6 - uVar4) + *(int *)((int)register0x00000010 + -0x14);
    iVar2 = *(int *)((int)register0x00000010 + -8) - (uVar6 - uVar4 >> 0xd);
  } while( true );
}



/* Function: FUN_00429fa0 */

void FUN_00429fa0(int param_1)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int in_FS_OFFSET;
  undefined4 local_c;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc)) {
    local_4 = 0x42a06f;
    FUN_0046afb0();
  }
  iVar3 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
  if (iVar3 != 0) {
    if (*(int *)(iVar3 + 0x708) != 0) goto LAB_00429ffe;
    uVar1 = 0;
    local_4 = iVar3;
    do {
      iVar2 = param_1;
      if (0x3f < (int)uVar1) {
        *(undefined4 *)(local_4 + 0x708) = 0x40;
        iVar3 = local_4;
LAB_00429ffe:
        iVar2 = *(int *)(iVar3 + 0x708);
        uVar1 = iVar2 - 1;
        if (uVar1 < 0x80) {
          *(uint *)(iVar3 + 0x708) = uVar1;
          return;
        }
        FUN_0046edf0();
      }
      FUN_00418000(iVar2 + 0x4590);
      *(undefined4 *)(local_4 + 0x70c + uVar1 * 4) = local_c;
      uVar1 = uVar1 + 1;
    } while( true );
  }
  FUN_00418000(param_1 + 0x4590);
  return;
}



/* Function: FUN_0042a080 */

void FUN_0042a080(void)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  undefined4 uVar8;
  uint uVar9;
  uint uVar10;
  undefined4 uVar11;
  undefined1 *puVar12;
  int in_FS_OFFSET;
  bool bVar13;
  
  do {
    puVar12 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) <
        (undefined1 *)((int)register0x00000010 + -4)) {
      puVar12 = (undefined1 *)((int)register0x00000010 + -0x84);
      iVar5 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
      *(int *)((int)register0x00000010 + -4) = iVar5;
      if (iVar5 == 0) {
        iVar5 = 0;
        iVar7 = 0;
        uVar8 = 0;
LAB_0042a1be:
        *(undefined4 *)((int)register0x00000010 + -0x4c) = uVar8;
        *(int *)((int)register0x00000010 + -0x30) = iVar7;
        *(int *)((int)register0x00000010 + -0x34) = iVar5;
        *(undefined4 *)((int)register0x00000010 + -0x84) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a1dc;
        FUN_0040ecf0();
        iVar5 = *(int *)((int)register0x00000010 + -0x34);
        if (iVar5 != 0) {
          uVar11 = 0;
          uVar8 = *(undefined4 *)((int)register0x00000010 + -0x4c);
          goto LAB_0042a299;
        }
        *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + 4) + 8;
        *(int *)((int)register0x00000010 + -0x84) = *(int *)((int)register0x00000010 + 4) + 8;
        *(undefined4 *)((int)register0x00000010 + -0x80) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a210;
        FUN_0042e070();
        iVar5 = *(int *)((int)register0x00000010 + -0x7c);
        uVar8 = *(undefined4 *)((int)register0x00000010 + -0x78);
        if (iVar5 != 0) {
          uVar11 = 0;
          goto LAB_0042a299;
        }
        *(undefined4 *)((int)register0x00000010 + -0x84) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x80) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a23a;
        FUN_0042aa60();
        if (*(char *)((int)register0x00000010 + -0x78) == '\0') {
          *(undefined4 *)((int)register0x00000010 + -0x84) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a258;
          FUN_0040f0e0();
          *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x3c) =
             *(undefined4 *)((int)register0x00000010 + -0x7c);
        *(undefined4 *)((int)register0x00000010 + -0x84) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x80) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a285;
        FUN_0042e070();
        iVar5 = *(int *)((int)register0x00000010 + -0x7c);
        if (iVar5 != 0) {
          uVar8 = *(undefined4 *)((int)register0x00000010 + -0x78);
          uVar11 = *(undefined4 *)((int)register0x00000010 + -0x3c);
LAB_0042a299:
          *(undefined4 *)((int)register0x00000010 + -0x4c) = uVar8;
          *(int *)((int)register0x00000010 + -0x34) = iVar5;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = uVar11;
          iVar5 = *(int *)((int)register0x00000010 + -0x30);
          if (iVar5 == 0) {
            *(undefined4 *)((int)register0x00000010 + -0x84) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a2bc;
            FUN_00429fa0();
            iVar5 = *(int *)((int)register0x00000010 + -0x80);
          }
          *(int *)((int)register0x00000010 + -0x30) = iVar5;
          *(undefined4 *)((int)register0x00000010 + -0x84) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a2d5;
          FUN_0040f0e0();
          uVar11 = *(undefined4 *)((int)register0x00000010 + -0x3c);
          iVar7 = *(int *)((int)register0x00000010 + -0x30);
          iVar5 = *(int *)((int)register0x00000010 + -0x34);
          uVar8 = *(undefined4 *)((int)register0x00000010 + -0x4c);
LAB_0042a2e5:
          *(undefined4 *)((int)register0x00000010 + -0x4c) = uVar8;
          *(int *)((int)register0x00000010 + -0x34) = iVar5;
          *(int *)((int)register0x00000010 + -0x30) = iVar7;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = uVar11;
          *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f6788;
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a303;
          thunk_FUN_004027a0();
          *(undefined4 *)((int)register0x00000010 + -0x60) =
               *(undefined4 *)((int)register0x00000010 + -0x80);
          *(undefined4 *)((int)register0x00000010 + -0x54) =
               *(undefined4 *)((int)register0x00000010 + -0x7c);
          *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f61a4;
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a322;
          FUN_00402470();
          if (*(char *)((int)register0x00000010 + -0x80) == '\0') {
            *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f68b8;
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a340;
            FUN_004027a0();
            uVar10 = *(uint *)((int)register0x00000010 + -0x80) +
                     *(uint *)((int)register0x00000010 + -0x4c);
            uVar9 = *(int *)((int)register0x00000010 + -0x7c) +
                    (uint)CARRY4(*(uint *)((int)register0x00000010 + -0x80),
                                 *(uint *)((int)register0x00000010 + -0x4c));
            uVar6 = *(uint *)((int)register0x00000010 + -0x54);
            uVar4 = *(uint *)((int)register0x00000010 + -0x60);
            bVar13 = uVar6 < uVar9 || uVar6 == uVar9 && uVar4 < uVar10;
            if (uVar6 < uVar9 || uVar6 == uVar9 && uVar4 < uVar10) {
              iVar5 = uVar10 - uVar4;
            }
            else {
              iVar5 = 0;
            }
          }
          else {
            iVar5 = 0;
            bVar13 = false;
          }
          *(bool *)((int)register0x00000010 + -0x69) = bVar13;
          *(int *)((int)register0x00000010 + -0x38) = iVar5;
          *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f60a0;
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a38e;
          FUN_004027a0();
          if (*(int *)((int)register0x00000010 + -0x7c) == -1 &&
              *(int *)((int)register0x00000010 + -0x80) == -1) {
            iVar5 = *(int *)((int)register0x00000010 + -4);
            bVar13 = iVar5 == 0;
            uVar6 = *(uint *)((int)register0x00000010 + -0x38);
          }
          else if (*(int *)((int)register0x00000010 + -0x3c) == 0) {
            iVar5 = *(int *)((int)register0x00000010 + -4);
            bVar13 = iVar5 == 0;
            uVar6 = *(uint *)((int)register0x00000010 + -0x38);
          }
          else {
            *(int *)((int)register0x00000010 + -0x58) = *(int *)((int)register0x00000010 + -0x7c);
            *(int *)((int)register0x00000010 + -100) = *(int *)((int)register0x00000010 + -0x80);
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a3d3;
            FUN_00423b80();
            uVar4 = *(uint *)((int)register0x00000010 + -0x3c);
            uVar6 = *(uint *)((int)register0x00000010 + -0x84) + uVar4;
            uVar10 = *(int *)((int)register0x00000010 + -0x80) +
                     (uint)CARRY4(*(uint *)((int)register0x00000010 + -0x84),uVar4);
            if (*(uint *)((int)register0x00000010 + -0x58) == uVar10 &&
                *(uint *)((int)register0x00000010 + -100) < uVar6 ||
                *(uint *)((int)register0x00000010 + -0x58) < uVar10) {
              uVar6 = uVar6 - *(uint *)((int)register0x00000010 + -100);
              if (uVar4 <= uVar6) {
                uVar6 = uVar4;
              }
              if (*(uint *)((int)register0x00000010 + -0x38) < uVar6) {
                iVar5 = *(int *)((int)register0x00000010 + -4);
                bVar13 = iVar5 == 0;
              }
              else {
                iVar5 = *(int *)((int)register0x00000010 + -4);
                bVar13 = iVar5 == 0;
                uVar6 = *(uint *)((int)register0x00000010 + -0x38);
              }
            }
            else {
              iVar5 = *(int *)((int)register0x00000010 + -4);
              bVar13 = iVar5 == 0;
              uVar6 = *(uint *)((int)register0x00000010 + -0x38);
            }
          }
          if ((!bVar13) && (uVar6 != 0)) {
            *(uint *)((int)register0x00000010 + -0x38) = uVar6;
            *(int *)((int)register0x00000010 + -0xc) = iVar5 + 0x958;
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a46e;
            FUN_0046fa70();
            uVar8 = *(undefined4 *)((int)register0x00000010 + -0x84);
            *(undefined4 *)((int)register0x00000010 + -0x68) = uVar8;
            uVar11 = *(undefined4 *)((int)register0x00000010 + -0x80);
            *(undefined4 *)((int)register0x00000010 + -0x5c) = uVar11;
            *(undefined4 *)((int)register0x00000010 + -0x84) =
                 *(undefined4 *)((int)register0x00000010 + -0xc);
            *(undefined1 *)((int)register0x00000010 + -0x80) = 3;
            *(undefined4 *)((int)register0x00000010 + -0x7c) = uVar8;
            *(undefined4 *)((int)register0x00000010 + -0x78) = uVar11;
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a496;
            FUN_0041c970();
            *(undefined1 *)((int)register0x00000010 + -0x6a) =
                 *(undefined1 *)((int)register0x00000010 + -0x74);
            *(int *)((int)register0x00000010 + -0x84) = *(int *)((int)register0x00000010 + 4) + 8;
            *(undefined4 *)((int)register0x00000010 + -0x80) =
                 *(undefined4 *)((int)register0x00000010 + -0x38);
            *(undefined ***)((int)register0x00000010 + -0x7c) = &PTR_LAB_00536a78;
            *(undefined1 *)((int)register0x00000010 + -0x78) =
                 *(undefined1 *)((int)register0x00000010 + -0x69);
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a4ce;
            FUN_00424720();
            *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005dde7c;
            *(undefined4 *)((int)register0x00000010 + -0x80) =
                 *(undefined4 *)((int)register0x00000010 + -0x74);
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a4e5;
            thunk_FUN_00402690();
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a4eb;
            FUN_0046fa70();
            uVar6 = *(uint *)((int)register0x00000010 + -0x84);
            iVar5 = *(int *)((int)register0x00000010 + -0x80);
            if (*(char *)((int)register0x00000010 + -0x6a) != '\0') {
              *(int *)((int)register0x00000010 + -0x44) = iVar5;
              *(uint *)((int)register0x00000010 + -0x48) = uVar6;
              *(undefined4 *)((int)register0x00000010 + -0x84) =
                   *(undefined4 *)((int)register0x00000010 + -0xc);
              *(undefined1 *)((int)register0x00000010 + -0x80) = 3;
              *(uint *)((int)register0x00000010 + -0x7c) = uVar6;
              *(int *)((int)register0x00000010 + -0x78) = iVar5;
              *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a51c;
              FUN_0041cb30();
              uVar6 = *(uint *)((int)register0x00000010 + -0x48);
              iVar5 = *(int *)((int)register0x00000010 + -0x44);
            }
            *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f60b0;
            *(uint *)((int)register0x00000010 + -0x80) =
                 uVar6 - *(uint *)((int)register0x00000010 + -0x68);
            *(uint *)((int)register0x00000010 + -0x7c) =
                 (iVar5 - *(int *)((int)register0x00000010 + -0x5c)) -
                 (uint)(uVar6 < *(uint *)((int)register0x00000010 + -0x68));
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a546;
            thunk_FUN_004026b0();
          }
          *(undefined4 *)((int)register0x00000010 + -0x84) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x80) =
               *(undefined4 *)((int)register0x00000010 + -0x30);
          *(undefined1 *)((int)register0x00000010 + -0x7c) =
               *(undefined1 *)((int)register0x00000010 + 0xc);
          *(undefined1 *)((int)register0x00000010 + -0x7b) =
               *(undefined1 *)((int)register0x00000010 + 0xd);
          *(undefined4 *)((int)register0x00000010 + -0x78) =
               *(undefined4 *)((int)register0x00000010 + -0x34);
          *(undefined4 *)((int)register0x00000010 + -0x74) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a588;
          FUN_0042a7d0();
          iVar7 = *(int *)((int)register0x00000010 + 8) << 0xd;
          *(int *)((int)register0x00000010 + -0x40) = iVar7;
          iVar5 = *(int *)((int)register0x00000010 + -0x4c);
          if (iVar5 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x84) =
                 *(undefined4 *)((int)register0x00000010 + -0x34);
            *(int *)((int)register0x00000010 + -0x80) = iVar7;
            *(int *)((int)register0x00000010 + -0x7c) = iVar5;
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a5b2;
            FUN_00414df0();
            *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f6898;
            *(int *)((int)register0x00000010 + -0x80) = -*(int *)((int)register0x00000010 + -0x4c);
            *(uint *)((int)register0x00000010 + -0x7c) =
                 -(uint)(*(int *)((int)register0x00000010 + -0x4c) != 0);
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a5d8;
            FUN_00433860();
            iVar7 = *(int *)((int)register0x00000010 + -0x40);
            iVar5 = *(int *)((int)register0x00000010 + -0x4c);
          }
          *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f68a0;
          *(int *)((int)register0x00000010 + -0x80) = -(iVar7 - iVar5);
          *(uint *)((int)register0x00000010 + -0x7c) = -(uint)(iVar7 - iVar5 != 0);
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a604;
          FUN_00433860();
          if (*(char *)((int)register0x00000010 + 0xc) == '\0') {
            *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f6890;
            *(undefined4 *)((int)register0x00000010 + -0x80) =
                 *(undefined4 *)((int)register0x00000010 + -0x40);
            *(undefined4 *)((int)register0x00000010 + -0x7c) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a62e;
            FUN_00433860();
          }
          *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f7700;
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a63c;
          FUN_00433980();
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)((int)register0x00000010 + -0x80);
          *(undefined4 *)((int)register0x00000010 + -0x84) =
               *(undefined4 *)((int)register0x00000010 + -0x80);
          *(undefined4 *)((int)register0x00000010 + -0x80) =
               *(undefined4 *)((int)register0x00000010 + -0x4c);
          *(undefined4 *)((int)register0x00000010 + -0x7c) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a65e;
          thunk_FUN_004026b0();
          *(int *)((int)register0x00000010 + -0x84) = *(int *)((int)register0x00000010 + -0x14) + 8;
          *(int *)((int)register0x00000010 + -0x80) = -*(int *)((int)register0x00000010 + -0x4c);
          *(uint *)((int)register0x00000010 + -0x7c) =
               -(uint)(*(int *)((int)register0x00000010 + -0x4c) != 0);
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a685;
          thunk_FUN_004026b0();
          bVar1 = *(byte *)((int)register0x00000010 + 0xc);
          if (bVar1 < 2) {
            if (bVar1 == 0) {
              *(int *)((int)register0x00000010 + -0x84) =
                   *(int *)((int)register0x00000010 + -0x14) + 0x10;
              *(undefined4 *)((int)register0x00000010 + -0x80) =
                   *(undefined4 *)((int)register0x00000010 + -0x40);
              *(undefined4 *)((int)register0x00000010 + -0x7c) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a6b5;
              thunk_FUN_004026b0();
            }
            else {
              *(int *)((int)register0x00000010 + -0x84) =
                   *(int *)((int)register0x00000010 + -0x14) + 0x18;
              *(undefined4 *)((int)register0x00000010 + -0x80) =
                   *(undefined4 *)((int)register0x00000010 + -0x40);
              *(undefined4 *)((int)register0x00000010 + -0x7c) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a6d6;
              thunk_FUN_004026b0();
            }
          }
          else if (bVar1 == 2) {
            *(int *)((int)register0x00000010 + -0x84) =
                 *(int *)((int)register0x00000010 + -0x14) + 0x28;
            *(undefined4 *)((int)register0x00000010 + -0x80) =
                 *(undefined4 *)((int)register0x00000010 + -0x40);
            *(undefined4 *)((int)register0x00000010 + -0x7c) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a722;
            thunk_FUN_004026b0();
          }
          else if (bVar1 == 3) {
            *(int *)((int)register0x00000010 + -0x84) =
                 *(int *)((int)register0x00000010 + -0x14) + 0x20;
            *(undefined4 *)((int)register0x00000010 + -0x80) =
                 *(undefined4 *)((int)register0x00000010 + -0x40);
            *(undefined4 *)((int)register0x00000010 + -0x7c) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a701;
            thunk_FUN_004026b0();
          }
          *(undefined **)((int)register0x00000010 + -0x84) = &DAT_005f7700;
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a730;
          FUN_00433a70();
          if (DAT_005d7d31 != '\0') {
            if (DAT_005d7d30 == '\0') {
              iVar5 = 0;
              uVar8 = 0;
            }
            else {
              *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a751;
              FUN_0045e520();
              uVar8 = *(undefined4 *)((int)register0x00000010 + -0x84);
              iVar5 = *(int *)((int)register0x00000010 + -0x80);
            }
            if (iVar5 != 0) {
              *(int *)((int)register0x00000010 + -0x50) = iVar5;
              *(undefined4 *)((int)register0x00000010 + -0x18) = uVar8;
              *(undefined4 *)((int)register0x00000010 + -0x84) = uVar8;
              *(int *)((int)register0x00000010 + -0x80) = iVar5;
              *(undefined4 *)((int)register0x00000010 + -0x7c) =
                   *(undefined4 *)((int)register0x00000010 + -0x30);
              *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a778;
              FUN_004585b0();
              *(undefined4 *)((int)register0x00000010 + -0x84) =
                   *(undefined4 *)((int)register0x00000010 + -0x18);
              *(undefined4 *)((int)register0x00000010 + -0x80) =
                   *(undefined4 *)((int)register0x00000010 + -0x50);
              *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a78c;
              FUN_0045e630();
            }
          }
          *(undefined4 *)((int)register0x00000010 + 0x10) =
               *(undefined4 *)((int)register0x00000010 + -0x30);
          return;
        }
        *(undefined **)((int)register0x00000010 + -0x84) = &DAT_004cc5ac;
        *(undefined4 *)((int)register0x00000010 + -0x80) = 0x2b;
        *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a7b4;
        FUN_00469a20();
      }
      else {
        uVar6 = *(uint *)((int)register0x00000010 + 8);
        if (0xf < uVar6) {
          iVar5 = 0;
          iVar7 = 0;
          uVar8 = 0;
          goto LAB_0042a1be;
        }
        iVar7 = iVar5 + 0x34;
        if (*(int *)(iVar5 + 0x3c) == 0 && *(int *)(iVar5 + 0x38) == 0) {
          *(int *)((int)register0x00000010 + -0x10) = iVar7;
          *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + 4) + 8;
          *(int *)((int)register0x00000010 + -0x84) = *(int *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a104;
          FUN_0040ecf0();
          *(undefined4 *)((int)register0x00000010 + -0x84) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a110;
          FUN_0042f210();
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a11d;
          FUN_0046f42e();
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a12a;
          FUN_0046f42e();
          *(undefined4 *)((int)register0x00000010 + -0x84) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a13b;
          FUN_0040f0e0();
          uVar6 = *(uint *)((int)register0x00000010 + 8);
          iVar7 = *(int *)((int)register0x00000010 + -0x10);
        }
        *(int *)((int)register0x00000010 + -0x84) = iVar7;
        *(uint *)((int)register0x00000010 + -0x80) = uVar6;
        *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a152;
        FUN_0042eb40();
        iVar5 = *(int *)((int)register0x00000010 + -0x7c);
        uVar8 = *(undefined4 *)((int)register0x00000010 + -0x78);
        if (iVar5 == 0) {
          iVar7 = 0;
          goto LAB_0042a1be;
        }
        iVar2 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
        if ((iVar2 == 0) || (iVar3 = *(int *)(iVar2 + 0x708), iVar3 == 0)) {
          iVar7 = 0;
LAB_0042a19d:
          if (iVar7 == 0) goto LAB_0042a1be;
          uVar11 = 0;
          goto LAB_0042a2e5;
        }
        if (iVar3 - 1U < 0x80) {
          iVar7 = *(int *)(iVar2 + 0x708 + iVar3 * 4);
          *(uint *)(iVar2 + 0x708) = iVar3 - 1U;
          goto LAB_0042a19d;
        }
      }
      *(undefined4 *)((int)register0x00000010 + -0x88) = 0x42a7c0;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar12 + -4) = 0x42a7c6;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar12;
  } while( true );
}



/* Function: FUN_0042a7d0 */

void FUN_0042a7d0(void)

{
  byte bVar1;
  ushort uVar2;
  undefined4 uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  undefined1 *puVar7;
  uint uVar8;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x18);
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 0x10);
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 0x14);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42a803;
      FUN_0042b2a0();
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 0x10);
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 0x14);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42a81f;
      FUN_00429e50();
      if (*(char *)((int)register0x00000010 + -0xc) == '\0') {
        iVar6 = *(int *)((int)register0x00000010 + 8);
      }
      else {
        iVar6 = *(int *)((int)register0x00000010 + 8);
        *(undefined1 *)(iVar6 + 0x40) = 1;
      }
      if (*(char *)((int)register0x00000010 + 0xc) != '\0') {
        *(undefined4 *)(iVar6 + 0x14) = 0;
        *(undefined2 *)(iVar6 + 0x1a) = 0;
        *(int *)((int)register0x00000010 + -0x18) = iVar6 + 0x3f;
        *(undefined1 *)((int)register0x00000010 + -0x14) = 2;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42a99b;
        FUN_00402810();
        goto LAB_0042a99b;
      }
      bVar1 = *(byte *)((int)register0x00000010 + 0xd);
      *(byte *)(iVar6 + 0x3e) = bVar1;
      uVar8 = *(int *)((int)register0x00000010 + 0x14) * 0x2000;
      if (bVar1 >> 1 == 0) {
        *(uint *)(iVar6 + 0x44) = uVar8;
        *(undefined2 *)(iVar6 + 0x1a) = 1;
        *(undefined4 *)(iVar6 + 0x38) = 0;
LAB_0042a8ea:
        *(undefined2 *)(iVar6 + 0x18) = 0;
        *(undefined2 *)(iVar6 + 0x1c) = 0;
        *(undefined4 *)(iVar6 + 0x20) = 0xffffffff;
        *(undefined4 *)(iVar6 + 0x24) = 0xffffffff;
        *(uint *)((int)register0x00000010 + -0x18) = (uint)*(ushort *)(iVar6 + 0x1a);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42a910;
        FUN_0042c440();
        iVar6 = *(int *)((int)register0x00000010 + 8);
        *(undefined4 *)(iVar6 + 0x2c) = *(undefined4 *)((int)register0x00000010 + -0x14);
        uVar2 = *(ushort *)(iVar6 + 0x1a);
        *(int *)((int)register0x00000010 + -4) = iVar6 + 0x34;
        *(int *)((int)register0x00000010 + -8) = iVar6 + 0x3f;
        *(uint *)((int)register0x00000010 + -0x18) = (uint)uVar2;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42a935;
        FUN_0042c440();
        iVar6 = *(int *)((int)register0x00000010 + 8);
        *(undefined4 *)(iVar6 + 0x28) = *(undefined4 *)((int)register0x00000010 + -0x14);
        *(uint *)(iVar6 + 0x48) =
             (uint)*(ushort *)(iVar6 + 0x1a) * *(int *)(iVar6 + 0x44) + *(int *)(iVar6 + 0xc);
        uVar3 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0xb0);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x14) = uVar3;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42a968;
        FUN_00402770();
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined1 *)((int)register0x00000010 + -0x14) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42a97a;
        FUN_00402810();
LAB_0042a99b:
        uVar3 = *(undefined4 *)(*(int *)((int)register0x00000010 + 8) + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x14) = uVar3;
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 0x14);
        *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42a9be;
        FUN_00429dc0();
        if (*(char *)((int)register0x00000010 + 0xc) == '\0') {
          uVar8 = *(uint *)(*(int *)((int)register0x00000010 + 8) + 0xc);
          *(uint *)((int)register0x00000010 + -0x18) =
               *(int *)(DAT_005ddf14 + (uVar8 >> 0x16) * 4) + 0x800 + (uVar8 >> 0x10 & 0x3f);
          *(char *)((int)register0x00000010 + -0x14) = (char)(1 << ((byte)(uVar8 >> 0xd) & 7));
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42aa11;
          FUN_004027f0();
          *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + 4) + 0xc0;
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)((int)register0x00000010 + 0x14);
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42aa2c;
          thunk_FUN_00402690();
        }
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42aa31;
        FUN_0046ea00();
        return;
      }
      uVar4 = (uint)(char)(bVar1 >> 1);
      if (uVar4 < 0x44) {
        uVar5 = (uint)(ushort)(&DAT_005cc900)[uVar4];
        *(uint *)(iVar6 + 0x44) = uVar5;
        if ((*(byte *)(iVar6 + 0x3e) & 1) == 0) {
          if (0x80 < uVar5) goto LAB_0042a8cc;
          if (uVar5 == 0) {
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42aa3a;
            FUN_00438080();
            goto LAB_0042aa3a;
          }
          iVar6 = *(int *)((int)register0x00000010 + 8);
          *(short *)(iVar6 + 0x1a) = (short)((uVar8 - (uVar8 >> 5)) / uVar5);
        }
        else {
          if (uVar5 == 0) {
LAB_0042aa3a:
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42aa3f;
            FUN_00438080();
            goto LAB_0042aa3f;
          }
LAB_0042a8cc:
          iVar6 = *(int *)((int)register0x00000010 + 8);
          *(short *)(iVar6 + 0x1a) = (short)(uVar8 / uVar5);
        }
        *(undefined4 *)(iVar6 + 0x38) = *(undefined4 *)(&DAT_005cccc0 + uVar4 * 4);
        goto LAB_0042a8ea;
      }
LAB_0042aa3f:
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42aa4b;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar7 + -4) = 0x42aa51;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_0042aa60 */

void FUN_0042aa60(int param_1,int param_2)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int in_FS_OFFSET;
  uint uVar5;
  int iVar6;
  uint uVar7;
  int local_40;
  int local_3c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar2 = (param_2 + 0x1ffU & 0xfffffe00) * 0x2000;
  uVar5 = *(uint *)(param_1 + 0x184) + uVar2;
  uVar3 = DAT_005f5de0 + -1 + uVar5 & -DAT_005f5de0;
  if ((*(uint *)(param_1 + 0x188) < uVar3) || (uVar5 < *(uint *)(param_1 + 0x184))) {
    iVar1 = param_1 + 0x14c;
    uVar5 = uVar2;
    FUN_0040f930(param_1,uVar2,iVar1,1);
    if (local_40 == 0) {
      FUN_004027a0(&DAT_005f68a0);
      uVar3 = uVar5;
      iVar6 = iVar1;
      FUN_004027a0(&DAT_005f6898);
      uVar7 = uVar3;
      iVar4 = iVar6;
      FUN_004027a0(&DAT_005f6890);
      FUN_0043a810();
      FUN_0043b060(&DAT_004cbf30,0x28);
      FUN_0043ad50(uVar2,0);
      FUN_0043b060("-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                   ,0xd);
      FUN_0043ad50(uVar7 + uVar3 + uVar5,
                   iVar6 + iVar1 + (uint)CARRY4(uVar3,uVar5) + iVar4 +
                   (uint)CARRY4(uVar7,uVar3 + uVar5));
      FUN_0043b060(&DAT_004c339c,9);
      FUN_0043a870();
      return;
    }
    if (local_40 == *(int *)(param_1 + 0x188)) {
      *(int *)(param_1 + 0x188) = local_40 + local_3c;
    }
    else {
      iVar1 = *(int *)(param_1 + 0x188) - *(int *)(param_1 + 0x184);
      if (iVar1 != 0) {
        iVar6 = iVar1;
        FUN_00433860(&DAT_005f6898,iVar1,0);
        FUN_00433980(&DAT_005f7700);
        thunk_FUN_004026b0(iVar6 + 8,iVar1,0);
        FUN_00433a70(&DAT_005f7700);
        FUN_0042c8e0(param_1 + 8,*(undefined4 *)(param_1 + 0x184),iVar1);
      }
      *(int *)(param_1 + 0x184) = local_40;
      *(int *)(param_1 + 0x188) = local_40 + local_3c;
    }
    uVar3 = -DAT_005f5de0 & DAT_005f5de0 + -1 + *(int *)(param_1 + 0x184) + uVar2;
  }
  iVar1 = *(int *)(param_1 + 0x184);
  *(uint *)(param_1 + 0x184) = uVar3;
  iVar4 = uVar3 - iVar1;
  iVar6 = iVar4;
  FUN_00433860(&DAT_005f6898,iVar4,0);
  FUN_00433980(&DAT_005f7700);
  thunk_FUN_004026b0(iVar6 + 8,iVar4,0);
  FUN_00433a70(&DAT_005f7700);
  FUN_0042c8e0(param_1 + 8,iVar1,iVar4);
  return;
}



/* Function: FUN_0042ada0 */

void FUN_0042ada0(undefined4 param_1,int param_2,undefined1 param_3)

{
  int in_FS_OFFSET;
  undefined4 in_stack_ffffffec;
  int in_stack_fffffff0;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc)) {
    FUN_0046afb0();
  }
  if (DAT_005d7d31 != '\0') {
    if (DAT_005d7d30 == '\0') {
      in_stack_fffffff0 = 0;
      in_stack_ffffffec = 0;
    }
    else {
      FUN_0045e520();
    }
    if (in_stack_fffffff0 != 0) {
      FUN_004586d0(in_stack_ffffffec,in_stack_fffffff0,param_2,in_stack_fffffff0,in_stack_ffffffec);
      FUN_0045e630(in_stack_ffffffec,in_stack_fffffff0);
    }
  }
  *(undefined1 *)(param_2 + 0x40) = 1;
  FUN_0040ecf0(param_1);
  FUN_0042ae70(param_1,param_2,param_3);
  FUN_0040f0e0(param_1);
  return;
}



/* Function: FUN_0042ae70 */

void FUN_0042ae70(void)

{
  byte bVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 *puVar4;
  int iVar5;
  char *pcVar6;
  uint uVar7;
  uint in_EBX;
  undefined1 *puVar8;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x2c);
      uVar7 = *(uint *)((int)register0x00000010 + 4);
      *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 8) + 0x3f;
      *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 8) + 0x3f;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42aea3;
      FUN_00402470();
      if (*(char *)((int)register0x00000010 + -0x28) != '\x01') {
        if (*(char *)((int)register0x00000010 + -0x28) != '\x02') goto LAB_0042b148;
        iVar5 = *(int *)((int)register0x00000010 + 8);
        uVar7 = (uint)*(ushort *)(iVar5 + 0x3c);
        if (*(ushort *)(iVar5 + 0x3c) != 0) goto LAB_0042b132;
        goto LAB_0042af68;
      }
      pcVar6 = *(char **)((int)register0x00000010 + 8);
      if (pcVar6[0x41] == '\0') break;
      *(char **)((int)register0x00000010 + -0x2c) =
           "mheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x37;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b28b;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x42b291;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
  uVar7 = (uint)*(ushort *)(pcVar6 + 0x3c);
  if (*(ushort *)(pcVar6 + 0x3c) != 0) goto LAB_0042b26c;
  in_EBX = *(uint *)((int)register0x00000010 + 4);
  if (*(int *)(in_EBX + 0xb0) == *(int *)(pcVar6 + 0x34)) {
    iVar5 = *(int *)(pcVar6 + 0x10);
    *(uint *)((int)register0x00000010 + -0x2c) = in_EBX + 0xc0;
    *(int *)((int)register0x00000010 + -0x28) = -iVar5;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42aef8;
    thunk_FUN_00402690();
    uVar7 = *(uint *)(*(int *)((int)register0x00000010 + 8) + 0xc);
    in_EBX = uVar7 >> 0xd & 7;
    *(uint *)((int)register0x00000010 + -0x2c) =
         *(int *)(DAT_005ddf14 + (uVar7 >> 0x16) * 4) + 0x800 + (uVar7 >> 0x10 & 0x3f);
    *(byte *)((int)register0x00000010 + -0x28) = ~(byte)(1 << (sbyte)in_EBX);
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42af48;
    FUN_00402800();
    iVar5 = *(int *)((int)register0x00000010 + 8);
LAB_0042af68:
    iVar5 = *(int *)(iVar5 + 0x10) << 0xd;
    *(int *)((int)register0x00000010 + -0x14) = iVar5;
    *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f68a0;
    *(int *)((int)register0x00000010 + -0x28) = iVar5;
    *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42af8c;
    FUN_00433860();
    if (*(char *)((int)register0x00000010 + 0xc) == '\0') {
      *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f6890;
      *(int *)((int)register0x00000010 + -0x28) = -*(int *)((int)register0x00000010 + -0x14);
      *(uint *)((int)register0x00000010 + -0x24) =
           -(uint)(*(int *)((int)register0x00000010 + -0x14) != 0);
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42afbb;
      FUN_00433860();
    }
    *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f7700;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42afc9;
    FUN_00433980();
    iVar5 = *(int *)((int)register0x00000010 + -0x28);
    bVar1 = *(byte *)((int)register0x00000010 + 0xc);
    if (bVar1 < 2) {
      if (bVar1 == 0) {
        *(int *)((int)register0x00000010 + -0x2c) = iVar5 + 0x10;
        *(int *)((int)register0x00000010 + -0x28) = -*(int *)((int)register0x00000010 + -0x14);
        *(uint *)((int)register0x00000010 + -0x24) =
             -(uint)(*(int *)((int)register0x00000010 + -0x14) != 0);
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b000;
        thunk_FUN_004026b0();
      }
      else {
        *(int *)((int)register0x00000010 + -0x2c) = iVar5 + 0x18;
        *(int *)((int)register0x00000010 + -0x28) = -*(int *)((int)register0x00000010 + -0x14);
        *(uint *)((int)register0x00000010 + -0x24) =
             -(uint)(*(int *)((int)register0x00000010 + -0x14) != 0);
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b027;
        thunk_FUN_004026b0();
      }
    }
    else if (bVar1 == 2) {
      *(int *)((int)register0x00000010 + -0x2c) = iVar5 + 0x28;
      *(int *)((int)register0x00000010 + -0x28) = -*(int *)((int)register0x00000010 + -0x14);
      *(uint *)((int)register0x00000010 + -0x24) =
           -(uint)(*(int *)((int)register0x00000010 + -0x14) != 0);
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b07f;
      thunk_FUN_004026b0();
    }
    else if (bVar1 == 3) {
      *(int *)((int)register0x00000010 + -0x2c) = iVar5 + 0x20;
      *(int *)((int)register0x00000010 + -0x28) = -*(int *)((int)register0x00000010 + -0x14);
      *(uint *)((int)register0x00000010 + -0x24) =
           -(uint)(*(int *)((int)register0x00000010 + -0x14) != 0);
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b058;
      thunk_FUN_004026b0();
    }
    *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f7700;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b08d;
    FUN_00433a70();
    uVar2 = *(undefined4 *)(*(int *)((int)register0x00000010 + 8) + 0x10);
    uVar3 = *(undefined4 *)(*(int *)((int)register0x00000010 + 8) + 0xc);
    *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 4) + 8;
    *(undefined4 *)((int)register0x00000010 + -0x28) = uVar3;
    *(undefined4 *)((int)register0x00000010 + -0x24) = uVar2;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b0ae;
    FUN_0042e2e0();
    *(undefined4 *)((int)register0x00000010 + -0x2c) = *(undefined4 *)((int)register0x00000010 + -4)
    ;
    *(undefined1 *)((int)register0x00000010 + -0x28) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b0c1;
    FUN_00402810();
    iVar5 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
    if (iVar5 != 0) {
      uVar7 = *(uint *)(iVar5 + 0x708);
      if ((int)uVar7 < 0x80) {
        if (uVar7 < 0x80) {
          *(undefined4 *)(iVar5 + 0x70c + uVar7 * 4) = *(undefined4 *)((int)register0x00000010 + 8);
          *(int *)(iVar5 + 0x708) = *(int *)(iVar5 + 0x708) + 1;
          return;
        }
        uVar7 = 0x80;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b132;
        FUN_0046edf0();
LAB_0042b132:
        *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004cc115;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x29;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b148;
        FUN_00469a20();
LAB_0042b148:
        pcVar6 = &DAT_004cc13e;
        *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004cc13e;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x29;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b15e;
        FUN_00469a20();
        goto LAB_0042b15e;
      }
    }
    iVar5 = *(int *)((int)register0x00000010 + 4);
    *(int *)(iVar5 + 0x45ac) = *(int *)(iVar5 + 0x45ac) - *(int *)(iVar5 + 0x4590);
    puVar4 = *(undefined4 **)((int)register0x00000010 + 8);
    *puVar4 = *(undefined4 *)(iVar5 + 0x459c);
    *(undefined4 **)(iVar5 + 0x459c) = puVar4;
    return;
  }
LAB_0042b15e:
  do {
    *(uint *)((int)register0x00000010 + -8) = uVar7 & 0xffff;
    *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)(pcVar6 + 0x34);
    uVar7 = *(uint *)(in_EBX + 0xb0);
    *(uint *)((int)register0x00000010 + -0x10) = uVar7;
    *(undefined4 *)((int)register0x00000010 + -0x18) = *(undefined4 *)(pcVar6 + 0xc);
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b182;
    FUN_0043a810();
    *(char **)((int)register0x00000010 + -0x2c) =
         "mheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetClassInstallParamsWSetupDiSetClassInstallParamsWCentral America Standard TimeNorth Asia East Standard TimeN. Central Asia Standard TimeChatham Islands Standard TimeCentral Pacific Standard Timeoperation already in progressno XENIX semaphores availabletoo many open files in systemmachine is not on the networkprotocol family not supportednumerical result out of rangenotesleep - waitm out of sync/cpu/classes/idle:cpu-seconds/cpu/classes/user:cpu-seconds/gc/heap/allocs-by-size:bytes/gc/stack/starting-size:bytesgc done but gcphase != _GCoffruntime: p.gcMarkWorkerMode= scanobject of a noscan objectruntime: marking free object addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
    ;
    *(undefined4 *)((int)register0x00000010 + -0x28) = 0x1c;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b198;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0x2c) = *(undefined4 *)((int)register0x00000010 + 8);
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b1a4;
    FUN_0043b020();
    *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004c2c64;
    *(undefined4 *)((int)register0x00000010 + -0x28) = 5;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b1ba;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0x2c) =
         *(undefined4 *)((int)register0x00000010 + -0x18);
    *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b1ce;
    FUN_0043aef0();
    *(char **)((int)register0x00000010 + -0x2c) = " allocCount ProcessPrng";
    *(undefined4 *)((int)register0x00000010 + -0x28) = 0xc;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b1e4;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0x2c) = *(undefined4 *)((int)register0x00000010 + -8)
    ;
    *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b1f8;
    FUN_0043ad50();
    *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004c36a7;
    *(undefined4 *)((int)register0x00000010 + -0x28) = 10;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b20e;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0x2c) =
         *(undefined4 *)((int)register0x00000010 + -0xc);
    *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b222;
    FUN_0043ad50();
    *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004c2924;
    *(undefined4 *)((int)register0x00000010 + -0x28) = 1;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b238;
    FUN_0043b060();
    *(undefined4 *)((int)register0x00000010 + -0x2c) =
         *(undefined4 *)((int)register0x00000010 + -0x10);
    *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b24c;
    FUN_0043ad50();
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b251;
    FUN_0043aa10();
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b256;
    FUN_0043a870();
    pcVar6 = 
    "mheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker..." /* TRUNCATED STRING LITERAL */
    ;
    *(char **)((int)register0x00000010 + -0x2c) =
         "mheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker..." /* TRUNCATED STRING LITERAL */
    ;
    *(undefined4 *)((int)register0x00000010 + -0x28) = 0x23;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42b26c;
    FUN_00469a20();
LAB_0042b26c:
    in_EBX = *(uint *)((int)register0x00000010 + 4);
  } while( true );
}



/* Function: FUN_0042b2a0 */

void FUN_0042b2a0(undefined4 *param_1,int param_2,int param_3)

{
  int in_FS_OFFSET;
  uint in_stack_fffffffc;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    in_stack_fffffffc = 0x42b344;
    FUN_0046d980();
  }
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[3] = param_2;
  param_1[4] = param_3;
  param_1[0x12] = param_2 + param_3 * 0x2000;
  *(undefined2 *)(param_1 + 0xf) = 0;
  *(undefined1 *)((int)param_1 + 0x3e) = 0;
  param_1[0x11] = 0;
  param_1[0x13] = 0;
  param_1[0x14] = 0;
  *(undefined1 *)(param_1 + 0x10) = 0;
  *(undefined2 *)(param_1 + 6) = 0;
  *(undefined2 *)(param_1 + 7) = 0;
  param_1[10] = 0;
  param_1[0xb] = 0;
  param_1[0xc] = 0;
  FUN_00402810((int)param_1 + 0x3f,in_stack_fffffffc & 0xffffff00);
  return;
}



/* Function: FUN_0042b350 */

void FUN_0042b350(void)

{
  int *piVar1;
  int *piVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x14);
      piVar1 = *(int **)((int)register0x00000010 + 8);
      piVar2 = *(int **)((int)register0x00000010 + 4);
      if (piVar2 == (int *)piVar1[2]) {
        if ((int *)*piVar2 == piVar1) {
          *piVar2 = *piVar1;
        }
        else {
          *(int *)piVar1[1] = *piVar1;
        }
        if ((int *)piVar2[1] == piVar1) {
          piVar2[1] = piVar1[1];
        }
        else {
          *(int *)(*piVar1 + 4) = piVar1[1];
        }
        *piVar1 = 0;
        piVar1[1] = 0;
        piVar1[2] = 0;
        return;
      }
      *(int **)((int)register0x00000010 + -4) = (int *)piVar1[2];
      *(int *)((int)register0x00000010 + -8) = piVar1[4];
      *(int *)((int)register0x00000010 + -0xc) = piVar1[1];
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b3cb;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004cc9c9;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x2d;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b3e1;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b3f5;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c2d86;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 6;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b40b;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b417;
      FUN_0043b020();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c2d8c;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 6;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b42d;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b439;
      FUN_0043b020();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c3ab7;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0xb;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b44f;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b45b;
      FUN_0043b020();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c2d92;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 6;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b471;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b47d;
      FUN_0043b020();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b482;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b487;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x14) =
           "mSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b49d;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x42b4a3;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_0042b4b0 */

void FUN_0042b4b0(void)

{
  int *piVar1;
  int iVar2;
  int *piVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x14);
      piVar1 = *(int **)((int)register0x00000010 + 8);
      iVar2 = *piVar1;
      *(int *)((int)register0x00000010 + -4) = iVar2;
      if (((iVar2 == 0) && (piVar1[1] == 0)) && (piVar1[2] == 0)) {
        piVar3 = *(int **)((int)register0x00000010 + 4);
        *piVar1 = *piVar3;
        if (*piVar3 == 0) {
          piVar3[1] = (int)piVar1;
        }
        else {
          *(int **)(*piVar3 + 4) = piVar1;
        }
        *piVar3 = (int)piVar1;
        piVar1[2] = (int)piVar3;
        return;
      }
      *(int *)((int)register0x00000010 + -8) = piVar1[1];
      *(int *)((int)register0x00000010 + -0xc) = piVar1[2];
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b515;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x14) =
           "runtime: failed mSpanList.insert runtime: castogscanstatus oldval=stoplockedm: inconsistent lockingfindrunnable: negative nmspinningfreeing stack not in a stack spanstackalloc not on scheduler stackruntime: goroutine stack exceeds runtime: text offset out of rangetimer period must be non-negativetoo many concurrent timer firingsruntime: name offset out of rangeruntime: type offset out of rangewaiting for unsupported file typeGODEBUG: no value specified for \"unaligned 64-bit atomic operationconcurrent map read and map writetable must have positive capacityCM_Get_Device_Interface_List_SizeWSetFileCompletionNotificationModestoo many references: cannot spliceslice bounds out of range [:%x:%y]slice bounds out of range [%x:%y:]out of memory allocating allArenas/memory/classes/heap/objects:bytesruntime.SetFinalizer: cannot pass too many pages allocated in chunk?mspan.ensureSwept: m is not lockedVirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the w..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x21;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b52b;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b537;
      FUN_0043b020();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b53c;
      FUN_0043a9d0();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b548;
      FUN_0043b020();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b54d;
      FUN_0043a9d0();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b559;
      FUN_0043b020();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b55e;
      FUN_0043a9d0();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b56a;
      FUN_0043b020();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b56f;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b574;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x14) =
           "mSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42b58a;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x42b590;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_0042b5a0 */

void FUN_0042b5a0(void)

{
  uint uVar1;
  uint uVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -8);
      uVar1 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0xc) >> 0xd;
      uVar2 = (uVar1 & 0x1ff) >> 3;
      if (uVar2 < 0x40) {
        *(uint *)((int)register0x00000010 + -8) =
             *(int *)(DAT_005ddf14 +
                     (*(uint *)(*(int *)((int)register0x00000010 + 4) + 0xc) >> 0x16) * 4) + 0x880 +
             uVar2;
        *(char *)((int)register0x00000010 + -4) = (char)(1 << ((byte)uVar1 & 7));
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x42b5fd;
        FUN_004027f0();
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x42b60d;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar3 + -4) = 0x42b613;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_0042b620 */

void FUN_0042b620(void)

{
  uint uVar1;
  uint uVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -8);
      uVar1 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0xc) >> 0xd;
      uVar2 = (uVar1 & 0x1ff) >> 3;
      if (uVar2 < 0x40) {
        *(uint *)((int)register0x00000010 + -8) =
             *(int *)(DAT_005ddf14 +
                     (*(uint *)(*(int *)((int)register0x00000010 + 4) + 0xc) >> 0x16) * 4) + 0x880 +
             uVar2;
        *(byte *)((int)register0x00000010 + -4) = ~(byte)(1 << ((byte)uVar1 & 7));
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x42b67f;
        FUN_00402800();
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x42b68f;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar3 + -4) = 0x42b695;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_0042b6a0 */

void FUN_0042b6a0(void)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  undefined1 uVar6;
  int *piVar7;
  char cVar8;
  undefined1 *puVar9;
  int in_FS_OFFSET;
  bool bVar10;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b6c3;
      FUN_00429300();
      iVar2 = *(int *)((int)register0x00000010 + -0x18);
      if (iVar2 != 0) break;
      *(char **)((int)register0x00000010 + -0x1c) =
           "addspecial on invalid pointerruntime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x1d;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b80b;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar9 + -4) = 0x42b811;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
  *(int *)((int)register0x00000010 + -0x10) = iVar2;
  *(int *)((int)register0x00000010 + -4) = iVar2 + 0x4c;
  iVar3 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  piVar1 = (int *)(*(int *)(iVar3 + 0x18) + 0x7c);
  *piVar1 = *piVar1 + 1;
  *(undefined4 *)((int)register0x00000010 + -8) = *(undefined4 *)(iVar3 + 0x18);
  *(int *)((int)register0x00000010 + -0x1c) = iVar2;
  *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b6fb;
  FUN_00426e40();
  *(int *)((int)register0x00000010 + -0xc) =
       *(int *)((int)register0x00000010 + 4) -
       *(int *)(*(int *)((int)register0x00000010 + -0x10) + 0xc);
  *(undefined1 *)((int)register0x00000010 + -0x12) =
       *(undefined1 *)(*(int *)((int)register0x00000010 + 8) + 8);
  *(undefined4 *)((int)register0x00000010 + -0x1c) = *(undefined4 *)((int)register0x00000010 + -4);
  *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b723;
  FUN_0040ecf0();
  iVar2 = *(int *)((int)register0x00000010 + -0x10);
  uVar4 = *(uint *)((int)register0x00000010 + -0xc);
  piVar1 = (int *)(iVar2 + 0x50);
  while( true ) {
    piVar7 = piVar1;
    piVar1 = (int *)*piVar7;
    if (piVar1 == (int *)0x0) {
      cVar8 = '\0';
      goto LAB_0042b763;
    }
    uVar5 = piVar1[1];
    if ((uVar5 == uVar4) && (*(byte *)(piVar1 + 2) == *(byte *)((int)register0x00000010 + -0x12)))
    break;
    if ((uVar4 < uVar5) ||
       ((uVar5 == uVar4 && (*(byte *)((int)register0x00000010 + -0x12) < *(byte *)(piVar1 + 2))))) {
      cVar8 = '\0';
LAB_0042b763:
      *(char *)((int)register0x00000010 + -0x11) = cVar8;
      if ((cVar8 == '\0') || (*(char *)((int)register0x00000010 + 0xc) != '\0')) {
        piVar1 = *(int **)((int)register0x00000010 + 8);
        piVar1[1] = uVar4;
        *piVar1 = *piVar7;
        *piVar7 = (int)piVar1;
        *(int *)((int)register0x00000010 + -0x1c) = iVar2;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b78b;
        FUN_0042b5a0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b799;
      FUN_0040f0e0();
      iVar2 = *(int *)(*(int *)((int)register0x00000010 + -8) + 0x7c);
      iVar3 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      *(int *)(*(int *)((int)register0x00000010 + -8) + 0x7c) = iVar2 + -1;
      if (iVar2 == 1) {
        if (*(char *)(iVar3 + 0x69) == '\0') {
          bVar10 = *(char *)((int)register0x00000010 + -0x11) == '\0';
        }
        else {
          *(undefined4 *)(iVar3 + 8) = 0xfffffade;
          bVar10 = *(char *)((int)register0x00000010 + -0x11) == '\0';
        }
      }
      else {
        bVar10 = *(char *)((int)register0x00000010 + -0x11) == '\0';
      }
      if (bVar10) {
        uVar6 = 1;
      }
      else {
        uVar6 = *(undefined1 *)((int)register0x00000010 + 0xc);
      }
      *(undefined1 *)((int)register0x00000010 + 0x10) = uVar6;
      return;
    }
  }
  cVar8 = '\x01';
  goto LAB_0042b763;
}



/* Function: FUN_0042b820 */

void FUN_0042b820(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  int *piVar5;
  undefined1 *puVar6;
  int *piVar7;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b843;
      FUN_00429300();
      iVar1 = *(int *)((int)register0x00000010 + -0x18);
      if (iVar1 != 0) break;
      *(char **)((int)register0x00000010 + -0x1c) =
           "removespecial on invalid pointergetWeakHandle on invalid pointerruntime: root level max pages = NtAssociateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x20;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b948;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x42b94e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
  *(int *)((int)register0x00000010 + -0x14) = iVar1;
  *(int *)((int)register0x00000010 + -4) = iVar1 + 0x4c;
  iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  piVar5 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
  *piVar5 = *piVar5 + 1;
  *(undefined4 *)((int)register0x00000010 + -8) = *(undefined4 *)(iVar2 + 0x18);
  *(int *)((int)register0x00000010 + -0x1c) = iVar1;
  *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b87b;
  FUN_00426e40();
  *(int *)((int)register0x00000010 + -0xc) =
       *(int *)((int)register0x00000010 + 4) -
       *(int *)(*(int *)((int)register0x00000010 + -0x14) + 0xc);
  *(undefined4 *)((int)register0x00000010 + -0x1c) = *(undefined4 *)((int)register0x00000010 + -4);
  *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b897;
  FUN_0040ecf0();
  iVar1 = *(int *)((int)register0x00000010 + -0x14);
  uVar3 = *(uint *)((int)register0x00000010 + -0xc);
  piVar5 = (int *)(iVar1 + 0x50);
  while( true ) {
    piVar7 = (int *)*piVar5;
    if (piVar7 == (int *)0x0) {
      piVar7 = (int *)0x0;
      goto LAB_0042b8d8;
    }
    uVar4 = piVar7[1];
    if ((uVar4 == uVar3) && (*(byte *)(piVar7 + 2) == *(byte *)((int)register0x00000010 + 8)))
    break;
    if ((uVar3 < uVar4) ||
       ((piVar5 = piVar7, uVar4 == uVar3 &&
        (*(byte *)((int)register0x00000010 + 8) < *(byte *)(piVar7 + 2))))) {
      piVar7 = (int *)0x0;
LAB_0042b8d8:
      *(int **)((int)register0x00000010 + -0x10) = piVar7;
      if (*(int *)(iVar1 + 0x50) == 0) {
        *(int *)((int)register0x00000010 + -0x1c) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b8eb;
        FUN_0042b620();
      }
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42b8f9;
      FUN_0040f0e0();
      iVar1 = *(int *)(*(int *)((int)register0x00000010 + -8) + 0x7c);
      iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      *(int *)(*(int *)((int)register0x00000010 + -8) + 0x7c) = iVar1 + -1;
      if ((iVar1 == 1) && (*(char *)(iVar2 + 0x69) != '\0')) {
        *(undefined4 *)(iVar2 + 8) = 0xfffffade;
      }
      *(undefined4 *)((int)register0x00000010 + 0xc) =
           *(undefined4 *)((int)register0x00000010 + -0x10);
      return;
    }
  }
  *piVar5 = *piVar7;
  goto LAB_0042b8d8;
}



/* Function: FUN_0042b960 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_0042b960(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  undefined4 *puVar4;
  int iVar5;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined4 *in_stack_ffffffe0;
  uint in_stack_ffffffe4;
  undefined4 in_stack_ffffffe8;
  int in_stack_ffffffec;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040ecf0(&DAT_005e24b0);
  FUN_00418000(&DAT_005e23c0);
  FUN_0040f0e0(&DAT_005e24b0);
  *(undefined1 *)(in_stack_ffffffe0 + 2) = 1;
  puVar4 = in_stack_ffffffe0;
  if (DAT_005f5fd0 != 0) {
    FUN_0046edc0();
    *in_EDI = param_2;
    in_EDI[1] = puVar4[3];
    in_EDI[2] = param_4;
    in_EDI[3] = puVar4[5];
    in_EDI[4] = param_5;
    in_EDI[5] = puVar4[6];
  }
  puVar4[3] = param_2;
  puVar4[4] = param_3;
  puVar4[5] = param_4;
  puVar4[6] = param_5;
  FUN_0042b6a0(param_1,puVar4,in_stack_ffffffe4 & 0xffffff00);
  if ((char)in_stack_ffffffe8 == '\0') {
    FUN_0040ecf0(&DAT_005e24b0);
    DAT_005e23dc = DAT_005e23dc - _DAT_005e23c0;
    *in_stack_ffffffe0 = DAT_005e23cc;
    DAT_005e23cc = in_stack_ffffffe0;
    FUN_0040f0e0(&DAT_005e24b0);
    return;
  }
  if (DAT_005f5e04 != 0) {
    FUN_004688e0(param_1,0,0);
    iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
    *piVar1 = *piVar1 + 1;
    iVar2 = *(int *)(iVar2 + 0x18);
    iVar5 = *(int *)(iVar2 + 0x58) + 0x96c;
    if ((*(byte *)(in_stack_ffffffec + 0x3e) & 1) == 0) {
      FUN_0041fe10(in_stack_ffffffe8,iVar5);
    }
    FUN_0041fcf0(in_stack_ffffffe0 + 3,4,&DAT_005cc260,iVar5,0);
    iVar5 = *(int *)(iVar2 + 0x7c);
    iVar3 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    *(int *)(iVar2 + 0x7c) = iVar5 + -1;
    if ((iVar5 == 1) && (*(char *)(iVar3 + 0x69) != '\0')) {
      *(undefined4 *)(iVar3 + 8) = 0xfffffade;
    }
  }
  return;
}



/* Function: FUN_0042bb60 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_0042bb60(undefined4 param_1)

{
  int in_FS_OFFSET;
  undefined4 *local_8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0042b820(param_1,1);
  if (local_8 != (undefined4 *)0x0) {
    FUN_0040ecf0(&DAT_005e24b0);
    DAT_005e23dc = DAT_005e23dc - _DAT_005e23c0;
    *local_8 = DAT_005e23cc;
    DAT_005e23cc = local_8;
    FUN_0040f0e0(&DAT_005e24b0);
    return;
  }
  return;
}



/* Function: FUN_0042bd00 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_0042bd00(void)

{
  int in_FS_OFFSET;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x42bd66;
    FUN_0046d980();
  }
  FUN_0040ecf0(&DAT_005d76cc);
  local_4 = DAT_005d76d0;
  DAT_005d76d0 = 0;
  _DAT_005d76d4 = 0;
  FUN_00442aa0(&local_4);
  FUN_0040f0e0(&DAT_005d76cc);
  return;
}



/* Function: FUN_0042c090 */

void FUN_0042c090(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x14);
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c0b7;
      FUN_0040ecf0();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e2410;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c0c5;
      FUN_00418000();
      *(undefined4 *)((int)register0x00000010 + -4) =
           *(undefined4 *)((int)register0x00000010 + -0x10);
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c0dd;
      FUN_0040f0e0();
      iVar1 = *(int *)((int)register0x00000010 + -4);
      *(undefined1 *)(iVar1 + 8) = 3;
      *(undefined4 *)(iVar1 + 0xc) = *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(int *)((int)register0x00000010 + -0x10) = iVar1;
      *(undefined1 *)((int)register0x00000010 + -0xc) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c101;
      FUN_0042b6a0();
      if (*(char *)((int)register0x00000010 + -8) != '\0') {
        return;
      }
      *(char **)((int)register0x00000010 + -0x14) =
           "setprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x25;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c124;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x42c12a;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_0042c130 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_0042c130(void)

{
  byte bVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined1 *puVar8;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x14);
      iVar2 = *(int *)((int)register0x00000010 + 4);
      bVar1 = *(byte *)(iVar2 + 8);
      if (bVar1 < 4) {
        if (bVar1 == 1) {
          uVar4 = *(undefined4 *)(iVar2 + 0xc);
          uVar5 = *(undefined4 *)(iVar2 + 0x10);
          uVar6 = *(undefined4 *)(iVar2 + 0x14);
          uVar7 = *(undefined4 *)(iVar2 + 0x18);
          *(undefined4 *)((int)register0x00000010 + -0x14) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0x10) = uVar4;
          *(undefined4 *)((int)register0x00000010 + -0xc) = uVar5;
          *(undefined4 *)((int)register0x00000010 + -8) = uVar6;
          *(undefined4 *)((int)register0x00000010 + -4) = uVar7;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c251;
          FUN_00416ff0();
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c261;
          FUN_0040ecf0();
          DAT_005e23dc = DAT_005e23dc - _DAT_005e23c0;
          puVar3 = *(undefined4 **)((int)register0x00000010 + 4);
          *puVar3 = DAT_005e23cc;
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c295;
          DAT_005e23cc = puVar3;
          FUN_0040f0e0();
          return;
        }
        if (bVar1 == 2) {
          *(undefined4 *)((int)register0x00000010 + -0x14) = *(undefined4 *)(iVar2 + 0xc);
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c1e0;
          thunk_FUN_00402770();
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c1f0;
          FUN_0040ecf0();
          DAT_005e24a4 = DAT_005e24a4 - _DAT_005e2488;
          puVar3 = *(undefined4 **)((int)register0x00000010 + 4);
          *puVar3 = DAT_005e2494;
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c224;
          DAT_005e2494 = puVar3;
          FUN_0040f0e0();
          return;
        }
        if (bVar1 == 3) {
          *(undefined4 *)((int)register0x00000010 + -0x14) = *(undefined4 *)(iVar2 + 0xc);
          *(undefined4 *)((int)register0x00000010 + -0x10) =
               *(undefined4 *)((int)register0x00000010 + 0xc);
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c182;
          FUN_00431610();
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c192;
          FUN_0040ecf0();
          DAT_005e242c = DAT_005e242c - _DAT_005e2410;
          puVar3 = *(undefined4 **)((int)register0x00000010 + 4);
          *puVar3 = DAT_005e241c;
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c1c6;
          DAT_005e241c = puVar3;
          FUN_0040f0e0();
          return;
        }
      }
      else {
        if (bVar1 == 4) {
          *(undefined1 *)(iVar2 + 0xc) = 1;
          return;
        }
        if (bVar1 == 5) {
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c337;
          FUN_0040ecf0();
          DAT_005e247c = DAT_005e247c - _DAT_005e2460;
          puVar3 = *(undefined4 **)((int)register0x00000010 + 4);
          *puVar3 = DAT_005e246c;
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c36c;
          DAT_005e246c = puVar3;
          FUN_0040f0e0();
          return;
        }
        if (bVar1 == 6) {
          uVar4 = *(undefined4 *)(iVar2 + 0xc);
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x10) = uVar4;
          *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
          *(undefined4 *)((int)register0x00000010 + -8) = 0;
          *(undefined4 *)((int)register0x00000010 + -4) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c2e1;
          FUN_00416ff0();
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c2f1;
          FUN_0040ecf0();
          DAT_005e2404 = DAT_005e2404 - _DAT_005e23e8;
          puVar3 = *(undefined4 **)((int)register0x00000010 + 4);
          *puVar3 = DAT_005e23f4;
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005e24b0;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c325;
          DAT_005e23f4 = puVar3;
          FUN_0040f0e0();
          return;
        }
      }
      *(char **)((int)register0x00000010 + -0x14) =
           "bad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c386;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x42c38c;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_0042c3a0 */

void FUN_0042c3a0(void)

{
  uint uVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0xc);
      if (*(int *)((int)register0x00000010 + 4) == 0) {
LAB_0042c3d4:
        *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
        return;
      }
      *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x42c3c3;
      thunk_FUN_00402510();
      if (0xfff8 < (uint)(*(int *)((int)register0x00000010 + -8) +
                         *(int *)((int)register0x00000010 + 8))) goto LAB_0042c3d4;
      *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)((int)register0x00000010 + 4)
      ;
      *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x42c3f0;
      thunk_FUN_00402690();
      if (0xfff8 < *(uint *)((int)register0x00000010 + -4)) {
        *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
        return;
      }
      uVar1 = *(uint *)((int)register0x00000010 + -4) - *(int *)((int)register0x00000010 + 8);
      if (uVar1 < 0xfff8) {
        *(uint *)((int)register0x00000010 + 0xc) = *(int *)((int)register0x00000010 + 4) + 8 + uVar1
        ;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x42c42e;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar2 + -4) = 0x42c434;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_0042c440 */

void FUN_0042c440(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x20);
      *(uint *)((int)register0x00000010 + -4) =
           (*(int *)((int)register0x00000010 + 4) + 0x3fU >> 6) << 3;
      *(undefined4 **)((int)register0x00000010 + -0x20) = &DAT_005f6028;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c476;
      FUN_00402520();
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c48a;
      FUN_0042c3a0();
      if (*(int *)((int)register0x00000010 + -0x18) != 0) {
        *(int *)((int)register0x00000010 + 8) = *(int *)((int)register0x00000010 + -0x18);
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x20) = &DAT_005f6020;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c4a6;
      FUN_0040ecf0();
      *(undefined4 *)((int)register0x00000010 + -0x20) = DAT_005f6028;
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c4bc;
      FUN_0042c3a0();
      if (*(int *)((int)register0x00000010 + -0x18) != 0) {
        *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + -0x18);
        *(undefined **)((int)register0x00000010 + -0x20) = &DAT_005f6020;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c598;
        FUN_0040f0e0();
        *(undefined4 *)((int)register0x00000010 + 8) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c4cd;
      FUN_0042c680();
      *(undefined4 *)((int)register0x00000010 + -8) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x20) = DAT_005f6028;
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c4ea;
      FUN_0042c3a0();
      if (*(int *)((int)register0x00000010 + -0x18) != 0) {
        *(int *)((int)register0x00000010 + -0x10) = *(int *)((int)register0x00000010 + -0x18);
        iVar1 = *(int *)((int)register0x00000010 + -8);
        *(int *)(iVar1 + 4) = DAT_005f6024;
        *(undefined **)((int)register0x00000010 + -0x20) = &DAT_005f6020;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c578;
        DAT_005f6024 = iVar1;
        FUN_0040f0e0();
        *(undefined4 *)((int)register0x00000010 + 8) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c506;
      FUN_0042c3a0();
      if (*(int *)((int)register0x00000010 + -0x18) != 0) {
        *(int *)((int)register0x00000010 + -0x14) = *(int *)((int)register0x00000010 + -0x18);
        iVar1 = *(int *)((int)register0x00000010 + -8);
        *(undefined4 *)(iVar1 + 4) = DAT_005f6028;
        *(undefined4 **)((int)register0x00000010 + -0x20) = &DAT_005f6028;
        *(int *)((int)register0x00000010 + -0x1c) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c535;
        FUN_00402760();
        *(undefined **)((int)register0x00000010 + -0x20) = &DAT_005f6020;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c545;
        FUN_0040f0e0();
        *(undefined4 *)((int)register0x00000010 + 8) =
             *(undefined4 *)((int)register0x00000010 + -0x14);
        return;
      }
      *(char **)((int)register0x00000010 + -0x20) =
           "markBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb";
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x11;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x42c5c2;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x42c5c8;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_0042c5d0 */

void FUN_0042c5d0(void)

{
  int iVar1;
  int iVar2;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040ecf0(&DAT_005f6020);
  if (DAT_005f6030 != 0) {
    iVar1 = DAT_005f6030;
    if (DAT_005f6024 == 0) {
      DAT_005f6024 = DAT_005f6030;
    }
    else {
      do {
        iVar2 = iVar1;
        iVar1 = *(int *)(iVar2 + 4);
      } while (iVar1 != 0);
      *(int *)(iVar2 + 4) = DAT_005f6024;
      DAT_005f6024 = DAT_005f6030;
    }
  }
  DAT_005f6030 = DAT_005f602c;
  DAT_005f602c = DAT_005f6028;
  FUN_00402760(&DAT_005f6028,0);
  FUN_0040f0e0(&DAT_005f6020);
  return;
}



/* Function: FUN_0042c680 */

void FUN_0042c680(void)

{
  int iVar1;
  undefined4 *puVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x14);
      if (DAT_005f6024 != 0) {
        *(int *)((int)register0x00000010 + -8) = DAT_005f6024;
        iVar1 = *(int *)(DAT_005f6024 + 4);
        *(int *)((int)register0x00000010 + -0x14) = DAT_005f6024;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x10000;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c6be;
        DAT_005f6024 = iVar1;
        FUN_0046f470();
        puVar2 = *(undefined4 **)((int)register0x00000010 + -8);
        goto LAB_0042c70a;
      }
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005f6020;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c6d4;
      FUN_0040f0e0();
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x10000;
      *(undefined **)((int)register0x00000010 + -0x10) = &DAT_005f84f0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c6ea;
      FUN_00414d10();
      if (*(int *)((int)register0x00000010 + -0xc) != 0) {
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + -0xc);
        *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005f6020;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c706;
        FUN_0040ecf0();
        puVar2 = *(undefined4 **)((int)register0x00000010 + -4);
LAB_0042c70a:
        puVar2[1] = 0;
        *puVar2 = 0;
        *(undefined4 **)((int)register0x00000010 + 4) = puVar2;
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004ca41d;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c735;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x42c73b;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_0042c740 */

void FUN_0042c740(void)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  undefined1 *puVar4;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x14);
      if (DAT_005cc490 < 0x13) {
        iVar1 = *(int *)((int)register0x00000010 + 4);
        if (DAT_005f5fd0 == 0) {
          uVar2 = *(undefined4 *)((int)register0x00000010 + 0xc);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c781;
          FUN_0046ed80();
          uVar2 = *(undefined4 *)((int)register0x00000010 + 0xc);
          *in_EDI = uVar2;
          in_EDI[1] = *(undefined4 *)(iVar1 + 0x9c);
        }
        *(undefined4 *)(iVar1 + 0x9c) = uVar2;
        *(int *)((int)register0x00000010 + -0x14) = iVar1 + 0x40;
        *(undefined4 *)((int)register0x00000010 + -0x10) = uVar2;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c7a5;
        FUN_004329b0();
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined1 *)((int)register0x00000010 + -0x10) =
             *(undefined1 *)((int)register0x00000010 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c7ba;
        FUN_0042e750();
        iVar1 = *(int *)((int)register0x00000010 + 4);
        *(undefined4 *)(iVar1 + 0x34) = DAT_005cc280;
        if (DAT_005f5fd0 == 0) {
          uVar2 = *(undefined4 *)((int)register0x00000010 + 8);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c7dc;
          FUN_0046ed80();
          uVar2 = *(undefined4 *)((int)register0x00000010 + 8);
          *in_EDI = uVar2;
          in_EDI[1] = *(undefined4 *)(iVar1 + 0x98);
        }
        *(undefined4 *)(iVar1 + 0x98) = uVar2;
        *(int *)((int)register0x00000010 + -0x14) = iVar1 + 0x58;
        *(undefined1 *)((int)register0x00000010 + -0x10) =
             *(undefined1 *)((int)register0x00000010 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c80d;
        FUN_00425610();
        iVar1 = *(int *)((int)register0x00000010 + 4);
        *(int *)(iVar1 + 0xa0) = *(int *)(iVar1 + 0xa0) + *(int *)((int)register0x00000010 + -8);
        *(undefined1 *)(iVar1 + 0xa5) = *(undefined1 *)((int)register0x00000010 + 0x10);
        return;
      }
      *(uint *)((int)register0x00000010 + -4) = DAT_005cc490;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c839;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x14) =
           "runtime: root level max pages = NtAssociateWaitCompletionPacket";
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x20;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c84f;
      FUN_0043b060();
      uVar3 = 1 << ((byte)*(uint *)((int)register0x00000010 + -4) & 0x1f) &
              -(uint)(*(uint *)((int)register0x00000010 + -4) < 0x20);
      *(uint *)((int)register0x00000010 + -0x14) = uVar3;
      *(int *)((int)register0x00000010 + -0x10) = (int)uVar3 >> 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c870;
      FUN_0043ae80();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c875;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c87a;
      FUN_0043a870();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c87f;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x14) =
           "runtime: summary max pages = runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x1d;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c895;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x40000;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c8a9;
      FUN_0043ae80();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c8ae;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c8b3;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004cc5d7;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x2b;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42c8c9;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x42c8cf;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_0042c8e0 */

void FUN_0042c8e0(void)

{
  undefined4 uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  undefined1 *puVar6;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x2c);
      *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0x58;
      uVar5 = *(int *)((int)register0x00000010 + 0xc) + 0x3fffff +
              *(uint *)((int)register0x00000010 + 8) & 0xffc00000;
      *(uint *)((int)register0x00000010 + -0x14) = uVar5;
      uVar2 = *(uint *)((int)register0x00000010 + 8) & 0xffc00000;
      *(uint *)((int)register0x00000010 + -0x18) = uVar2;
      *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 4);
      *(uint *)((int)register0x00000010 + -0x28) = uVar2;
      *(uint *)((int)register0x00000010 + -0x24) = uVar5;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42c939;
      FUN_0042e8c0();
      uVar1 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x9c);
      *(undefined4 *)((int)register0x00000010 + -0x2c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + -0x18);
      *(undefined4 *)((int)register0x00000010 + -0x24) =
           *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x20) = uVar1;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42c963;
      FUN_00425680();
      iVar4 = *(int *)((int)register0x00000010 + 4);
      *(int *)(iVar4 + 0xa0) = *(int *)(iVar4 + 0xa0) + *(int *)((int)register0x00000010 + -0x1c);
      uVar2 = *(uint *)((int)register0x00000010 + -0x18);
      uVar5 = uVar2 >> 0x16;
      if ((*(uint *)(iVar4 + 0x38) == 0) || (uVar5 < *(uint *)(iVar4 + 0x38))) {
        *(uint *)(iVar4 + 0x38) = uVar5;
      }
      *(uint *)((int)register0x00000010 + -8) = uVar5;
      uVar5 = *(uint *)((int)register0x00000010 + -0x14);
      uVar3 = uVar5 >> 0x16;
      *(uint *)((int)register0x00000010 + -0xc) = uVar3;
      if (*(uint *)(iVar4 + 0x3c) < uVar3) {
        *(uint *)(iVar4 + 0x3c) = uVar3;
      }
      *(uint *)((int)register0x00000010 + -0x2c) = uVar2;
      *(uint *)((int)register0x00000010 + -0x28) = uVar5;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42c9b5;
      FUN_00432830();
      *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 4) + 0x40;
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + -0x24);
      *(undefined4 *)((int)register0x00000010 + -0x24) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42c9d4;
      FUN_00432bc0();
      uVar2 = *(uint *)((int)register0x00000010 + -0x18);
      iVar4 = *(int *)((int)register0x00000010 + 4);
      if (uVar2 < *(uint *)(iVar4 + 0x34)) {
        *(uint *)(iVar4 + 0x34) = uVar2;
      }
      uVar3 = *(uint *)((int)register0x00000010 + -0xc);
      uVar5 = *(uint *)((int)register0x00000010 + -8);
      while( true ) {
        if (uVar3 <= uVar5) {
          *(int *)((int)register0x00000010 + -0x2c) = iVar4;
          *(uint *)((int)register0x00000010 + -0x28) = uVar2;
          *(uint *)((int)register0x00000010 + -0x24) =
               *(uint *)((int)register0x00000010 + 0xc) >> 0xd;
          *(undefined2 *)((int)register0x00000010 + -0x20) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42ca97;
          FUN_0042cb80();
          return;
        }
        *(uint *)((int)register0x00000010 + -0x10) = uVar5;
        if (*(int *)(iVar4 + 0x30) == 0) {
          uVar1 = *(undefined4 *)(iVar4 + 0x9c);
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x20000;
          *(undefined4 *)((int)register0x00000010 + -0x28) = uVar1;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42ca4e;
          FUN_00414d10();
          if (*(int *)((int)register0x00000010 + -0x24) == 0) goto LAB_0042caa7;
          iVar4 = *(int *)((int)register0x00000010 + 4);
          *(int *)(iVar4 + 0x30) = *(int *)((int)register0x00000010 + -0x24);
          uVar5 = *(uint *)((int)register0x00000010 + -0x10);
        }
        if (0x3ff < uVar5) break;
        *(uint *)((int)register0x00000010 + -0x2c) = *(int *)(iVar4 + 0x30) + 0x40 + uVar5 * 0x80;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x200;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42ca12;
        FUN_0042f5a0();
        uVar5 = *(int *)((int)register0x00000010 + -0x10) + 1;
        iVar4 = *(int *)((int)register0x00000010 + 4);
        uVar2 = *(uint *)((int)register0x00000010 + -0x18);
        uVar3 = *(uint *)((int)register0x00000010 + -0xc);
      }
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42caa7;
      FUN_0046ee00();
LAB_0042caa7:
      *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004c808f;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x18;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42cabd;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x42cac3;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_0042cad0 */

void FUN_0042cad0(int param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined1 local_14 [16];
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc)) {
    local_4 = 0x42cb74;
    FUN_0046afb0();
  }
  FUN_0040ecf0(&DAT_005ddde0);
  if (*(char *)(param_1 + 0xa4) == '\0') {
    *(undefined1 *)(param_1 + 0xa4) = 1;
    FUN_0046ef4b();
    local_4 = *(undefined4 *)(param_1 + 0x9c);
    FUN_00433020(param_1 + 0x40,local_14);
    FUN_0040f0e0(&DAT_005ddde0);
    for (iVar1 = *(int *)(param_1 + 0x44); 0 < iVar1; iVar1 = iVar1 + -1) {
    }
    return;
  }
  FUN_0040f0e0(&DAT_005ddde0);
  return;
}



/* Function: FUN_0042cb80 */

void FUN_0042cb80(void)

{
  int *piVar1;
  undefined4 *puVar2;
  int iVar3;
  int iVar4;
  undefined4 uVar5;
  uint uVar6;
  byte bVar7;
  char cVar8;
  uint in_EDX;
  uint uVar9;
  undefined1 *puVar10;
  uint uVar11;
  int iVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  int in_FS_OFFSET;
  
  do {
    puVar10 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar10 = (undefined1 *)((int)register0x00000010 + -100);
      uVar9 = *(uint *)((int)register0x00000010 + 4);
      uVar11 = *(int *)((int)register0x00000010 + 0xc) * 0x2000 + -1 +
               *(uint *)((int)register0x00000010 + 8);
      *(uint *)((int)register0x00000010 + -0x30) = uVar11;
      uVar13 = *(uint *)((int)register0x00000010 + 8) >> 0x16;
      *(uint *)((int)register0x00000010 + -0x18) = uVar13;
      uVar11 = uVar11 >> 0x16;
      if (uVar11 == uVar13) {
        if (*(uint *)(uVar9 + 0x28) <= uVar13) goto LAB_0042ceb7;
        puVar2 = (undefined4 *)(*(int *)(uVar9 + 0x24) + uVar13 * 8);
        *(undefined4 *)((int)register0x00000010 + -0x48) = *puVar2;
        *(undefined4 *)((int)register0x00000010 + -0x44) = puVar2[1];
        *(uint *)((int)register0x00000010 + -100) = *(int *)(uVar9 + 0x30) + uVar13 * 0x80;
        *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cccc;
        FUN_0042fff0();
        iVar12 = *(int *)((int)register0x00000010 + -0x60);
        iVar3 = *(int *)((int)register0x00000010 + -0x5c);
        iVar4 = *(int *)((int)register0x00000010 + -0x48);
        in_EDX = CONCAT31((int3)((uint)iVar4 >> 8),iVar12 == iVar4);
        if (iVar3 == *(int *)((int)register0x00000010 + -0x44) && iVar12 == iVar4) {
          return;
        }
        uVar9 = *(uint *)((int)register0x00000010 + 4);
        uVar11 = *(uint *)(uVar9 + 0x28);
        if (uVar11 <= *(uint *)((int)register0x00000010 + -0x18)) goto LAB_0042ceae;
        piVar1 = (int *)(*(int *)(uVar9 + 0x24) + *(uint *)((int)register0x00000010 + -0x18) * 8);
        *piVar1 = iVar12;
        piVar1[1] = iVar3;
        uVar13 = uVar9;
        goto LAB_0042cd12;
      }
      *(uint *)((int)register0x00000010 + -0x1c) = uVar11;
      if (*(char *)((int)register0x00000010 + 0x10) != '\0') {
        *(undefined4 *)((int)register0x00000010 + -4) = *(undefined4 *)(uVar9 + 0x24);
        *(undefined4 *)((int)register0x00000010 + -0x3c) = *(undefined4 *)(uVar9 + 0x28);
        *(uint *)((int)register0x00000010 + -100) = *(int *)(uVar9 + 0x30) + uVar13 * 0x80;
        *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cc0c;
        FUN_0042fff0();
        uVar9 = *(uint *)((int)register0x00000010 + -0x18);
        uVar13 = uVar9;
        if (uVar9 < *(uint *)((int)register0x00000010 + -0x3c)) {
          iVar12 = *(int *)((int)register0x00000010 + -4);
          uVar5 = *(undefined4 *)((int)register0x00000010 + -0x5c);
          *(undefined4 *)(iVar12 + uVar9 * 8) = *(undefined4 *)((int)register0x00000010 + -0x60);
          ((undefined4 *)(iVar12 + uVar9 * 8))[1] = uVar5;
          uVar11 = *(uint *)((int)register0x00000010 + 4);
          uVar15 = *(uint *)((int)register0x00000010 + -0x1c);
          if (uVar15 <= *(uint *)(uVar11 + 0x2c)) {
            uVar13 = uVar9 + 1;
            if (uVar13 <= uVar15) {
              uVar13 = ((int)-((*(uint *)(uVar11 + 0x2c) - uVar9) + -1) >> 0x1f & uVar13 * 8) +
                       *(int *)(uVar11 + 0x24);
              in_EDX = (uVar15 - uVar9) - 1;
              uVar9 = (uint)*(byte *)((int)register0x00000010 + 0x11);
              if (*(byte *)((int)register0x00000010 + 0x11) != 0) {
                if (in_EDX == 0) goto LAB_0042cebe;
                *(uint *)((int)register0x00000010 + -100) = uVar13;
                in_EDX = in_EDX * 8;
                *(uint *)((int)register0x00000010 + -0x60) = in_EDX;
                *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cc8f;
                FUN_0046f470();
                uVar11 = *(uint *)((int)register0x00000010 + 4);
                goto LAB_0042cebe;
              }
              uVar9 = 0;
              goto LAB_0042cf13;
            }
            *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cf22;
            FUN_0046ee60();
          }
          *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cf29;
          FUN_0046ee40();
        }
        *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cf2e;
        FUN_0046ee00();
        goto LAB_0042cf2e;
      }
      *(undefined4 *)((int)register0x00000010 + -0x40) = *(undefined4 *)(uVar9 + 0x28);
      in_EDX = *(uint *)(uVar9 + 0x24);
      *(uint *)((int)register0x00000010 + -8) = in_EDX;
      while( true ) {
        if (uVar11 < uVar13) goto LAB_0042cef4;
        if (0x3ff < uVar13) goto LAB_0042cf8c;
        *(uint *)((int)register0x00000010 + -0x20) = uVar13;
        *(uint *)((int)register0x00000010 + -100) = *(int *)(uVar9 + 0x30) + uVar13 * 0x80;
        *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cf7b;
        FUN_0042fff0();
        uVar13 = *(uint *)((int)register0x00000010 + -0x20);
        if (*(uint *)((int)register0x00000010 + -0x40) <= uVar13) break;
LAB_0042cf2e:
        in_EDX = *(uint *)((int)register0x00000010 + -8);
        puVar2 = (undefined4 *)(in_EDX + uVar13 * 8);
        uVar5 = *(undefined4 *)((int)register0x00000010 + -0x5c);
        *puVar2 = *(undefined4 *)((int)register0x00000010 + -0x60);
        puVar2[1] = uVar5;
        uVar13 = uVar13 + 1;
        uVar11 = *(uint *)((int)register0x00000010 + -0x1c);
        uVar9 = *(uint *)((int)register0x00000010 + 4);
      }
      *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cf8c;
      FUN_0046ee00();
LAB_0042cf8c:
      *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cf98;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar10 + -4) = 0x42cf9e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar10;
  } while( true );
LAB_0042cef4:
  uVar13 = *(uint *)((int)register0x00000010 + 4);
LAB_0042cd12:
  uVar11 = *(uint *)((int)register0x00000010 + -0x30);
  uVar15 = *(uint *)((int)register0x00000010 + 8);
  uVar6 = 2;
  cVar8 = '\x01';
  while( true ) {
    if (((int)uVar6 < 0) || (cVar8 == '\0')) {
      return;
    }
    uVar9 = uVar13;
    if (3 < uVar6 + 1) goto LAB_0042cea2;
    uVar5 = *(undefined4 *)(uVar6 * 4 + 0x5cc474);
    in_EDX = *(uint *)(uVar6 * 4 + 0x5cc494);
    if (3 < uVar6) break;
    *(uint *)((int)register0x00000010 + -0x2c) = uVar6;
    *(undefined4 *)((int)register0x00000010 + -0x34) = uVar5;
    *(uint *)((int)register0x00000010 + -0x38) = in_EDX;
    bVar7 = (byte)(&DAT_005cc480)[uVar6];
    uVar14 = -(uint)((uint)(&DAT_005cc480)[uVar6] < 0x20);
    iVar12 = (uVar11 >> (bVar7 & 0x1f) & uVar14) + 1;
    *(int *)((int)register0x00000010 + -0x24) = iVar12;
    uVar9 = *(uint *)((int)register0x00000010 + -0x34);
    cVar8 = '\0';
    uVar14 = uVar15 >> (bVar7 & 0x1f) & uVar14;
    while ((int)uVar14 < iVar12) {
      *(uint *)((int)register0x00000010 + -0x28) = uVar14;
      *(char *)((int)register0x00000010 + -0x49) = cVar8;
      *(uint *)((int)register0x00000010 + -0xc) = uVar6 * 3;
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)(uVar13 + 0x14 + uVar6 * 0xc);
      *(int *)((int)register0x00000010 + -0x14) = *(int *)((int)register0x00000010 + -0x28) + 1;
      uVar11 = *(int *)((int)register0x00000010 + -0x28) + 1 << ((byte)uVar9 & 0x1f) &
               -(uint)(uVar9 < 0x20);
      uVar14 = uVar14 << ((byte)uVar9 & 0x1f) & -(uint)(uVar9 < 0x20);
      uVar15 = *(uint *)((int)register0x00000010 + -0x10);
      uVar9 = uVar13;
      if (uVar15 < uVar11) {
LAB_0042ce8f:
        in_EDX = uVar15;
        *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42ce98;
        FUN_0046ee30();
        goto LAB_0042ce98;
      }
      if (uVar11 < uVar14) {
LAB_0042ce86:
        *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42ce8f;
        FUN_0046ee50();
        goto LAB_0042ce8f;
      }
      iVar12 = uVar15 - uVar14;
      uVar11 = uVar11 - uVar14;
      uVar15 = -iVar12 >> 0x1f & uVar14 << 3;
      *(uint *)((int)register0x00000010 + -100) = *(int *)(uVar13 + 0xc + uVar6 * 0xc) + uVar15;
      *(uint *)((int)register0x00000010 + -0x60) = uVar11;
      *(int *)((int)register0x00000010 + -0x5c) = iVar12;
      *(uint *)((int)register0x00000010 + -0x58) = in_EDX;
      *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42ce2d;
      FUN_0042e5c0();
      uVar13 = *(uint *)((int)register0x00000010 + 4);
      uVar9 = *(uint *)((int)register0x00000010 + -0x28);
      if (*(uint *)(uVar13 + 4 + *(int *)((int)register0x00000010 + -0xc) * 4) <= uVar9) {
        *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42ce86;
        FUN_0046edf0();
        goto LAB_0042ce86;
      }
      iVar12 = *(int *)((int)register0x00000010 + -0x50);
      piVar1 = (int *)(*(int *)(uVar13 + *(int *)((int)register0x00000010 + -0xc) * 4) + uVar9 * 8);
      if (piVar1[1] == iVar12 && *piVar1 == *(int *)((int)register0x00000010 + -0x54)) {
        cVar8 = *(char *)((int)register0x00000010 + -0x49);
      }
      else {
        *piVar1 = *(int *)((int)register0x00000010 + -0x54);
        piVar1[1] = iVar12;
        cVar8 = '\x01';
      }
      iVar12 = *(int *)((int)register0x00000010 + -0x24);
      uVar9 = *(uint *)((int)register0x00000010 + -0x34);
      in_EDX = *(uint *)((int)register0x00000010 + -0x38);
      uVar6 = *(uint *)((int)register0x00000010 + -0x2c);
      uVar14 = *(uint *)((int)register0x00000010 + -0x14);
    }
    uVar6 = uVar6 - 1;
    uVar11 = *(uint *)((int)register0x00000010 + -0x30);
    uVar15 = *(uint *)((int)register0x00000010 + 8);
  }
LAB_0042ce98:
  *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cea2;
  FUN_0046edf0();
LAB_0042cea2:
  *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42ceae;
  FUN_0046edf0();
LAB_0042ceae:
  *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42ceb7;
  FUN_0046ee00();
LAB_0042ceb7:
  *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cebe;
  FUN_0046ee00();
LAB_0042cebe:
  while( true ) {
    *(int *)((int)register0x00000010 + -100) =
         *(int *)(uVar11 + 0x30) + *(int *)((int)register0x00000010 + -0x1c) * 0x80;
    *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42ced4;
    FUN_0042fff0();
    uVar13 = *(uint *)((int)register0x00000010 + -0x1c);
    if (uVar13 < *(uint *)((int)register0x00000010 + -0x3c)) break;
    *(undefined4 *)((int)register0x00000010 + -0x68) = 0x42cf02;
    FUN_0046ee00();
    do {
      puVar2 = (undefined4 *)(uVar13 + uVar9 * 8);
      *puVar2 = 0x8000200;
      puVar2[1] = 0x2000;
      uVar9 = uVar9 + 1;
LAB_0042cf13:
    } while ((int)uVar9 < (int)in_EDX);
  }
  iVar12 = *(int *)((int)register0x00000010 + -4);
  uVar5 = *(undefined4 *)((int)register0x00000010 + -0x5c);
  *(undefined4 *)(iVar12 + uVar13 * 8) = *(undefined4 *)((int)register0x00000010 + -0x60);
  ((undefined4 *)(iVar12 + uVar13 * 8))[1] = uVar5;
  goto LAB_0042cef4;
}



/* Function: FUN_0042cfb0 */

void FUN_0042cfb0(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  undefined4 uVar8;
  undefined1 *puVar9;
  uint uVar10;
  uint uVar11;
  int in_FS_OFFSET;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0x44);
      iVar4 = *(int *)((int)register0x00000010 + 4);
      uVar10 = *(uint *)((int)register0x00000010 + 8);
      uVar11 = (uVar10 - 1) + *(int *)((int)register0x00000010 + 0xc) * 0x2000;
      uVar7 = uVar10 >> 0x16;
      *(uint *)((int)register0x00000010 + -0x10) = uVar7;
      uVar5 = uVar11 >> 0x16;
      uVar10 = (uVar10 & 0x3fffff) >> 0xd;
      *(uint *)((int)register0x00000010 + -0x14) = uVar10;
      uVar11 = (uVar11 & 0x3fffff) >> 0xd;
      if (uVar5 == uVar7) {
        *(int *)((int)register0x00000010 + -4) = iVar4 + 0x58;
        iVar1 = (uVar11 - uVar10) + 1;
        *(int *)((int)register0x00000010 + -0x20) = iVar1;
        iVar4 = *(int *)(iVar4 + 0x30);
        *(int *)((int)register0x00000010 + -8) = iVar4;
        *(uint *)((int)register0x00000010 + -0x24) = uVar7 * 0x80;
        *(uint *)((int)register0x00000010 + -0x44) = iVar4 + 0x40 + uVar7 * 0x80;
        *(uint *)((int)register0x00000010 + -0x40) = uVar10;
        *(int *)((int)register0x00000010 + -0x3c) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d0dd;
        FUN_0042fa80();
        *(undefined4 *)((int)register0x00000010 + -0x28) =
             *(undefined4 *)((int)register0x00000010 + -0x38);
        *(int *)((int)register0x00000010 + -0x44) =
             *(int *)((int)register0x00000010 + -0x24) + *(int *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -0x14);
        *(undefined4 *)((int)register0x00000010 + -0x3c) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d107;
        FUN_00430c30();
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x3c) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d123;
        FUN_004258f0();
        iVar4 = *(int *)((int)register0x00000010 + -0x28);
LAB_0042d127:
        *(int *)((int)register0x00000010 + -0x34) = iVar4;
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x3c) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined2 *)((int)register0x00000010 + -0x38) = 0x101;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d14e;
        FUN_0042cb80();
        *(int *)((int)register0x00000010 + 0x10) = *(int *)((int)register0x00000010 + -0x34) << 0xd;
        return;
      }
      *(uint *)((int)register0x00000010 + -0x18) = uVar5;
      *(uint *)((int)register0x00000010 + -0x1c) = uVar11;
      *(uint *)((int)register0x00000010 + -0x20) = -(uVar10 - 0x200);
      *(int *)((int)register0x00000010 + -4) = iVar4 + 0x58;
      iVar4 = *(int *)(iVar4 + 0x30);
      *(int *)((int)register0x00000010 + -8) = iVar4;
      *(uint *)((int)register0x00000010 + -0x24) = uVar7 * 0x80;
      *(uint *)((int)register0x00000010 + -0x44) = iVar4 + 0x40 + uVar7 * 0x80;
      *(uint *)((int)register0x00000010 + -0x40) = uVar10;
      *(uint *)((int)register0x00000010 + -0x3c) = -(uVar10 - 0x200);
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d04c;
      FUN_0042fa80();
      *(undefined4 *)((int)register0x00000010 + -0x28) =
           *(undefined4 *)((int)register0x00000010 + -0x38);
      *(int *)((int)register0x00000010 + -0x44) =
           *(int *)((int)register0x00000010 + -0x24) + *(int *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x40) =
           *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x3c) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d076;
      FUN_00430c30();
      *(undefined4 *)((int)register0x00000010 + -0x44) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x40) =
           *(undefined4 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x3c) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d092;
      FUN_004258f0();
      uVar10 = *(int *)((int)register0x00000010 + -0x10) + 1;
      uVar11 = *(uint *)((int)register0x00000010 + -0x18);
      iVar4 = *(int *)((int)register0x00000010 + 4);
      uVar8 = *(undefined4 *)((int)register0x00000010 + -0x28);
      while( true ) {
        *(undefined4 *)((int)register0x00000010 + -0x34) = uVar8;
        if (uVar11 <= uVar10) {
          *(int *)((int)register0x00000010 + -0x20) = *(int *)((int)register0x00000010 + -0x1c) + 1;
          iVar4 = *(int *)(iVar4 + 0x30);
          *(int *)((int)register0x00000010 + -8) = iVar4;
          *(uint *)((int)register0x00000010 + -0x24) = uVar11 * 0x80;
          *(uint *)((int)register0x00000010 + -0x44) = iVar4 + 0x40 + uVar11 * 0x80;
          *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
          *(int *)((int)register0x00000010 + -0x3c) = *(int *)((int)register0x00000010 + -0x1c) + 1;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d24d;
          FUN_0042fa80();
          *(undefined4 *)((int)register0x00000010 + -0x28) =
               *(undefined4 *)((int)register0x00000010 + -0x38);
          *(int *)((int)register0x00000010 + -0x44) =
               *(int *)((int)register0x00000010 + -0x24) + *(int *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x3c) =
               *(undefined4 *)((int)register0x00000010 + -0x20);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d277;
          FUN_00430c30();
          *(undefined4 *)((int)register0x00000010 + -0x44) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x40) =
               *(undefined4 *)((int)register0x00000010 + -0x18);
          *(undefined4 *)((int)register0x00000010 + -0x3c) =
               *(undefined4 *)((int)register0x00000010 + -0x20);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d293;
          FUN_004258f0();
          iVar4 = *(int *)((int)register0x00000010 + -0x28) +
                  *(int *)((int)register0x00000010 + -0x34);
          goto LAB_0042d127;
        }
        if (0x3ff < uVar10) break;
        *(uint *)((int)register0x00000010 + -0x30) = uVar10;
        iVar4 = *(int *)(iVar4 + 0x30);
        *(int *)((int)register0x00000010 + -8) = iVar4;
        *(uint *)((int)register0x00000010 + -0x24) = uVar10 * 0x80;
        iVar4 = uVar10 * 0x80 + 0x40 + iVar4;
        *(int *)((int)register0x00000010 + -0xc) = iVar4;
        *(int *)((int)register0x00000010 + -0x44) = iVar4;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x200;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d1ff;
        FUN_0042fa80();
        iVar4 = *(int *)((int)register0x00000010 + -0x38);
        iVar1 = *(int *)((int)register0x00000010 + -0x34);
        iVar2 = *(int *)((int)register0x00000010 + -0x24);
        iVar3 = *(int *)((int)register0x00000010 + -8);
        for (iVar6 = 0; iVar6 < 8; iVar6 = iVar6 + 1) {
          *(undefined4 *)(iVar2 + iVar3 + iVar6 * 8) = 0xffffffff;
          ((undefined4 *)(iVar2 + iVar3 + iVar6 * 8))[1] = 0xffffffff;
        }
        *(int *)((int)register0x00000010 + -0x34) = iVar4 + iVar1;
        *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + -0x30) + 1;
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x40;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d17f;
        FUN_0046f470();
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -0x30);
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x200;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d19b;
        FUN_004258f0();
        uVar11 = *(uint *)((int)register0x00000010 + -0x18);
        uVar10 = *(uint *)((int)register0x00000010 + -0x2c);
        iVar4 = *(int *)((int)register0x00000010 + 4);
        uVar8 = *(undefined4 *)((int)register0x00000010 + -0x34);
      }
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x42d2c7;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar9 + -4) = 0x42d2cd;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
}



/* Function: FUN_0042d2e0 */

void FUN_0042d2e0(int param_1,uint param_2)

{
  int in_FS_OFFSET;
  char local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 'f';
    FUN_0046d980();
  }
  if (((*(char *)(param_1 + 0xa5) == '\0') && (DAT_005ddf14 != 0)) &&
     (*(int *)(DAT_005ddf14 + (param_2 >> 0x16) * 4) != 0)) {
    return;
  }
  FUN_00432af0(param_1 + 0x40,param_2);
  if (local_4 == '\0') {
    return;
  }
  return;
}



/* Function: FUN_0042d370 */

void FUN_0042d370(void)

{
  uint *puVar1;
  int *piVar2;
  int iVar3;
  undefined4 uVar4;
  uint uVar5;
  byte bVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  undefined1 *puVar10;
  uint uVar11;
  int iVar12;
  uint uVar13;
  uint in_EDI;
  int in_FS_OFFSET;
  bool bVar14;
  
  while (puVar10 = (undefined1 *)register0x00000010,
        (undefined1 *)((int)register0x00000010 + -0x3c) <=
        *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
LAB_0042df12:
    *(undefined4 *)(puVar10 + -4) = 0x42df17;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar10;
  }
  puVar10 = (undefined1 *)((int)register0x00000010 + -0xbc);
  iVar9 = *(int *)((int)register0x00000010 + 4);
  *(undefined4 *)((int)register0x00000010 + -0x5c) = DAT_005f5e20;
  *(undefined4 *)((int)register0x00000010 + -0x58) = DAT_005cc280;
  *(code **)((int)register0x00000010 + -0xc) = FUN_0042df20;
  *(undefined1 **)((int)register0x00000010 + -8) = (undefined1 *)((int)register0x00000010 + -0x5c);
  uVar5 = 0;
  uVar7 = 0;
  uVar11 = 0;
  iVar12 = 0;
  uVar8 = 0xffffffff;
LAB_0042d3f6:
  *(uint *)((int)register0x00000010 + -0x60) = uVar7;
  if (3 < (int)uVar5) {
    if (uVar7 < 0x400) {
      *(uint *)((int)register0x00000010 + -0xbc) = *(int *)(iVar9 + 0x30) + uVar7 * 0x80;
      *(undefined4 *)((int)register0x00000010 + -0xb8) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0xb4) = 0;
      *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d52c;
      FUN_00430510();
      if (*(int *)((int)register0x00000010 + -0xb0) != -1) {
        iVar12 = *(int *)((int)register0x00000010 + -0x60) * 0x400000;
        *(int *)((int)register0x00000010 + -0x48) =
             *(int *)((int)register0x00000010 + -0xb0) * 0x2000 + iVar12;
        iVar12 = *(int *)((int)register0x00000010 + -0xac) * 0x2000 + iVar12;
        *(int *)((int)register0x00000010 + -0xbc) = iVar12;
        *(int *)((int)register0x00000010 + -0xb8) =
             (*(int *)((int)register0x00000010 + -0x60) + 1) * 0x400000 - iVar12;
        *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d56e;
        (**(code **)((int)register0x00000010 + -0xc))();
        *(undefined4 *)((int)register0x00000010 + -0xbc) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0xb8) =
             *(undefined4 *)((int)register0x00000010 + -0x5c);
        *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d585;
        FUN_0042d2e0();
        *(undefined4 *)((int)register0x00000010 + 0xc) =
             *(undefined4 *)((int)register0x00000010 + -0x48);
        *(undefined4 *)((int)register0x00000010 + 0x10) =
             *(undefined4 *)((int)register0x00000010 + -0xb4);
        return;
      }
      uVar8 = *(uint *)((int)register0x00000010 + 4);
      uVar7 = *(uint *)(uVar8 + 0x28);
      if (*(uint *)((int)register0x00000010 + -0x60) < uVar7) {
        puVar1 = (uint *)(*(int *)(uVar8 + 0x24) + *(uint *)((int)register0x00000010 + -0x60) * 8);
        uVar7 = puVar1[1];
        uVar8 = *puVar1;
        bVar14 = (uVar7 & 0x80000000) == 0;
        if (bVar14) {
          uVar11 = uVar8 & 0x3ffff;
          bVar14 = (uVar7 & 0x80000000) == 0;
        }
        else {
          uVar11 = 0x40000;
        }
        if (bVar14) {
          uVar8 = uVar8 >> 0x12 | (uVar7 & 0xf) << 0xe;
          bVar14 = (uVar7 & 0x80000000) == 0;
        }
        else {
          uVar8 = 0x40000;
        }
        *(uint *)((int)register0x00000010 + -0xa4) = uVar8;
        *(uint *)((int)register0x00000010 + -0xa0) = uVar11;
        if (bVar14) goto LAB_0042d739;
        uVar7 = 0x40000;
        do {
          *(uint *)((int)register0x00000010 + -0xa8) = uVar7;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d5fb;
          FUN_0043a810();
          *(char **)((int)register0x00000010 + -0xbc) =
               "runtime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb";
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x11;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d611;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) = 3;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d625;
          FUN_0043ae80();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2952;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d63b;
          FUN_0043b060();
          *(int *)((int)register0x00000010 + -0xbc) = *(int *)((int)register0x00000010 + -0x60);
          *(int *)((int)register0x00000010 + -0xb8) =
               *(int *)((int)register0x00000010 + -0x60) >> 0x1f;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d64e;
          FUN_0043ae80();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2c69;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 5;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d664;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0xa0);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d678;
          FUN_0043ad50();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c293a;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d68e;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0xa4);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d6a2;
          FUN_0043ad50();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c293a;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d6b8;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0xa8);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d6cc;
          FUN_0043ad50();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2946;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d6e2;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d6e7;
          FUN_0043a870();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d6ec;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c5bfe;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x12;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d702;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d719;
          FUN_0043ad50();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d71e;
          FUN_0043aa10();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d723;
          FUN_0043a870();
          *(char **)((int)register0x00000010 + -0xbc) =
               "bad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod";
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x10;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d739;
          FUN_00469a20();
LAB_0042d739:
          uVar7 = uVar7 >> 4 & 0x3ffff;
        } while( true );
      }
      *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d77a;
      FUN_0046edf0();
    }
    uVar5 = 0x400;
    *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d786;
    FUN_0046ee00();
    goto LAB_0042d786;
  }
  *(int *)((int)register0x00000010 + -0x7c) = iVar12;
  *(uint *)((int)register0x00000010 + -0x78) = uVar11;
  *(uint *)((int)register0x00000010 + -0x80) = uVar8;
  uVar7 = (&DAT_005cc470)[uVar5];
  bVar6 = (byte)uVar7;
  *(int *)((int)register0x00000010 + -0x14) =
       *(int *)((int)register0x00000010 + -0x60) << (bVar6 & 0x1f);
  *(undefined4 *)((int)register0x00000010 + -0x18) = *(undefined4 *)(iVar9 + 8 + uVar5 * 0xc);
  uVar8 = (&DAT_005cc490)[uVar5];
  *(undefined4 *)((int)register0x00000010 + -4) = *(undefined4 *)(iVar9 + uVar5 * 0xc);
  uVar7 = -(uint)(uVar7 < 0x20);
  in_EDI = 1 << (bVar6 & 0x1f) & uVar7;
  uVar7 = *(uint *)((int)register0x00000010 + -0x14) & uVar7;
  if (uVar7 + in_EDI <= *(uint *)((int)register0x00000010 + -0x18)) {
    if (uVar7 <= uVar7 + in_EDI) {
      *(uint *)((int)register0x00000010 + -0x74) = uVar5;
      *(uint *)((int)register0x00000010 + -0x54) = in_EDI;
      *(uint *)((int)register0x00000010 + -0x60) = uVar7;
      puVar1 = (uint *)(iVar9 + 0x34);
      iVar9 = *(int *)((int)register0x00000010 + -4) +
              ((int)-(*(uint *)((int)register0x00000010 + -0x18) - uVar7) >> 0x1f & uVar7 << 3);
      uVar13 = *puVar1 >> ((byte)(&DAT_005cc480)[uVar5] & 0x1f) &
               -(uint)((uint)(&DAT_005cc480)[uVar5] < 0x20);
      uVar11 = *(uint *)((int)register0x00000010 + -0x60);
      if ((-in_EDI & uVar13) == uVar11) {
        uVar5 = *(uint *)((int)register0x00000010 + -0x54);
        uVar13 = uVar5 - 1 & uVar13;
      }
      else {
        uVar5 = *(uint *)((int)register0x00000010 + -0x54);
        uVar13 = 0;
      }
      *(uint *)((int)register0x00000010 + -0x1c) = uVar8;
      *(int *)((int)register0x00000010 + -0x10) = iVar9;
      *(uint *)((int)register0x00000010 + -0x70) = uVar13;
      uVar7 = 0;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0;
      in_EDI = uVar13;
      do {
        if ((int)uVar5 <= (int)in_EDI) {
          uVar8 = *(uint *)((int)register0x00000010 + -0x4c);
LAB_0042d982:
          in_EDI = *(uint *)((int)register0x00000010 + 8);
          if (in_EDI <= uVar7) {
            *(uint *)((int)register0x00000010 + -0x50) = uVar8 << 0xd;
            uVar4 = (&DAT_005cc480)[*(int *)((int)register0x00000010 + -0x74)];
            *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar4;
            *(uint *)((int)register0x00000010 + -0x30) = uVar11 << ((byte)uVar4 & 0x1f);
            *(undefined4 *)((int)register0x00000010 + -0xbc) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0xb8) =
                 *(undefined4 *)((int)register0x00000010 + -0x5c);
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dd2c;
            FUN_0042d2e0();
            *(uint *)((int)register0x00000010 + 0xc) =
                 (-(uint)(*(uint *)((int)register0x00000010 + -0x1c) < 0x20) &
                 *(uint *)((int)register0x00000010 + -0x30)) +
                 *(int *)((int)register0x00000010 + -0x50);
            *(undefined4 *)((int)register0x00000010 + 0x10) =
                 *(undefined4 *)((int)register0x00000010 + -0xb4);
            return;
          }
          if (*(int *)((int)register0x00000010 + -0x74) == 0) {
            *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
            *(undefined4 *)((int)register0x00000010 + 0x10) = DAT_005cc280;
            return;
          }
          uVar7 = *(uint *)((int)register0x00000010 + -0x78);
          bVar14 = (uVar7 & 0x80000000) == 0;
          if (bVar14) {
            bVar14 = (uVar7 & 0x80000000) == 0;
            *(uint *)((int)register0x00000010 + -0x88) =
                 *(uint *)((int)register0x00000010 + -0x7c) & 0x3ffff;
          }
          else {
            *(uint *)((int)register0x00000010 + -0x3c) = uVar13;
            *(undefined4 *)((int)register0x00000010 + -0x88) = 0x40000;
            uVar13 = *(uint *)((int)register0x00000010 + -0x3c);
          }
          if (bVar14) {
            uVar8 = uVar7 & 0xf;
            uVar7 = *(uint *)((int)register0x00000010 + -0x78);
            bVar14 = (uVar7 & 0x80000000) == 0;
            *(uint *)((int)register0x00000010 + -0x8c) =
                 *(uint *)((int)register0x00000010 + -0x7c) >> 0x12 | uVar8 << 0xe;
          }
          else {
            *(uint *)((int)register0x00000010 + -0x44) = uVar13;
            *(undefined4 *)((int)register0x00000010 + -0x8c) = 0x40000;
          }
          if (bVar14) {
            uVar7 = uVar7 >> 4 & 0x3ffff;
          }
          else {
            uVar7 = 0x40000;
          }
          *(uint *)((int)register0x00000010 + -0x90) = uVar7;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42da34;
          FUN_0043a810();
          *(char **)((int)register0x00000010 + -0xbc) =
               "runtime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb";
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x11;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42da4a;
          FUN_0043b060();
          *(int *)((int)register0x00000010 + -0x28) =
               *(int *)((int)register0x00000010 + -0x80) >> 0x1f;
          *(int *)((int)register0x00000010 + -0xbc) = *(int *)((int)register0x00000010 + -0x74) + -1
          ;
          *(int *)((int)register0x00000010 + -0xb8) =
               *(int *)((int)register0x00000010 + -0x74) + -1 >> 0x1f;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42da6c;
          FUN_0043ae80();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2952;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42da82;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0x80);
          *(undefined4 *)((int)register0x00000010 + -0xb8) =
               *(undefined4 *)((int)register0x00000010 + -0x28);
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42da99;
          FUN_0043ae80();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2b19;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 4;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42daaf;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0x88);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dac3;
          FUN_0043ad50();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c293a;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dad9;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0x8c);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42daed;
          FUN_0043ad50();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c293a;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db03;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0x90);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db17;
          FUN_0043ad50();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db1c;
          FUN_0043aa10();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db21;
          FUN_0043a870();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db26;
          FUN_0043a810();
          *(char **)((int)register0x00000010 + -0xbc) =
               "runtime: level = , p.searchAddr = RtlGetCurrentPeb";
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x11;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db3c;
          FUN_0043b060();
          *(int *)((int)register0x00000010 + -0xbc) = *(int *)((int)register0x00000010 + -0x74);
          iVar12 = *(int *)((int)register0x00000010 + -0x74) >> 0x1f;
          *(int *)((int)register0x00000010 + -0x28) = iVar12;
          *(int *)((int)register0x00000010 + -0xb8) = iVar12;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db56;
          FUN_0043ae80();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c3ac2;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0xb;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db6c;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db83;
          FUN_0043ad50();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2f23;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 7;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42db99;
          FUN_0043b060();
          *(int *)((int)register0x00000010 + -0xbc) = *(int *)((int)register0x00000010 + -0x70);
          *(int *)((int)register0x00000010 + -0xb8) =
               *(int *)((int)register0x00000010 + -0x70) >> 0x1f;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dbac;
          FUN_0043ae80();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dbb1;
          FUN_0043aa10();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dbb6;
          FUN_0043a870();
          *(int *)((int)register0x00000010 + -0x2c) =
               *(int *)((int)register0x00000010 + -0x60) >> 0x1f;
          *(undefined4 *)((int)register0x00000010 + -0x30) =
               *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x34);
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dbda;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c80a7;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x18;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dbf0;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0x30);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dc07;
          FUN_0043aef0();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2d98;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 6;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dc1d;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0x60);
          *(undefined4 *)((int)register0x00000010 + -0xb8) =
               *(undefined4 *)((int)register0x00000010 + -0x2c);
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dc34;
          FUN_0043ae80();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dc39;
          FUN_0043aa10();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dc3e;
          FUN_0043a870();
          *(undefined4 *)((int)register0x00000010 + -0x1c) =
               (&DAT_005cc480)[*(int *)((int)register0x00000010 + -0x74)];
          *(undefined4 *)((int)register0x00000010 + -0x34) =
               (&DAT_005cc470)[*(int *)((int)register0x00000010 + -0x74)];
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dc67;
          FUN_0043a810();
          *(char **)((int)register0x00000010 + -0xbc) =
               "runtime: levelShift[level] = doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket"
          ;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x1d;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dc7d;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dc94;
          FUN_0043ad50();
          *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c6da4;
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x15;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dcaa;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0xbc) =
               *(undefined4 *)((int)register0x00000010 + -0x34);
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dcc1;
          FUN_0043ad50();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dcc6;
          FUN_0043aa10();
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dccb;
          FUN_0043a870();
          iVar12 = 0;
          while (iVar12 < *(int *)((int)register0x00000010 + -0x54)) {
            uVar7 = ((uint *)(*(int *)((int)register0x00000010 + -0x10) + iVar12 * 8))[1];
            uVar8 = *(uint *)(*(int *)((int)register0x00000010 + -0x10) + iVar12 * 8);
            bVar14 = (uVar7 & 0x80000000) == 0;
            if (bVar14) {
              uVar11 = uVar8 & 0x3ffff;
              bVar14 = (uVar7 & 0x80000000) == 0;
              in_EDI = uVar11;
            }
            else {
              uVar11 = 0x40000;
            }
            if (bVar14) {
              uVar8 = (uVar7 & 0xf) << 0xe | uVar8 >> 0x12;
              bVar14 = (uVar7 & 0x80000000) == 0;
              in_EDI = uVar7;
            }
            else {
              uVar8 = 0x40000;
            }
            *(int *)((int)register0x00000010 + -0x6c) = iVar12;
            *(uint *)((int)register0x00000010 + -0x98) = uVar8;
            *(uint *)((int)register0x00000010 + -0x94) = uVar11;
            if (bVar14) {
              uVar7 = uVar7 >> 4 & 0x3ffff;
            }
            else {
              uVar7 = 0x40000;
            }
            *(uint *)((int)register0x00000010 + -0x9c) = uVar7;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dd69;
            FUN_0043a810();
            *(char **)((int)register0x00000010 + -0xbc) =
                 "runtime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb";
            *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x11;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dd7f;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0xbc) =
                 *(undefined4 *)((int)register0x00000010 + -0x74);
            *(undefined4 *)((int)register0x00000010 + -0xb8) =
                 *(undefined4 *)((int)register0x00000010 + -0x28);
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dd96;
            FUN_0043ae80();
            *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2952;
            *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42ddac;
            FUN_0043b060();
            *(int *)((int)register0x00000010 + -0xbc) =
                 *(int *)((int)register0x00000010 + -0x60) +
                 *(int *)((int)register0x00000010 + -0x6c);
            *(int *)((int)register0x00000010 + -0xb8) =
                 *(int *)((int)register0x00000010 + -0x60) +
                 *(int *)((int)register0x00000010 + -0x6c) >> 0x1f;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42ddc5;
            FUN_0043ae80();
            *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2c69;
            *(undefined4 *)((int)register0x00000010 + -0xb8) = 5;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42dddb;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0xbc) =
                 *(undefined4 *)((int)register0x00000010 + -0x94);
            *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42ddef;
            FUN_0043ad50();
            *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c293a;
            *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42de05;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0xbc) =
                 *(undefined4 *)((int)register0x00000010 + -0x98);
            *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42de19;
            FUN_0043ad50();
            *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c293a;
            *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42de2f;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0xbc) =
                 *(undefined4 *)((int)register0x00000010 + -0x9c);
            *(undefined4 *)((int)register0x00000010 + -0xb8) = 0;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42de43;
            FUN_0043ad50();
            *(undefined **)((int)register0x00000010 + -0xbc) = &DAT_004c2946;
            *(undefined4 *)((int)register0x00000010 + -0xb8) = 2;
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42de59;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42de5e;
            FUN_0043a870();
            iVar12 = *(int *)((int)register0x00000010 + -0x6c) + 1;
          }
          *(char **)((int)register0x00000010 + -0xbc) =
               "bad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod";
          *(undefined4 *)((int)register0x00000010 + -0xb8) = 0x10;
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42defc;
          FUN_00469a20();
LAB_0042defc:
          *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42df03;
          FUN_0046edf0();
          break;
        }
        if (uVar5 <= in_EDI) goto LAB_0042defc;
        *(uint *)((int)register0x00000010 + -0x84) = uVar7;
        piVar2 = (int *)(iVar9 + in_EDI * 8);
        iVar12 = piVar2[1];
        *(int *)((int)register0x00000010 + -0x20) = iVar12;
        iVar3 = *piVar2;
        *(int *)((int)register0x00000010 + -0x24) = iVar3;
        if (iVar12 == 0 && iVar3 == 0) {
          uVar7 = 0;
          iVar12 = *(int *)((int)register0x00000010 + -0x4c);
          goto LAB_0042d786;
        }
        *(uint *)((int)register0x00000010 + -0x68) = in_EDI;
        *(uint *)((int)register0x00000010 + -100) = in_EDI + uVar11;
        *(uint *)((int)register0x00000010 + -0xbc) =
             -(uint)((uint)(&DAT_005cc480)[*(int *)((int)register0x00000010 + -0x74)] < 0x20) &
             in_EDI + uVar11 <<
             ((byte)(&DAT_005cc480)[*(int *)((int)register0x00000010 + -0x74)] & 0x1f);
        *(uint *)((int)register0x00000010 + -0xb8) =
             (1 << ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20)) << 0xd;
        *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42d824;
        (**(code **)((int)register0x00000010 + -0xc))();
        uVar11 = *(uint *)((int)register0x00000010 + -0x20);
        if ((uVar11 & 0x80000000) == 0) {
          uVar8 = *(uint *)((int)register0x00000010 + -0x24);
          uVar5 = uVar8 & 0x3ffff;
        }
        else {
          uVar8 = *(uint *)((int)register0x00000010 + -0x24);
          uVar5 = 0x40000;
        }
        iVar12 = *(int *)((int)register0x00000010 + -0x84);
        uVar7 = iVar12 + uVar5;
        if (*(uint *)((int)register0x00000010 + 8) <= uVar7) {
          if (iVar12 == 0) {
            uVar8 = *(int *)((int)register0x00000010 + -0x68) <<
                    ((byte)*(uint *)((int)register0x00000010 + -0x1c) & 0x1f) &
                    -(uint)(*(uint *)((int)register0x00000010 + -0x1c) < 0x20);
          }
          else {
            uVar8 = *(uint *)((int)register0x00000010 + -0x4c);
          }
          uVar13 = *(uint *)((int)register0x00000010 + -0x70);
          uVar11 = *(uint *)((int)register0x00000010 + -0x60);
          goto LAB_0042d982;
        }
        if ((uVar11 & 0x80000000) == 0) {
          uVar7 = uVar8 >> 0x12 | (uVar11 & 0xf) << 0xe;
        }
        else {
          uVar7 = 0x40000;
        }
        if (*(uint *)((int)register0x00000010 + 8) <= uVar7) goto LAB_0042d3d2;
        if (iVar12 != 0) {
          uVar8 = *(uint *)((int)register0x00000010 + -0x1c);
          uVar7 = 1 << ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20);
          if (uVar7 <= uVar5) {
            uVar7 = iVar12 + uVar7;
            uVar5 = *(uint *)((int)register0x00000010 + -0x54);
            iVar9 = *(int *)((int)register0x00000010 + -0x10);
            uVar11 = *(uint *)((int)register0x00000010 + -0x60);
            in_EDI = *(uint *)((int)register0x00000010 + -0x68);
            iVar12 = *(int *)((int)register0x00000010 + -0x4c);
            goto LAB_0042d786;
          }
        }
        if ((uVar11 & 0x80000000) == 0) {
          uVar7 = uVar11 >> 4 & 0x3ffff;
          uVar8 = *(uint *)((int)register0x00000010 + -0x1c);
        }
        else {
          uVar8 = *(uint *)((int)register0x00000010 + -0x1c);
          uVar7 = 0x40000;
        }
        in_EDI = *(uint *)((int)register0x00000010 + -0x68);
        iVar12 = (in_EDI + 1 << ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20)) - uVar7;
        uVar5 = *(uint *)((int)register0x00000010 + -0x54);
        iVar9 = *(int *)((int)register0x00000010 + -0x10);
        uVar11 = *(uint *)((int)register0x00000010 + -0x60);
        uVar8 = *(uint *)((int)register0x00000010 + -0x1c);
LAB_0042d786:
        in_EDI = in_EDI + 1;
        *(int *)((int)register0x00000010 + -0x4c) = iVar12;
        uVar13 = *(uint *)((int)register0x00000010 + -0x70);
      } while( true );
    }
    *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42df0a;
    FUN_0046ee50();
  }
  *(undefined4 *)((int)register0x00000010 + -0xc0) = 0x42df11;
  FUN_0046ee30();
  goto LAB_0042df12;
LAB_0042d3d2:
  uVar5 = *(int *)((int)register0x00000010 + -0x74) + 1;
  iVar9 = *(int *)((int)register0x00000010 + 4);
  uVar7 = *(uint *)((int)register0x00000010 + -100);
  uVar11 = *(uint *)((int)register0x00000010 + -0x20);
  iVar12 = *(int *)((int)register0x00000010 + -0x24);
  uVar8 = uVar7;
  in_EDI = uVar5;
  goto LAB_0042d3f6;
}



/* Function: FUN_0042df20 */

void FUN_0042df20(void)

{
  uint uVar1;
  uint *puVar2;
  uint in_EDX;
  undefined1 *puVar3;
  int iVar4;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x14);
      puVar2 = *(uint **)(in_EDX + 4);
      in_EDX = *(uint *)((int)register0x00000010 + 4);
      if (in_EDX < *puVar2) {
        iVar4 = *(int *)((int)register0x00000010 + 8);
      }
      else {
        iVar4 = *(int *)((int)register0x00000010 + 8);
        uVar1 = (in_EDX - 1) + iVar4;
        if (uVar1 <= puVar2[1]) {
          *puVar2 = in_EDX;
          puVar2[1] = uVar1;
          return;
        }
      }
      if ((in_EDX - 1) + iVar4 < *puVar2) {
        return;
      }
      if (puVar2[1] < in_EDX) {
        return;
      }
      *(uint **)((int)register0x00000010 + -4) = puVar2;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42df78;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x14) =
           "runtime: addr = runtime: base = runtime: head = timeBeginPeriod";
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42df8e;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42dfa2;
      FUN_0043aef0();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c33a5;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 9;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42dfb8;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42dfcc;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42dfd1;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42dfd6;
      FUN_0043a870();
      *(undefined4 *)((int)register0x00000010 + -8) =
           **(undefined4 **)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           (*(undefined4 **)((int)register0x00000010 + -4))[1];
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42dfec;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x14) =
           "runtime: base = runtime: head = timeBeginPeriod";
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42e002;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42e016;
      FUN_0043aef0();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c36b1;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 10;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42e02c;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42e040;
      FUN_0043aef0();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42e045;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42e04a;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004c80bf;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x18;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x42e060;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x42e066;
    FUN_0046d900();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_0042e070 */

void FUN_0042e070(void)

{
  uint *puVar1;
  uint uVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  undefined1 *puVar9;
  int in_FS_OFFSET;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0x24);
      iVar5 = *(int *)((int)register0x00000010 + 4);
      uVar8 = *(uint *)(iVar5 + 0x34) >> 0x16;
      if (*(uint *)(iVar5 + 0x3c) <= uVar8) {
        *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
        return;
      }
      uVar4 = (*(uint *)(iVar5 + 0x34) & 0x3fffff) >> 0xd;
      uVar2 = *(uint *)((int)register0x00000010 + 8);
      if (-(uVar4 - 0x200) < uVar2) goto LAB_0042e135;
      if (uVar8 < *(uint *)(iVar5 + 0x28)) {
        puVar1 = (uint *)(*(int *)(iVar5 + 0x24) + uVar8 * 8);
        uVar6 = puVar1[1];
        if ((uVar6 & 0x80000000) == 0) {
          uVar6 = *puVar1 >> 0x12 | (uVar6 & 0xf) << 0xe;
        }
        else {
          uVar6 = 0x40000;
        }
        if (uVar6 < uVar2) {
LAB_0042e135:
          *(int *)((int)register0x00000010 + -0x24) = iVar5;
          *(uint *)((int)register0x00000010 + -0x20) = uVar2;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e141;
          FUN_0042d370();
          iVar5 = *(int *)((int)register0x00000010 + -0x1c);
          if (iVar5 == 0) {
            if (*(int *)((int)register0x00000010 + 8) == 1) {
              *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x34) = DAT_005cc280;
            }
            *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
            *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
            return;
          }
          iVar7 = *(int *)((int)register0x00000010 + -0x18);
LAB_0042e177:
          *(int *)((int)register0x00000010 + -4) = iVar5;
          *(int *)((int)register0x00000010 + -0xc) = iVar7;
          *(undefined4 *)((int)register0x00000010 + -0x24) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(int *)((int)register0x00000010 + -0x20) = iVar5;
          *(undefined4 *)((int)register0x00000010 + -0x1c) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e197;
          FUN_0042cfb0();
          uVar3 = *(undefined4 *)((int)register0x00000010 + -0x18);
          if (*(uint *)(*(int *)((int)register0x00000010 + 4) + 0x34) <
              *(uint *)((int)register0x00000010 + -0xc)) {
            *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x34) =
                 *(uint *)((int)register0x00000010 + -0xc);
          }
          *(undefined4 *)((int)register0x00000010 + 0xc) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + 0x10) = uVar3;
          return;
        }
        *(uint *)((int)register0x00000010 + -4) = uVar8;
        *(uint *)((int)register0x00000010 + -0x10) = uVar6;
        *(uint *)((int)register0x00000010 + -0x24) = *(int *)(iVar5 + 0x30) + uVar8 * 0x80;
        *(uint *)((int)register0x00000010 + -0x20) = uVar2;
        *(uint *)((int)register0x00000010 + -0x1c) = uVar4;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e111;
        FUN_00430510();
        if (*(int *)((int)register0x00000010 + -0x18) != -1) {
          iVar5 = *(int *)((int)register0x00000010 + -0x18) * 0x2000 +
                  *(int *)((int)register0x00000010 + -4) * 0x400000;
          iVar7 = *(int *)((int)register0x00000010 + -0x14) * 0x2000 +
                  *(int *)((int)register0x00000010 + -4) * 0x400000;
          goto LAB_0042e177;
        }
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e1d4;
        FUN_0043a810();
        *(char **)((int)register0x00000010 + -0x24) =
             "runtime: max = requested skip=bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0xf;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e1ea;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x24) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e1fe;
        FUN_0043ad50();
        *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c3ac2;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0xb;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e214;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x24) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e228;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e22d;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e232;
        FUN_0043a870();
        uVar8 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x34);
        *(uint *)((int)register0x00000010 + -4) = uVar8;
        *(uint *)((int)register0x00000010 + -8) = (uVar8 & 0x3fffff) >> 0xd;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e24e;
        FUN_0043a810();
        *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c6db9;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x15;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e264;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x24) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e278;
        FUN_0043ad50();
        *(char **)((int)register0x00000010 + -0x24) = ", p.searchAddr = RtlGetCurrentPeb";
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x11;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e28e;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x24) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e2a2;
        FUN_0043aef0();
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e2a7;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e2ac;
        FUN_0043a870();
        *(char **)((int)register0x00000010 + -0x24) =
             "bad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod";
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x10;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e2c2;
        FUN_00469a20();
      }
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42e2c9;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar9 + -4) = 0x42e2cf;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
}



/* Function: FUN_0042e2e0 */

void FUN_0042e2e0(void)

{
  int iVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  undefined1 *puVar7;
  uint uVar8;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x38);
      uVar4 = *(uint *)((int)register0x00000010 + 8);
      iVar5 = *(int *)((int)register0x00000010 + 4);
      if (uVar4 < *(uint *)(iVar5 + 0x34)) {
        *(uint *)(iVar5 + 0x34) = uVar4;
      }
      uVar8 = *(int *)((int)register0x00000010 + 0xc) * 0x2000 + -1 + uVar4;
      if (*(int *)((int)register0x00000010 + 0xc) == 1) {
        *(uint *)((int)register0x00000010 + -8) = uVar4 & 0x3fffff;
        iVar1 = *(int *)(iVar5 + 0x30);
        uVar8 = (uVar4 & 0x3fffff) >> 0x13;
        if (7 < uVar8) {
          iVar5 = 8;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e4e9;
          FUN_0046ee00();
          goto LAB_0042e4e9;
        }
        *(uint *)((int)register0x00000010 + -0xc) = uVar4 >> 0x16;
        *(int *)((int)register0x00000010 + -4) = iVar5 + 0x58;
        uVar3 = *(uint *)((int)register0x00000010 + -8);
        *(uint *)((int)register0x00000010 + -8) = uVar3 >> 0xd;
        puVar2 = (uint *)(iVar1 + (uVar4 >> 0x16) * 0x80 + uVar8 * 8);
        uVar8 = uVar3 >> 0xd & 0x3f;
        uVar4 = uVar8 - 0x20;
        *puVar2 = *puVar2 & ~(-(uint)(uVar8 < 0x20) & 1 << ((byte)uVar8 & 0x1f));
        puVar2[1] = ~(1U >> ((byte)-uVar4 & 0x1f) & -(uint)(-uVar4 < 0x20) |
                     -(uint)(uVar4 < 0x20) & 1 << ((byte)uVar4 & 0x1f)) & puVar2[1];
        *(undefined4 *)((int)register0x00000010 + -0x38) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x34) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x30) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e4b6;
        FUN_004259b0();
LAB_0042e4b6:
        *(undefined4 *)((int)register0x00000010 + -0x38) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x34) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x30) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined2 *)((int)register0x00000010 + -0x2c) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e4d9;
        FUN_0042cb80();
        return;
      }
      uVar3 = uVar4 >> 0x16;
      *(uint *)((int)register0x00000010 + -8) = uVar3;
      uVar6 = uVar8 >> 0x16;
      uVar4 = (uVar4 & 0x3fffff) >> 0xd;
      *(uint *)((int)register0x00000010 + -0xc) = uVar4;
      uVar8 = (uVar8 & 0x3fffff) >> 0xd;
      if (uVar6 == uVar3) {
        *(int *)((int)register0x00000010 + -4) = iVar5 + 0x58;
        iVar1 = (uVar8 - uVar4) + 1;
        *(int *)((int)register0x00000010 + -0x20) = iVar1;
        *(uint *)((int)register0x00000010 + -0x38) = uVar3 * 0x80 + *(int *)(iVar5 + 0x30);
        *(uint *)((int)register0x00000010 + -0x34) = uVar4;
        *(int *)((int)register0x00000010 + -0x30) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e3de;
        FUN_0042f7f0();
        *(undefined4 *)((int)register0x00000010 + -0x38) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x34) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x30) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x2c) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e402;
        FUN_004259b0();
        goto LAB_0042e4b6;
      }
      *(uint *)((int)register0x00000010 + -0x10) = uVar6;
      *(uint *)((int)register0x00000010 + -0x14) = uVar8;
      *(uint *)((int)register0x00000010 + -0x24) = -(uVar4 - 0x200);
      *(int *)((int)register0x00000010 + -4) = iVar5 + 0x58;
      *(uint *)((int)register0x00000010 + -0x38) = uVar3 * 0x80 + *(int *)(iVar5 + 0x30);
      *(uint *)((int)register0x00000010 + -0x34) = uVar4;
      *(uint *)((int)register0x00000010 + -0x30) = -(uVar4 - 0x200);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e37e;
      FUN_0042f7f0();
      *(undefined4 *)((int)register0x00000010 + -0x38) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x34) =
           *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x30) =
           *(undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0x2c) =
           *(undefined4 *)((int)register0x00000010 + -0x24);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e3a2;
      FUN_004259b0();
      uVar8 = *(int *)((int)register0x00000010 + -8) + 1;
      iVar5 = *(int *)((int)register0x00000010 + 4);
      uVar4 = *(uint *)((int)register0x00000010 + -0x10);
      while( true ) {
        if (uVar4 <= uVar8) {
          *(int *)((int)register0x00000010 + -0x28) = *(int *)((int)register0x00000010 + -0x14) + 1;
          *(uint *)((int)register0x00000010 + -0x38) = *(int *)(iVar5 + 0x30) + uVar4 * 0x80;
          *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
          *(int *)((int)register0x00000010 + -0x30) = *(int *)((int)register0x00000010 + -0x14) + 1;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e57f;
          FUN_0042f7f0();
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x34) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x2c) =
               *(undefined4 *)((int)register0x00000010 + -0x28);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e5a3;
          FUN_004259b0();
          goto LAB_0042e4b6;
        }
        if (0x3ff < uVar8) break;
LAB_0042e4e9:
        *(uint *)((int)register0x00000010 + -0x1c) = uVar8;
        iVar5 = *(int *)(iVar5 + 0x30);
        *(uint *)((int)register0x00000010 + -0x18) = uVar8 + 1;
        *(uint *)((int)register0x00000010 + -0x38) = uVar8 * 0x80 + iVar5;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x40;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e511;
        FUN_0046f470();
        *(undefined4 *)((int)register0x00000010 + -0x38) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x34) =
             *(undefined4 *)((int)register0x00000010 + -0x1c);
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x200;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e535;
        FUN_004259b0();
        iVar5 = *(int *)((int)register0x00000010 + 4);
        uVar4 = *(uint *)((int)register0x00000010 + -0x10);
        uVar8 = *(uint *)((int)register0x00000010 + -0x18);
      }
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42e5b2;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar7 + -4) = 0x42e5b8;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_0042e5c0 */

void FUN_0042e5c0(void)

{
  uint *puVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  undefined1 *puVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  int in_FS_OFFSET;
  bool bVar11;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x1c);
      iVar4 = *(int *)((int)register0x00000010 + 8);
      if (iVar4 != 0) {
        puVar1 = *(uint **)((int)register0x00000010 + 4);
        uVar9 = puVar1[1];
        if ((uVar9 & 0x80000000) == 0) {
          uVar10 = *puVar1 & 0x3ffff;
          uVar6 = (uVar9 & 0xf) << 0xe | *puVar1 >> 0x12;
          uVar9 = uVar9 >> 4 & 0x3ffff;
        }
        else {
          uVar10 = 0x40000;
          uVar6 = 0x40000;
          uVar9 = 0x40000;
        }
        uVar3 = *(uint *)((int)register0x00000010 + 0x10);
        iVar8 = 1;
        while (iVar8 < iVar4) {
          uVar5 = (puVar1 + iVar8 * 2)[1];
          if ((uVar5 & 0x80000000) == 0) {
            *(uint *)((int)register0x00000010 + -0xc) = uVar6;
            *(uint *)((int)register0x00000010 + -0x10) = uVar5;
            uVar6 = puVar1[iVar8 * 2];
            *(uint *)((int)register0x00000010 + -0x14) = uVar6;
            uVar2 = *(uint *)((int)register0x00000010 + -0x14) & 0x3ffff;
            uVar5 = (uVar5 & 0xf) << 0xe | uVar6 >> 0x12;
            *(uint *)((int)register0x00000010 + -4) =
                 *(uint *)((int)register0x00000010 + -0x10) >> 4 & 0x3ffff;
            uVar6 = *(uint *)((int)register0x00000010 + -0xc);
          }
          else {
            uVar5 = 0x40000;
            *(undefined4 *)((int)register0x00000010 + -4) = 0x40000;
            uVar2 = 0x40000;
          }
          *(int *)((int)register0x00000010 + -8) = iVar8;
          bVar11 = uVar3 < 0x20;
          if (uVar10 == (iVar8 << ((byte)uVar3 & 0x1f) & -(uint)bVar11)) {
            uVar10 = uVar10 + uVar2;
          }
          uVar3 = uVar2 + uVar9;
          if (uVar2 + uVar9 <= uVar6) {
            uVar3 = uVar6;
          }
          uVar6 = uVar5;
          if (uVar5 <= uVar3) {
            uVar6 = uVar3;
          }
          uVar3 = *(uint *)((int)register0x00000010 + 0x10);
          uVar2 = 1 << ((byte)uVar3 & 0x1f) & -(uint)bVar11;
          uVar5 = *(uint *)((int)register0x00000010 + -4);
          if (uVar5 == uVar2) {
            uVar5 = uVar2 + uVar9;
          }
          puVar1 = *(uint **)((int)register0x00000010 + 4);
          iVar4 = *(int *)((int)register0x00000010 + 8);
          uVar9 = uVar5;
          iVar8 = *(int *)((int)register0x00000010 + -8) + 1;
        }
        if (uVar6 == 0x40000) {
          uVar9 = 0x80000000;
          uVar10 = 0;
        }
        else {
          uVar10 = (uVar6 & 0x3ffff) << 0x12 | uVar10 & 0x3ffff;
          uVar9 = (uVar9 & 0x3ffff) << 4 | (uVar6 & 0x3ffff) >> 0xe;
        }
        *(uint *)((int)register0x00000010 + 0x14) = uVar10;
        *(uint *)((int)register0x00000010 + 0x18) = uVar9;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x42e743;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar7 + -4) = 0x42e749;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_0042e750 */

void FUN_0042e750(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  undefined4 *puVar5;
  int iVar6;
  undefined4 uVar7;
  undefined1 *puVar8;
  undefined4 *puVar9;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x30);
      iVar4 = 0;
      for (iVar2 = 0; iVar2 < 4; iVar2 = iVar2 + 1) {
        iVar4 = iVar4 + (-(uint)((uint)-((&DAT_005cc480)[iVar2] + -0x20) < 0x20) &
                        1 << ((byte)-((&DAT_005cc480)[iVar2] + -0x20) & 0x1f)) * 8;
      }
      uVar3 = -DAT_005f5de0 & iVar4 + -1 + DAT_005f5de0;
      *(uint *)((int)register0x00000010 + -0x24) = uVar3;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
      *(uint *)((int)register0x00000010 + -0x2c) = uVar3;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x42e7ba;
      FUN_00415340();
      if (*(int *)((int)register0x00000010 + -0x28) != 0) {
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + -0x28);
        *(undefined4 *)((int)register0x00000010 + -0x30) =
             *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x9c);
        *(undefined4 *)((int)register0x00000010 + -0x2c) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x42e7ec;
        FUN_00433860();
        *(undefined4 *)((int)register0x00000010 + -0x30) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x2c) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x28) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x42e804;
        FUN_00414df0();
        *(int *)(*(int *)((int)register0x00000010 + 4) + 0xa0) =
             *(int *)(*(int *)((int)register0x00000010 + 4) + 0xa0) +
             *(int *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x42e821;
        FUN_0046f438();
        iVar2 = *(int *)((int)register0x00000010 + 4);
        iVar4 = *(int *)((int)register0x00000010 + -4);
        for (iVar6 = 0; iVar6 < 4; iVar6 = iVar6 + 1) {
          iVar1 = *(int *)((int)register0x00000010 + iVar6 * 4 + -0x14);
          *(int *)((int)register0x00000010 + -0x20) = iVar4;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
          puVar5 = (undefined4 *)(iVar6 * 3);
          uVar3 = 1 << ((byte)-(iVar1 + -0x20) & 0x1f) & -(uint)((uint)-(iVar1 + -0x20) < 0x20);
          *(uint *)((int)register0x00000010 + -0x18) = uVar3;
          uVar7 = *(undefined4 *)((int)register0x00000010 + -0x20);
          *(undefined4 *)(iVar2 + 4 + iVar6 * 0xc) = 0;
          *(uint *)(iVar2 + 8 + iVar6 * 0xc) = uVar3;
          iVar4 = iVar4 + uVar3 * 8;
          if (DAT_005f5fd0 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x34) = 0x42e88c;
            puVar9 = puVar5;
            FUN_0046ed80();
            *puVar9 = uVar7;
            puVar9[1] = *(undefined4 *)(iVar2 + (int)puVar5 * 4);
          }
          *(undefined4 *)(iVar2 + (int)puVar5 * 4) = uVar7;
        }
        return;
      }
      *(char **)((int)register0x00000010 + -0x30) =
           "failed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x25;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x42e8b2;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x42e8b8;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_0042e8c0 */

void FUN_0042e8c0(void)

{
  undefined4 uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
code_r0x0042e8c0:
  puVar5 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar5 = (undefined1 *)((int)register0x00000010 + -0x18);
    if (((*(uint *)((int)register0x00000010 + 8) & 0x3fffff) == 0) &&
       (uVar3 = *(uint *)((int)register0x00000010 + 0xc), (uVar3 & 0x3fffff) == 0)) {
      iVar4 = *(int *)((int)register0x00000010 + 4);
      uVar2 = 3;
      do {
        if ((int)uVar2 < 0) {
          return;
        }
        if (3 < uVar2) goto LAB_0042e9b3;
        *(uint *)((int)register0x00000010 + -8) = uVar2 * 3;
        *(uint *)((int)register0x00000010 + -4) = iVar4 + uVar2 * 0xc;
        *(uint *)((int)register0x00000010 + -0xc) = uVar3 - 1;
        uVar1 = (&DAT_005cc480)[uVar2];
        *(undefined4 *)((int)register0x00000010 + -0x10) = uVar1;
        *(uint *)((int)register0x00000010 + -0xc) =
             *(uint *)((int)register0x00000010 + -0xc) >> ((byte)uVar1 & 0x1f);
        uVar3 = -(uint)((uint)(&DAT_005cc470)[uVar2] < 0x20) &
                1 << ((byte)(&DAT_005cc470)[uVar2] & 0x1f);
        uVar3 = -uVar3 & uVar3 + (*(uint *)((int)register0x00000010 + -0xc) &
                                 -(uint)(*(uint *)((int)register0x00000010 + -0x10) < 0x20));
        if (*(int *)(*(int *)((int)register0x00000010 + -4) + 4) < (int)uVar3) {
          if (*(uint *)(iVar4 + 8 + uVar2 * 0xc) < uVar3) goto LAB_0042e9ae;
          iVar4 = *(int *)((int)register0x00000010 + 4);
          *(uint *)(iVar4 + 4 + *(int *)((int)register0x00000010 + -8) * 4) = uVar3;
        }
        else {
          iVar4 = *(int *)((int)register0x00000010 + 4);
        }
        uVar2 = uVar2 - 1;
        uVar3 = *(uint *)((int)register0x00000010 + 0xc);
      } while( true );
    }
    goto LAB_0042e9bd;
  }
  goto LAB_0042ea37;
LAB_0042e9ae:
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42e9b3;
  FUN_0046ee30();
LAB_0042e9b3:
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42e9bd;
  FUN_0046edf0();
LAB_0042e9bd:
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42e9c2;
  FUN_0043a810();
  *(char **)((int)register0x00000010 + -0x18) = "runtime: base = runtime: head = timeBeginPeriod";
  *(undefined4 *)((int)register0x00000010 + -0x14) = 0x10;
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42e9d8;
  FUN_0043b060();
  *(undefined4 *)((int)register0x00000010 + -0x18) = *(undefined4 *)((int)register0x00000010 + 8);
  *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42e9ec;
  FUN_0043aef0();
  *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c36bb;
  *(undefined4 *)((int)register0x00000010 + -0x14) = 10;
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42ea02;
  FUN_0043b060();
  *(undefined4 *)((int)register0x00000010 + -0x18) = *(undefined4 *)((int)register0x00000010 + 0xc);
  *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42ea16;
  FUN_0043aef0();
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42ea1b;
  FUN_0043aa10();
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42ea20;
  FUN_0043a870();
  *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004ccb90;
  *(undefined4 *)((int)register0x00000010 + -0x14) = 0x2e;
  *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x42ea36;
  FUN_00469a20();
LAB_0042ea37:
  *(undefined4 *)(puVar5 + -4) = 0x42ea3c;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar5;
  goto code_r0x0042e8c0;
}



/* Function: FUN_0042ea50 */

void FUN_0042ea50(undefined4 *param_1,char param_2,undefined4 param_3)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined4 local_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  puVar1 = param_1;
  if (param_2 == '\0') {
    param_1[1] = 0x400;
    param_1[2] = 0x400;
    if (DAT_005f5fd0 != 0) {
      uVar2 = *param_1;
      FUN_0046ed70();
      *in_EDI = uVar2;
    }
    *puVar1 = &DAT_005f9540;
  }
  else {
    FUN_00414d10(0x2000,param_3);
    param_1[1] = 0x400;
    param_1[2] = 0x400;
    if (DAT_005f5fd0 != 0) {
      FUN_0046ed80();
      *in_EDI = local_c;
      in_EDI[1] = *puVar1;
    }
    *puVar1 = local_c;
  }
  thunk_FUN_00402770(puVar1 + 3,1);
  thunk_FUN_00402770(puVar1 + 4,param_1[1]);
  return;
}



/* Function: FUN_0042eb40 */

void FUN_0042eb40(int param_1,int param_2)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar3 = *(uint *)(param_1 + 4);
  uVar2 = *(uint *)(param_1 + 8);
  if (uVar2 != 0 || uVar3 != 0) {
    if (param_2 == 1) {
      uVar5 = 0;
      if (uVar3 != 0) {
        for (; (uVar3 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
        }
      }
      if (uVar3 == 0) {
        iVar4 = 0;
        if (uVar2 != 0) {
          for (; (uVar2 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
          }
        }
        if (uVar2 == 0) {
          iVar4 = 0x20;
        }
        uVar5 = iVar4 + 0x20;
      }
      uVar1 = uVar5 - 0x20;
      uVar5 = ~(1 << ((byte)uVar5 & 0x1f) & -(uint)(uVar5 < 0x20));
      *(uint *)(param_1 + 4) = uVar3 & uVar5;
      uVar3 = ~(1 << ((byte)uVar1 & 0x1f) & -(uint)(uVar1 < 0x20) |
               1U >> ((byte)-uVar1 & 0x1f) & -(uint)(-uVar1 < 0x20));
      *(uint *)(param_1 + 8) = uVar2 & uVar3;
      *(uint *)(param_1 + 0xc) = *(uint *)(param_1 + 0xc) & uVar5;
      *(uint *)(param_1 + 0x10) = uVar3 & *(uint *)(param_1 + 0x10);
      return;
    }
    FUN_0042ecb0(param_1,param_2);
    return;
  }
  return;
}



/* Function: FUN_0042ecb0 */

void FUN_0042ecb0(int param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  int in_FS_OFFSET;
  undefined4 local_20;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar6 = param_2 - 1;
  local_20 = 1;
  uVar2 = *(uint *)(param_1 + 4);
  uVar4 = *(uint *)(param_1 + 8);
  do {
    if (uVar6 == 0) {
LAB_0042edf4:
      uVar6 = 0;
      if (uVar2 != 0) {
        for (; (uVar2 >> uVar6 & 1) == 0; uVar6 = uVar6 + 1) {
        }
      }
      if (uVar2 == 0) {
        iVar7 = 0;
        if (uVar4 != 0) {
          for (; (uVar4 >> iVar7 & 1) == 0; iVar7 = iVar7 + 1) {
          }
        }
        if (uVar4 == 0) {
          iVar7 = 0x20;
        }
        uVar6 = iVar7 + 0x20;
      }
LAB_0042ee06:
      if (0x3f < uVar6) {
        return;
      }
      uVar2 = param_2 - 0x20;
      uVar4 = uVar6 - 0x20;
      uVar3 = 1 << ((byte)param_2 & 0x1f) & -(uint)(param_2 < 0x20);
      uVar1 = uVar3 - 1;
      uVar5 = ~(uVar1 << ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20));
      *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) & uVar5;
      uVar6 = ~(uVar1 >> ((byte)-uVar4 & 0x1f) & -(uint)(-uVar4 < 0x20) |
                ((1 << ((byte)uVar2 & 0x1f) & -(uint)(uVar2 < 0x20) |
                 1U >> ((byte)-uVar2 & 0x1f) & -(uint)(-uVar2 < 0x20)) - 1) + (uint)(uVar3 != 0) <<
                ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20) |
               uVar1 << ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20));
      *(uint *)(param_1 + 8) = *(uint *)(param_1 + 8) & uVar6;
      *(uint *)(param_1 + 0xc) = *(uint *)(param_1 + 0xc) & uVar5;
      *(uint *)(param_1 + 0x10) = uVar6 & *(uint *)(param_1 + 0x10);
      return;
    }
    if (uVar6 <= local_20) {
      uVar6 = uVar6 & 0x3f;
      uVar3 = uVar6 - 0x20;
      uVar1 = uVar4 >> ((byte)uVar3 & 0x1f);
      uVar5 = uVar4 << ((byte)-uVar3 & 0x1f);
      uVar4 = uVar4 >> ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20) & uVar4;
      uVar2 = (uVar2 >> ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20) |
               uVar5 & -(uint)(-uVar3 < 0x20) | uVar1 & -(uint)(uVar3 < 0x20)) & uVar2;
      goto LAB_0042edf4;
    }
    uVar8 = local_20 & 0x3f;
    uVar3 = uVar8 - 0x20;
    uVar1 = uVar4 >> ((byte)uVar3 & 0x1f);
    uVar5 = uVar4 << ((byte)-uVar3 & 0x1f);
    uVar4 = uVar4 >> ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20) & uVar4;
    uVar2 = (uVar2 >> ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20) | uVar5 & -(uint)(-uVar3 < 0x20)
            | uVar1 & -(uint)(uVar3 < 0x20)) & uVar2;
    if (uVar4 == 0 && uVar2 == 0) {
      uVar6 = 0x40;
      goto LAB_0042ee06;
    }
    uVar6 = uVar6 - local_20;
    local_20 = local_20 << 1;
  } while( true );
}



/* Function: FUN_0042efd0 */

void FUN_0042efd0(void)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  int iVar4;
  undefined1 *puVar5;
  uint uVar6;
  int in_FS_OFFSET;
  
code_r0x0042efd0:
  puVar5 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
    puVar5 = (undefined1 *)((int)register0x00000010 + -0x2c);
    puVar3 = *(uint **)((int)register0x00000010 + 4);
    if (puVar3[2] == 0 && puVar3[1] == 0) {
      return;
    }
    iVar4 = *(int *)((int)register0x00000010 + 8);
    uVar1 = *puVar3;
    *(uint *)((int)register0x00000010 + -8) = uVar1 >> 0x16;
    *(uint *)((int)register0x00000010 + -0xc) = (uVar1 & 0x3fffff) >> 0xd;
    uVar1 = 0;
    do {
      if (0x3f < uVar1) {
        if (*puVar3 < *(uint *)(iVar4 + 0x34)) {
          *(uint *)(iVar4 + 0x34) = *puVar3;
        }
        uVar1 = *puVar3;
        *(int *)((int)register0x00000010 + -0x2c) = iVar4;
        *(uint *)((int)register0x00000010 + -0x28) = uVar1;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x40;
        *(undefined2 *)((int)register0x00000010 + -0x20) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42f1e1;
        FUN_0042cb80();
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42f1ec;
        FUN_0046ef4b();
        return;
      }
      *(uint *)((int)register0x00000010 + -0x18) = uVar1;
      uVar2 = puVar3[1];
      *(uint *)((int)register0x00000010 + -0x10) = puVar3[2];
      uVar6 = uVar1 - 0x20;
      uVar1 = -(uint)(uVar1 < 0x20) & 1 << ((byte)uVar1 & 0x1f);
      uVar6 = 1 << ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20) |
              1U >> ((byte)-uVar6 & 0x1f) & -(uint)(-uVar6 < 0x20);
      if ((*(uint *)((int)register0x00000010 + -0x10) & uVar6) != 0 || (uVar1 & uVar2) != 0) {
        *(int *)((int)register0x00000010 + -0x1c) =
             *(int *)((int)register0x00000010 + -0x18) + *(int *)((int)register0x00000010 + -0xc);
        iVar4 = *(int *)(*(int *)((int)register0x00000010 + 8) + 0x30);
        uVar2 = (uint)(*(int *)((int)register0x00000010 + -0x18) +
                      *(int *)((int)register0x00000010 + -0xc)) >> 6;
        if (7 < uVar2) goto LAB_0042f1f0;
        *(uint *)((int)register0x00000010 + -0x10) = uVar1;
        *(uint *)((int)register0x00000010 + -0x14) = uVar6;
        *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 8) + 0x58;
        puVar3 = (uint *)(*(int *)((int)register0x00000010 + -8) * 0x80 + iVar4 + uVar2 * 8);
        uVar6 = *(uint *)((int)register0x00000010 + -0x1c) & 0x3f;
        uVar1 = uVar6 - 0x20;
        *puVar3 = *puVar3 & ~(-(uint)(uVar6 < 0x20) & 1 << ((byte)uVar6 & 0x1f));
        puVar3[1] = ~(-(uint)(uVar1 < 0x20) & 1 << ((byte)uVar1 & 0x1f) |
                     -(uint)(-uVar1 < 0x20) & 1U >> ((byte)-uVar1 & 0x1f)) & puVar3[1];
        *(undefined4 *)((int)register0x00000010 + -0x2c) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x28) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x24) =
             *(undefined4 *)((int)register0x00000010 + -0x1c);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42f153;
        FUN_004259b0();
        uVar1 = *(uint *)((int)register0x00000010 + -0x10);
        uVar6 = *(uint *)((int)register0x00000010 + -0x14);
      }
      puVar3 = *(uint **)((int)register0x00000010 + 4);
      if ((uVar6 & puVar3[4]) != 0 || (uVar1 & puVar3[3]) != 0) {
        *(int *)((int)register0x00000010 + -0x2c) =
             *(int *)(*(int *)((int)register0x00000010 + 8) + 0x30) + 0x40 +
             *(int *)((int)register0x00000010 + -8) * 0x80;
        *(int *)((int)register0x00000010 + -0x28) =
             *(int *)((int)register0x00000010 + -0xc) + *(int *)((int)register0x00000010 + -0x18);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42f1b1;
        FUN_0042f5a0();
        puVar3 = *(uint **)((int)register0x00000010 + 4);
      }
      uVar1 = *(int *)((int)register0x00000010 + -0x18) + 1;
      iVar4 = *(int *)((int)register0x00000010 + 8);
    } while( true );
  }
  goto LAB_0042f1fd;
LAB_0042f1f0:
  *(undefined4 *)((int)register0x00000010 + -0x30) = 0x42f1fc;
  FUN_0046ee00();
LAB_0042f1fd:
  *(undefined4 *)(puVar5 + -4) = 0x42f202;
  FUN_0046afb0();
  register0x00000010 = (BADSPACEBASE *)puVar5;
  goto code_r0x0042efd0;
}



/* Function: FUN_0042f210 */

void FUN_0042f210(void)

{
  int *piVar1;
  uint *puVar2;
  uint *puVar3;
  undefined4 *puVar4;
  int iVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  undefined1 *puVar13;
  uint uVar14;
  int in_FS_OFFSET;
  
  do {
    puVar13 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar13 = (undefined1 *)((int)register0x00000010 + -0x40);
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f232;
      FUN_0046ef4b();
      if (*(uint *)(*(int *)((int)register0x00000010 + 4) + 0x3c) <=
          *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x34) >> 0x16) {
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f24e;
      FUN_0046ef4b();
      iVar8 = *(int *)((int)register0x00000010 + 4);
      uVar9 = *(uint *)(iVar8 + 0x34);
      uVar10 = uVar9 >> 0x16;
      if (uVar10 < *(uint *)(iVar8 + 0x28)) {
        piVar1 = (int *)(*(int *)(iVar8 + 0x24) + uVar10 * 8);
        if (piVar1[1] == 0 && *piVar1 == 0) {
          *(int *)((int)register0x00000010 + -0x40) = iVar8;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f298;
          FUN_0042d370();
          uVar9 = *(uint *)((int)register0x00000010 + -0x38);
          if (uVar9 == 0) {
            *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x34) = DAT_005cc280;
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f326;
            FUN_0046ef4b();
            return;
          }
          uVar11 = uVar9 >> 0x16;
          iVar5 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x30);
          iVar12 = uVar11 * 0x80;
          uVar10 = (uVar9 & 0x3fffff) >> 0x13;
          iVar8 = iVar12 + iVar5;
          if (uVar10 < 8) {
            puVar4 = (undefined4 *)(iVar5 + 0x40 + iVar12 + uVar10 * 8);
            uVar6 = *puVar4;
            uVar7 = puVar4[1];
            puVar2 = (uint *)(iVar5 + iVar12 + uVar10 * 8);
            uVar10 = *puVar2;
            uVar14 = puVar2[1];
            *(uint *)((int)register0x00000010 + -0x28) = uVar9 & 0xfff80000;
            *(uint *)((int)register0x00000010 + -0x24) = ~uVar10;
            *(uint *)((int)register0x00000010 + -0x20) = ~uVar14;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar6;
            *(undefined4 *)((int)register0x00000010 + -0x18) = uVar7;
LAB_0042f3d7:
            uVar9 = (*(uint *)((int)register0x00000010 + -0x28) & 0x3fffff) >> 0x13;
            if (uVar9 < 8) {
              *(uint *)((int)register0x00000010 + -0x2c) = uVar11;
              uVar10 = *(uint *)((int)register0x00000010 + -0x20);
              iVar5 = *(int *)((int)register0x00000010 + 4);
              *(int *)((int)register0x00000010 + -0xc) = iVar5 + 0x58;
              puVar3 = (uint *)(iVar8 + 0x40 + uVar9 * 8);
              puVar2 = (uint *)(iVar8 + uVar9 * 8);
              *puVar2 = *puVar2 | *(uint *)((int)register0x00000010 + -0x24);
              puVar2[1] = uVar10 | puVar2[1];
              uVar9 = *(uint *)((int)register0x00000010 + -0x20);
              uVar10 = *(uint *)((int)register0x00000010 + -0x18);
              *puVar3 = *puVar3 & ~(*(uint *)((int)register0x00000010 + -0x24) &
                                   *(uint *)((int)register0x00000010 + -0x1c));
              puVar3[1] = ~(uVar9 & uVar10) & puVar3[1];
              *(int *)((int)register0x00000010 + -0x40) = iVar5;
              *(undefined4 *)((int)register0x00000010 + -0x3c) =
                   *(undefined4 *)((int)register0x00000010 + -0x28);
              *(undefined4 *)((int)register0x00000010 + -0x38) = 0x40;
              *(undefined2 *)((int)register0x00000010 + -0x34) = 0x100;
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f44e;
              FUN_0042cb80();
              uVar11 = *(uint *)((int)register0x00000010 + -0x24) >> 1 & 0x55555555;
              uVar9 = *(uint *)((int)register0x00000010 + -0x24) & 0x55555555;
              *(undefined4 *)((int)register0x00000010 + -0x40) =
                   *(undefined4 *)((int)register0x00000010 + -0xc);
              *(undefined4 *)((int)register0x00000010 + -0x3c) =
                   *(undefined4 *)((int)register0x00000010 + -0x2c);
              uVar10 = uVar9 + uVar11;
              uVar14 = (*(uint *)((int)register0x00000010 + -0x20) & 0x55555555) +
                       (*(uint *)((int)register0x00000010 + -0x20) >> 1 & 0x55555555) +
                       (uint)CARRY4(uVar9,uVar11);
              uVar9 = uVar10 >> 2 & 0x33333333;
              uVar10 = uVar10 & 0x33333333;
              uVar11 = uVar10 + uVar9;
              uVar10 = (uVar14 & 0x33333333) + (uVar14 >> 2 & 0x33333333) +
                       (uint)CARRY4(uVar10,uVar9);
              uVar9 = uVar10 * 0x10000000 | uVar11 >> 4;
              uVar14 = uVar10 + (uVar10 >> 4) + (uint)CARRY4(uVar9,uVar11) & 0xf0f0f0f;
              uVar9 = uVar9 + uVar11 & 0xf0f0f0f;
              uVar10 = uVar14 << 0x18 | uVar9 >> 8;
              uVar11 = uVar9 + uVar10;
              uVar10 = uVar14 + (uVar14 >> 8) + (uint)CARRY4(uVar9,uVar10);
              uVar9 = uVar10 * 0x10000 | uVar11 >> 0x10;
              *(uint *)((int)register0x00000010 + -0x38) =
                   uVar10 + (uVar10 >> 0x10) + (uint)CARRY4(uVar9,uVar11) + uVar9 + uVar11 & 0x7f;
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f513;
              FUN_004258f0();
              *(int *)(*(int *)((int)register0x00000010 + 4) + 0x34) =
                   *(int *)((int)register0x00000010 + -0x28) + 0x7e000;
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f530;
              FUN_0046f42e();
              *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f53d;
              FUN_0046f42e();
              return;
            }
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f54f;
            FUN_0046ee00();
LAB_0042f54f:
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f55b;
            FUN_0046ee00();
            goto LAB_0042f55b;
          }
        }
        else {
          *(uint *)((int)register0x00000010 + -0x10) = uVar10;
          iVar8 = *(int *)(iVar8 + 0x30);
          *(int *)((int)register0x00000010 + -4) = iVar8;
          *(uint *)((int)register0x00000010 + -0x14) = uVar10 * 0x80;
          iVar8 = iVar8 + uVar10 * 0x80;
          *(int *)((int)register0x00000010 + -8) = iVar8;
          *(int *)((int)register0x00000010 + -0x40) = iVar8;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 1;
          *(uint *)((int)register0x00000010 + -0x38) = (uVar9 & 0x3fffff) >> 0xd;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f362;
          FUN_00430510();
          uVar9 = *(uint *)((int)register0x00000010 + -0x34);
          iVar8 = *(int *)((int)register0x00000010 + -0x14) + *(int *)((int)register0x00000010 + -4)
          ;
          if (uVar9 != 0xffffffff) {
            uVar10 = uVar9 >> 6;
            if (uVar10 < 8) {
              uVar11 = *(uint *)((int)register0x00000010 + -0x10);
              puVar4 = (undefined4 *)
                       (*(int *)((int)register0x00000010 + -4) + 0x40 +
                        *(int *)((int)register0x00000010 + -0x14) + uVar10 * 8);
              uVar6 = *puVar4;
              uVar7 = puVar4[1];
              uVar14 = *(uint *)(*(int *)((int)register0x00000010 + -8) + uVar10 * 8);
              uVar10 = ((uint *)(*(int *)((int)register0x00000010 + -8) + uVar10 * 8))[1];
              *(uint *)((int)register0x00000010 + -0x28) =
                   uVar11 * 0x400000 + (uVar9 & 0xffffffc0) * 0x2000;
              *(uint *)((int)register0x00000010 + -0x24) = ~uVar14;
              *(uint *)((int)register0x00000010 + -0x20) = ~uVar10;
              *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar6;
              *(undefined4 *)((int)register0x00000010 + -0x18) = uVar7;
              goto LAB_0042f3d7;
            }
            goto LAB_0042f54f;
          }
LAB_0042f55b:
          *(char **)((int)register0x00000010 + -0x40) =
               "bad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod";
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x10;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f571;
          FUN_00469a20();
        }
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f57d;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x42f586;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar13 + -4) = 0x42f58c;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar13;
  } while( true );
}



/* Function: FUN_0042f5a0 */

void FUN_0042f5a0(void)

{
  uint *puVar1;
  undefined4 *puVar2;
  uint uVar3;
  undefined4 uVar4;
  uint uVar5;
  uint uVar6;
  byte bVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  undefined1 *puVar11;
  uint uVar12;
  int in_FS_OFFSET;
  
  do {
    puVar11 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar11 = (undefined1 *)((int)register0x00000010 + -0x24);
      uVar8 = *(uint *)((int)register0x00000010 + 8);
      uVar5 = uVar8 >> 6;
      if (uVar5 < 8) {
        iVar9 = *(int *)((int)register0x00000010 + 4);
        uVar3 = *(uint *)((int)register0x00000010 + 0xc);
        if (uVar3 == 1) {
          puVar1 = (uint *)(iVar9 + uVar5 * 8);
          uVar8 = uVar8 & 0x3f;
          uVar5 = uVar8 - 0x20;
          *puVar1 = *puVar1 | 1 << ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20);
          puVar1[1] = 1 << ((byte)uVar5 & 0x1f) & -(uint)(uVar5 < 0x20) |
                      1U >> ((byte)-uVar5 & 0x1f) & -(uint)(-uVar5 < 0x20) | puVar1[1];
          return;
        }
        uVar6 = (uVar3 - 1) + uVar8;
        uVar12 = uVar6 >> 6;
        if (uVar12 == uVar5) {
          *(uint *)((int)register0x00000010 + -4) = iVar9 + uVar5 * 8;
          uVar5 = uVar3 - 0x20;
          *(uint *)((int)register0x00000010 + -8) = uVar8 & 0x3f;
          iVar9 = (uVar8 & 0x3f) - 0x20;
          *(int *)((int)register0x00000010 + -0x14) = iVar9;
          uVar10 = -iVar9;
          uVar6 = -(uint)(uVar3 < 0x20) & 1 << ((byte)uVar3 & 0x1f);
          uVar12 = uVar6 - 1;
          bVar7 = (byte)*(uint *)((int)register0x00000010 + -8);
          *(uint *)((int)register0x00000010 + -0x18) = uVar12 << (bVar7 & 0x1f);
          uVar4 = *(undefined4 *)((int)register0x00000010 + -0x14);
          uVar8 = *(uint *)((int)register0x00000010 + -0x14);
          uVar3 = -(uint)(*(uint *)((int)register0x00000010 + -8) < 0x20);
          puVar1 = *(uint **)((int)register0x00000010 + -4);
          *puVar1 = *puVar1 | *(uint *)((int)register0x00000010 + -0x18) & uVar3;
          puVar1[1] = uVar12 >> ((byte)uVar10 & 0x1f) & -(uint)(uVar10 < 0x20) |
                      ((-(uint)(-uVar5 < 0x20) & 1U >> ((byte)-uVar5 & 0x1f) |
                       1 << ((byte)uVar5 & 0x1f) & -(uint)(uVar5 < 0x20)) - 1) + (uint)(uVar6 != 0)
                      << (bVar7 & 0x1f) & uVar3 |
                      uVar12 << ((byte)uVar4 & 0x1f) & -(uint)(uVar8 < 0x20) | puVar1[1];
          return;
        }
        if (uVar12 < 8) {
          *(uint *)((int)register0x00000010 + -8) = uVar6;
          *(uint *)((int)register0x00000010 + -0xc) = uVar12;
          puVar1 = (uint *)(iVar9 + uVar5 * 8);
          uVar8 = uVar8 & 0x3f;
          *(uint *)((int)register0x00000010 + -0x10) = uVar8;
          uVar3 = uVar8 - 0x20;
          *(uint *)((int)register0x00000010 + -0x1c) = uVar5 + 1;
          uVar8 = -1 << ((byte)uVar8 & 0x1f) &
                  -(uint)(*(uint *)((int)register0x00000010 + -0x10) < 0x20);
          *puVar1 = *puVar1 | uVar8;
          puVar1[1] = -1 << ((byte)uVar3 & 0x1f) & -(uint)(uVar3 < 0x20) |
                      0xffffffffU >> ((byte)-uVar3 & 0x1f) & -(uint)(-uVar3 < 0x20) | uVar8 |
                      puVar1[1];
          uVar8 = *(uint *)((int)register0x00000010 + -0xc);
          iVar9 = *(int *)((int)register0x00000010 + 4);
          for (uVar5 = *(uint *)((int)register0x00000010 + -0x1c); uVar5 < uVar8; uVar5 = uVar5 + 1)
          {
            puVar2 = (undefined4 *)(iVar9 + uVar5 * 8);
            *puVar2 = 0xffffffff;
            puVar2[1] = 0xffffffff;
          }
          *(uint *)((int)register0x00000010 + -4) = iVar9 + uVar8 * 8;
          uVar8 = (*(uint *)((int)register0x00000010 + -8) & 0x3f) - 0x1f;
          uVar5 = (*(uint *)((int)register0x00000010 + -8) & 0x3f) + 1;
          uVar5 = -(uint)(uVar5 < 0x20) & 1 << ((byte)uVar5 & 0x1f);
          puVar1 = *(uint **)((int)register0x00000010 + -4);
          *puVar1 = *puVar1 | uVar5 - 1;
          puVar1[1] = ((1 << ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20) |
                       -(uint)(-uVar8 < 0x20) & 1U >> ((byte)-uVar8 & 0x1f)) - 1) +
                      (uint)(uVar5 != 0) | puVar1[1];
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42f7cc;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42f7d6;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar11 + -4) = 0x42f7dc;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar11;
  } while( true );
}



/* Function: FUN_0042f7f0 */

void FUN_0042f7f0(void)

{
  uint *puVar1;
  uint uVar2;
  undefined4 uVar3;
  uint uVar4;
  byte bVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  undefined1 *puVar10;
  uint uVar11;
  int in_FS_OFFSET;
  
  do {
    puVar10 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar10 = (undefined1 *)((int)register0x00000010 + -0x24);
      uVar6 = *(uint *)((int)register0x00000010 + 8);
      uVar4 = uVar6 >> 6;
      if (uVar4 < 8) {
        iVar8 = *(int *)((int)register0x00000010 + 4);
        uVar2 = *(uint *)((int)register0x00000010 + 0xc);
        if (uVar2 == 1) {
          puVar1 = (uint *)(iVar8 + uVar4 * 8);
          uVar6 = uVar6 & 0x3f;
          uVar4 = uVar6 - 0x20;
          *puVar1 = *puVar1 & ~(1 << ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20));
          puVar1[1] = ~(1 << ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20) |
                       1U >> ((byte)-uVar4 & 0x1f) & -(uint)(-uVar4 < 0x20)) & puVar1[1];
          return;
        }
        uVar9 = (uVar2 - 1) + uVar6;
        uVar11 = uVar9 >> 6;
        if (uVar11 == uVar4) {
          *(uint *)((int)register0x00000010 + -4) = iVar8 + uVar4 * 8;
          uVar4 = uVar2 - 0x20;
          *(uint *)((int)register0x00000010 + -8) = uVar6 & 0x3f;
          iVar8 = (uVar6 & 0x3f) - 0x20;
          *(int *)((int)register0x00000010 + -0x18) = iVar8;
          uVar9 = -iVar8;
          uVar6 = 1 << ((byte)uVar2 & 0x1f) & -(uint)(uVar2 < 0x20);
          uVar11 = uVar6 - 1;
          bVar5 = (byte)*(uint *)((int)register0x00000010 + -8);
          uVar3 = *(undefined4 *)((int)register0x00000010 + -0x18);
          *(uint *)((int)register0x00000010 + -0x1c) =
               ((1 << ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20) |
                1U >> ((byte)-uVar4 & 0x1f) & -(uint)(-uVar4 < 0x20)) - 1) + (uint)(uVar6 != 0) <<
               (bVar5 & 0x1f);
          uVar6 = *(uint *)((int)register0x00000010 + -0x18);
          uVar2 = -(uint)(*(uint *)((int)register0x00000010 + -8) < 0x20);
          uVar4 = *(uint *)((int)register0x00000010 + -0x1c);
          puVar1 = *(uint **)((int)register0x00000010 + -4);
          *puVar1 = *puVar1 & ~(uVar11 << (bVar5 & 0x1f) & uVar2);
          puVar1[1] = ~(uVar11 << ((byte)uVar3 & 0x1f) & -(uint)(uVar6 < 0x20) |
                       uVar4 & uVar2 | uVar11 >> ((byte)uVar9 & 0x1f) & -(uint)(uVar9 < 0x20)) &
                      puVar1[1];
          return;
        }
        if (uVar11 < 8) {
          *(uint *)((int)register0x00000010 + -8) = uVar4;
          *(uint *)((int)register0x00000010 + -0xc) = uVar9;
          *(uint *)((int)register0x00000010 + -0x10) = uVar11;
          puVar1 = (uint *)(iVar8 + uVar4 * 8);
          uVar6 = uVar6 & 0x3f;
          *(uint *)((int)register0x00000010 + -0x14) = uVar6;
          uVar2 = uVar6 - 0x20;
          uVar6 = -1 << ((byte)uVar6 & 0x1f) &
                  -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20);
          *puVar1 = *puVar1 & ~uVar6;
          puVar1[1] = ~(-1 << ((byte)uVar2 & 0x1f) & -(uint)(uVar2 < 0x20) |
                       0xffffffffU >> ((byte)-uVar2 & 0x1f) & -(uint)(-uVar2 < 0x20) | uVar6) &
                      puVar1[1];
          uVar6 = *(uint *)((int)register0x00000010 + -0x10);
          if (uVar4 + 1 <= uVar6) {
            iVar8 = (uVar6 - *(int *)((int)register0x00000010 + -8)) + -1;
            iVar7 = *(int *)((int)register0x00000010 + 4);
            if (iVar8 != 0) {
              *(uint *)((int)register0x00000010 + -0x24) =
                   ((uVar4 + 1) * 8 & *(int *)((int)register0x00000010 + -8) + -7 >> 0x1f) + iVar7;
              *(int *)((int)register0x00000010 + -0x20) = iVar8 * 8;
              *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42f8e7;
              FUN_0046f470();
              iVar7 = *(int *)((int)register0x00000010 + 4);
              uVar6 = *(uint *)((int)register0x00000010 + -0x10);
            }
            *(uint *)((int)register0x00000010 + -4) = iVar7 + uVar6 * 8;
            uVar6 = (*(uint *)((int)register0x00000010 + -0xc) & 0x3f) - 0x1f;
            uVar4 = (*(uint *)((int)register0x00000010 + -0xc) & 0x3f) + 1;
            uVar4 = 1 << ((byte)uVar4 & 0x1f) & -(uint)(uVar4 < 0x20);
            puVar1 = *(uint **)((int)register0x00000010 + -4);
            *puVar1 = *puVar1 & -uVar4;
            puVar1[1] = -(uint)(uVar4 != 0) -
                        (1 << ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20) |
                        1U >> ((byte)-uVar6 & 0x1f) & -(uint)(-uVar6 < 0x20)) & puVar1[1];
            return;
          }
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42fa58;
          FUN_0046ee60();
        }
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42fa64;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x42fa6e;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar10 + -4) = 0x42fa74;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar10;
  } while( true );
}



/* Function: FUN_0042fa80 */

void FUN_0042fa80(void)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int in_EBX;
  uint uVar7;
  undefined1 *puVar8;
  uint unaff_EBP;
  uint uVar9;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x38);
      uVar6 = *(uint *)((int)register0x00000010 + 0xc);
      if (uVar6 == 1) {
        uVar3 = *(uint *)((int)register0x00000010 + 8) >> 6;
        if (uVar3 < 8) {
          uVar4 = ((uint *)(*(int *)((int)register0x00000010 + 4) + uVar3 * 8))[1];
          uVar7 = *(uint *)((int)register0x00000010 + 8) & 0x3f;
          uVar6 = uVar7 - 0x20;
          *(uint *)((int)register0x00000010 + 0x10) =
               (uVar4 >> ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20) |
               uVar4 << ((byte)-uVar6 & 0x1f) & -(uint)(-uVar6 < 0x20) |
               *(uint *)(*(int *)((int)register0x00000010 + 4) + uVar3 * 8) >> ((byte)uVar7 & 0x1f)
               & -(uint)(uVar7 < 0x20)) & 1;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42fd9d;
        FUN_0046ee00();
        goto LAB_0042fd9d;
      }
      uVar4 = *(uint *)((int)register0x00000010 + 8);
      uVar3 = uVar4 >> 6;
      if (uVar3 < 8) {
        in_EBX = *(int *)((int)register0x00000010 + 4);
        uVar7 = (uVar6 - 1) + uVar4;
        unaff_EBP = uVar7 >> 6;
        if (unaff_EBP == uVar3) {
          puVar1 = (uint *)(in_EBX + uVar3 * 8);
          uVar7 = puVar1[1];
          *(uint *)((int)register0x00000010 + -0x10) = uVar7;
          uVar4 = uVar4 & 0x3f;
          *(uint *)((int)register0x00000010 + -0x18) = *puVar1 >> ((byte)uVar4 & 0x1f);
          *(uint *)((int)register0x00000010 + -0x1c) = uVar7 >> ((byte)uVar4 & 0x1f);
          uVar3 = uVar4 - 0x20;
          *(uint *)((int)register0x00000010 + -0x20) = -uVar3;
          iVar2 = *(int *)((int)register0x00000010 + -0x10);
          *(int *)((int)register0x00000010 + -0x10) = 1 << ((byte)uVar6 & 0x1f);
          uVar6 = uVar6 - 0x20;
          *(int *)((int)register0x00000010 + -0x24) = 1 << ((byte)uVar6 & 0x1f);
          *(uint *)((int)register0x00000010 + -0x1c) =
               *(uint *)((int)register0x00000010 + -0x1c) & -(uint)(uVar4 < 0x20);
          uVar5 = ((*(uint *)((int)register0x00000010 + -0x24) & -(uint)(uVar6 < 0x20) |
                   1U >> ((byte)-uVar6 & 0x1f) & -(uint)(-uVar6 < 0x20)) - 1) +
                  (uint)((*(uint *)((int)register0x00000010 + -0x10) &
                         -(uint)(*(uint *)((int)register0x00000010 + 0xc) < 0x20)) != 0) &
                  *(uint *)((int)register0x00000010 + -0x1c);
          uVar3 = (uVar7 >> ((byte)uVar3 & 0x1f) & -(uint)(uVar3 < 0x20) |
                  iVar2 << ((byte)-uVar3 & 0x1f) &
                  -(uint)(*(uint *)((int)register0x00000010 + -0x20) < 0x20) |
                  *(uint *)((int)register0x00000010 + -0x18) & -(uint)(uVar4 < 0x20)) &
                  (*(uint *)((int)register0x00000010 + -0x10) &
                  -(uint)(*(uint *)((int)register0x00000010 + 0xc) < 0x20)) - 1;
          uVar6 = uVar3 >> 1 & 0x55555555;
          uVar3 = uVar3 & 0x55555555;
          uVar4 = uVar3 + uVar6;
          uVar7 = (uVar5 & 0x55555555) + (uVar5 >> 1 & 0x55555555) + (uint)CARRY4(uVar3,uVar6);
          uVar6 = uVar4 >> 2 & 0x33333333;
          uVar4 = uVar4 & 0x33333333;
          uVar3 = uVar4 + uVar6;
          uVar4 = (uVar7 & 0x33333333) + (uVar7 >> 2 & 0x33333333) + (uint)CARRY4(uVar4,uVar6);
          uVar6 = uVar4 * 0x10000000 | uVar3 >> 4;
          uVar7 = (uVar4 >> 4) + uVar4 + (uint)CARRY4(uVar3,uVar6) & 0xf0f0f0f;
          uVar3 = uVar3 + uVar6 & 0xf0f0f0f;
          uVar6 = uVar7 << 0x18 | uVar3 >> 8;
          uVar4 = uVar3 + uVar6;
          uVar3 = uVar7 + (uVar7 >> 8) + (uint)CARRY4(uVar3,uVar6);
          uVar6 = uVar3 * 0x10000 | uVar4 >> 0x10;
          *(uint *)((int)register0x00000010 + 0x10) =
               uVar4 + uVar6 + (uVar3 >> 0x10) + uVar3 + (uint)CARRY4(uVar4,uVar6) & 0x7f;
          return;
        }
        if (unaff_EBP < 8) {
          *(uint *)((int)register0x00000010 + -8) = uVar7;
          *(uint *)((int)register0x00000010 + -0xc) = unaff_EBP;
          puVar1 = (uint *)(in_EBX + uVar3 * 8);
          uVar7 = puVar1[1];
          *(uint *)((int)register0x00000010 + -0x10) = uVar7;
          uVar5 = *puVar1;
          uVar4 = uVar4 & 0x3f;
          *(uint *)((int)register0x00000010 + -0x14) = uVar4;
          uVar6 = uVar4 - 0x20;
          uVar9 = uVar7 >> ((byte)uVar4 & 0x1f) &
                  -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20);
          uVar7 = *(uint *)((int)register0x00000010 + -0x10) >> ((byte)uVar6 & 0x1f) &
                  -(uint)(uVar6 < 0x20) |
                  *(int *)((int)register0x00000010 + -0x10) << ((byte)-uVar6 & 0x1f) &
                  -(uint)(-uVar6 < 0x20) |
                  uVar5 >> ((byte)uVar4 & 0x1f) &
                  -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20);
          uVar6 = uVar7 >> 1 & 0x55555555;
          uVar7 = uVar7 & 0x55555555;
          uVar4 = uVar7 + uVar6;
          uVar6 = (uVar9 & 0x55555555) + (uVar9 >> 1 & 0x55555555) + (uint)CARRY4(uVar7,uVar6);
          uVar4 = uVar4 >> 2 & 0x33333333;
          uVar4 = uVar4 & 0x33333333;
          uVar4 = uVar4 + uVar4;
          uVar6 = (uVar6 & 0x33333333) + (uVar6 >> 2 & 0x33333333) + (uint)CARRY4(uVar4,uVar4);
          uVar6 = uVar6 * 0x10000000 | uVar4 >> 4;
          uVar6 = (uVar6 >> 4) + uVar6 + (uint)CARRY4(uVar4,uVar6) & 0xf0f0f0f;
          uVar6 = uVar4 + uVar6 & 0xf0f0f0f;
          uVar6 = uVar6 << 0x18 | uVar6 >> 8;
          uVar6 = uVar6 + uVar6;
          uVar6 = uVar6 + (uVar6 >> 8) + (uint)CARRY4(uVar6,uVar6);
          uVar6 = uVar6 * 0x10000 | uVar6 >> 0x10;
          unaff_EBP = uVar6 + uVar6 + (uVar6 >> 0x10) + uVar6 + (uint)CARRY4(uVar6,uVar6) & 0x7f;
          uVar6 = *(uint *)((int)register0x00000010 + -0xc);
          in_EBX = *(int *)((int)register0x00000010 + 4);
          while (uVar3 = uVar3 + 1, uVar3 < uVar6) {
LAB_0042fd9d:
            puVar1 = (uint *)(in_EBX + uVar3 * 8);
            uVar4 = puVar1[1];
            *(uint *)((int)register0x00000010 + -0x2c) = uVar4;
            uVar7 = *puVar1;
            *(uint *)((int)register0x00000010 + -0x30) = uVar7;
            uVar5 = uVar7 >> 1 & 0x55555555;
            *(uint *)((int)register0x00000010 + -0x10) =
                 *(uint *)((int)register0x00000010 + -0x2c) & 0x55555555;
            uVar7 = *(uint *)((int)register0x00000010 + -0x30);
            uVar9 = (uVar7 & 0x55555555) + uVar5;
            *(uint *)((int)register0x00000010 + -0x30) = uVar9;
            uVar7 = *(int *)((int)register0x00000010 + -0x10) + (uVar4 >> 1 & 0x55555555) +
                    (uint)CARRY4(uVar7 & 0x55555555,uVar5);
            *(uint *)((int)register0x00000010 + -0x28) = uVar7;
            uVar9 = uVar9 >> 2 & 0x33333333;
            *(uint *)((int)register0x00000010 + -0x10) =
                 *(uint *)((int)register0x00000010 + -0x28) & 0x33333333;
            uVar4 = *(uint *)((int)register0x00000010 + -0x30);
            uVar5 = (uVar4 & 0x33333333) + uVar9;
            *(uint *)((int)register0x00000010 + -0x30) = uVar5;
            uVar7 = *(int *)((int)register0x00000010 + -0x10) + (uVar7 >> 2 & 0x33333333) +
                    (uint)CARRY4(uVar4 & 0x33333333,uVar9);
            *(uint *)((int)register0x00000010 + -0x28) = uVar7;
            uVar4 = uVar7 * 0x10000000 | uVar5 >> 4;
            uVar5 = (uVar7 >> 4) + *(int *)((int)register0x00000010 + -0x28) +
                    (uint)CARRY4(*(uint *)((int)register0x00000010 + -0x30),uVar4) & 0xf0f0f0f;
            *(uint *)((int)register0x00000010 + -0x2c) = uVar5;
            uVar4 = *(uint *)((int)register0x00000010 + -0x30) + uVar4 & 0xf0f0f0f;
            *(uint *)((int)register0x00000010 + -0x30) = uVar4;
            uVar7 = uVar5 << 0x18 | uVar4 >> 8;
            uVar4 = *(uint *)((int)register0x00000010 + -0x30);
            uVar9 = uVar4 + uVar7;
            *(uint *)((int)register0x00000010 + -0x30) = uVar9;
            uVar7 = *(int *)((int)register0x00000010 + -0x2c) + (uVar5 >> 8) +
                    (uint)CARRY4(uVar4,uVar7);
            *(uint *)((int)register0x00000010 + -0x28) = uVar7;
            uVar4 = uVar7 * 0x10000 | uVar9 >> 0x10;
            unaff_EBP = unaff_EBP +
                        (*(uint *)((int)register0x00000010 + -0x30) + uVar4 +
                         (uVar7 >> 0x10) + *(int *)((int)register0x00000010 + -0x28) +
                         (uint)CARRY4(*(uint *)((int)register0x00000010 + -0x30),uVar4) & 0x7f);
          }
          *(uint *)((int)register0x00000010 + -0xc) = unaff_EBP;
          *(uint *)((int)register0x00000010 + -4) = in_EBX + uVar6 * 8;
          uVar6 = (*(uint *)((int)register0x00000010 + -8) & 0x3f) - 0x1f;
          uVar3 = (*(uint *)((int)register0x00000010 + -8) & 0x3f) + 1;
          uVar3 = 1 << ((byte)uVar3 & 0x1f) & -(uint)(uVar3 < 0x20);
          uVar7 = ((1 << ((byte)uVar6 & 0x1f) & -(uint)(uVar6 < 0x20) |
                   1U >> ((byte)-uVar6 & 0x1f) & -(uint)(-uVar6 < 0x20)) - 1) + (uint)(uVar3 != 0) &
                  (*(uint **)((int)register0x00000010 + -4))[1];
          uVar6 = uVar3 - 1 & **(uint **)((int)register0x00000010 + -4);
          uVar3 = uVar6 >> 1 & 0x55555555;
          uVar6 = uVar6 & 0x55555555;
          uVar4 = uVar6 + uVar3;
          uVar7 = (uVar7 & 0x55555555) + (uVar7 >> 1 & 0x55555555) + (uint)CARRY4(uVar6,uVar3);
          uVar6 = uVar4 >> 2 & 0x33333333;
          uVar4 = uVar4 & 0x33333333;
          uVar3 = uVar4 + uVar6;
          uVar4 = (uVar7 & 0x33333333) + (uVar7 >> 2 & 0x33333333) + (uint)CARRY4(uVar4,uVar6);
          uVar6 = uVar4 * 0x10000000 | uVar3 >> 4;
          uVar4 = (uVar4 >> 4) + uVar4 + (uint)CARRY4(uVar3,uVar6) & 0xf0f0f0f;
          uVar7 = uVar3 + uVar6 & 0xf0f0f0f;
          uVar6 = uVar4 << 0x18 | uVar7 >> 8;
          uVar3 = uVar7 + uVar6;
          uVar4 = uVar4 + (uVar4 >> 8) + (uint)CARRY4(uVar7,uVar6);
          uVar6 = uVar4 * 0x10000 | uVar3 >> 0x10;
          *(uint *)((int)register0x00000010 + 0x10) =
               *(int *)((int)register0x00000010 + -0xc) +
               (uVar3 + uVar6 + (uVar4 >> 0x10) + uVar4 + (uint)CARRY4(uVar3,uVar6) & 0x7f);
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42ffce;
        FUN_0046ee00();
      }
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x42ffd8;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar8 + -4) = 0x42ffde;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_0042fff0 */

void FUN_0042fff0(void)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  undefined1 *puVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  int in_FS_OFFSET;
  
code_r0x0042fff0:
  puVar7 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar7 = (undefined1 *)((int)register0x00000010 + -0x48);
    iVar4 = *(int *)((int)register0x00000010 + 4);
    iVar2 = 0;
    uVar3 = 0xffffffff;
    uVar6 = 0;
    uVar8 = 0;
    do {
      *(uint *)((int)register0x00000010 + -0x34) = uVar3;
      if (7 < iVar2) {
        if (uVar3 == 0xffffffff) {
          *(undefined4 *)((int)register0x00000010 + 8) = 0x8000200;
          *(undefined4 *)((int)register0x00000010 + 0xc) = 0x2000;
          return;
        }
        if (uVar8 < uVar6) {
          uVar8 = uVar6;
        }
        if (0x3d < uVar8) {
          if (uVar8 == 0x40000) {
            uVar6 = 0x80000000;
            uVar3 = 0;
          }
          else {
            uVar3 = (uVar8 & 0x3ffff) << 0x12 | uVar3 & 0x3ffff;
            uVar6 = (uVar8 & 0x3ffff) >> 0xe | (uVar6 & 0x3ffff) << 4;
          }
          *(uint *)((int)register0x00000010 + 8) = uVar3;
          *(uint *)((int)register0x00000010 + 0xc) = uVar6;
          return;
        }
        *(uint *)((int)register0x00000010 + -8) = uVar6;
        iVar2 = 0;
        goto LAB_004301c9;
      }
      *(int *)((int)register0x00000010 + -0x20) = iVar2;
      puVar1 = (uint *)(iVar4 + iVar2 * 8);
      uVar9 = puVar1[1];
      uVar10 = *puVar1;
      if (uVar9 == 0 && uVar10 == 0) {
        uVar6 = uVar6 + 0x40;
      }
      else {
        *(uint *)((int)register0x00000010 + -0x2c) = uVar8;
        iVar4 = 0;
        if (uVar10 != 0) {
          for (; (uVar10 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
          }
        }
        if (uVar10 == 0) {
          iVar4 = 0;
          if (uVar9 != 0) {
            for (; (uVar9 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
            }
          }
          if (uVar9 == 0) {
            iVar4 = 0x20;
          }
          iVar4 = iVar4 + 0x20;
        }
        if (uVar9 == 0) {
          iVar2 = 0;
        }
        else {
          iVar2 = 0x20;
          uVar10 = uVar9;
        }
        *(int *)((int)register0x00000010 + -4) = iVar4;
        if (0xffff < uVar10) {
          uVar10 = uVar10 >> 0x10;
          iVar2 = iVar2 + 0x10;
        }
        if (0xff < uVar10) {
          uVar10 = uVar10 >> 8;
          iVar2 = iVar2 + 8;
        }
        if (0xff < uVar10) goto LAB_004304e4;
        uVar8 = *(int *)((int)register0x00000010 + -4) + uVar6;
        uVar3 = *(uint *)((int)register0x00000010 + -0x34);
        if (uVar3 == 0xffffffff) {
          uVar3 = uVar8;
        }
        if (uVar8 <= *(uint *)((int)register0x00000010 + -0x2c)) {
          uVar8 = *(uint *)((int)register0x00000010 + -0x2c);
        }
        uVar6 = -(((byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                         [uVar10 + 0x1510] - 0x40) + iVar2);
      }
      iVar2 = *(int *)((int)register0x00000010 + -0x20) + 1;
      iVar4 = *(int *)((int)register0x00000010 + 4);
    } while( true );
  }
  goto LAB_00430501;
LAB_004301c9:
  if (7 < iVar2) {
    if (uVar8 == 0x40000) {
      uVar3 = 0;
      uVar6 = 0x80000000;
    }
    else {
      uVar3 = (uVar8 & 0x3ffff) << 0x12 | uVar3 & 0x3ffff;
      uVar6 = (uVar8 & 0x3ffff) >> 0xe | (uVar6 & 0x3ffff) << 4;
    }
    *(uint *)((int)register0x00000010 + 8) = uVar3;
    *(uint *)((int)register0x00000010 + 0xc) = uVar6;
    return;
  }
  *(int *)((int)register0x00000010 + -0x24) = iVar2;
  *(uint *)((int)register0x00000010 + -0x2c) = uVar8;
  puVar1 = (uint *)(iVar4 + iVar2 * 8);
  uVar6 = puVar1[1];
  *(uint *)((int)register0x00000010 + -0x38) = uVar6;
  uVar3 = *puVar1;
  uVar8 = 0;
  if (uVar3 != 0) {
    for (; (uVar3 >> uVar8 & 1) == 0; uVar8 = uVar8 + 1) {
    }
  }
  if (uVar3 == 0) {
    iVar4 = 0;
    if (uVar6 != 0) {
      for (; (uVar6 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
      }
    }
    if (uVar6 == 0) {
      iVar4 = 0x20;
    }
    uVar8 = iVar4 + 0x20;
  }
  uVar8 = uVar8 & 0x3f;
  uVar9 = uVar8 - 0x20;
  uVar10 = uVar6 >> ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20);
  uVar6 = *(uint *)((int)register0x00000010 + -0x38) >> ((byte)uVar9 & 0x1f) & -(uint)(uVar9 < 0x20)
          | *(int *)((int)register0x00000010 + -0x38) << ((byte)-uVar9 & 0x1f) &
            -(uint)(-uVar9 < 0x20) | uVar3 >> ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20);
  if ((uVar6 + 1 & uVar6) != 0 || (uVar10 + (0xfffffffe < uVar6) & uVar10) != 0) {
    uVar3 = *(uint *)((int)register0x00000010 + -0x2c);
    uVar8 = 1;
    uVar9 = uVar3;
    do {
      *(uint *)((int)register0x00000010 + -0x2c) = uVar9;
      while (*(uint *)((int)register0x00000010 + -0x28) = uVar8, uVar3 != 0) {
        *(uint *)((int)register0x00000010 + -0xc) = uVar10;
        if (uVar3 <= uVar8) {
          uVar3 = uVar3 & 0x3f;
          *(uint *)((int)register0x00000010 + -0x14) = uVar3;
          uVar8 = uVar3 - 0x20;
          *(uint *)((int)register0x00000010 + -0x10) = uVar10 >> ((byte)uVar8 & 0x1f);
          uVar10 = uVar10 >> ((byte)uVar3 & 0x1f) &
                   -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20) |
                   *(uint *)((int)register0x00000010 + -0xc);
          uVar6 = uVar6 >> ((byte)uVar3 & 0x1f) &
                  -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20) |
                  *(int *)((int)register0x00000010 + -0xc) << ((byte)-uVar8 & 0x1f) &
                  -(uint)(-uVar8 < 0x20) |
                  -(uint)(uVar8 < 0x20) & *(uint *)((int)register0x00000010 + -0x10) | uVar6;
          if ((uVar10 + (0xfffffffe < uVar6) & uVar10) == 0 && (uVar6 + 1 & uVar6) == 0) {
            uVar8 = *(uint *)((int)register0x00000010 + -0x2c);
            goto LAB_004301b4;
          }
          uVar9 = *(uint *)((int)register0x00000010 + -0x2c);
          break;
        }
        *(uint *)((int)register0x00000010 + -0x3c) = uVar6;
        *(uint *)((int)register0x00000010 + -0x30) = uVar3;
        uVar8 = uVar8 & 0x3f;
        uVar3 = uVar8 - 0x20;
        *(uint *)((int)register0x00000010 + -0x10) =
             *(uint *)((int)register0x00000010 + -0xc) >> ((byte)uVar3 & 0x1f);
        uVar10 = uVar10 >> ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20) |
                 *(uint *)((int)register0x00000010 + -0xc);
        uVar6 = uVar6 >> ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20) |
                *(int *)((int)register0x00000010 + -0xc) << ((byte)-uVar3 & 0x1f) &
                -(uint)(-uVar3 < 0x20) |
                -(uint)(uVar3 < 0x20) & *(uint *)((int)register0x00000010 + -0x10) |
                *(uint *)((int)register0x00000010 + -0x3c);
        if ((uVar10 + (0xfffffffe < uVar6) & uVar10) == 0 && (uVar6 + 1 & uVar6) == 0) {
          uVar8 = *(uint *)((int)register0x00000010 + -0x2c);
          goto LAB_004301b4;
        }
        uVar8 = *(int *)((int)register0x00000010 + -0x28) << 1;
        uVar9 = *(uint *)((int)register0x00000010 + -0x2c);
        uVar3 = *(int *)((int)register0x00000010 + -0x30) -
                *(int *)((int)register0x00000010 + -0x28);
      }
      *(uint *)((int)register0x00000010 + -0x38) = uVar10;
      uVar5 = ~uVar10;
      uVar8 = ~uVar6;
      uVar3 = 0;
      if (uVar8 != 0) {
        for (; (uVar8 >> uVar3 & 1) == 0; uVar3 = uVar3 + 1) {
        }
      }
      if (uVar8 == 0) {
        iVar4 = 0;
        if (uVar5 != 0) {
          for (; (uVar5 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
          }
        }
        if (uVar5 == 0) {
          iVar4 = 0x20;
        }
        uVar3 = iVar4 + 0x20;
      }
      uVar3 = uVar3 & 0x3f;
      *(uint *)((int)register0x00000010 + -0x14) = uVar3;
      uVar8 = uVar3 - 0x20;
      iVar4 = *(int *)((int)register0x00000010 + -0x38);
      uVar5 = uVar10 >> ((byte)uVar3 & 0x1f) &
              -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20);
      *(uint *)((int)register0x00000010 + -0x38) = uVar5;
      uVar3 = uVar10 >> ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20) |
              iVar4 << ((byte)-uVar8 & 0x1f) & -(uint)(-uVar8 < 0x20) |
              uVar6 >> ((byte)uVar3 & 0x1f) &
              -(uint)(*(uint *)((int)register0x00000010 + -0x14) < 0x20);
      uVar6 = 0;
      if (uVar3 != 0) {
        for (; (uVar3 >> uVar6 & 1) == 0; uVar6 = uVar6 + 1) {
        }
      }
      if (uVar3 == 0) {
        iVar4 = 0;
        if (uVar5 != 0) {
          for (; (uVar5 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
          }
        }
        if (uVar5 == 0) {
          iVar4 = 0x20;
        }
        uVar6 = iVar4 + 0x20;
      }
      *(uint *)((int)register0x00000010 + -4) = uVar6;
      uVar8 = uVar6 & 0x3f;
      *(uint *)((int)register0x00000010 + -0x10) = uVar3 >> ((byte)uVar8 & 0x1f);
      iVar4 = uVar8 - 0x20;
      *(int *)((int)register0x00000010 + -0x18) = iVar4;
      *(uint *)((int)register0x00000010 + -0x1c) = uVar5 >> ((byte)iVar4 & 0x1f);
      *(uint *)((int)register0x00000010 + -0x2c) = uVar9 + uVar6;
      uVar10 = uVar5 >> ((byte)uVar8 & 0x1f) & -(uint)(uVar8 < 0x20);
      uVar6 = *(uint *)((int)register0x00000010 + -0x1c) &
              -(uint)(*(uint *)((int)register0x00000010 + -0x18) < 0x20) |
              *(int *)((int)register0x00000010 + -0x38) << ((byte)-iVar4 & 0x1f) &
              -(uint)((uint)-iVar4 < 0x20) |
              *(uint *)((int)register0x00000010 + -0x10) & -(uint)(uVar8 < 0x20);
      if ((uVar6 + 1 & uVar6) == 0 && (uVar10 + (0xfffffffe < uVar6) & uVar10) == 0)
      goto LAB_00430277;
      uVar3 = *(uint *)((int)register0x00000010 + -4);
      uVar8 = *(uint *)((int)register0x00000010 + -0x28);
      uVar9 = *(uint *)((int)register0x00000010 + -0x2c);
    } while( true );
  }
  uVar8 = *(uint *)((int)register0x00000010 + -0x2c);
  goto LAB_004301b4;
LAB_00430277:
  uVar8 = *(uint *)((int)register0x00000010 + -0x2c);
LAB_004301b4:
  iVar2 = *(int *)((int)register0x00000010 + -0x24) + 1;
  iVar4 = *(int *)((int)register0x00000010 + 4);
  uVar3 = *(uint *)((int)register0x00000010 + -0x34);
  uVar6 = *(uint *)((int)register0x00000010 + -8);
  goto LAB_004301c9;
LAB_004304e4:
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4304f0;
  FUN_0046ee00();
  *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x430500;
  FUN_0046ee90();
LAB_00430501:
  *(undefined4 *)(puVar7 + -4) = 0x430506;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar7;
  goto code_r0x0042fff0;
}



/* Function: FUN_00430510 */

void FUN_00430510(int param_1,uint param_2,uint param_3)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_2 == 1) {
    param_3 = param_3 >> 6;
    while( true ) {
      if (7 < param_3) {
        return;
      }
      puVar1 = (uint *)(param_1 + param_3 * 8);
      uVar3 = ~puVar1[1];
      uVar4 = ~*puVar1;
      if (uVar3 != 0 || uVar4 != 0) break;
      param_3 = param_3 + 1;
    }
    iVar2 = 0;
    if (uVar4 != 0) {
      for (; (uVar4 >> iVar2 & 1) == 0; iVar2 = iVar2 + 1) {
      }
    }
    if ((uVar4 == 0) && (iVar2 = 0, uVar3 != 0)) {
      for (; (uVar3 >> iVar2 & 1) == 0; iVar2 = iVar2 + 1) {
      }
    }
    return;
  }
  if (0x40 < param_2) {
    FUN_00430930(param_1,param_2,param_3);
    return;
  }
  FUN_00430600(param_1,param_2,param_3);
  return;
}



/* Function: FUN_00430600 */

void FUN_00430600(void)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  undefined1 *puVar9;
  int iVar10;
  uint uVar11;
  int in_FS_OFFSET;
  
code_r0x00430600:
  puVar9 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar9 = (undefined1 *)((int)register0x00000010 + -0x34);
    uVar6 = *(uint *)((int)register0x00000010 + 0xc) >> 6;
    iVar10 = *(int *)((int)register0x00000010 + 4);
    iVar2 = -1;
    iVar4 = 0;
    do {
      if (7 < uVar6) {
        *(undefined4 *)((int)register0x00000010 + 0x10) = 0xffffffff;
        *(int *)((int)register0x00000010 + 0x14) = iVar2;
        return;
      }
      puVar1 = (uint *)(iVar10 + uVar6 * 8);
      uVar8 = puVar1[1];
      *(uint *)((int)register0x00000010 + -0x14) = uVar8;
      uVar7 = *puVar1;
      *(uint *)((int)register0x00000010 + -0x18) = uVar7;
      uVar7 = ~uVar7;
      uVar8 = ~uVar8;
      if (uVar8 == 0 && uVar7 == 0) {
        iVar4 = 0;
      }
      else {
        if (iVar2 == -1) {
          iVar2 = 0;
          if (uVar7 != 0) {
            for (; (uVar7 >> iVar2 & 1) == 0; iVar2 = iVar2 + 1) {
            }
          }
          if (uVar7 == 0) {
            iVar2 = 0;
            if (uVar8 != 0) {
              for (; (uVar8 >> iVar2 & 1) == 0; iVar2 = iVar2 + 1) {
              }
            }
            if (uVar8 == 0) {
              iVar2 = 0x20;
            }
            iVar2 = iVar2 + 0x20;
          }
          iVar2 = uVar6 * 0x40 + iVar2;
        }
        *(int *)((int)register0x00000010 + -0x28) = iVar2;
        uVar3 = *(uint *)((int)register0x00000010 + -0x18);
        uVar11 = *(uint *)((int)register0x00000010 + -0x14);
        iVar2 = 0;
        if (uVar3 != 0) {
          for (; (uVar3 >> iVar2 & 1) == 0; iVar2 = iVar2 + 1) {
          }
        }
        if (uVar3 == 0) {
          iVar2 = 0;
          if (uVar11 != 0) {
            for (; (uVar11 >> iVar2 & 1) == 0; iVar2 = iVar2 + 1) {
            }
          }
          if (uVar11 == 0) {
            iVar2 = 0x20;
          }
          iVar2 = iVar2 + 0x20;
        }
        if (*(uint *)((int)register0x00000010 + 8) <= (uint)(iVar2 + iVar4)) {
          *(uint *)((int)register0x00000010 + 0x10) = uVar6 * 0x40 - iVar4;
          *(undefined4 *)((int)register0x00000010 + 0x14) =
               *(undefined4 *)((int)register0x00000010 + -0x28);
          return;
        }
        *(uint *)((int)register0x00000010 + -4) = uVar6;
        uVar5 = 1;
        for (uVar3 = *(uint *)((int)register0x00000010 + 8) - 1; uVar3 != 0;
            uVar3 = uVar3 - *(int *)((int)register0x00000010 + -0x24)) {
          *(uint *)((int)register0x00000010 + -0x1c) = uVar8;
          *(uint *)((int)register0x00000010 + -0x20) = uVar7;
          if (uVar3 <= uVar5) {
            uVar3 = uVar3 & 0x3f;
            uVar6 = uVar3 - 0x20;
            uVar8 = uVar8 >> ((byte)uVar3 & 0x1f) & -(uint)(uVar3 < 0x20) &
                    *(uint *)((int)register0x00000010 + -0x1c);
            uVar7 = (uVar7 >> ((byte)uVar3 & 0x1f) & -(uint)(uVar3 < 0x20) |
                     *(int *)((int)register0x00000010 + -0x1c) << ((byte)-uVar6 & 0x1f) &
                     -(uint)(-uVar6 < 0x20) |
                    *(uint *)((int)register0x00000010 + -0x1c) >> ((byte)uVar6 & 0x1f) &
                    -(uint)(uVar6 < 0x20)) & *(uint *)((int)register0x00000010 + -0x20);
            uVar6 = *(uint *)((int)register0x00000010 + -4);
            uVar11 = *(uint *)((int)register0x00000010 + -0x14);
            break;
          }
          *(uint *)((int)register0x00000010 + -0x24) = uVar5;
          uVar5 = uVar5 & 0x3f;
          *(uint *)((int)register0x00000010 + -8) = uVar5;
          uVar6 = uVar5 - 0x20;
          *(uint *)((int)register0x00000010 + -0xc) =
               *(uint *)((int)register0x00000010 + -0x1c) >> ((byte)uVar6 & 0x1f);
          *(int *)((int)register0x00000010 + -0x10) =
               *(int *)((int)register0x00000010 + -0x1c) << ((byte)-uVar6 & 0x1f);
          uVar8 = *(uint *)((int)register0x00000010 + -0x1c) &
                  uVar8 >> ((byte)uVar5 & 0x1f) &
                  -(uint)(*(uint *)((int)register0x00000010 + -8) < 0x20);
          uVar7 = *(uint *)((int)register0x00000010 + -0x20) &
                  (*(uint *)((int)register0x00000010 + -0x10) & -(uint)(-uVar6 < 0x20) |
                   uVar7 >> ((byte)uVar5 & 0x1f) &
                   -(uint)(*(uint *)((int)register0x00000010 + -8) < 0x20) |
                  *(uint *)((int)register0x00000010 + -0xc) & -(uint)(uVar6 < 0x20));
          if (uVar7 == 0 && uVar8 == 0) {
            uVar6 = *(uint *)((int)register0x00000010 + -4);
            uVar11 = *(uint *)((int)register0x00000010 + -0x14);
            uVar3 = 0x40;
            goto LAB_00430753;
          }
          uVar5 = *(int *)((int)register0x00000010 + -0x24) << 1;
          uVar11 = *(uint *)((int)register0x00000010 + -0x14);
          uVar6 = *(uint *)((int)register0x00000010 + -4);
        }
        uVar3 = 0;
        if (uVar7 != 0) {
          for (; (uVar7 >> uVar3 & 1) == 0; uVar3 = uVar3 + 1) {
          }
        }
        if (uVar7 == 0) {
          iVar2 = 0;
          if (uVar8 != 0) {
            for (; (uVar8 >> iVar2 & 1) == 0; iVar2 = iVar2 + 1) {
            }
          }
          if (uVar8 == 0) {
            iVar2 = 0x20;
          }
          uVar3 = iVar2 + 0x20;
        }
LAB_00430753:
        if (uVar3 < 0x40) {
          *(uint *)((int)register0x00000010 + 0x10) = uVar3 + uVar6 * 0x40;
          *(undefined4 *)((int)register0x00000010 + 0x14) =
               *(undefined4 *)((int)register0x00000010 + -0x28);
          return;
        }
        if (uVar11 == 0) {
          uVar11 = *(uint *)((int)register0x00000010 + -0x18);
          iVar2 = 0;
        }
        else {
          iVar2 = 0x20;
        }
        if (0xffff < uVar11) {
          uVar11 = uVar11 >> 0x10;
          iVar2 = iVar2 + 0x10;
        }
        if (0xff < uVar11) {
          uVar11 = uVar11 >> 8;
          iVar2 = iVar2 + 8;
        }
        if (0xff < uVar11) goto LAB_00430904;
        iVar4 = -(((byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                         [uVar11 + 0x1510] - 0x40) + iVar2);
        iVar2 = *(int *)((int)register0x00000010 + -0x28);
      }
      uVar6 = uVar6 + 1;
      iVar10 = *(int *)((int)register0x00000010 + 4);
    } while( true );
  }
  goto LAB_0043091f;
LAB_00430904:
  *(undefined4 *)((int)register0x00000010 + -0x38) = 0x430910;
  FUN_0046ee00();
  *(undefined4 *)((int)register0x00000010 + -0x38) = 0x43091e;
  FUN_0046ee90();
LAB_0043091f:
  *(undefined4 *)(puVar9 + -4) = 0x430924;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar9;
  goto code_r0x00430600;
}



/* Function: FUN_00430930 */

void FUN_00430930(void)

{
  uint *puVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  undefined1 *puVar9;
  uint uVar10;
  int iVar11;
  int in_FS_OFFSET;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0x1c);
      uVar5 = *(uint *)((int)register0x00000010 + 0xc) >> 6;
      iVar8 = *(int *)((int)register0x00000010 + 4);
      uVar10 = *(uint *)((int)register0x00000010 + 8);
      uVar2 = 0;
      iVar4 = -1;
      iVar11 = -1;
LAB_00430975:
      if (7 < uVar5) {
        if (uVar2 < uVar10) {
          *(undefined4 *)((int)register0x00000010 + 0x10) = 0xffffffff;
          *(int *)((int)register0x00000010 + 0x14) = iVar4;
          return;
        }
        *(int *)((int)register0x00000010 + 0x10) = iVar11;
        *(int *)((int)register0x00000010 + 0x14) = iVar4;
        return;
      }
      *(uint *)((int)register0x00000010 + -0xc) = uVar2;
      puVar1 = (uint *)(iVar8 + uVar5 * 8);
      uVar10 = puVar1[1];
      uVar2 = *puVar1;
      if (uVar10 == 0xffffffff && uVar2 == 0xffffffff) {
        uVar2 = 0;
LAB_00430964:
        uVar5 = uVar5 + 1;
        iVar8 = *(int *)((int)register0x00000010 + 4);
        uVar10 = *(uint *)((int)register0x00000010 + 8);
        goto LAB_00430975;
      }
      *(uint *)((int)register0x00000010 + -4) = uVar5;
      if (iVar4 == -1) {
        uVar6 = ~uVar10;
        uVar7 = ~uVar2;
        iVar4 = 0;
        if (uVar7 != 0) {
          for (; (uVar7 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
          }
        }
        if (uVar7 == 0) {
          iVar4 = 0;
          if (uVar6 != 0) {
            for (; (uVar6 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
            }
          }
          if (uVar6 == 0) {
            iVar4 = 0x20;
          }
          iVar4 = iVar4 + 0x20;
        }
        iVar4 = uVar5 * 0x40 + iVar4;
        uVar5 = *(uint *)((int)register0x00000010 + -4);
      }
      iVar8 = *(int *)((int)register0x00000010 + -0xc);
      if (iVar8 == 0) {
        if (uVar10 == 0) {
          iVar8 = 0;
        }
        else {
          iVar8 = 0x20;
          uVar2 = uVar10;
        }
        *(int *)((int)register0x00000010 + -8) = iVar4;
        if (0xffff < uVar2) {
          uVar2 = uVar2 >> 0x10;
          iVar8 = iVar8 + 0x10;
        }
        if (0xff < uVar2) {
          uVar2 = uVar2 >> 8;
          iVar8 = iVar8 + 8;
        }
        if (0xff < uVar2) goto LAB_00430c05;
        iVar11 = iVar8 + (uint)(byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                                     [uVar2 + 0x1510] + uVar5 * 0x40;
        uVar2 = -(((byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                         [uVar2 + 0x1510] - 0x40) + iVar8);
        iVar4 = *(int *)((int)register0x00000010 + -8);
        goto LAB_00430964;
      }
      *(uint *)((int)register0x00000010 + -0x10) = uVar2;
      uVar5 = 0;
      if (uVar2 != 0) {
        for (; (uVar2 >> uVar5 & 1) == 0; uVar5 = uVar5 + 1) {
        }
      }
      if (uVar2 == 0) {
        iVar3 = 0;
        if (uVar10 != 0) {
          for (; (uVar10 >> iVar3 & 1) == 0; iVar3 = iVar3 + 1) {
          }
        }
        if (uVar10 == 0) {
          iVar3 = 0x20;
        }
        uVar5 = iVar3 + 0x20;
      }
      if (*(uint *)((int)register0x00000010 + 8) <= iVar8 + uVar5) {
        *(int *)((int)register0x00000010 + 0x10) = iVar11;
        *(int *)((int)register0x00000010 + 0x14) = iVar4;
        return;
      }
      if (0x3f < uVar5) {
        uVar2 = iVar8 + 0x40;
        uVar5 = *(uint *)((int)register0x00000010 + -4);
        goto LAB_00430964;
      }
      if (uVar10 == 0) {
        uVar10 = *(uint *)((int)register0x00000010 + -0x10);
        iVar8 = 0;
      }
      else {
        iVar8 = 0x20;
      }
      if (0xffff < uVar10) {
        uVar10 = uVar10 >> 0x10;
        iVar8 = iVar8 + 0x10;
      }
      if (0xff < uVar10) {
        uVar10 = uVar10 >> 8;
        iVar8 = iVar8 + 8;
      }
      if (uVar10 < 0x100) {
        uVar5 = *(uint *)((int)register0x00000010 + -4);
        iVar11 = uVar5 * 0x40 +
                 iVar8 + (uint)(byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                                     [uVar10 + 0x1510];
        uVar2 = -(((byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                         [uVar10 + 0x1510] - 0x40) + iVar8);
        goto LAB_00430964;
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x430bf7;
      FUN_0046ee00();
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x430c05;
      FUN_0046ee90();
LAB_00430c05:
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x430c11;
      FUN_0046ee00();
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x430c1f;
      FUN_0046ee90();
    }
    *(undefined4 *)(puVar9 + -4) = 0x430c25;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
}



/* Function: FUN_00430c30 */

void FUN_00430c30(int param_1,undefined4 param_2,undefined4 param_3)

{
  int in_FS_OFFSET;
  int iVar1;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar1 = param_1 + 0x40;
  FUN_0042f5a0(param_1,param_2,param_3,iVar1);
  FUN_0042f7f0(iVar1,param_2,param_3);
  return;
}



/* Function: FUN_00430c90 */

void FUN_00430c90(undefined4 param_1)

{
  int in_FS_OFFSET;
  undefined1 local_8;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  do {
    FUN_00402510(param_1);
    FUN_00402540(param_1);
  } while (local_8 == '\0');
  return;
}



/* Function: FUN_00430d00 */

void FUN_00430d00(undefined4 param_1)

{
  int in_FS_OFFSET;
  undefined1 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 'g';
    FUN_0046d980();
  }
  do {
    FUN_00402510(param_1);
    FUN_00402540(param_1);
  } while (local_4 == '\0');
  return;
}



/* Function: FUN_00430d70 */

void FUN_00430d70(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x10);
      if (*(int *)((int)register0x00000010 + 4) == 1) {
        iVar1 = *(int *)((int)register0x00000010 + 8) * 4 + 0x58;
        goto LAB_00430da3;
      }
      if (*(int *)((int)register0x00000010 + 4) - 2U < 2) {
        iVar1 = *(int *)((int)register0x00000010 + 8) * 4 + 0x28;
LAB_00430da3:
        *(int *)((int)register0x00000010 + -0x10) = iVar1;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
        *(undefined **)((int)register0x00000010 + -8) = &DAT_005f84e8;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x430dbd;
        FUN_004119f0();
        iVar1 = *(int *)((int)register0x00000010 + -4);
        *(undefined4 *)(iVar1 + 8) = *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)(iVar1 + 0x14) = *(undefined4 *)((int)register0x00000010 + 8);
        *(int *)((int)register0x00000010 + 0xc) = iVar1;
        return;
      }
      *(char **)((int)register0x00000010 + -0x10) =
           "invalid profile bucket typeruntime: corrupted polldescruntime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformat..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x1b;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x430ded;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x430df3;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00430e00 */

void FUN_00430e00(void)

{
  uint uVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -8);
      uVar1 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x14);
      if (uVar1 < 0x401) {
        *(int *)((int)register0x00000010 + 8) = *(int *)((int)register0x00000010 + 4) + 0x18;
        *(uint *)((int)register0x00000010 + 0xc) = uVar1;
        *(uint *)((int)register0x00000010 + 0x10) = uVar1;
        return;
      }
      *(undefined **)((int)register0x00000010 + -8) = &DAT_004c7a9f;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x17;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x430e4c;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x430e52;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00430e60 */

void FUN_00430e60(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -8);
      iVar1 = *(int *)((int)register0x00000010 + 4);
      if (*(int *)(iVar1 + 8) == 1) {
        *(int *)((int)register0x00000010 + 8) = iVar1 + 0x18 + *(int *)(iVar1 + 0x14) * 4;
        return;
      }
      *(undefined **)((int)register0x00000010 + -8) = &DAT_004c6888;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x430ea2;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x430ea8;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00430eb0 */

void FUN_00430eb0(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -8);
      iVar1 = *(int *)((int)register0x00000010 + 4);
      if ((*(int *)(iVar1 + 8) == 2) || (*(int *)(iVar1 + 8) == 3)) {
        *(int *)((int)register0x00000010 + 8) = iVar1 + 0x18 + *(int *)(iVar1 + 0x14) * 4;
        return;
      }
      *(undefined **)((int)register0x00000010 + -8) = &DAT_004c689c;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x14;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x430ef9;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x430eff;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00430f10 */

void FUN_00430f10(void)

{
  uint uVar1;
  undefined4 *puVar2;
  undefined *puVar3;
  int iVar4;
  int iVar5;
  undefined1 *puVar6;
  uint uVar7;
  int iVar8;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x30);
      *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005d6dd0;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x430f36;
      FUN_00402520();
      iVar8 = *(int *)((int)register0x00000010 + -0x2c);
      if (iVar8 == 0) {
        *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005f5e10;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x430f4e;
        FUN_0040ecf0();
        *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005d6dd0;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x430f5d;
        FUN_00402520();
        iVar8 = *(int *)((int)register0x00000010 + -0x2c);
        if (iVar8 != 0) {
LAB_00430fa2:
          *(int *)((int)register0x00000010 + -0xc) = iVar8;
          *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005f5e10;
          *(undefined4 *)((int)register0x00000010 + -0x34) = 0x430fb6;
          FUN_0040f0e0();
          iVar8 = *(int *)((int)register0x00000010 + -0xc);
          goto LAB_00430fba;
        }
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0xafc7c;
        *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f84e8;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x430f7b;
        FUN_00414d10();
        iVar8 = *(int *)((int)register0x00000010 + -0x28);
        if (iVar8 != 0) {
          *(int *)((int)register0x00000010 + -4) = iVar8;
          *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005d6dd0;
          *(int *)((int)register0x00000010 + -0x2c) = iVar8;
          *(undefined4 *)((int)register0x00000010 + -0x34) = 0x430f9e;
          FUN_00402760();
          iVar8 = *(int *)((int)register0x00000010 + -4);
          goto LAB_00430fa2;
        }
      }
      else {
LAB_00430fba:
        uVar7 = 0;
        for (iVar4 = 0; iVar4 < *(int *)((int)register0x00000010 + 0x10); iVar4 = iVar4 + 1) {
          uVar7 = (*(int *)(*(int *)((int)register0x00000010 + 0xc) + iVar4 * 4) + uVar7) * 0x401;
          uVar7 = uVar7 ^ uVar7 >> 6;
        }
        uVar7 = ((uVar7 + *(int *)((int)register0x00000010 + 8)) * 0x401 >> 6 ^
                (uVar7 + *(int *)((int)register0x00000010 + 8)) * 0x401) * 9;
        uVar7 = uVar7 >> 0xb ^ uVar7;
        uVar1 = uVar7 + (((uint)((ulong)uVar7 * 0x174d43f79 >> 0x21) |
                         (uint)CARRY4((uint)((ulong)uVar7 * 0x74d43f79 >> 0x20),uVar7) << 0x1f) >>
                        0x11) * -179999;
        if (uVar1 < 179999) {
          *(uint *)((int)register0x00000010 + -0x20) = uVar7;
          iVar8 = iVar8 + uVar1 * 4;
          *(int *)((int)register0x00000010 + -8) = iVar8;
          *(int *)((int)register0x00000010 + -0x30) = iVar8;
          *(undefined4 *)((int)register0x00000010 + -0x34) = 0x43103a;
          FUN_00402520();
          puVar2 = *(undefined4 **)((int)register0x00000010 + -0x2c);
          iVar8 = *(int *)((int)register0x00000010 + 8);
          iVar4 = *(int *)((int)register0x00000010 + -0x20);
          iVar5 = *(int *)((int)register0x00000010 + 4);
          do {
            if (puVar2 == (undefined4 *)0x0) {
              if (*(char *)((int)register0x00000010 + 0x18) == '\0') {
                *(undefined4 *)((int)register0x00000010 + 0x1c) = 0;
                return;
              }
              *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005f5e10;
              *(undefined4 *)((int)register0x00000010 + -0x34) = 0x4310b3;
              FUN_0040ecf0();
              *(undefined4 *)((int)register0x00000010 + -0x30) =
                   *(undefined4 *)((int)register0x00000010 + -8);
              *(undefined4 *)((int)register0x00000010 + -0x34) = 0x4310bf;
              FUN_00402520();
              puVar2 = *(undefined4 **)((int)register0x00000010 + -0x2c);
              iVar8 = *(int *)((int)register0x00000010 + 8);
              iVar4 = *(int *)((int)register0x00000010 + -0x20);
              iVar5 = *(int *)((int)register0x00000010 + 4);
              do {
                if (puVar2 == (undefined4 *)0x0) {
                  *(int *)((int)register0x00000010 + -0x30) = iVar5;
                  *(undefined4 *)((int)register0x00000010 + -0x2c) =
                       *(undefined4 *)((int)register0x00000010 + 0x10);
                  *(undefined4 *)((int)register0x00000010 + -0x34) = 0x43113b;
                  FUN_00430d70();
                  *(undefined4 *)((int)register0x00000010 + -0x14) =
                       *(undefined4 *)((int)register0x00000010 + -0x28);
                  *(undefined4 *)((int)register0x00000010 + -0x30) =
                       *(undefined4 *)((int)register0x00000010 + -0x28);
                  *(undefined4 *)((int)register0x00000010 + -0x34) = 0x43114b;
                  FUN_00430e00();
                  iVar8 = *(int *)((int)register0x00000010 + 0x10);
                  if (*(int *)((int)register0x00000010 + -0x28) <=
                      *(int *)((int)register0x00000010 + 0x10)) {
                    iVar8 = *(int *)((int)register0x00000010 + -0x28);
                  }
                  if (*(int *)((int)register0x00000010 + 0xc) !=
                      *(int *)((int)register0x00000010 + -0x2c)) {
                    *(int *)((int)register0x00000010 + -0x30) =
                         *(int *)((int)register0x00000010 + -0x2c);
                    *(int *)((int)register0x00000010 + -0x2c) =
                         *(int *)((int)register0x00000010 + 0xc);
                    *(int *)((int)register0x00000010 + -0x28) = iVar8 << 2;
                    *(undefined4 *)((int)register0x00000010 + -0x34) = 0x431178;
                    FUN_0046f640();
                  }
                  iVar8 = *(int *)((int)register0x00000010 + -0x14);
                  *(undefined4 *)(iVar8 + 0xc) = *(undefined4 *)((int)register0x00000010 + -0x20);
                  *(undefined4 *)(iVar8 + 0x10) = *(undefined4 *)((int)register0x00000010 + 8);
                  if (*(int *)((int)register0x00000010 + 4) == 1) {
                    puVar3 = &DAT_005d6dc4;
                  }
                  else if (*(int *)((int)register0x00000010 + 4) == 3) {
                    puVar3 = &DAT_005d6dcc;
                  }
                  else {
                    puVar3 = &DAT_005d6dc8;
                  }
                  *(undefined **)((int)register0x00000010 + -0x10) = puVar3;
                  *(undefined4 *)((int)register0x00000010 + -0x30) =
                       *(undefined4 *)((int)register0x00000010 + -8);
                  *(undefined4 *)((int)register0x00000010 + -0x34) = 0x4311be;
                  FUN_00402520();
                  **(undefined4 **)((int)register0x00000010 + -0x14) =
                       *(undefined4 *)((int)register0x00000010 + -0x2c);
                  *(undefined4 *)((int)register0x00000010 + -0x30) =
                       *(undefined4 *)((int)register0x00000010 + -0x10);
                  *(undefined4 *)((int)register0x00000010 + -0x34) = 0x4311d4;
                  FUN_00402520();
                  iVar8 = *(int *)((int)register0x00000010 + -0x14);
                  *(undefined4 *)(iVar8 + 4) = *(undefined4 *)((int)register0x00000010 + -0x2c);
                  *(undefined4 *)((int)register0x00000010 + -0x30) =
                       *(undefined4 *)((int)register0x00000010 + -8);
                  *(int *)((int)register0x00000010 + -0x2c) = iVar8;
                  *(undefined4 *)((int)register0x00000010 + -0x34) = 0x4311f0;
                  FUN_00402760();
                  *(undefined4 *)((int)register0x00000010 + -0x30) =
                       *(undefined4 *)((int)register0x00000010 + -0x10);
                  *(undefined4 *)((int)register0x00000010 + -0x2c) =
                       *(undefined4 *)((int)register0x00000010 + -0x14);
                  *(undefined4 *)((int)register0x00000010 + -0x34) = 0x431205;
                  FUN_00402760();
                  *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005f5e10;
                  *(undefined4 *)((int)register0x00000010 + -0x34) = 0x431215;
                  FUN_0040f0e0();
                  *(undefined4 *)((int)register0x00000010 + 0x1c) =
                       *(undefined4 *)((int)register0x00000010 + -0x14);
                  return;
                }
                if (((puVar2[2] == iVar5) && (puVar2[3] == iVar4)) && (puVar2[4] == iVar8)) {
                  *(undefined4 **)((int)register0x00000010 + -0x1c) = puVar2;
                  *(undefined4 **)((int)register0x00000010 + -0x30) = puVar2;
                  *(undefined4 *)((int)register0x00000010 + -0x34) = 0x4310fe;
                  FUN_00430e00();
                  if (*(int *)((int)register0x00000010 + 0x10) ==
                      *(int *)((int)register0x00000010 + -0x28)) {
                    iVar8 = 0;
                    while( true ) {
                      if (*(int *)((int)register0x00000010 + -0x28) <= iVar8) {
                        *(undefined **)((int)register0x00000010 + -0x30) = &DAT_005f5e10;
                        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x431255;
                        FUN_0040f0e0();
                        *(undefined4 *)((int)register0x00000010 + 0x1c) =
                             *(undefined4 *)((int)register0x00000010 + -0x1c);
                        return;
                      }
                      if (*(int *)(*(int *)((int)register0x00000010 + 0xc) + iVar8 * 4) !=
                          *(int *)(*(int *)((int)register0x00000010 + -0x2c) + iVar8 * 4)) break;
                      iVar8 = iVar8 + 1;
                    }
                    puVar2 = *(undefined4 **)((int)register0x00000010 + -0x1c);
                    iVar8 = *(int *)((int)register0x00000010 + 8);
                    iVar4 = *(int *)((int)register0x00000010 + -0x20);
                    iVar5 = *(int *)((int)register0x00000010 + 4);
                  }
                  else {
                    puVar2 = *(undefined4 **)((int)register0x00000010 + -0x1c);
                    iVar8 = *(int *)((int)register0x00000010 + 8);
                    iVar4 = *(int *)((int)register0x00000010 + -0x20);
                    iVar5 = *(int *)((int)register0x00000010 + 4);
                  }
                }
                puVar2 = (undefined4 *)*puVar2;
              } while( true );
            }
            if (((puVar2[2] == iVar5) && (puVar2[3] == iVar4)) && (puVar2[4] == iVar8)) {
              *(undefined4 **)((int)register0x00000010 + -0x18) = puVar2;
              *(undefined4 **)((int)register0x00000010 + -0x30) = puVar2;
              *(undefined4 *)((int)register0x00000010 + -0x34) = 0x43106d;
              FUN_00430e00();
              if (*(int *)((int)register0x00000010 + 0x10) ==
                  *(int *)((int)register0x00000010 + -0x28)) {
                iVar8 = 0;
                while( true ) {
                  if (*(int *)((int)register0x00000010 + -0x28) <= iVar8) {
                    *(undefined4 *)((int)register0x00000010 + 0x1c) =
                         *(undefined4 *)((int)register0x00000010 + -0x18);
                    return;
                  }
                  if (*(int *)(*(int *)((int)register0x00000010 + 0xc) + iVar8 * 4) !=
                      *(int *)(*(int *)((int)register0x00000010 + -0x2c) + iVar8 * 4)) break;
                  iVar8 = iVar8 + 1;
                }
                puVar2 = *(undefined4 **)((int)register0x00000010 + -0x18);
                iVar8 = *(int *)((int)register0x00000010 + 8);
                iVar4 = *(int *)((int)register0x00000010 + -0x20);
                iVar5 = *(int *)((int)register0x00000010 + 4);
              }
              else {
                puVar2 = *(undefined4 **)((int)register0x00000010 + -0x18);
                iVar8 = *(int *)((int)register0x00000010 + 8);
                iVar4 = *(int *)((int)register0x00000010 + -0x20);
                iVar5 = *(int *)((int)register0x00000010 + 4);
              }
            }
            puVar2 = (undefined4 *)*puVar2;
          } while( true );
        }
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0x43129b;
        FUN_0046edf0();
      }
      *(undefined **)((int)register0x00000010 + -0x30) = &DAT_004ca41d;
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x34) = 0x4312b1;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar6 + -4) = 0x4312b7;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_004312c0 */

void FUN_004312c0(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x14);
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005f5e1c;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x4312e5;
      FUN_00430c90();
      if (*(char *)((int)register0x00000010 + -0xc) != '\0') {
        return;
      }
      *(uint *)((int)register0x00000010 + -8) = *(uint *)((int)register0x00000010 + -0x10) % 3;
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005f5e18;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x431314;
      FUN_0040ecf0();
      if (*(uint *)((int)register0x00000010 + -8) < 3) {
        *(undefined **)((int)register0x00000010 + -4) =
             &DAT_005f5fa0 + *(uint *)((int)register0x00000010 + -8) * 4;
        *(undefined **)((int)register0x00000010 + -0x14) =
             &DAT_005f5fa0 + *(uint *)((int)register0x00000010 + -8) * 4;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x431333;
        FUN_0040ecf0();
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43133f;
        FUN_00431380();
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43134d;
        FUN_0040f0e0();
        *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005f5e18;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43135d;
        FUN_0040f0e0();
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43136f;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar1 + -4) = 0x431375;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00431380 */

void FUN_00431380(void)

{
  int *piVar1;
  int iVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0xc);
      if (*(uint *)((int)register0x00000010 + 4) < 3) {
        *(undefined **)((int)register0x00000010 + -0xc) = &DAT_005d6dc4;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x4313b3;
        FUN_00402520();
        iVar2 = *(int *)((int)register0x00000010 + -8);
        while (iVar2 != 0) {
          *(int *)((int)register0x00000010 + -4) = iVar2;
          *(int *)((int)register0x00000010 + -0xc) = iVar2;
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0x4313c5;
          FUN_00430e60();
          piVar1 = *(int **)((int)register0x00000010 + -8);
          iVar2 = *(int *)((int)register0x00000010 + 4);
          *piVar1 = *piVar1 + piVar1[iVar2 * 4 + 4];
          piVar1[1] = piVar1[1] + piVar1[iVar2 * 4 + 5];
          piVar1[2] = piVar1[2] + piVar1[iVar2 * 4 + 6];
          piVar1[3] = piVar1[3] + piVar1[iVar2 * 4 + 7];
          piVar1[iVar2 * 4 + 4] = 0;
          piVar1[iVar2 * 4 + 5] = 0;
          piVar1[iVar2 * 4 + 6] = 0;
          piVar1[iVar2 * 4 + 7] = 0;
          iVar2 = *(int *)(*(int *)((int)register0x00000010 + -4) + 4);
        }
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x431430;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar3 + -4) = 0x431436;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00431440 */

void FUN_00431440(void)

{
  uint uVar1;
  undefined4 uVar2;
  int iVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x44);
      iVar3 = *(int *)(*(int *)((int)register0x00000010 + 4) + 0x178);
      if (iVar3 == 0) {
        return;
      }
      uVar1 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x180);
      if (DAT_005f625c <= uVar1) {
        *(undefined4 *)((int)register0x00000010 + -0x44) = 5;
        *(int *)((int)register0x00000010 + -0x40) = iVar3;
        *(uint *)((int)register0x00000010 + -0x3c) = DAT_005f625c;
        *(uint *)((int)register0x00000010 + -0x38) = uVar1;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x431495;
        FUN_0046d1d0();
        *(undefined4 *)((int)register0x00000010 + -0x28) =
             *(undefined4 *)((int)register0x00000010 + -0x34);
        *(undefined **)((int)register0x00000010 + -0x44) = &DAT_005f5e1c;
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4314ac;
        FUN_00402510();
        uVar1 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x180);
        iVar3 = (*(uint *)((int)register0x00000010 + -0x40) >> 1) +
                (((*(uint *)((int)register0x00000010 + -0x40) >> 1) + 2) / 3) * -3;
        if (*(uint *)((int)register0x00000010 + -0x28) <= uVar1) {
          *(int *)((int)register0x00000010 + -0x1c) = iVar3;
          *(int *)((int)register0x00000010 + -0x24) = iVar3 + 2;
          uVar2 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x178);
          *(undefined4 *)((int)register0x00000010 + -0x44) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x40) =
               *(undefined4 *)((int)register0x00000010 + 0xc);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = uVar2;
          *(uint *)((int)register0x00000010 + -0x38) = *(uint *)((int)register0x00000010 + -0x28);
          *(uint *)((int)register0x00000010 + -0x34) = uVar1;
          *(undefined1 *)((int)register0x00000010 + -0x30) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x431513;
          FUN_00430f10();
          *(undefined4 *)((int)register0x00000010 + -0x20) =
               *(undefined4 *)((int)register0x00000010 + -0x2c);
          *(undefined4 *)((int)register0x00000010 + -0x44) =
               *(undefined4 *)((int)register0x00000010 + -0x2c);
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x431523;
          FUN_00430e60();
          if (*(uint *)((int)register0x00000010 + -0x24) < 3) {
            iVar3 = *(uint *)((int)register0x00000010 + -0x24) * 0x10;
            *(int *)((int)register0x00000010 + -0x18) =
                 *(int *)((int)register0x00000010 + -0x1c) * 4 + 0x5f5fa8;
            *(int *)((int)register0x00000010 + -0x10) =
                 *(int *)((int)register0x00000010 + -0x40) + 0x10 + iVar3;
            *(int *)((int)register0x00000010 + -0x14) =
                 *(int *)((int)register0x00000010 + -0x40) + 0x18 + iVar3;
            *(int *)((int)register0x00000010 + -0x44) =
                 *(int *)((int)register0x00000010 + -0x1c) * 4 + 0x5f5fa8;
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x431564;
            FUN_0040ecf0();
            **(int **)((int)register0x00000010 + -0x10) =
                 **(int **)((int)register0x00000010 + -0x10) + 1;
            **(int **)((int)register0x00000010 + -0x14) =
                 **(int **)((int)register0x00000010 + -0x14) +
                 *(int *)((int)register0x00000010 + 0xc);
            *(undefined4 *)((int)register0x00000010 + -0x44) =
                 *(undefined4 *)((int)register0x00000010 + -0x18);
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x431582;
            FUN_0040f0e0();
            *(undefined1 **)((int)register0x00000010 + -0xc) = &LAB_004315e0;
            *(undefined4 *)((int)register0x00000010 + -8) =
                 *(undefined4 *)((int)register0x00000010 + 8);
            *(undefined4 *)((int)register0x00000010 + -4) =
                 *(undefined4 *)((int)register0x00000010 + -0x20);
            *(undefined1 **)((int)register0x00000010 + -0x44) =
                 (undefined1 *)((int)register0x00000010 + -0xc);
            *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4315a8;
            FUN_0046d890();
            return;
          }
          *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4315ba;
          FUN_0046ee00();
        }
        *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4315c3;
        FUN_0046ee30();
      }
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0x4315c8;
      FUN_0046ee30();
    }
    *(undefined4 *)(puVar4 + -4) = 0x4315ce;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_00431610 */

void FUN_00431610(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x18);
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_005f5e1c;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x431636;
      FUN_00402510();
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43164a;
      FUN_00430e60();
      iVar3 = (*(uint *)((int)register0x00000010 + -0x10) >> 1) +
              (((*(uint *)((int)register0x00000010 + -0x10) >> 1) + 1) / 3) * -3;
      uVar1 = iVar3 + 1;
      if (uVar1 < 3) {
        iVar2 = uVar1 * 0x10;
        iVar3 = iVar3 * 4 + 0x5f5fa4;
        *(int *)((int)register0x00000010 + -0xc) = iVar3;
        *(int *)((int)register0x00000010 + -4) =
             *(int *)((int)register0x00000010 + -0x14) + 0x14 + iVar2;
        *(int *)((int)register0x00000010 + -8) =
             *(int *)((int)register0x00000010 + -0x14) + 0x1c + iVar2;
        *(int *)((int)register0x00000010 + -0x18) = iVar3;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43169d;
        FUN_0040ecf0();
        **(int **)((int)register0x00000010 + -4) = **(int **)((int)register0x00000010 + -4) + 1;
        **(int **)((int)register0x00000010 + -8) =
             **(int **)((int)register0x00000010 + -8) + *(int *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4316bb;
        FUN_0040f0e0();
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4316c9;
      FUN_0046ee00();
    }
    *(undefined4 *)(puVar4 + -4) = 0x4316cf;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_004316e0 */

void FUN_004316e0(void)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  uint uVar9;
  uint uVar10;
  undefined1 *puVar11;
  int in_FS_OFFSET;
  
  do {
    puVar11 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar11 = (undefined1 *)((int)register0x00000010 + -0x24);
      if (DAT_005f625c == 0) {
        return;
      }
      iVar2 = *(int *)((int)register0x00000010 + 0x14);
      if (iVar2 < 7) {
        iVar3 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
        piVar1 = (int *)(*(int *)(iVar3 + 0x18) + 0x7c);
        *piVar1 = *piVar1 + 1;
        iVar4 = *(int *)(iVar3 + 0x18);
        *(int *)((int)register0x00000010 + -4) = iVar4;
        iVar5 = *(int *)(iVar4 + 0x50);
        if ((iVar5 == 0) || (iVar3 == iVar5)) {
          uVar6 = *(undefined4 *)(iVar4 + 0x178);
          uVar7 = *(undefined4 *)(iVar4 + 0x17c);
          uVar8 = *(undefined4 *)(iVar4 + 0x180);
          *(int *)((int)register0x00000010 + -0x24) = iVar2;
          *(undefined4 *)((int)register0x00000010 + -0x20) = uVar6;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar7;
          *(undefined4 *)((int)register0x00000010 + -0x18) = uVar8;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x43178c;
          FUN_0046d1d0();
          uVar10 = *(uint *)((int)register0x00000010 + -0x14);
        }
        else {
          uVar6 = *(undefined4 *)(iVar4 + 0x17c);
          uVar7 = *(undefined4 *)(iVar4 + 0x180);
          uVar8 = *(undefined4 *)(iVar4 + 0x178);
          *(int *)((int)register0x00000010 + -0x24) = iVar5;
          *(int *)((int)register0x00000010 + -0x20) = iVar2;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar8;
          *(undefined4 *)((int)register0x00000010 + -0x18) = uVar6;
          *(undefined4 *)((int)register0x00000010 + -0x14) = uVar7;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x431760;
          FUN_0045b670();
          uVar10 = *(uint *)((int)register0x00000010 + -0x10);
        }
        uVar9 = *(uint *)(*(int *)((int)register0x00000010 + -4) + 0x180);
        if (uVar10 <= uVar9) {
          uVar6 = *(undefined4 *)(*(int *)((int)register0x00000010 + -4) + 0x178);
          *(undefined4 *)((int)register0x00000010 + -0x24) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x20) =
               *(undefined4 *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0x1c) =
               *(undefined4 *)((int)register0x00000010 + 0xc);
          *(undefined4 *)((int)register0x00000010 + -0x18) =
               *(undefined4 *)((int)register0x00000010 + 0x10);
          *(undefined4 *)((int)register0x00000010 + -0x14) = uVar6;
          *(uint *)((int)register0x00000010 + -0x10) = uVar10;
          *(uint *)((int)register0x00000010 + -0xc) = uVar9;
          *(undefined4 *)((int)register0x00000010 + -8) =
               *(undefined4 *)((int)register0x00000010 + 0x18);
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x4317dc;
          FUN_00432130();
          iVar2 = *(int *)(*(int *)((int)register0x00000010 + -4) + 0x7c);
          iVar3 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
          *(int *)(*(int *)((int)register0x00000010 + -4) + 0x7c) = iVar2 + -1;
          if ((iVar2 == 1) && (*(char *)(iVar3 + 0x69) != '\0')) {
            *(undefined4 *)(iVar3 + 8) = 0xfffffade;
          }
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x431818;
        FUN_0046ee30();
      }
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x43181d;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x24) =
           "requested skip=bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0xf;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x431833;
      FUN_0043b060();
      *(int *)((int)register0x00000010 + -0x24) = *(int *)((int)register0x00000010 + 0x14);
      *(int *)((int)register0x00000010 + -0x20) = *(int *)((int)register0x00000010 + 0x14) >> 0x1f;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x431846;
      FUN_0043ae80();
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x43184b;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x24) = &DAT_004c5c10;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x12;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x431861;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar11 + -4) = 0x431867;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar11;
  } while( true );
}



/* Function: FUN_00431870 */

void FUN_00431870(int param_1)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int in_FS_OFFSET;
  int iVar4;
  uint in_stack_ffffffe4;
  undefined4 uVar5;
  int in_stack_ffffffe8;
  int local_10;
  int local_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_004027a0(&DAT_005f5f00);
  *(undefined4 *)(param_1 + 4) = 8;
  *(undefined4 *)(param_1 + 8) = 0;
  if ((in_stack_ffffffe8 != 0 || in_stack_ffffffe4 != 0) &&
     (in_stack_ffffffe4 < 8 && in_stack_ffffffe8 == 0 || in_stack_ffffffe8 < 0)) {
    *(uint *)(param_1 + 4) = in_stack_ffffffe4;
    *(int *)(param_1 + 8) = in_stack_ffffffe8;
  }
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  uVar2 = *(uint *)(iVar1 + 0x45c);
  uVar3 = *(uint *)(iVar1 + 0x458) ^ *(uint *)(iVar1 + 0x458) << 0x11;
  uVar3 = uVar2 >> 0x10 ^ uVar3 >> 7 ^ uVar2 ^ uVar3;
  iVar4 = uVar2 + uVar3;
  *(uint *)(iVar1 + 0x458) = uVar2;
  *(uint *)(iVar1 + 0x45c) = uVar3;
  uVar5 = 0;
  FUN_00464ef0(iVar4,0,*(undefined4 *)(param_1 + 4),*(undefined4 *)(param_1 + 8));
  if (local_10 == 0 && local_c == 0) {
    FUN_0046fa70();
    *(int *)(param_1 + 0xc) = iVar4;
    *(undefined4 *)(param_1 + 0x10) = uVar5;
  }
  if (in_stack_ffffffe4 != 0 && in_stack_ffffffe8 == 0 || 0 < in_stack_ffffffe8) {
    iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
    uVar2 = *(uint *)(iVar1 + 0x45c);
    uVar3 = *(uint *)(iVar1 + 0x458) ^ *(uint *)(iVar1 + 0x458) << 0x11;
    uVar3 = uVar2 >> 0x10 ^ uVar3 >> 7 ^ uVar2 ^ uVar3;
    iVar4 = uVar2 + uVar3;
    *(uint *)(iVar1 + 0x458) = uVar2;
    *(uint *)(iVar1 + 0x45c) = uVar3;
    uVar5 = 0;
    FUN_00464ef0(iVar4,0,in_stack_ffffffe4,in_stack_ffffffe8);
    if (local_10 == 0 && local_c == 0) {
      FUN_0046ebf0();
      *(int *)(param_1 + 0x14) = iVar4;
      *(undefined4 *)(param_1 + 0x18) = uVar5;
    }
  }
  return;
}



/* Function: FUN_00431a50 */

void FUN_00431a50(undefined4 *param_1)

{
  int iVar1;
  int iVar2;
  long lVar3;
  uint uVar4;
  uint uVar5;
  int in_FS_OFFSET;
  uint in_stack_ffffffe8;
  int in_stack_ffffffec;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar1 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  uVar4 = in_stack_ffffffe8;
  if (param_1[3] != 0 || param_1[4] != 0) {
    FUN_0046fa70();
    uVar4 = *(int *)(iVar1 + 0x18) + 0x148;
    uVar5 = in_stack_ffffffe8 - param_1[3];
    iVar2 = in_stack_ffffffec - param_1[4];
    lVar3 = (ulong)uVar5 * (ulong)(uint)param_1[1];
    in_stack_ffffffec = (int)lVar3;
    thunk_FUN_004026b0(uVar4,in_stack_ffffffec,
                       param_1[1] * (iVar2 - (uint)(in_stack_ffffffe8 < (uint)param_1[3])) +
                       (int)((ulong)lVar3 >> 0x20) + param_1[2] * uVar5);
  }
  if (param_1[5] != 0 || param_1[6] != 0) {
    FUN_0046ebf0();
    FUN_00431b50(*(int *)(iVar1 + 0x18) + 0x148,uVar4 - param_1[5],
                 (in_stack_ffffffec - param_1[6]) - (uint)(uVar4 < (uint)param_1[5]),*param_1);
  }
  return;
}



/* Function: FUN_00431b50 */

/* WARNING: Removing unreachable block (ram,0x00431c7a) */

void FUN_00431b50(int param_1,uint param_2,int param_3,int param_4)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_3 < 0) {
    param_3 = 0;
    param_2 = 0;
  }
  if (*(char *)(param_1 + 0x29) != '\0') {
    uVar1 = *(uint *)(param_1 + 0x20);
    *(uint *)(param_1 + 0x20) = uVar1 + param_2;
    *(uint *)(param_1 + 0x24) = *(int *)(param_1 + 0x24) + param_3 + (uint)CARRY4(uVar1,param_2);
    return;
  }
  if (*(int *)(param_1 + 0x14) == param_4) {
    uVar1 = *(uint *)(param_1 + 0x18);
    *(uint *)(param_1 + 0x18) = param_2 + uVar1;
    *(uint *)(param_1 + 0x1c) = param_3 + *(int *)(param_1 + 0x1c) + (uint)CARRY4(param_2,uVar1);
    return;
  }
  uVar1 = *(uint *)(param_1 + 0x18);
  iVar2 = *(int *)(param_1 + 0x1c);
  if (uVar1 != 0 && iVar2 == 0 || 0 < iVar2) {
    if (param_3 == 0 && param_2 == 0) {
      return;
    }
    FUN_0046a250();
    FUN_00464d10();
    FUN_0046a250();
    FUN_00464d10();
    uVar3 = *(uint *)(param_1 + 0x20);
    *(uint *)(param_1 + 0x20) = uVar1 + uVar3;
    *(uint *)(param_1 + 0x24) = iVar2 + *(int *)(param_1 + 0x24) + (uint)CARRY4(uVar1,uVar3);
  }
  *(int *)(param_1 + 0x14) = param_4;
  *(uint *)(param_1 + 0x18) = param_2;
  *(int *)(param_1 + 0x1c) = param_3;
  return;
}



/* Function: FUN_00431ce0 */

void FUN_00431ce0(int param_1,int param_2)

{
  int iVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (*(int *)(param_1 + 0x14) == param_2) {
    FUN_00431d40(param_1);
  }
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  if ((*(int *)(iVar1 + 0x7c) == 1) && (*(char *)(iVar1 + 0x170) != '\0')) {
    FUN_00431f60(param_1);
  }
  return;
}



/* Function: FUN_00431d40 */

void FUN_00431d40(void)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined4 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined4 *)((int)register0x00000010 + -0x28);
      if (DAT_005f625c == 0) {
        return;
      }
      iVar1 = *(int *)((int)register0x00000010 + 4);
      *(undefined4 *)(iVar1 + 0x14) = 0;
      *(undefined1 *)(iVar1 + 0x28) = 1;
      if (*(int *)(iVar1 + 0xc) != 0) {
        **(undefined4 **)(iVar1 + 8) = 0xffffffff;
        *(undefined **)((int)register0x00000010 + -0x28) = &DAT_005f6230;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x431d96;
        thunk_FUN_00402510();
        if (*(int *)((int)register0x00000010 + -0x24) == 0) {
          iVar1 = *(int *)((int)register0x00000010 + 4);
          if (1 < *(uint *)(iVar1 + 0xc)) {
            *(undefined **)(*(int *)(iVar1 + 8) + 4) = &DAT_00445d31;
            if (2 < *(uint *)(iVar1 + 0xc)) {
              *(undefined4 *)(*(int *)(iVar1 + 8) + 8) = 0;
              return;
            }
            goto LAB_00431e54;
          }
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0;
          uVar2 = **(undefined4 **)(in_FS_OFFSET + DAT_005f5ed0);
          *(undefined1 **)((int)register0x00000010 + -0x1c) = &LAB_00431e80;
          *(undefined4 *)((int)register0x00000010 + -0x18) = *(undefined4 *)register0x00000010;
          *(undefined4 **)((int)register0x00000010 + -0x14) =
               (undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -0x10) = uVar2;
          *(undefined4 **)((int)register0x00000010 + -0xc) =
               (undefined4 *)((int)register0x00000010 + -0x20);
          *(undefined4 *)((int)register0x00000010 + -8) = 3;
          *(undefined4 *)((int)register0x00000010 + -4) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 **)((int)register0x00000010 + -0x28) =
               (undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x431e2a;
          FUN_0046d890();
          uVar3 = *(uint *)((int)register0x00000010 + -0x20);
          uVar4 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0xc);
          if ((int)uVar4 <= (int)uVar3) {
            return;
          }
          if (uVar3 < uVar4) {
            *(undefined4 *)(*(int *)(*(int *)((int)register0x00000010 + 4) + 8) + uVar3 * 4) = 0;
            return;
          }
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x431e54;
          FUN_0046edf0();
LAB_00431e54:
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x431e5e;
          FUN_0046edf0();
        }
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x431e68;
        FUN_0046edf0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x2c) = 0x431e71;
      FUN_0046edf0();
    }
    *(undefined4 *)((int)puVar5 + -4) = 0x431e77;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00431f60 */

void FUN_00431f60(void)

{
  int *piVar1;
  int iVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  undefined1 *puVar9;
  int in_FS_OFFSET;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0x48);
      iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
      *piVar1 = *piVar1 + 1;
      *(undefined4 *)((int)register0x00000010 + -4) = *(undefined4 *)(iVar2 + 0x18);
      iVar2 = *(int *)((int)register0x00000010 + 4);
      *(undefined1 *)(iVar2 + 0x29) = 1;
      for (uVar7 = 0; uVar8 = DAT_005f625c, (int)uVar7 < (int)DAT_005f625c; uVar7 = uVar7 + 1) {
        if (*(uint *)(iVar2 + 0xc) <= uVar7) goto LAB_00432112;
        uVar8 = uVar7;
        if (*(int *)(*(int *)(iVar2 + 8) + uVar7 * 4) == 0) break;
      }
      *(uint *)((int)register0x00000010 + -0x24) = uVar8;
      *(undefined4 *)((int)register0x00000010 + -0x10) = *(undefined4 *)(iVar2 + 0x18);
      *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)(iVar2 + 0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x18) = *(undefined4 *)(iVar2 + 0x20);
      *(undefined4 *)((int)register0x00000010 + -0x14) = *(undefined4 *)(iVar2 + 0x24);
      *(undefined4 *)(iVar2 + 0x18) = 0;
      *(undefined4 *)(iVar2 + 0x1c) = 0;
      *(undefined4 *)(iVar2 + 0x20) = 0;
      *(undefined4 *)(iVar2 + 0x24) = 0;
      *(undefined1 *)(iVar2 + 0x28) = 0;
      *(undefined4 **)((int)register0x00000010 + -0x48) = &DAT_005f5f00;
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x43200e;
      FUN_004027a0();
      uVar7 = *(uint *)(*(int *)((int)register0x00000010 + 4) + 0x10);
      if (*(uint *)((int)register0x00000010 + -0x24) <= uVar7) {
        uVar3 = *(undefined4 *)((int)register0x00000010 + -0x44);
        *(undefined4 *)((int)register0x00000010 + -0x28) = uVar3;
        uVar4 = *(undefined4 *)((int)register0x00000010 + -0x40);
        *(undefined4 *)((int)register0x00000010 + -8) = uVar4;
        uVar5 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 8);
        *(undefined4 *)((int)register0x00000010 + -0x48) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x44) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x40) = uVar3;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = uVar4;
        *(undefined4 *)((int)register0x00000010 + -0x38) = uVar5;
        *(uint *)((int)register0x00000010 + -0x34) = *(uint *)((int)register0x00000010 + -0x24);
        *(uint *)((int)register0x00000010 + -0x30) = uVar7;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 3;
        *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x432064;
        FUN_00432130();
        iVar2 = *(int *)((int)register0x00000010 + -0x14);
        if (0 < iVar2 || iVar2 == 0 && *(int *)((int)register0x00000010 + -0x18) != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0xffffffff;
          *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_00445d31;
          *(int *)((int)register0x00000010 + -0x48) = *(int *)((int)register0x00000010 + -0x18);
          *(int *)((int)register0x00000010 + -0x44) = iVar2;
          *(undefined4 *)((int)register0x00000010 + -0x40) =
               *(undefined4 *)((int)register0x00000010 + -0x28);
          *(undefined4 *)((int)register0x00000010 + -0x3c) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined1 **)((int)register0x00000010 + -0x38) =
               (undefined1 *)((int)register0x00000010 + -0x20);
          *(undefined4 *)((int)register0x00000010 + -0x34) = 2;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 2;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 3;
          *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x4320d4;
          FUN_00432130();
        }
        *(undefined1 *)(*(int *)((int)register0x00000010 + 4) + 0x29) = 0;
        iVar2 = *(int *)(*(int *)((int)register0x00000010 + -4) + 0x7c);
        iVar6 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
        *(int *)(*(int *)((int)register0x00000010 + -4) + 0x7c) = iVar2 + -1;
        if ((iVar2 == 1) && (*(char *)(iVar6 + 0x69) != '\0')) {
          *(undefined4 *)(iVar6 + 8) = 0xfffffade;
        }
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x432112;
      FUN_0046ee30();
LAB_00432112:
      *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x432117;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar9 + -4) = 0x43211d;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
}



/* Function: FUN_00432130 */

void FUN_00432130(uint param_1,int param_2,uint param_3,int param_4,undefined4 param_5,
                 undefined4 param_6,undefined4 param_7,int param_8)

{
  double dVar1;
  uint uVar2;
  double dVar3;
  uint uVar4;
  int in_FS_OFFSET;
  double *pdVar5;
  undefined1 uVar6;
  undefined4 local_1c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  pdVar5 = (double *)0x0;
  uVar6 = 1;
  FUN_00430f10(param_8);
  FUN_00430eb0(local_1c);
  FUN_0040ecf0(&DAT_005f5e14);
  if ((param_8 == 2) && (param_2 < param_4 || param_4 == param_2 && param_1 < param_3)) {
    dVar1 = *pdVar5;
    FUN_00464a40(param_3,param_4,param_5,param_6,param_7,uVar6);
    dVar3 = (double)CONCAT44(param_6,param_5);
    FUN_00464a40(param_1,param_2);
    *pdVar5 = dVar3 / (double)CONCAT44(param_6,param_5) + dVar1;
    uVar2 = *(uint *)(pdVar5 + 1);
    *(uint *)(pdVar5 + 1) = param_3 + uVar2;
    *(uint *)((int)pdVar5 + 0xc) =
         param_4 + *(int *)((int)pdVar5 + 0xc) + (uint)CARRY4(param_3,uVar2);
  }
  else if (param_8 == 3) {
    dVar1 = *pdVar5;
    FUN_00464a40(param_3,param_4,param_5,param_6,param_7,uVar6);
    *pdVar5 = dVar1 + (double)CONCAT44(param_6,param_5);
    uVar2 = *(uint *)(pdVar5 + 1);
    uVar4 = (uint)((ulong)param_3 * (ulong)param_1);
    *(uint *)(pdVar5 + 1) = uVar4 + uVar2;
    *(uint *)((int)pdVar5 + 0xc) =
         (int)((ulong)param_3 * (ulong)param_1 >> 0x20) + param_4 * param_1 + param_2 * param_3 +
         *(int *)((int)pdVar5 + 0xc) + (uint)CARRY4(uVar4,uVar2);
  }
  else {
    *pdVar5 = DAT_00550bd4 + *pdVar5;
    uVar2 = *(uint *)(pdVar5 + 1);
    *(uint *)(pdVar5 + 1) = param_1 + uVar2;
    *(uint *)((int)pdVar5 + 0xc) =
         param_2 + *(int *)((int)pdVar5 + 0xc) + (uint)CARRY4(param_1,uVar2);
  }
  FUN_0040f0e0(&DAT_005f5e14);
  return;
}



/* Function: FUN_00432310 */

void FUN_00432310(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x14);
      if (*(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58) != 0) {
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
        *(undefined4 *)((int)register0x00000010 + -8) = 0;
        *(undefined ***)((int)register0x00000010 + -4) = &PTR_LAB_00536c2c;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x432366;
        FUN_00432390();
        return;
      }
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_004cc838;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x2c;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 4400000;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x432386;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00432390 */

void FUN_00432390(int param_1,undefined4 param_2,undefined4 param_3,char param_4,undefined4 *param_5
                 )

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int in_FS_OFFSET;
  int in_stack_ffffffec;
  undefined1 local_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00402510(param_1 + 0x4c);
  if (in_stack_ffffffec == 6) {
    return;
  }
  while( true ) {
    iVar4 = param_1 + 0xe8;
    FUN_00402510(iVar4);
    if (in_stack_ffffffec == 2) break;
    if (in_stack_ffffffec == 1) {
      (*(code *)*param_5)();
    }
    else {
      iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
      *piVar1 = *piVar1 + 1;
      iVar2 = *(int *)(iVar2 + 0x18);
      in_stack_ffffffec = 0;
      FUN_00402540(iVar4,0,1);
      if (local_c != '\0') {
        FUN_004324c0(param_1,param_2,param_3);
        in_stack_ffffffec = 2;
        FUN_00402770(iVar4);
        local_c = param_4;
      }
      iVar4 = *(int *)(iVar2 + 0x7c);
      iVar3 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      *(int *)(iVar2 + 0x7c) = iVar4 + -1;
      if ((iVar4 == 1) && (*(char *)(iVar3 + 0x69) != '\0')) {
        *(undefined4 *)(iVar3 + 8) = 0xfffffade;
      }
    }
  }
  return;
}



/* Function: FUN_004324c0 */

void FUN_004324c0(void)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  undefined1 *puVar4;
  undefined4 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x3c);
      *(undefined4 *)((int)register0x00000010 + -0x3c) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined1 *)((int)register0x00000010 + -0x38) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x4324e8;
      FUN_0045c260();
      if (*(char *)((int)register0x00000010 + -0x34) != '\0') {
        return;
      }
      *(int *)((int)register0x00000010 + -0x3c) = *(int *)((int)register0x00000010 + 4) + 0x4c;
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x432506;
      FUN_00402510();
      if (*(int *)((int)register0x00000010 + -0x38) != 2) {
        *(undefined **)((int)register0x00000010 + -0x3c) = &DAT_005d52c8;
        *(undefined4 *)((int)register0x00000010 + -0x38) = 1;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x43252f;
        thunk_FUN_004026b0();
        iVar2 = *(int *)((int)register0x00000010 + -0x30) + -1;
        if (DAT_005d52d4 <= iVar2) {
          return;
        }
        *(int *)((int)register0x00000010 + -0x28) = *(int *)((int)register0x00000010 + -0x30);
        *(int *)((int)register0x00000010 + -0x24) = iVar2;
        puVar5 = (undefined4 *)((int)register0x00000010 + -0x18);
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x432558;
        FUN_0046ef4a();
        *(undefined1 **)((int)register0x00000010 + -0x18) = &LAB_00432660;
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + -0x24);
        *(undefined4 *)((int)register0x00000010 + -8) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -4) =
             *(undefined4 *)((int)register0x00000010 + 0x10);
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined1 **)((int)register0x00000010 + -0x3c) =
             (undefined1 *)((int)register0x00000010 + -0x18);
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x432596;
        FUN_0046d890();
        if (DAT_005d52dc == 0) {
          return;
        }
        if (*(uint *)((int)register0x00000010 + -0x24) < DAT_005d52e0) {
          uVar3 = *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0xd4);
          iVar2 = DAT_005d52dc;
          if (DAT_005f5fd0 == 0) {
            iVar1 = *(int *)((int)register0x00000010 + -0x28);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x40) = 0x4325cd;
            FUN_0046ed80();
            *puVar5 = uVar3;
            iVar1 = *(int *)((int)register0x00000010 + -0x28);
            puVar5[1] = *(undefined4 *)(iVar2 + -4 + iVar1 * 4);
          }
          *(undefined4 *)(iVar2 + -4 + iVar1 * 4) = uVar3;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x40) = 0x4325ed;
        FUN_0046edf0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x54);
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)(*(int *)((int)register0x00000010 + 4) + 0x58);
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x432604;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x3c) =
           "doRecordGoroutineProfile gp1=NtCreateWaitCompletionPacket";
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x1d;
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x43261a;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x3c) =
           *(undefined4 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x38) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x43262e;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x432633;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x432638;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x3c) =
           "cannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x26;
      *(undefined4 *)((int)register0x00000010 + -0x40) = 0x43264e;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x432654;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_004326e0 */

void FUN_004326e0(undefined4 param_1,undefined4 param_2,undefined4 param_3,int *param_4,int param_5,
                 int param_6,int param_7)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int in_FS_OFFSET;
  int in_stack_ffffffb4;
  int local_44;
  int local_40 [12];
  int local_10;
  int local_c;
  int local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x432822;
    FUN_0046d980();
  }
  local_8 = param_6;
  local_c = param_7;
  if (param_5 == 0) {
    param_5 = in_stack_ffffffb4;
    FUN_0046a780(&DAT_004ae1a0,DAT_005f625c,DAT_005f625c);
    local_8 = DAT_005f625c;
    local_c = DAT_005f625c;
  }
  piVar3 = local_40;
  local_4 = param_5;
  FUN_0046ef44();
  local_44 = CONCAT31(local_44._1_3_,2);
  FUN_00458b40(local_40,param_1,param_2,0,param_3);
  iVar1 = local_8;
  FUN_00459600(local_40,0,local_4,local_8,local_c);
  local_10 = local_44;
  FUN_0046a780(&DAT_004ae1a0,local_44,local_44);
  param_4[1] = local_10;
  param_4[2] = local_10;
  iVar2 = local_10;
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *piVar3 = iVar1;
    piVar3[1] = *param_4;
  }
  *param_4 = iVar1;
  iVar1 = local_8;
  if (iVar2 <= local_8) {
    iVar1 = iVar2;
  }
  if (local_4 != *param_4) {
    FUN_0046f640(*param_4,local_4,iVar1 << 2);
  }
  return;
}



/* Function: FUN_00432830 */

/* WARNING: Removing unreachable block (ram,0x00432865) */

void FUN_00432830(void)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  return;
}



/* Function: FUN_00432890 */

void FUN_00432890(undefined4 param_1)

{
  int in_FS_OFFSET;
  undefined4 local_10;
  undefined1 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = -0x13;
    FUN_0046d980();
  }
  do {
    thunk_FUN_004027a0(param_1);
    if (local_10 < 0) {
      return;
    }
    thunk_FUN_00402640(param_1);
  } while (local_4 == '\0');
  return;
}



/* Function: FUN_004328f0 */

void FUN_004328f0(undefined4 param_1,uint param_2)

{
  int in_FS_OFFSET;
  undefined4 local_14;
  undefined4 local_10;
  undefined1 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = '^';
    FUN_0046d980();
  }
  do {
    thunk_FUN_004027a0(param_1);
    if (local_10 < 0 || local_10 == 0 && local_14 < param_2) {
      return;
    }
    thunk_FUN_00402640(param_1);
  } while (local_4 == '\0');
  return;
}



/* Function: FUN_00432960 */

void FUN_00432960(undefined4 param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  thunk_FUN_004027a0(param_1);
  return;
}



/* Function: FUN_004329b0 */

void FUN_004329b0(undefined4 *param_1,undefined4 param_2)

{
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x432a2f;
    FUN_0046d980();
  }
  param_1[1] = 0;
  param_1[2] = 0x10;
  FUN_004119f0(0x80,4,param_2);
  *param_1 = local_4;
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = param_2;
    in_EDI[1] = param_1[4];
  }
  param_1[4] = param_2;
  param_1[3] = 0;
  return;
}



/* Function: FUN_00432a40 */

void FUN_00432a40(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  undefined1 *puVar6;
  uint uVar7;
  uint uVar8;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0xc);
      uVar1 = (*(int **)((int)register0x00000010 + 4))[1];
      iVar5 = **(int **)((int)register0x00000010 + 4);
      *(int *)((int)register0x00000010 + -4) = iVar5;
      uVar2 = *(uint *)((int)register0x00000010 + 8);
      uVar7 = 0;
      uVar4 = uVar1;
      while (8 < (int)(uVar4 - uVar7)) {
        uVar8 = uVar7 + uVar4 >> 1;
        if (uVar1 <= uVar8) goto LAB_00432ad9;
        uVar3 = *(uint *)(iVar5 + uVar8 * 8);
        if ((uVar3 <= uVar2) && (uVar2 < *(uint *)(iVar5 + uVar8 * 8 + 4))) {
          *(uint *)((int)register0x00000010 + 0xc) = uVar8 + 1;
          return;
        }
        if (uVar3 <= uVar2) {
          uVar7 = uVar8 + 1;
          uVar8 = uVar4;
        }
        uVar4 = uVar8;
        iVar5 = *(int *)((int)register0x00000010 + -4);
      }
      while( true ) {
        if ((int)uVar4 <= (int)uVar7) {
          *(uint *)((int)register0x00000010 + 0xc) = uVar4;
          return;
        }
        if (uVar1 <= uVar7) break;
        if (uVar2 < *(uint *)(iVar5 + uVar7 * 8)) {
          *(uint *)((int)register0x00000010 + 0xc) = uVar7;
          return;
        }
        uVar7 = uVar7 + 1;
      }
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x432ad9;
      FUN_0046edf0();
LAB_00432ad9:
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x432ae2;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar6 + -4) = 0x432ae8;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_00432af0 */

void FUN_00432af0(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)((int)register0x00000010 + 4)
      ;
      *(undefined4 *)((int)register0x00000010 + -8) = *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x432b1b;
      FUN_00432a40();
      iVar1 = *(int *)((int)register0x00000010 + -4);
      if (iVar1 == 0) {
        if ((*(undefined4 **)((int)register0x00000010 + 4))[1] != 0) {
          *(undefined4 *)((int)register0x00000010 + 0xc) =
               *(undefined4 *)**(undefined4 **)((int)register0x00000010 + 4);
          *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
          return;
        }
      }
      else {
        uVar2 = (*(int **)((int)register0x00000010 + 4))[1];
        if (iVar1 - 1U < uVar2) {
          iVar3 = **(int **)((int)register0x00000010 + 4);
          uVar4 = *(uint *)((int)register0x00000010 + 8);
          if ((*(uint *)(iVar3 + -8 + iVar1 * 8) <= uVar4) &&
             (uVar4 < *(uint *)(iVar3 + iVar1 * 8 + -4))) {
            *(uint *)((int)register0x00000010 + 0xc) = uVar4;
            *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
            return;
          }
          if (iVar1 < (int)uVar2) {
            *(undefined4 *)((int)register0x00000010 + 0xc) = *(undefined4 *)(iVar3 + iVar1 * 8);
            *(undefined1 *)((int)register0x00000010 + 0x10) = 1;
            return;
          }
          *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
          *(undefined1 *)((int)register0x00000010 + 0x10) = 0;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x432ba1;
        FUN_0046edf0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x432baa;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar5 + -4) = 0x432bb0;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_00432bc0 */

void FUN_00432bc0(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int *piVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  undefined1 *puVar10;
  int in_FS_OFFSET;
  bool bVar11;
  bool bVar12;
  
  do {
    puVar10 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar10 = (undefined1 *)((int)register0x00000010 + -0x20);
      uVar2 = *(uint *)((int)register0x00000010 + 8);
      if (uVar2 < *(uint *)((int)register0x00000010 + 0xc)) {
        iVar4 = *(uint *)((int)register0x00000010 + 0xc) - uVar2;
      }
      else {
        iVar4 = 0;
      }
      if (iVar4 != 0) {
        *(undefined4 *)((int)register0x00000010 + -0x20) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(uint *)((int)register0x00000010 + -0x1c) = uVar2;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432c06;
        FUN_00432a40();
        uVar2 = *(uint *)((int)register0x00000010 + -0x18);
        if ((int)uVar2 < 1) {
          piVar6 = *(int **)((int)register0x00000010 + 4);
          uVar3 = *(uint *)((int)register0x00000010 + 8);
          bVar11 = false;
LAB_00432c40:
          uVar1 = piVar6[1];
          iVar4 = *piVar6;
          if ((int)uVar2 < (int)uVar1) {
            if (uVar2 < uVar1) {
              uVar7 = *(uint *)((int)register0x00000010 + 0xc);
              bVar12 = *(uint *)(iVar4 + uVar2 * 8) == uVar7;
              goto LAB_00432c63;
            }
          }
          else {
            uVar7 = *(uint *)((int)register0x00000010 + 0xc);
            bVar12 = false;
LAB_00432c63:
            if (bVar12) {
              if (!bVar11) {
LAB_00432d5c:
                if (bVar12) {
                  if (uVar2 < uVar1) {
                    *(uint *)(iVar4 + uVar2 * 8) = uVar3;
                    bVar11 = uVar3 < uVar7;
                    piVar6 = *(int **)((int)register0x00000010 + 4);
                    goto LAB_00432f08;
                  }
                }
                else {
                  *(uint *)((int)register0x00000010 + -0x10) = uVar2;
                  *(int *)((int)register0x00000010 + -4) = iVar4;
                  piVar6 = *(int **)((int)register0x00000010 + 4);
                  uVar7 = piVar6[2];
                  uVar3 = uVar1 + 1;
                  if ((int)uVar7 < (int)uVar3) {
                    *(uint *)((int)register0x00000010 + -8) = uVar7;
                    *(uint *)((int)register0x00000010 + -0xc) = uVar1;
                    piVar6[1] = uVar3;
                    piVar6[2] = uVar7 << 1;
                    iVar4 = piVar6[4];
                    *(uint *)((int)register0x00000010 + -0x20) = uVar7 << 4;
                    *(undefined4 *)((int)register0x00000010 + -0x1c) = 4;
                    *(int *)((int)register0x00000010 + -0x18) = iVar4;
                    *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432e35;
                    FUN_004119f0();
                    iVar4 = *(int *)((int)register0x00000010 + -0x14);
                    piVar6 = *(int **)((int)register0x00000010 + 4);
                    *piVar6 = iVar4;
                    uVar2 = *(uint *)((int)register0x00000010 + -0x10);
                    if (uVar2 <= (uint)piVar6[2]) {
                      uVar3 = *(uint *)((int)register0x00000010 + -8);
                      if (uVar2 <= uVar3) {
                        iVar8 = *(int *)((int)register0x00000010 + -4);
                        if (iVar4 != iVar8) {
                          *(int *)((int)register0x00000010 + -0x20) = iVar4;
                          *(int *)((int)register0x00000010 + -0x1c) = iVar8;
                          *(uint *)((int)register0x00000010 + -0x18) = uVar2 << 3;
                          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432e75;
                          FUN_0046f640();
                          piVar6 = *(int **)((int)register0x00000010 + 4);
                          uVar3 = *(uint *)((int)register0x00000010 + -8);
                          uVar2 = *(uint *)((int)register0x00000010 + -0x10);
                          iVar8 = *(int *)((int)register0x00000010 + -4);
                        }
                        if (uVar2 + 1 <= (uint)piVar6[1]) {
                          iVar9 = (piVar6[1] - uVar2) + -1;
                          iVar4 = *piVar6 + ((int)-((piVar6[2] - uVar2) + -1) >> 0x1f &
                                            (uVar2 + 1) * 8);
                          iVar8 = ((int)-(uVar3 - uVar2) >> 0x1f & uVar2 << 3) + iVar8;
                          iVar5 = *(int *)((int)register0x00000010 + -0xc) - uVar2;
                          if (iVar9 <= (int)(*(int *)((int)register0x00000010 + -0xc) - uVar2)) {
                            iVar5 = iVar9;
                          }
                          if (iVar8 != iVar4) {
                            *(int *)((int)register0x00000010 + -0x20) = iVar4;
                            *(int *)((int)register0x00000010 + -0x1c) = iVar8;
                            *(int *)((int)register0x00000010 + -0x18) = iVar5 << 3;
                            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432ede;
                            FUN_0046f640();
                          }
                          uVar2 = *(uint *)((int)register0x00000010 + -0x10);
                          goto LAB_00432ee2;
                        }
LAB_00432f1d:
                        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f24;
                        FUN_0046ee50();
                      }
                      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f2b;
                      FUN_0046ee30();
                    }
                    *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f32;
                    FUN_0046ee30();
LAB_00432f32:
                    *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f39;
                    FUN_0046ee50();
LAB_00432f39:
                    *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f42;
                    FUN_0046ee50();
                  }
                  else if (uVar3 <= uVar7) {
                    piVar6[1] = uVar3;
                    if (uVar3 < uVar2 + 1) goto LAB_00432f39;
                    iVar8 = uVar1 - uVar2;
                    iVar4 = *piVar6 + ((int)-((piVar6[2] - uVar2) + -1) >> 0x1f & (uVar2 + 1) * 8);
                    if (uVar3 < uVar2) goto LAB_00432f32;
                    iVar9 = *piVar6 + ((int)-(piVar6[2] - uVar2) >> 0x1f & uVar2 << 3);
                    iVar5 = iVar8 + 1;
                    if (iVar8 <= iVar8 + 1) {
                      iVar5 = iVar8;
                    }
                    if (iVar9 != iVar4) {
                      *(int *)((int)register0x00000010 + -0x20) = iVar4;
                      *(int *)((int)register0x00000010 + -0x1c) = iVar9;
                      *(int *)((int)register0x00000010 + -0x18) = iVar5 << 3;
                      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432e00;
                      FUN_0046f640();
                      uVar2 = *(uint *)((int)register0x00000010 + -0x10);
                    }
LAB_00432ee2:
                    piVar6 = *(int **)((int)register0x00000010 + 4);
                    if ((uint)piVar6[1] <= uVar2) {
                      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f1d;
                      FUN_0046edf0();
                      goto LAB_00432f1d;
                    }
                    iVar4 = *piVar6;
                    uVar3 = *(uint *)((int)register0x00000010 + 8);
                    *(uint *)(iVar4 + uVar2 * 8) = uVar3;
                    uVar7 = *(uint *)((int)register0x00000010 + 0xc);
                    *(uint *)(iVar4 + 4 + uVar2 * 8) = uVar7;
                    bVar11 = uVar3 < uVar7;
                    goto LAB_00432f08;
                  }
                  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f49;
                  FUN_0046ee30();
                }
                *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f4e;
                FUN_0046edf0();
                goto LAB_00432f4e;
              }
              if (uVar2 < uVar1) {
                if (uVar1 <= uVar2 - 1) goto LAB_00432f66;
                *(undefined4 *)(iVar4 + -4 + uVar2 * 8) = *(undefined4 *)(iVar4 + 4 + uVar2 * 8);
                piVar6 = *(int **)((int)register0x00000010 + 4);
                uVar3 = piVar6[1];
                if (uVar3 < uVar2) goto LAB_00432f61;
                *(uint *)((int)register0x00000010 + -8) = uVar3;
                iVar4 = *piVar6;
                iVar8 = piVar6[2];
                *(uint *)((int)register0x00000010 + -0xc) = iVar8 - uVar2;
                iVar5 = uVar3 - uVar2;
                iVar8 = ((int)-(iVar8 - uVar2) >> 0x1f & uVar2 << 3) + iVar4;
                if (*(uint *)((int)register0x00000010 + -8) < uVar2 + 1) goto LAB_00432f5a;
                iVar4 = iVar4 + (-(*(int *)((int)register0x00000010 + -0xc) + -1) >> 0x1f &
                                (uVar2 + 1) * 8);
                iVar9 = iVar5 + -1;
                if (iVar5 <= iVar5 + -1) {
                  iVar9 = iVar5;
                }
                if (iVar4 != iVar8) {
                  *(int *)((int)register0x00000010 + -0x20) = iVar8;
                  *(int *)((int)register0x00000010 + -0x1c) = iVar4;
                  *(int *)((int)register0x00000010 + -0x18) = iVar9 << 3;
                  *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432d09;
                  FUN_0046f640();
                  piVar6 = *(int **)((int)register0x00000010 + 4);
                }
                if ((uint)piVar6[2] < piVar6[1] - 1U) goto LAB_00432f55;
                piVar6[1] = piVar6[1] - 1U;
                uVar3 = *(uint *)((int)register0x00000010 + 8);
                uVar7 = *(uint *)((int)register0x00000010 + 0xc);
                bVar11 = uVar3 < uVar7;
LAB_00432f08:
                if (bVar11) {
                  iVar4 = uVar7 - uVar3;
                }
                else {
                  iVar4 = 0;
                }
                piVar6[3] = piVar6[3] + iVar4;
                return;
              }
            }
            else {
              if (!bVar11) goto LAB_00432d5c;
              if (uVar2 - 1 < uVar1) {
                *(uint *)(iVar4 + -4 + uVar2 * 8) = uVar7;
                bVar11 = uVar3 < uVar7;
                piVar6 = *(int **)((int)register0x00000010 + 4);
                goto LAB_00432f08;
              }
LAB_00432f4e:
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f55;
              FUN_0046edf0();
LAB_00432f55:
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f5a;
              FUN_0046ee30();
LAB_00432f5a:
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f61;
              FUN_0046ee50();
LAB_00432f61:
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f66;
              FUN_0046ee50();
LAB_00432f66:
              *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f6d;
              FUN_0046edf0();
            }
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f72;
            FUN_0046edf0();
          }
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f77;
          FUN_0046edf0();
        }
        else {
          piVar6 = *(int **)((int)register0x00000010 + 4);
          if (uVar2 - 1 < (uint)piVar6[1]) {
            uVar3 = *(uint *)((int)register0x00000010 + 8);
            bVar11 = *(uint *)(*piVar6 + -4 + uVar2 * 8) == uVar3;
            goto LAB_00432c40;
          }
        }
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f7e;
        FUN_0046edf0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f83;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004c5c22;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x12;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432f99;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432fad;
      FUN_0043aef0();
      *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004c293a;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432fc3;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432fd7;
      FUN_0043aef0();
      *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004c2954;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432fed;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x432ff2;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004cc167;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x29;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x433008;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar10 + -4) = 0x43300e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar10;
  } while( true );
}



/* Function: FUN_00433020 */

void FUN_00433020(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  uint uVar5;
  undefined1 *puVar6;
  int *piVar7;
  int in_FS_OFFSET;
  
  do {
    puVar6 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar6 = (undefined1 *)((int)register0x00000010 + -0x10);
      piVar4 = *(int **)((int)register0x00000010 + 8);
      piVar7 = *(int **)((int)register0x00000010 + 4);
      if (piVar4[2] < piVar7[1]) {
        piVar4[1] = 0;
        iVar1 = piVar7[2];
        piVar4[2] = iVar1;
        iVar2 = piVar4[4];
        *(int *)((int)register0x00000010 + -0x10) = iVar1 << 3;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 4;
        *(int *)((int)register0x00000010 + -8) = iVar2;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x43306e;
        FUN_004119f0();
        piVar4 = *(int **)((int)register0x00000010 + 8);
        *piVar4 = *(int *)((int)register0x00000010 + -4);
        piVar7 = *(int **)((int)register0x00000010 + 4);
      }
      uVar3 = piVar7[1];
      if (uVar3 <= (uint)piVar4[2]) {
        piVar4[1] = uVar3;
        piVar4[3] = piVar7[3];
        uVar5 = piVar7[1];
        if ((int)uVar3 <= piVar7[1]) {
          uVar5 = uVar3;
        }
        iVar1 = *piVar7;
        if (iVar1 != *piVar4) {
          *(int *)((int)register0x00000010 + -0x10) = *piVar4;
          *(int *)((int)register0x00000010 + -0xc) = iVar1;
          *(uint *)((int)register0x00000010 + -8) = uVar5 << 3;
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4330b6;
          FUN_0046f640();
        }
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4330bf;
      FUN_0046ee30();
    }
    *(undefined4 *)(puVar6 + -4) = 0x4330c5;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar6;
  } while( true );
}



/* Function: FUN_004330d0 */

void FUN_004330d0(int param_1,undefined4 param_2)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int in_FS_OFFSET;
  uint in_stack_ffffffc8;
  uint local_30;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00433760(param_1 + 0x10);
  uVar1 = in_stack_ffffffc8 - 1;
  iVar3 = param_1 + 8;
  uVar2 = uVar1 >> 9;
  thunk_FUN_00402510(iVar3);
  uVar5 = in_stack_ffffffc8;
  do {
    if (uVar2 < in_stack_ffffffc8) {
      FUN_00402520(param_1 + 4);
      FUN_00402520(uVar5 + uVar2 * 4);
LAB_004332a0:
      FUN_00402760(uVar5 + 0x10 + (uVar1 & 0x1ff) * 4,param_2);
      return;
    }
    FUN_0040ecf0(param_1);
    in_stack_ffffffc8 = uVar5;
    thunk_FUN_00402510(iVar3);
    uVar5 = in_stack_ffffffc8;
    if (in_stack_ffffffc8 <= uVar2) {
      FUN_00402520(param_1 + 4);
      uVar6 = uVar5;
      if (in_stack_ffffffc8 == *(uint *)(param_1 + 0xc)) {
        iVar4 = *(uint *)(param_1 + 0xc) << 1;
        if (iVar4 == 0) {
          iVar4 = 0x100;
        }
        FUN_004119f0(iVar4 << 2,DAT_005cc2b8,&DAT_005f84f0);
        if (*(int *)(param_1 + 0xc) != 0) {
          FUN_0046f640(local_30,uVar5,*(int *)(param_1 + 0xc) << 2);
        }
        uVar5 = local_30;
        FUN_00402760(param_1 + 4,local_30);
        *(int *)(param_1 + 0xc) = iVar4;
        uVar6 = local_30;
      }
      FUN_004336a0(&DAT_005f5f08);
      FUN_00402760(uVar6 + uVar2 * 4);
      thunk_FUN_00402770(iVar3,in_stack_ffffffc8 + 1);
      FUN_0040f0e0(param_1);
      goto LAB_004332a0;
    }
    FUN_0040f0e0(param_1);
  } while( true );
}



/* Function: FUN_004332d0 */

void FUN_004332d0(int param_1)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  int in_FS_OFFSET;
  uint in_stack_ffffffbc;
  uint uVar5;
  uint in_stack_ffffffc0;
  char local_34;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  while( true ) {
    uVar5 = in_stack_ffffffc0;
    uVar4 = in_stack_ffffffbc;
    iVar2 = param_1 + 0x10;
    FUN_004027a0(iVar2);
    if (uVar4 <= uVar5) {
      return;
    }
    in_stack_ffffffbc = uVar4;
    in_stack_ffffffc0 = uVar5;
    thunk_FUN_00402510(param_1 + 8);
    uVar3 = uVar5;
    if (in_stack_ffffffbc <= uVar5 >> 9) break;
    while (uVar3 == uVar5) {
      in_stack_ffffffc0 = uVar3;
      FUN_00402640(iVar2,uVar4,uVar3,uVar4,uVar5 + 1);
      if (local_34 != '\0') {
        FUN_00402520(param_1 + 4);
        iVar2 = uVar4 + (uVar3 >> 9) * 4;
        FUN_00402520(iVar2);
        iVar1 = uVar4 + 0x10 + (uVar3 & 0x1ff) * 4;
        uVar5 = uVar4;
        FUN_00402520(iVar1);
        while (uVar5 == 0) {
          FUN_00402520(iVar1);
        }
        FUN_00402760(iVar1,0);
        FUN_00402690(uVar4 + 0xc,1);
        if (in_stack_ffffffc0 == 0x200) {
          FUN_00402760(iVar2,0);
          FUN_00433710(&DAT_005f5f08,uVar4);
        }
        return;
      }
      FUN_004027a0(iVar2);
      uVar3 = in_stack_ffffffc0;
      in_stack_ffffffbc = uVar4;
    }
  }
  return;
}



/* Function: FUN_004334b0 */

void FUN_004334b0(void)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  undefined1 *puVar4;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x2c);
      *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0x10;
      *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 4) + 0x10;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x4334dd;
      FUN_004027a0();
      pcVar2 = *(char **)((int)register0x00000010 + -0x28);
      pcVar3 = *(char **)((int)register0x00000010 + -0x24);
      if (pcVar2 <= pcVar3) {
        *(uint *)((int)register0x00000010 + -0x18) = (uint)pcVar3 >> 9;
        *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + 4) + 8;
        *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 4) + 8;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433507;
        thunk_FUN_00402510();
        if (*(uint *)((int)register0x00000010 + -0x28) <= *(uint *)((int)register0x00000010 + -0x18)
           ) goto code_r0x004335aa;
        *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 4) + 4;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433526;
        FUN_00402520();
        pcVar3 = *(char **)((int)register0x00000010 + -0x18);
        *(int *)((int)register0x00000010 + -0xc) =
             *(int *)((int)register0x00000010 + -0x28) + (int)pcVar3 * 4;
        *(int *)((int)register0x00000010 + -0x2c) =
             *(int *)((int)register0x00000010 + -0x28) + (int)pcVar3 * 4;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x43353f;
        FUN_00402520();
        iVar1 = *(int *)((int)register0x00000010 + -0x28);
        if (iVar1 == 0) goto code_r0x004335aa;
        *(int *)((int)register0x00000010 + -0x14) = iVar1;
        *(int *)((int)register0x00000010 + -0x10) = iVar1 + 0xc;
        *(int *)((int)register0x00000010 + -0x2c) = iVar1 + 0xc;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x43355a;
        FUN_00402510();
        if (*(int *)((int)register0x00000010 + -0x28) != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x2c) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433572;
          FUN_00402510();
          if (*(int *)((int)register0x00000010 + -0x28) != 0x200) {
            *(undefined4 *)((int)register0x00000010 + -0x2c) =
                 *(undefined4 *)((int)register0x00000010 + -0xc);
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433592;
            FUN_00402760();
            *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_005f5f08;
            *(undefined4 *)((int)register0x00000010 + -0x28) =
                 *(undefined4 *)((int)register0x00000010 + -0x14);
            *(undefined4 *)((int)register0x00000010 + -0x30) = 0x4335a8;
            FUN_00433710();
code_r0x004335aa:
            *(undefined4 *)((int)register0x00000010 + -0x2c) =
                 *(undefined4 *)((int)register0x00000010 + -4);
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x30) = 0x4335c6;
            FUN_004027c0();
            *(undefined4 *)((int)register0x00000010 + -0x2c) =
                 *(undefined4 *)((int)register0x00000010 + -8);
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x30) = 0x4335db;
            thunk_FUN_00402770();
            return;
          }
          *(char **)((int)register0x00000010 + -0x2c) =
               "fully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefaile..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0x31;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x4335f5;
          FUN_00469a20();
        }
        pcVar2 = 
        "span set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of has..." /* TRUNCATED STRING LITERAL */
        ;
        *(char **)((int)register0x00000010 + -0x2c) =
             "span set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of has..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0x34;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x43360b;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x1c) = pcVar3;
      *(char **)((int)register0x00000010 + -0x20) = pcVar2;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433618;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004c2f2a;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 7;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x43362e;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x2c) =
           *(undefined4 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433642;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004c33ae;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 9;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433658;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x2c) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x43366c;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433671;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433676;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x2c) =
           "attempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime:..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x28) = 0x23;
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x43368c;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar4 + -4) = 0x433692;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_004336a0 */

void FUN_004336a0(undefined4 param_1)

{
  int in_FS_OFFSET;
  int in_stack_fffffff4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040e520(param_1);
  if (in_stack_fffffff4 != 0) {
    return;
  }
  FUN_004119f0(0x810,DAT_005cc2b8,&DAT_005f84f0);
  return;
}



/* Function: FUN_00433710 */

void FUN_00433710(undefined4 param_1,int param_2)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_00402770(param_2 + 0xc,0);
  FUN_0040e4a0(param_1,param_2);
  return;
}



/* Function: FUN_00433760 */

void FUN_00433760(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x18);
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 1;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x433795;
      FUN_004026b0();
      if (*(int *)((int)register0x00000010 + -0xc) != 0) {
        *(int *)((int)register0x00000010 + 8) = *(int *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + 0xc) =
             *(undefined4 *)((int)register0x00000010 + -8);
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -4) = *(undefined4 *)((int)register0x00000010 + -8);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4337b6;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x18) = "runtime: head = timeBeginPeriod";
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x10;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4337cc;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x18) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4337e0;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c33ae;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 9;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4337f6;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43380a;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43380f;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x433814;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c73d8;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x16;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43382a;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x433830;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00433860 */

void FUN_00433860(undefined4 param_1,uint param_2,int param_3)

{
  code *pcVar1;
  int iVar2;
  uint local_10;
  int local_c;
  
  FUN_004026b0(param_1,param_2,param_3);
  if (((param_3 < 1 && (param_2 == 0 || param_3 != 0)) ||
      ((param_2 <= local_10 || param_3 != local_c) && (param_3 == local_c || param_3 < local_c))) &&
     ((-1 < param_3 ||
      (iVar2 = local_c + param_3 + (uint)CARRY4(local_10,param_2),
      (param_2 <= local_10 + param_2 || param_3 != iVar2) && (param_3 == iVar2 || param_3 < iVar2)))
     )) {
    return;
  }
  FUN_0043a810();
  FUN_0043b060("runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
               ,0xd);
  FUN_0043ad50(local_10,local_c);
  FUN_0043b060(&DAT_004c2a2f,3);
  FUN_0043ae80(param_2,param_3);
  FUN_0043aa10();
  FUN_0043a870();
  FUN_00469a20(&DAT_004c624e,0x13);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



/* Function: FUN_00433980 */

void FUN_00433980(int param_1)

{
  int iVar1;
  code *pcVar2;
  int in_FS_OFFSET;
  uint in_stack_fffffff4;
  uint local_8;
  
  iVar1 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
  if (iVar1 == 0) {
    FUN_0040ecf0(param_1 + 0xdcc);
  }
  else {
    in_stack_fffffff4 = 1;
    FUN_00402690(iVar1 + 0x1194);
    if ((local_8 & 1) == 0) goto LAB_00433a1a;
  }
  FUN_00402510(param_1 + 0xdc8);
  local_8 = in_stack_fffffff4 % 3;
  if (local_8 < 3) {
    return;
  }
  FUN_0046ee00();
LAB_00433a1a:
  FUN_0043a810();
  FUN_0043b060("runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
               ,0xd);
  FUN_0043ad50(local_8,0);
  FUN_0043aa10();
  FUN_0043a870();
  FUN_00469a20(&DAT_004c6261,0x13);
  pcVar2 = (code *)swi(3);
  (*pcVar2)();
  return;
}



/* Function: FUN_00433a70 */

void FUN_00433a70(int param_1)

{
  int iVar1;
  code *pcVar2;
  int in_FS_OFFSET;
  uint local_8;
  
  iVar1 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x58);
  if (iVar1 == 0) {
    FUN_0040f0e0(param_1 + 0xdcc);
  }
  else {
    FUN_00402690(iVar1 + 0x1194,1);
    if ((local_8 & 1) != 0) {
      FUN_0043a810();
      FUN_0043b060("runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read mem statsgcstoptheworldprofstackdepthtraceallocfreeGC assist waitfinalizer waitsync.Cond.Waits.allocCount= nil elem type! to finalizer GC worker initruntime: full=runtime: want=MB; allocated RtlGetVersion"
                   ,0xd);
      FUN_0043ad50(local_8,0);
      FUN_0043aa10();
      FUN_0043a870();
      FUN_00469a20(&DAT_004c6261,0x13);
      pcVar2 = (code *)swi(3);
      (*pcVar2)();
      return;
    }
  }
  return;
}



/* Function: FUN_00433b20 */

void FUN_00433b20(uint *param_1,uint param_2,int param_3,char param_4)

{
  long lVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  int in_FS_OFFSET;
  bool bVar9;
  uint local_40;
  int local_3c;
  uint local_28;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_4 == '\0') {
    local_28 = 0;
    iVar8 = 0;
  }
  else {
    thunk_FUN_004027a0(&DAT_005f6840);
    thunk_FUN_004027a0(&DAT_005f6848);
    thunk_FUN_004027a0(&DAT_005f6850);
    thunk_FUN_004027a0(&DAT_005f6858);
    local_28 = local_40;
    iVar8 = local_3c;
  }
  thunk_FUN_004027a0(&DAT_005f60b0);
  thunk_FUN_004027a0(&DAT_005f60b8);
  uVar2 = *param_1;
  *param_1 = uVar2 + local_28;
  param_1[1] = param_1[1] + iVar8 + (uint)CARRY4(uVar2,local_28);
  uVar2 = param_1[2];
  param_1[2] = uVar2 + local_28 * 2;
  param_1[3] = param_1[3] + iVar8 * 2 + (uint)CARRY4(local_28,local_28) +
               (uint)CARRY4(uVar2,local_28 * 2);
  uVar2 = param_1[4];
  param_1[4] = uVar2 + local_28;
  param_1[5] = param_1[5] + iVar8 + (uint)CARRY4(uVar2,local_28);
  uVar2 = param_1[8];
  param_1[8] = uVar2 + local_28 * 4;
  param_1[9] = iVar8 * 4 + (uint)CARRY4(local_28,local_28) + (uint)CARRY4(local_28,local_28 * 2) +
               (uint)CARRY4(local_28,local_28 * 3) + param_1[9] + (uint)CARRY4(uVar2,local_28 * 4);
  uVar2 = param_1[10];
  param_1[10] = uVar2 + local_40;
  param_1[0xb] = param_1[0xb] + local_3c + (uint)CARRY4(uVar2,local_40);
  uVar2 = param_1[0xc];
  param_1[0xc] = uVar2 + local_40;
  param_1[0xd] = param_1[0xd] + local_3c + (uint)CARRY4(uVar2,local_40);
  uVar2 = param_1[0xe];
  param_1[0xe] = uVar2 + local_40 * 2;
  param_1[0xf] = local_3c * 2 + (uint)CARRY4(local_40,local_40) + param_1[0xf] +
                 (uint)CARRY4(uVar2,local_40 * 2);
  iVar8 = DAT_005d85a4;
  iVar5 = (int)DAT_005f5e88 >> 0x1f;
  uVar3 = param_2 - DAT_005d8598;
  lVar1 = (ulong)uVar3 * (ulong)DAT_005f5e88;
  uVar2 = (uint)lVar1;
  iVar4 = ((param_3 - DAT_005d859c) - (uint)(param_2 < DAT_005d8598)) * DAT_005f5e88;
  bVar9 = CARRY4(uVar2,DAT_005d85a0);
  param_1[0x14] = uVar2 + DAT_005d85a0;
  param_1[0x15] = (int)((ulong)lVar1 >> 0x20) + iVar4 + iVar5 * uVar3 + iVar8 + (uint)bVar9;
  thunk_FUN_004027a0(&DAT_005d8ac0);
  uVar2 = param_1[0x10];
  uVar3 = uVar2 + local_40;
  param_1[0x10] = uVar3;
  uVar2 = param_1[0x11] + local_3c + (uint)CARRY4(uVar2,local_40);
  param_1[0x11] = uVar2;
  uVar6 = param_1[8] + param_1[0xe];
  uVar7 = uVar6 + uVar3;
  param_1[0x12] = param_1[0x14] - uVar7;
  param_1[0x13] =
       (param_1[0x15] -
       (param_1[9] + param_1[0xf] + (uint)CARRY4(param_1[8],param_1[0xe]) + uVar2 +
       (uint)CARRY4(uVar6,uVar3))) - (uint)(param_1[0x14] < uVar7);
  return;
}



/* Function: FUN_00433de0 */

void FUN_00433de0(int *param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  *param_1 = (int)(param_1 + 2);
  param_1[1] = (int)(param_1 + 0x202);
  return;
}



/* Function: FUN_00433e10 */

void FUN_00433e10(void)

{
  int iVar1;
  int in_FS_OFFSET;
  
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  if (0 < *(int *)(iVar1 + 0x80)) {
    iVar1 = *(int *)(iVar1 + 0x58);
    *(int *)(iVar1 + 0x988) = iVar1 + 0x990;
    return;
  }
  FUN_0046d890(&PTR_LAB_00536ca8);
  return;
}



/* Function: FUN_00433e50 */

void FUN_00433e50(void)

{
  uint uVar1;
  byte bVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  undefined1 *puVar7;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x2c);
      iVar3 = *(int *)((int)register0x00000010 + 4);
      uVar4 = (uint)(*(int *)(iVar3 + 0x988) - (iVar3 + 0x990)) >> 2;
      if (uVar4 < 0x201) {
        *(uint *)((int)register0x00000010 + -0xc) = uVar4;
        *(undefined4 *)(iVar3 + 0x988) = 0;
        if (DAT_005f5da9 != '\0') {
          iVar5 = 0;
          while (iVar5 < (int)uVar4) {
            *(int *)((int)register0x00000010 + -4) = iVar5;
            *(undefined4 *)((int)register0x00000010 + -0x2c) =
                 *(undefined4 *)(iVar3 + 0x990 + iVar5 * 4);
            *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433ebe;
            FUN_004202c0();
            iVar3 = *(int *)((int)register0x00000010 + 4);
            uVar4 = *(uint *)((int)register0x00000010 + -0xc);
            iVar5 = *(int *)((int)register0x00000010 + -4) + 1;
          }
          *(int *)((int)register0x00000010 + -0x2c) = iVar3 + 0x988;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433ede;
          FUN_00433de0();
          return;
        }
        uVar6 = 0;
        for (iVar5 = 0; iVar5 < (int)uVar4; iVar5 = iVar5 + 1) {
          uVar1 = *(uint *)(iVar3 + 0x990 + iVar5 * 4);
          if (0xfff < uVar1) {
            *(int *)((int)register0x00000010 + -4) = iVar5;
            *(uint *)((int)register0x00000010 + -0x10) = uVar6;
            *(uint *)((int)register0x00000010 + -0x2c) = uVar1;
            *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433f1a;
            FUN_004688e0();
            if (*(int *)((int)register0x00000010 + -0x20) == 0) {
              iVar3 = *(int *)((int)register0x00000010 + 4);
              uVar4 = *(uint *)((int)register0x00000010 + -0xc);
              iVar5 = *(int *)((int)register0x00000010 + -4);
              uVar6 = *(uint *)((int)register0x00000010 + -0x10);
            }
            else {
              iVar3 = *(int *)(*(int *)((int)register0x00000010 + -0x1c) + 0x2c);
              uVar4 = *(uint *)((int)register0x00000010 + -0x18) >> 3;
              bVar2 = (byte)(1 << ((byte)*(uint *)((int)register0x00000010 + -0x18) & 7));
              if ((bVar2 & *(byte *)(iVar3 + uVar4)) == 0) {
                *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + -0x20);
                *(int *)((int)register0x00000010 + -0x14) =
                     *(int *)((int)register0x00000010 + -0x1c);
                *(uint *)((int)register0x00000010 + -0x2c) = iVar3 + uVar4;
                *(byte *)((int)register0x00000010 + -0x28) = bVar2;
                *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433f8d;
                FUN_004027f0();
                iVar5 = *(int *)((int)register0x00000010 + -0x14);
                uVar4 = *(uint *)(iVar5 + 0xc);
                uVar6 = uVar4 >> 0x10 & 0x3f;
                iVar3 = *(int *)(DAT_005ddf14 + (uVar4 >> 0x16) * 4);
                bVar2 = (byte)(1 << ((byte)(uVar4 >> 0xd) & 7));
                if ((bVar2 & *(byte *)(iVar3 + 0x840 + uVar6)) == 0) {
                  *(uint *)((int)register0x00000010 + -0x2c) = iVar3 + 0x840 + uVar6;
                  *(byte *)((int)register0x00000010 + -0x28) = bVar2;
                  *(undefined4 *)((int)register0x00000010 + -0x30) = 0x433fe8;
                  FUN_004027f0();
                  iVar5 = *(int *)((int)register0x00000010 + -0x14);
                }
                if ((*(byte *)(iVar5 + 0x3e) & 1) == 0) {
                  uVar6 = *(uint *)((int)register0x00000010 + -0x10);
                  uVar4 = *(uint *)((int)register0x00000010 + -0xc);
                  if (uVar4 <= uVar6) goto LAB_0043409f;
                  iVar3 = *(int *)((int)register0x00000010 + 4);
                  *(undefined4 *)(iVar3 + 0x990 + uVar6 * 4) =
                       *(undefined4 *)((int)register0x00000010 + -8);
                  uVar6 = uVar6 + 1;
                  iVar5 = *(int *)((int)register0x00000010 + -4);
                }
                else {
                  iVar3 = *(int *)((int)register0x00000010 + 4);
                  uVar4 = *(uint *)(iVar3 + 0x974);
                  uVar6 = *(uint *)(iVar5 + 0x44);
                  *(uint *)(iVar3 + 0x974) = uVar4 + uVar6;
                  *(uint *)(iVar3 + 0x978) = *(int *)(iVar3 + 0x978) + (uint)CARRY4(uVar4,uVar6);
                  uVar4 = *(uint *)((int)register0x00000010 + -0xc);
                  iVar5 = *(int *)((int)register0x00000010 + -4);
                  uVar6 = *(uint *)((int)register0x00000010 + -0x10);
                }
              }
              else {
                iVar3 = *(int *)((int)register0x00000010 + 4);
                uVar4 = *(uint *)((int)register0x00000010 + -0xc);
                iVar5 = *(int *)((int)register0x00000010 + -4);
                uVar6 = *(uint *)((int)register0x00000010 + -0x10);
              }
            }
          }
        }
        if (uVar6 < 0x201) {
          *(int *)((int)register0x00000010 + -0x2c) = iVar3 + 0x96c;
          *(int *)((int)register0x00000010 + -0x28) = iVar3 + 0x990;
          *(uint *)((int)register0x00000010 + -0x24) = uVar6;
          *(undefined4 *)((int)register0x00000010 + -0x20) = 0x200;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x43407e;
          FUN_00428720();
          *(int *)((int)register0x00000010 + -0x2c) = *(int *)((int)register0x00000010 + 4) + 0x988;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x43408f;
          FUN_00433de0();
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x43409f;
        FUN_0046ee30();
LAB_0043409f:
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0x4340a4;
        FUN_0046edf0();
      }
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x4340ae;
      FUN_0046ee20();
    }
    *(undefined4 *)(puVar7 + -4) = 0x4340b4;
    FUN_0046afb0();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_004340c0 */

void FUN_004340c0(int param_1)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int in_FS_OFFSET;
  uint in_stack_ffffffec;
  undefined1 local_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar3 = (uint)*(byte *)(param_1 + 0x1c);
  if (*(int *)(param_1 + 100) < 0) {
    uVar3 = uVar3 | 4;
  }
  if (*(int *)(param_1 + 0xa8) < 0) {
    uVar3 = uVar3 | 8;
  }
  iVar1 = param_1 + 0xc;
  thunk_FUN_00402510(param_1 + 8);
  uVar2 = in_stack_ffffffec << 0x10;
  FUN_00402510(iVar1);
  while( true ) {
    FUN_00402540(iVar1,in_stack_ffffffec,in_stack_ffffffec & 2 | uVar3 | uVar2);
    if (local_c != '\0') break;
    FUN_00402510(iVar1);
  }
  return;
}



/* Function: FUN_00434270 */

void FUN_00434270(void)

{
  int in_FS_OFFSET;
  int in_stack_fffffffc;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    in_stack_fffffffc = 0x4342f4;
    FUN_0046d980();
  }
  FUN_00402510(&DAT_005f5e28);
  if (in_stack_fffffffc == 0) {
    FUN_0040ecf0(&DAT_005f5e24);
    FUN_00402510(&DAT_005f5e28);
    if (in_stack_fffffffc == 0) {
      FUN_00434980();
      FUN_00402770(&DAT_005f5e28,1);
    }
    FUN_0040f0e0(&DAT_005f5e24);
  }
  return;
}



/* Function: FUN_00434300 */

void FUN_00434300(int param_1,undefined4 *param_2)

{
  int in_FS_OFFSET;
  int in_stack_fffffff4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0040ecf0(param_2 + 6);
  thunk_FUN_00402510(param_2 + 2);
  thunk_FUN_00402770(param_2 + 2,in_stack_fffffff4 + 1);
  FUN_004340c0(param_2);
  FUN_0040f0e0(param_2 + 6);
  FUN_0040ecf0(param_1);
  *param_2 = *(undefined4 *)(param_1 + 4);
  *(undefined4 **)(param_1 + 4) = param_2;
  FUN_0040f0e0(param_1);
  return;
}



/* Function: FUN_004343b0 */

void FUN_004343b0(int *param_1,undefined4 param_2,int param_3)

{
  int in_FS_OFFSET;
  int local_c;
  undefined4 local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x43447f;
    FUN_0046d980();
  }
  local_8 = 0;
  if ((param_3 == 0x72) || (param_3 == 0xe9)) {
    FUN_00434790(param_2,0x72,1,&local_8);
    local_4 = local_c;
  }
  else {
    local_4 = 0;
  }
  if ((param_3 == 0x77) || (param_3 == 0xe9)) {
    FUN_00434790(param_2,0x77,1,&local_8);
  }
  else {
    local_c = 0;
  }
  if (local_4 != 0) {
    *(int *)(local_4 + 0x5c) = *param_1;
    *param_1 = local_4;
  }
  if (local_c != 0) {
    *(int *)(local_c + 0x5c) = *param_1;
    *param_1 = local_c;
  }
  return;
}



/* Function: FUN_004345a0 */

void FUN_004345a0(undefined4 param_1,int param_2)

{
  int in_FS_OFFSET;
  undefined1 *local_c;
  undefined4 local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x4345e3;
    FUN_0046d980();
  }
  local_4 = param_2 + 1;
  local_c = &LAB_004345f0;
  local_8 = param_1;
  FUN_0046d890(&local_c);
  return;
}



/* Function: FUN_00434790 */

void FUN_00434790(int param_1,int param_2,char param_3,int *param_4)

{
  int iVar1;
  int in_FS_OFFSET;
  int local_14;
  char local_c;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar1 = param_1 + 0x10;
  if (param_2 == 0x77) {
    iVar1 = param_1 + 0x14;
  }
  while( true ) {
    thunk_FUN_00402510(iVar1);
    if (local_14 == 1) {
      return;
    }
    if ((local_14 == 0) && (param_3 == '\0')) break;
    thunk_FUN_00402540(iVar1);
    if (local_c != '\0') {
      if ((local_14 != 2) && (local_14 != 0)) {
        *param_4 = *param_4 + -1;
      }
      return;
    }
  }
  return;
}



/* Function: FUN_00434980 */

void FUN_00434980(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x1c);
      *(code **)((int)register0x00000010 + -0x1c) = CreateIoCompletionPort_exref;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0xffffffff;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0xffffffff;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4349c5;
      FUN_00437120();
      DAT_005cc284 = *(int *)((int)register0x00000010 + -8);
      if (DAT_005cc284 != 0) {
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4349dc;
      FUN_0046f970();
      *(undefined4 *)((int)register0x00000010 + -4) =
           *(undefined4 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4349e8;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x1c) =
           "runtime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exite..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x2f;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x4349fe;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434a12;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c2a32;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 3;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434a28;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434a2d;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x1c) =
           "runtime: netpollinit failedruntime: asyncPreemptStack=runtime: thread ID overflowstopTheWorld: holding locksgcstopm: not waiting for gcruntime: checkdead: nmidle=runtime: checkdead: find g runlock of unlocked rwmutexsigsend: inconsistent statemakeslice: len out of rangemakeslice: cap out of rangegrowslice: len out of rangestack size not a power of 2too many callback functionstimer when must be positive: unexpected return pc for httpservecontentkeepheadersGetSecurityDescriptorControlInitializeSecurityDescriptorSetSecurityDescriptorControlCertCreateCertificateContextNotifyUnicastIpAddressChangeFindFirstChangeNotificationWGetFileInformationByHandleExGetProcessShutdownParametersSetProcessShutdownParametersWTSGetActiveConsoleSessionIdSetupDiClassGuidsFromNameExWSetupDiDestroyDeviceInfoListSetupDiDestroyDriverInfoListEvalSymlinks: too many linksCanada Central Standard TimeCen. Australia Standard TimeAus Central W. Standard TimeCentral Europe Standard TimeEnglish name for time zone \"file descriptor in bad statedestination address requiredprotocol driver not attachedGC mark assist wait for workcomparing uncomparable type region exceeds uintptr range/gc/heap/frees-by-size:bytes/gc/heap/tiny/allocs:objects/sched/goroutines:goroutinesgcBgMarkWorker: mode not setmspan.sweep: m is not lockedfound pointer to free objectmheap.freeSpanLocked - span runtime.semasleep unexpectedfatal: morestack on gsignal\nruntime: casgstatus: oldval=gcstopm: negative nmspinningfindrunnable: netpoll with psave on system g not allowednewproc1: newg missing stacknewproc1: new g is not GdeadFixedStack is not power-of-2missing stack in shrinkstack args stack map entries for invalid runtime symbol tableruntime: no module data for mismatched isSending updates[originating from goroutine traceRegion: alloc too largeMicrosoftUpdateProtectServersCM_Get_Device_Interface_ListWRegisterServiceCtrlHandlerExWDeleteProcThreadAttributeListGetSystemPreferredUILanguagesGetThreadPreferredUILanguagesGetVolumeInformationByHandleWSetupDiCancelDriverInfoSearchSetupDiGetCla..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x1b;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434a43;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x434a49;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00434ad0 */

void FUN_00434ad0(void)

{
  undefined1 *puVar1;
  int in_FS_OFFSET;
  
  do {
    puVar1 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar1 = (undefined1 *)((int)register0x00000010 + -0x1c);
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_005f5e2c;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 1;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434b05;
      FUN_00402540();
      if (*(char *)((int)register0x00000010 + -0x10) == '\0') {
        return;
      }
      *(code **)((int)register0x00000010 + -0x1c) = PostQueuedCompletionStatus_exref;
      *(undefined4 *)((int)register0x00000010 + -0x18) = DAT_005cc284;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 2;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434b47;
      FUN_00437120();
      if (*(int *)((int)register0x00000010 + -8) != 0) {
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434b58;
      FUN_0046f970();
      *(undefined4 *)((int)register0x00000010 + -4) =
           *(undefined4 *)((int)register0x00000010 + -0x1c);
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434b64;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x1c) =
           "runtime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x3c;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434b7a;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x1c) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434b8e;
      FUN_0043ad50();
      *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c2a32;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 3;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434ba4;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434ba9;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x1c) =
           "runtime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same ..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x33;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x434bbf;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar1 + -4) = 0x434bc5;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar1;
  } while( true );
}



/* Function: FUN_00434bd0 */

void FUN_00434bd0(void)

{
  undefined4 uVar1;
  undefined1 *puVar2;
  undefined *puVar3;
  int iVar4;
  int iVar5;
  code *pcVar6;
  undefined1 *puVar7;
  uint uVar8;
  undefined4 *puVar9;
  int in_FS_OFFSET;
  byte bVar10;
  bool bVar11;
  byte bVar12;
  
  bVar12 = 0;
code_r0x00434bd0:
  puVar7 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) <
      (undefined1 *)((int)register0x00000010 + -0x3cc)) {
    puVar7 = (undefined1 *)((int)register0x00000010 + -0x44c);
    if (DAT_005cc284 == -1) {
      *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
      *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
      return;
    }
    puVar9 = (undefined4 *)((int)register0x00000010 + -0x400);
    for (iVar4 = 0x100; iVar4 != 0; iVar4 = iVar4 + -1) {
      *puVar9 = 0;
      puVar9 = puVar9 + (uint)bVar12 * -2 + 1;
    }
    *(undefined4 *)((int)register0x00000010 + -0x428) = 0;
    iVar4 = *(int *)((int)register0x00000010 + 8);
    uVar8 = *(uint *)((int)register0x00000010 + 4);
    if (0xa4c67fff < uVar8 && iVar4 == 0x38d7e || 0x38d7e < iVar4) {
      uVar8 = 0xa4c68000;
      iVar4 = 0x38d7e;
    }
    *(uint *)((int)register0x00000010 + -0x408) = uVar8;
    *(int *)((int)register0x00000010 + -0x40c) = iVar4;
    iVar5 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
    *(int *)((int)register0x00000010 + -0x404) = iVar5;
    bVar10 = iVar4 == 0;
    *(byte *)((int)register0x00000010 + -0x429) = bVar10;
    if ((uVar8 == 0 || !(bool)bVar10) && iVar4 < 1) {
      bVar11 = iVar4 < 0;
    }
    else if (*(int *)(iVar5 + 0x324) == 0) {
      bVar11 = iVar4 < 0;
    }
    else {
      *(uint *)((int)register0x00000010 + -0x44c) = uVar8;
      *(int *)((int)register0x00000010 + -0x448) = iVar4;
      *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434ca3;
      FUN_00435070();
      if (*(char *)((int)register0x00000010 + -0x444) != '\0') {
        *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
        return;
      }
      bVar11 = *(int *)((int)register0x00000010 + -0x40c) < 0;
      iVar5 = *(int *)((int)register0x00000010 + -0x404);
      iVar4 = *(int *)((int)register0x00000010 + -0x40c);
      bVar10 = *(byte *)((int)register0x00000010 + -0x429);
      uVar8 = *(uint *)((int)register0x00000010 + -0x408);
    }
    if (bVar11) {
      uVar1 = 0xffffffff;
    }
    else if ((uVar8 == 0 & bVar10) == 0) {
      if ((uVar8 < 1000000 & bVar10) == 0 && -1 < iVar4) {
        *(uint *)((int)register0x00000010 + -0x44c) = uVar8;
        *(int *)((int)register0x00000010 + -0x448) = iVar4;
        *(undefined4 *)((int)register0x00000010 + -0x444) = 1000000;
        *(undefined4 *)((int)register0x00000010 + -0x440) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434d45;
        FUN_00464db0();
        uVar1 = *(undefined4 *)((int)register0x00000010 + -0x43c);
        iVar5 = *(int *)((int)register0x00000010 + -0x404);
        uVar8 = *(uint *)((int)register0x00000010 + -0x408);
      }
      else {
        uVar1 = 1;
      }
    }
    else {
      uVar1 = 0;
    }
    if (DAT_005f5e88 != 0) {
      iVar4 = (int)(0x40 / (long)DAT_005f5e88);
      *(int *)((int)register0x00000010 + -0x424) = iVar4;
      if (iVar4 < 8) {
        *(undefined4 *)((int)register0x00000010 + -0x424) = 8;
        iVar4 = *(int *)((int)register0x00000010 + -0x40c);
      }
      else {
        iVar4 = *(int *)((int)register0x00000010 + -0x40c);
      }
      if (iVar4 != 0 || uVar8 != 0) {
        *(undefined1 *)(iVar5 + 0x89) = 1;
      }
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x400);
      *(code **)((int)register0x00000010 + -0x44c) = GetQueuedCompletionStatusEx_exref;
      *(int *)((int)register0x00000010 + -0x448) = DAT_005cc284;
      *(undefined1 **)((int)register0x00000010 + -0x444) = puVar2;
      *(undefined4 *)((int)register0x00000010 + -0x440) =
           *(undefined4 *)((int)register0x00000010 + -0x424);
      *(undefined1 **)((int)register0x00000010 + -0x43c) =
           (undefined1 *)((int)register0x00000010 + -0x424);
      *(undefined4 *)((int)register0x00000010 + -0x438) = uVar1;
      *(undefined4 *)((int)register0x00000010 + -0x434) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434de2;
      pcVar6 = GetQueuedCompletionStatusEx_exref;
      FUN_004371c0();
      if (*(int *)((int)register0x00000010 + -0x430) == 0) {
        *(undefined1 *)(*(int *)((int)register0x00000010 + -0x404) + 0x89) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434e0e;
        FUN_0046f970();
        if (*(int *)((int)register0x00000010 + -0x44c) == 0x102) {
          *(undefined4 *)((int)register0x00000010 + 0xc) = 0;
          *(undefined4 *)((int)register0x00000010 + 0x10) = 0;
          return;
        }
        *(int *)((int)register0x00000010 + -0x418) = *(int *)((int)register0x00000010 + -0x44c);
        *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434e5b;
        FUN_0043a810();
        *(char **)((int)register0x00000010 + -0x44c) =
             "runtime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -0x448) = 0x34;
        *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434e71;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x44c) =
             *(undefined4 *)((int)register0x00000010 + -0x418);
        *(undefined4 *)((int)register0x00000010 + -0x448) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434e85;
        FUN_0043ad50();
        *(undefined **)((int)register0x00000010 + -0x44c) = &DAT_004c2a32;
        *(undefined4 *)((int)register0x00000010 + -0x448) = 3;
        *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434e9b;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434ea0;
        FUN_0043a870();
        *(undefined **)((int)register0x00000010 + -0x44c) = &DAT_004c7ab6;
        *(undefined4 *)((int)register0x00000010 + -0x448) = 0x17;
        *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434eb6;
        FUN_00469a20();
        goto LAB_00434eb6;
      }
      *(undefined1 *)(*(int *)((int)register0x00000010 + -0x404) + 0x89) = 0;
      puVar2 = (undefined1 *)0x0;
      pcVar6 = (code *)0x0;
      do {
        if (*(int *)((int)register0x00000010 + -0x424) <= (int)puVar2) {
          *(undefined4 *)((int)register0x00000010 + 0xc) =
               *(undefined4 *)((int)register0x00000010 + -0x428);
          *(code **)((int)register0x00000010 + 0x10) = pcVar6;
          return;
        }
        if (&DAT_0000003f < puVar2) goto LAB_00435055;
        *(undefined1 **)((int)register0x00000010 + -0x41c) = puVar2;
        *(code **)((int)register0x00000010 + -0x414) = pcVar6;
        uVar8 = *(uint *)((int)register0x00000010 + (int)puVar2 * 0x10 + -0x400);
        bVar10 = (byte)uVar8 & 0xf;
        if (bVar10 == 1) {
          iVar4 = *(int *)((int)register0x00000010 + (int)puVar2 * 0x10 + -0x3fc);
          if (iVar4 == 0) {
            iVar4 = 0;
          }
          else if (*(int *)(iVar4 + 0x14) << 4 != (uVar8 & 0xfffffff0)) {
            iVar4 = 0;
          }
          if (iVar4 != 0) {
            puVar3 = *(undefined **)(iVar4 + 0x18);
            if ((puVar3 != (undefined *)0x72) && (puVar3 != (undefined *)0x77)) goto LAB_00435003;
            uVar1 = *(undefined4 *)(iVar4 + 0x14);
            *(undefined1 **)((int)register0x00000010 + -0x44c) =
                 (undefined1 *)((int)register0x00000010 + -0x428);
            *(undefined4 *)((int)register0x00000010 + -0x448) = uVar1;
            *(undefined **)((int)register0x00000010 + -0x444) = puVar3;
            *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434f2e;
            FUN_004343b0();
            pcVar6 = (code *)(*(int *)((int)register0x00000010 + -0x414) +
                             *(int *)((int)register0x00000010 + -0x440));
            puVar2 = *(undefined1 **)((int)register0x00000010 + -0x41c);
          }
        }
        else if (bVar10 == 2) {
          *(byte *)((int)register0x00000010 + -0x42a) =
               *(int *)((int)register0x00000010 + -0x408) == 0 &
               *(byte *)((int)register0x00000010 + -0x429);
          *(undefined **)((int)register0x00000010 + -0x44c) = &DAT_005f5e2c;
          *(undefined4 *)((int)register0x00000010 + -0x448) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434f7c;
          FUN_00402770();
          if (*(char *)((int)register0x00000010 + -0x42a) != '\0') {
            *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434f8a;
            FUN_00434ad0();
          }
          puVar2 = *(undefined1 **)((int)register0x00000010 + -0x41c);
          pcVar6 = *(code **)((int)register0x00000010 + -0x414);
        }
        else if (bVar10 != 3) goto LAB_00434fb0;
LAB_00434eb6:
        puVar2 = puVar2 + 1;
      } while( true );
    }
    goto LAB_0043505f;
  }
  goto LAB_00435065;
LAB_00434fb0:
  *(uint *)((int)register0x00000010 + -0x410) = uVar8;
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434fb9;
  FUN_0043a810();
  *(char **)((int)register0x00000010 + -0x44c) =
       "runtime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
  ;
  *(undefined4 *)((int)register0x00000010 + -0x448) = 0x47;
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434fcf;
  FUN_0043b060();
  *(undefined4 *)((int)register0x00000010 + -0x44c) =
       *(undefined4 *)((int)register0x00000010 + -0x410);
  *(undefined4 *)((int)register0x00000010 + -0x448) = 0;
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434fe3;
  FUN_0043ad50();
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434fe8;
  FUN_0043aa10();
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x434fed;
  FUN_0043a870();
  puVar3 = &DAT_004c7ab6;
  *(undefined **)((int)register0x00000010 + -0x44c) = &DAT_004c7ab6;
  *(undefined4 *)((int)register0x00000010 + -0x448) = 0x17;
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x435003;
  FUN_00469a20();
LAB_00435003:
  *(undefined **)((int)register0x00000010 + -0x420) = puVar3;
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x43500c;
  FUN_0043a810();
  *(char **)((int)register0x00000010 + -0x44c) =
       "runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
  ;
  *(undefined4 *)((int)register0x00000010 + -0x448) = 0x48;
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x435022;
  FUN_0043b060();
  *(int *)((int)register0x00000010 + -0x44c) = *(int *)((int)register0x00000010 + -0x420);
  *(int *)((int)register0x00000010 + -0x448) = *(int *)((int)register0x00000010 + -0x420) >> 0x1f;
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x435035;
  FUN_0043ae80();
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x43503a;
  FUN_0043aa10();
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x43503f;
  FUN_0043a870();
  *(undefined **)((int)register0x00000010 + -0x44c) = &DAT_004c7ab6;
  *(undefined4 *)((int)register0x00000010 + -0x448) = 0x17;
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x435055;
  FUN_00469a20();
LAB_00435055:
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x43505f;
  FUN_0046edf0();
LAB_0043505f:
  *(undefined4 *)((int)register0x00000010 + -0x450) = 0x435064;
  FUN_00438080();
LAB_00435065:
  *(undefined4 *)(puVar7 + -4) = 0x43506a;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar7;
  goto code_r0x00434bd0;
}



/* Function: FUN_00435070 */

void FUN_00435070(void)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined *puVar4;
  undefined1 *puVar5;
  int in_FS_OFFSET;
  
  do {
    puVar5 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar5 = (undefined1 *)((int)register0x00000010 + -0x40);
      *(undefined1 *)((int)register0x00000010 + 0xc) = 0;
      iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
      *(int *)((int)register0x00000010 + -4) = iVar1;
      uVar2 = *(undefined4 *)(iVar1 + 0x324);
      *(undefined4 *)((int)register0x00000010 + -0x40) = DAT_005d6de4;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = uVar2;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 1;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4350be;
      FUN_00437080();
      puVar4 = *(undefined **)((int)register0x00000010 + -0x34);
      if (puVar4 == (undefined *)0x0) {
LAB_004350dc:
        *(int *)((int)register0x00000010 + -0x40) = -*(int *)((int)register0x00000010 + 4);
        *(uint *)((int)register0x00000010 + -0x3c) =
             -(uint)(*(int *)((int)register0x00000010 + 4) != 0) -
             *(int *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x38) = 100;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43510b;
        FUN_00464db0();
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + -0x30);
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + -0x2c);
        uVar2 = *(undefined4 *)(*(int *)((int)register0x00000010 + -4) + 800);
        *(code **)((int)register0x00000010 + -0x40) = SetWaitableTimer_exref;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = uVar2;
        *(undefined1 **)((int)register0x00000010 + -0x38) =
             (undefined1 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x2c) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43515f;
        FUN_004371c0();
        if (*(int *)((int)register0x00000010 + -0x24) != 0) {
          uVar2 = *(undefined4 *)(*(int *)((int)register0x00000010 + -4) + 0x324);
          uVar3 = *(undefined4 *)(*(int *)((int)register0x00000010 + -4) + 800);
          *(undefined4 *)((int)register0x00000010 + -0x40) = DAT_005d6de0;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = uVar2;
          *(undefined4 *)((int)register0x00000010 + -0x38) = DAT_005cc284;
          *(undefined4 *)((int)register0x00000010 + -0x34) = uVar3;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 3;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
          *(undefined1 **)((int)register0x00000010 + -0x20) =
               (undefined1 *)((int)register0x00000010 + 0xc);
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4351c8;
          FUN_00437260();
          if (*(int *)((int)register0x00000010 + -0x1c) == 0) {
            return;
          }
          *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4351dd;
          FUN_0043a810();
          *(char **)((int)register0x00000010 + -0x40) =
               "runtime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintptr-sized resultattempted to trace stack of a goroutine this thread does not ownuser arena chunk size is not a multiple of the physical page sizeruntime: function marked with #cgo nocallback called back into Goruntime.SetFinalizer: pointer not at beginning of allocated blockcasGToWaitingForSuspendG with non-isWaitingForSuspendG wait reasonruntime: GetQueuedCompletionStatusEx returned net_op with invalid key= too many concurrent operations on a single file or socket (max 1048575)runtime: GetQueuedCompletionStatusEx returned net_op with invalid mode= runtime.Goexit called in a thread that was not created by the Go runtimeNtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXP..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x38;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4351f3;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x40) =
               *(undefined4 *)((int)register0x00000010 + -0x18);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x435207;
          FUN_0043ad50();
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43520c;
          FUN_0043aa10();
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x435211;
          FUN_0043a870();
          *(undefined **)((int)register0x00000010 + -0x40) = &DAT_004c7ab6;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x17;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x435227;
          FUN_00469a20();
        }
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43522c;
        FUN_0046f970();
        *(undefined4 *)((int)register0x00000010 + -8) =
             *(undefined4 *)((int)register0x00000010 + -0x40);
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x435238;
        FUN_0043a810();
        *(undefined **)((int)register0x00000010 + -0x40) = &DAT_004cc1b9;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x29;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43524e;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x40) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x435262;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x435267;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43526c;
        FUN_0043a870();
        puVar4 = &DAT_004c7ab6;
        *(undefined **)((int)register0x00000010 + -0x40) = &DAT_004c7ab6;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x17;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x435282;
        FUN_00469a20();
      }
      else {
        if (puVar4 == (undefined *)0x103) {
          return;
        }
        if (puVar4 == (undefined *)0xc0000120) goto LAB_004350dc;
      }
      *(undefined **)((int)register0x00000010 + -0x14) = puVar4;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43528b;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x40) =
           "runtime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`runtime.SetFinalizer: first argument was allocated into an arenacompileCallback: expected function with one uintp..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x35;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4352a1;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x40) =
           *(undefined4 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4352b5;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4352ba;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4352bf;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x40) = &DAT_004c7ab6;
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x17;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x4352d5;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar5 + -4) = 0x4352db;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar5;
  } while( true );
}



/* Function: FUN_004352e0 */

void FUN_004352e0(void)

{
  uint uVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x10);
      uVar1 = *(uint *)((int)register0x00000010 + 0xc);
      if (uVar1 - 1 < uVar1) {
        if (*(char *)((uVar1 - 1) + *(int *)((int)register0x00000010 + 8)) == '\0') {
          *(code **)((int)register0x00000010 + -0x10) = GetProcAddress_exref;
          *(undefined4 *)((int)register0x00000010 + -0xc) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + 8);
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0x435325;
          FUN_00437080();
          *(undefined4 *)((int)register0x00000010 + 0x14) =
               *(undefined4 *)((int)register0x00000010 + -4);
          return;
        }
        *(undefined **)((int)register0x00000010 + -0x10) = &DAT_004c2c6e;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 5;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x435347;
        FUN_00469a20();
      }
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x43534c;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar2 + -4) = 0x435352;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00435360 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_00435360(void)

{
  uint uVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x10);
      *(code **)((int)register0x00000010 + -0x10) = GetSystemDirectoryA_exref;
      *(undefined **)((int)register0x00000010 + -0xc) = &DAT_005f6500;
      *(undefined4 *)((int)register0x00000010 + -8) = 0x104;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x435393;
      FUN_00437080();
      uVar1 = *(uint *)((int)register0x00000010 + -4);
      if ((uVar1 != 0) && (uVar1 < 0x105)) {
        (&DAT_005f6500)[uVar1] = 0x5c;
        _DAT_005f5e30 = uVar1 + 1;
        return;
      }
      *(char **)((int)register0x00000010 + -0x10) =
           "Unable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNoti..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x24;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4353cd;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x4353d3;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_004353e0 */

void FUN_004353e0(void)

{
  int iVar1;
  undefined1 *puVar2;
  int *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x18);
      *(code **)((int)register0x00000010 + -0x18) = LoadLibraryExW_exref;
      *(wchar16 **)((int)register0x00000010 + -0x14) = u_bcryptprimitives_dll_005cc5a0;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x800;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x435420;
      FUN_004370d0();
      if (*(int *)((int)register0x00000010 + -8) != 0) {
        *(int *)((int)register0x00000010 + -0x18) = *(int *)((int)register0x00000010 + -8);
        *(char **)((int)register0x00000010 + -0x14) = "ProcessPrng";
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0xc;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0xc;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43544e;
        FUN_004352e0();
        iVar1 = *(int *)((int)register0x00000010 + -8);
        if (DAT_005f5fd0 != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x435461;
          FUN_0046ed80();
          *in_EDI = iVar1;
          in_EDI[1] = DAT_005d6dd8;
        }
        *(code **)((int)register0x00000010 + -0x18) = LoadLibraryExW_exref;
        *(wchar16 **)((int)register0x00000010 + -0x14) = u_ntdll_dll_005cc4e0;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0x800;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43549b;
        DAT_005d6dd8 = iVar1;
        FUN_004370d0();
        iVar1 = *(int *)((int)register0x00000010 + -8);
        if (iVar1 != 0) {
          *(int *)((int)register0x00000010 + -4) = iVar1;
          *(int *)((int)register0x00000010 + -0x18) = iVar1;
          *(char **)((int)register0x00000010 + -0x14) = "NtCreateWaitCompletionPacket";
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0x1d;
          *(undefined4 *)((int)register0x00000010 + -0xc) = 0x1d;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4354cd;
          FUN_004352e0();
          iVar1 = *(int *)((int)register0x00000010 + -8);
          if (DAT_005f5fd0 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4354e0;
            FUN_0046ed80();
            *in_EDI = iVar1;
            in_EDI[1] = DAT_005d6ddc;
          }
          DAT_005d6ddc = iVar1;
          if (iVar1 == 0) {
LAB_0043559d:
            *(undefined4 *)((int)register0x00000010 + -0x18) =
                 *(undefined4 *)((int)register0x00000010 + -4);
            *(char **)((int)register0x00000010 + -0x14) = "RtlGetCurrentPeb";
            *(undefined4 *)((int)register0x00000010 + -0x10) = 0x11;
            *(undefined4 *)((int)register0x00000010 + -0xc) = 0x11;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4355c3;
            FUN_004352e0();
            iVar1 = *(int *)((int)register0x00000010 + -8);
            if (DAT_005f5fd0 != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x4355d6;
              FUN_0046ed80();
              *in_EDI = iVar1;
              in_EDI[1] = DAT_005d6de8;
            }
            *(undefined4 *)((int)register0x00000010 + -0x18) =
                 *(undefined4 *)((int)register0x00000010 + -4);
            *(char **)((int)register0x00000010 + -0x14) = "RtlGetVersion";
            *(undefined4 *)((int)register0x00000010 + -0x10) = 0xe;
            *(undefined4 *)((int)register0x00000010 + -0xc) = 0xe;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43560d;
            DAT_005d6de8 = iVar1;
            FUN_004352e0();
            iVar1 = *(int *)((int)register0x00000010 + -8);
            if (DAT_005f5fd0 != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x435620;
              FUN_0046ed80();
              *in_EDI = iVar1;
              in_EDI[1] = DAT_005d6dec;
            }
            DAT_005d6dec = iVar1;
            return;
          }
          *(undefined4 *)((int)register0x00000010 + -0x18) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(char **)((int)register0x00000010 + -0x14) = "NtAssociateWaitCompletionPacket";
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0x20;
          *(undefined4 *)((int)register0x00000010 + -0xc) = 0x20;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43551f;
          FUN_004352e0();
          iVar1 = *(int *)((int)register0x00000010 + -8);
          if (DAT_005f5fd0 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x435532;
            FUN_0046ed80();
            *in_EDI = iVar1;
            in_EDI[1] = DAT_005d6de0;
          }
          DAT_005d6de0 = iVar1;
          if (iVar1 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x18) =
                 *(undefined4 *)((int)register0x00000010 + -4);
            *(char **)((int)register0x00000010 + -0x14) = "NtCancelWaitCompletionPacket";
            *(undefined4 *)((int)register0x00000010 + -0x10) = 0x1d;
            *(undefined4 *)((int)register0x00000010 + -0xc) = 0x1d;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x435571;
            FUN_004352e0();
            iVar1 = *(int *)((int)register0x00000010 + -8);
            if (DAT_005f5fd0 != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x435584;
              FUN_0046ed80();
              *in_EDI = iVar1;
              in_EDI[1] = DAT_005d6de4;
            }
            DAT_005d6de4 = iVar1;
            if (iVar1 != 0) goto LAB_0043559d;
            *(char **)((int)register0x00000010 + -0x18) =
                 "NtCreateWaitCompletionPacket exists but NtCancelWaitCompletionPacket does notcannot convert slice with length %y to array or pointer to array with length %xNtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
            ;
            *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4d;
            *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43564b;
            FUN_00469a20();
          }
          *(char **)((int)register0x00000010 + -0x18) =
               "NtCreateWaitCompletionPacket exists but NtAssociateWaitCompletionPacket does not (bad use of unsafe.Pointer or having race conditions? try -d=checkptr or -race)\nexpected all size classes up to min size for malloc header to fit in one-page spanscgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."
          ;
          *(undefined4 *)((int)register0x00000010 + -0x14) = 0x50;
          *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x435661;
          FUN_00469a20();
        }
        *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004c6274;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x13;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x435677;
        FUN_00469a20();
      }
      *(undefined **)((int)register0x00000010 + -0x18) = &DAT_004ca124;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x1e;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x43568d;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x435693;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_004356a0 */

void FUN_004356a0(void)

{
  int in_FS_OFFSET;
  undefined4 uVar1;
  int local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  int local_c;
  undefined *local_8;
  undefined **local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (undefined **)0x435790;
    FUN_0046d980();
  }
  FUN_004370d0(LoadLibraryExW_exref,u_powrprof_dll_005cc540,0,0x800);
  if (local_1c != 0) {
    uVar1 = 0x27;
    FUN_004352e0(local_1c,"PowerRegisterSuspendResumeNotification",0x27,0x27);
    if (local_1c != 0) {
      local_c = local_1c;
      local_8 = &DAT_004af120;
      local_4 = &PTR_LAB_00536c18;
      FUN_0046bba0(&DAT_004af120,&PTR_LAB_00536c18,1);
      local_14 = 0;
      local_10 = 0;
      local_18 = uVar1;
      FUN_004370d0(local_c,2,&local_18,&local_10);
      return;
    }
    return;
  }
  return;
}



/* Function: FUN_004357a0 */

void FUN_004357a0(void)

{
  int iVar1;
  int iVar2;
  int in_FS_OFFSET;
  int local_30;
  undefined4 local_2c;
  uint local_28;
  undefined1 local_24 [32];
  undefined4 uStack_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    uStack_4 = 0x435857;
    FUN_0046d980();
  }
  local_28 = 0;
  local_2c = 0;
  FUN_004370d0(GetProcessAffinityMask_exref,0xffffffff,&local_28,&local_2c);
  if (local_30 != 0) {
    iVar2 = 0;
    for (iVar1 = 0; iVar1 < 0x20; iVar1 = iVar1 + 1) {
      if ((1 << ((byte)iVar1 & 0x1f) & local_28) != 0) {
        iVar2 = iVar2 + 1;
      }
    }
    if (iVar2 != 0) {
      return;
    }
  }
  FUN_0046ef47();
  FUN_00437030(GetSystemInfo_exref,local_24);
  return;
}



/* Function: FUN_00435860 */

void FUN_00435860(char param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (DAT_005f5dab == '\0') {
    if (param_1 != '\0') {
      FUN_00437030(DAT_005d6df4,1);
      return;
    }
    FUN_00437030(DAT_005d6df0,1);
    return;
  }
  return;
}



/* Function: FUN_004358e0 */

void FUN_004358e0(void)

{
  int iVar1;
  undefined1 *puVar2;
  int *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0x20);
      *(code **)((int)register0x00000010 + -0x20) = CreateWaitableTimerExW_exref;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x100003;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435926;
      FUN_00437120();
      if (*(int *)((int)register0x00000010 + -0xc) != 0) {
        DAT_005f5dab = 1;
        DAT_005f5dbb = DAT_005d6ddc != 0;
        *(code **)((int)register0x00000010 + -0x20) = CloseHandle_exref;
        *(int *)((int)register0x00000010 + -0x1c) = *(int *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435958;
        FUN_00437030();
        return;
      }
      *(code **)((int)register0x00000010 + -0x20) = LoadLibraryExW_exref;
      *(wchar16 **)((int)register0x00000010 + -0x1c) = u_winmm_dll_005cc500;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x800;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435986;
      FUN_004370d0();
      iVar1 = *(int *)((int)register0x00000010 + -0x10);
      if (iVar1 != 0) {
        *(int *)((int)register0x00000010 + -8) = iVar1;
        *(int *)((int)register0x00000010 + -0x20) = iVar1;
        *(char **)((int)register0x00000010 + -0x1c) = "timeBeginPeriod";
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x10;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x10;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4359b8;
        FUN_004352e0();
        iVar1 = *(int *)((int)register0x00000010 + -0x10);
        if (DAT_005f5fd0 != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x4359cb;
          FUN_0046ed80();
          *in_EDI = iVar1;
          in_EDI[1] = DAT_005d6df0;
        }
        *(undefined4 *)((int)register0x00000010 + -0x20) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(char **)((int)register0x00000010 + -0x1c) = "timeEndPeriod";
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0xe;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0xe;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a02;
        DAT_005d6df0 = iVar1;
        FUN_004352e0();
        iVar1 = *(int *)((int)register0x00000010 + -0x10);
        if (DAT_005f5fd0 != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a15;
          FUN_0046ed80();
          *in_EDI = iVar1;
          in_EDI[1] = DAT_005d6df4;
        }
        if ((DAT_005d6df0 != 0) && (iVar1 != 0)) {
          DAT_005d6df4 = iVar1;
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a3d;
        DAT_005d6df4 = iVar1;
        FUN_0046f970();
        *(undefined4 *)((int)register0x00000010 + -4) =
             *(undefined4 *)((int)register0x00000010 + -0x20);
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a49;
        FUN_0043a810();
        *(char **)((int)register0x00000010 + -0x20) =
             "runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
        ;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x26;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a5f;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x20) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a73;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a78;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a7d;
        FUN_0043a870();
        *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004c9bcf;
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x1d;
        *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a93;
        FUN_00469a20();
      }
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435a98;
      FUN_0046f970();
      *(undefined4 *)((int)register0x00000010 + -4) =
           *(undefined4 *)((int)register0x00000010 + -0x20);
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435aa4;
      FUN_0043a810();
      *(char **)((int)register0x00000010 + -0x20) =
           "runtime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x26;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435aba;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x20) =
           *(undefined4 *)((int)register0x00000010 + -4);
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435ace;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435ad3;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435ad8;
      FUN_0043a870();
      *(undefined **)((int)register0x00000010 + -0x20) = &DAT_004c6287;
      *(undefined4 *)((int)register0x00000010 + -0x1c) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0x435aee;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x435af4;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00435b00 */

/* WARNING: Restarted to delay deadcode elimination for space: stack */

void FUN_00435b00(void)

{
  int iVar1;
  undefined4 uVar2;
  int in_FS_OFFSET;
  uint local_110;
  int local_10c;
  uint local_108;
  undefined1 local_a0 [156];
  undefined4 uStack_4;
  
  while (local_a0 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    uStack_4 = 0x435bc0;
    FUN_0046d980();
  }
  FUN_0046ef0b();
  FUN_00437030(DAT_005d6dec);
  uVar2 = DAT_005d6de8;
  if ((9 < local_110) && (((local_110 != 10 || (local_10c != 0)) || (0x3ad6 < local_108)))) {
    iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
    *(undefined4 *)(iVar1 + 0x1c0) = 0;
    *(undefined4 *)(iVar1 + 0x1c4) = 0;
    FUN_00436f40(uVar2);
    DAT_005f5dbc = 1;
    return;
  }
  return;
}



/* Function: FUN_00435bd0 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_00435bd0(void)

{
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  uint in_stack_ffffffcc;
  undefined4 in_stack_ffffffd0;
  undefined1 local_24 [4];
  undefined4 local_20;
  undefined4 uStack_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    uStack_4 = 0x435c9b;
    FUN_0046d980();
  }
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed70();
    *in_EDI = DAT_005d6df8;
  }
  DAT_005d6df8 = FUN_0046f920;
  FUN_004353e0();
  FUN_0044d670();
  FUN_0044d790();
  FUN_004358e0();
  in_stack_ffffffcc = in_stack_ffffffcc & 0xffffff00;
  FUN_00435860();
  _DAT_005f5e34 = in_stack_ffffffd0;
  FUN_00435360();
  FUN_00435b00();
  FUN_004357a0();
  DAT_005f5e8c = in_stack_ffffffcc;
  FUN_0046ef47();
  FUN_00437030(GetSystemInfo_exref,local_24);
  DAT_005f5de0 = local_20;
  FUN_00437080(SetProcessPriorityBoost_exref,0xffffffff,1);
  return;
}



/* Function: FUN_00435ca0 */

void FUN_00435ca0(undefined4 param_1,int param_2)

{
  code *pcVar1;
  
  if (param_2 != 0) {
    FUN_00437080(DAT_005d6dd8,param_1,param_2);
    return;
  }
  FUN_0046edf0();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



/* Function: FUN_00435cf0 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_00435cf0(void)

{
  code *pcVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  int *piVar6;
  short *psVar7;
  int iVar8;
  int iVar9;
  undefined1 *puVar10;
  int iVar11;
  int *in_EDI;
  int in_FS_OFFSET;
  
code_r0x00435cf0:
  pcVar1 = GetEnvironmentStringsW_exref;
  puVar10 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar10 = (undefined1 *)((int)register0x00000010 + -0x2c);
    iVar8 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
    *(undefined4 *)(iVar8 + 0x1c0) = 0;
    *(undefined4 *)(iVar8 + 0x1c4) = 0;
    *(code **)((int)register0x00000010 + -0x2c) = pcVar1;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435d37;
    FUN_00436f40();
    uVar4 = 0;
    iVar8 = 0;
    for (uVar3 = 0; uVar3 < 0x1000000; uVar3 = uVar3 + 1) {
      if (*(short *)(*(int *)((int)register0x00000010 + -0x28) + uVar3 * 2) == 0) {
        if (uVar4 == uVar3) {
          *(int *)((int)register0x00000010 + -0x10) = *(int *)((int)register0x00000010 + -0x28);
          *(int *)((int)register0x00000010 + -0x18) = iVar8;
          *(undefined **)((int)register0x00000010 + -0x2c) = &DAT_004adee0;
          *(int *)((int)register0x00000010 + -0x28) = iVar8;
          *(int *)((int)register0x00000010 + -0x24) = iVar8;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435d83;
          FUN_0046a780();
          iVar8 = *(int *)((int)register0x00000010 + -0x20);
          uVar4 = *(uint *)((int)register0x00000010 + -0x18);
          DAT_005d7004 = uVar4;
          _DAT_005d7008 = uVar4;
          if (DAT_005f5fd0 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435da6;
            FUN_0046ed80();
            *in_EDI = iVar8;
            in_EDI[1] = DAT_005d7000;
          }
          iVar2 = *(int *)((int)register0x00000010 + -0x10);
          iVar9 = 0;
          iVar11 = 0x1000000;
          iVar5 = iVar2;
          DAT_005d7000 = iVar8;
          goto LAB_00435de3;
        }
        uVar4 = uVar3 + 1;
        iVar8 = iVar8 + 1;
      }
    }
    goto LAB_00435ee5;
  }
  goto LAB_00435ef2;
LAB_00435de3:
  if ((int)uVar4 <= iVar9) {
    *(code **)((int)register0x00000010 + -0x2c) = FreeEnvironmentStringsW_exref;
    *(int *)((int)register0x00000010 + -0x28) = iVar5;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435e60;
    FUN_00437030();
    *(undefined **)((int)register0x00000010 + -8) = &DAT_004acc40;
    *(undefined ***)((int)register0x00000010 + -4) = &PTR_LAB_00536ab8;
    *(undefined4 *)((int)register0x00000010 + -0x2c) = *(undefined4 *)((int)register0x00000010 + -8)
    ;
    *(undefined ***)((int)register0x00000010 + -0x28) = &PTR_LAB_00536ab8;
    *(undefined1 *)((int)register0x00000010 + -0x24) = 1;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435e89;
    FUN_0046bba0();
    *(code **)((int)register0x00000010 + -0x2c) = SetConsoleCtrlHandler_exref;
    *(undefined4 *)((int)register0x00000010 + -0x28) =
         *(undefined4 *)((int)register0x00000010 + -0x20);
    *(undefined4 *)((int)register0x00000010 + -0x24) = 1;
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435ea7;
    FUN_00437080();
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435eac;
    FUN_004356a0();
    return;
  }
  if (iVar11 == 0) goto LAB_00435edc;
  *(int *)((int)register0x00000010 + -0x14) = iVar9;
  *(int *)((int)register0x00000010 + -0xc) = iVar2;
  *(int *)((int)register0x00000010 + -0x1c) = iVar11;
  *(int *)((int)register0x00000010 + -0x2c) = iVar2;
  *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435e03;
  FUN_00452ae0();
  uVar4 = *(uint *)((int)register0x00000010 + -0x14);
  if (DAT_005d7004 <= uVar4) goto LAB_00435ed7;
  piVar6 = (int *)(DAT_005d7000 + uVar4 * 8);
  iVar8 = *(int *)((int)register0x00000010 + -0x28);
  *(undefined4 *)(DAT_005d7000 + 4 + uVar4 * 8) = *(undefined4 *)((int)register0x00000010 + -0x24);
  if (DAT_005f5fd0 != 0) {
    *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435e3b;
    FUN_0046ed80();
    *in_EDI = iVar8;
    in_EDI[1] = *piVar6;
  }
  *piVar6 = iVar8;
  psVar7 = *(short **)((int)register0x00000010 + -0xc);
  iVar11 = *(int *)((int)register0x00000010 + -0x1c);
  while( true ) {
    if (iVar11 == 0) {
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435ed7;
      FUN_0046edf0();
      goto LAB_00435ed7;
    }
    if (*psVar7 == 0) break;
    iVar11 = iVar11 + -1;
    psVar7 = (short *)((int)psVar7 + (-iVar11 >> 0x1f & 2U));
  }
  iVar11 = iVar11 + -1;
  iVar9 = uVar4 + 1;
  iVar2 = (int)psVar7 + (-iVar11 >> 0x1f & 2U);
  uVar4 = *(uint *)((int)register0x00000010 + -0x18);
  iVar5 = *(int *)((int)register0x00000010 + -0x10);
  goto LAB_00435de3;
LAB_00435ed7:
  *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435edc;
  FUN_0046edf0();
LAB_00435edc:
  *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435ee5;
  FUN_0046edf0();
LAB_00435ee5:
  *(undefined4 *)((int)register0x00000010 + -0x30) = 0x435ef1;
  FUN_0046edf0();
LAB_00435ef2:
  *(undefined4 *)(puVar10 + -4) = 0x435ef7;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar10;
  goto code_r0x00435cf0;
}



/* Function: FUN_00435f00 */

void FUN_00435f00(undefined4 param_1)

{
  FUN_0040ecf0(&DAT_005f5e44);
  FUN_00402770(&DAT_005f5e38,1);
  FUN_00437030(ExitProcess_exref,param_1);
  return;
}



/* Function: FUN_00435f50 */

void FUN_00435f50(int param_1,int param_2,uint param_3)

{
  code *pcVar1;
  int iVar2;
  int in_stack_ffffffe0;
  int in_stack_ffffffe4;
  undefined4 local_c;
  undefined4 local_8;
  int local_4;
  
  if (param_1 == 1) {
    param_1 = in_stack_ffffffe0;
    FUN_00437030(GetStdHandle_exref,0xfffffff5);
  }
  else if (param_1 == 2) {
    param_1 = in_stack_ffffffe0;
    FUN_00437030(GetStdHandle_exref,0xfffffff4);
  }
  if (0x40000000 < param_3) {
    FUN_0046ee10();
    pcVar1 = (code *)swi(3);
    (*pcVar1)();
    return;
  }
  iVar2 = 0;
  do {
    if ((int)param_3 <= iVar2) {
LAB_00436023:
      local_c = 0;
      FUN_00437170(WriteFile_exref,param_1,param_2,param_3,&local_c,0);
      return;
    }
    if (0x7f < *(byte *)(param_2 + iVar2)) {
      local_8 = 0;
      local_4 = param_1;
      FUN_00437080(GetConsoleMode_exref,param_1,&local_8);
      param_1 = local_4;
      if (in_stack_ffffffe4 != 0) {
        FUN_00436070(local_4,param_2,param_3);
        return;
      }
      goto LAB_00436023;
    }
    iVar2 = iVar2 + 1;
  } while( true );
}



/* Function: FUN_00436070 */

void FUN_00436070(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined1 *puVar4;
  int iVar5;
  uint uVar6;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x34);
      *(undefined **)((int)register0x00000010 + -0x34) = &DAT_005f5e3c;
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436097;
      FUN_0040ecf0();
      if (*(uint *)((int)register0x00000010 + 0xc) < 0x40000001) {
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(uint *)((int)register0x00000010 + -8) = *(uint *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -4) = 0x40000000;
        iVar3 = *(int *)((int)register0x00000010 + -8);
        *(int *)((int)register0x00000010 + -0x1c) = iVar3;
        iVar5 = *(int *)((int)register0x00000010 + -0xc);
        *(int *)((int)register0x00000010 + -0x10) = iVar5;
        iVar1 = 0;
        uVar2 = 0;
        while (iVar1 < iVar3) {
          uVar6 = (uint)*(byte *)(iVar5 + iVar1);
          if (uVar6 < 0x80) {
            iVar1 = iVar1 + 1;
          }
          else {
            *(uint *)((int)register0x00000010 + -0x20) = uVar2;
            *(int *)((int)register0x00000010 + -0x34) = iVar5;
            *(int *)((int)register0x00000010 + -0x30) = iVar3;
            *(int *)((int)register0x00000010 + -0x2c) = iVar1;
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436107;
            FUN_00464670();
            uVar6 = *(uint *)((int)register0x00000010 + -0x28);
            iVar1 = *(int *)((int)register0x00000010 + -0x24);
            uVar2 = *(uint *)((int)register0x00000010 + -0x20);
            iVar3 = *(int *)((int)register0x00000010 + -0x1c);
            iVar5 = *(int *)((int)register0x00000010 + -0x10);
          }
          if (0x3e5 < (int)uVar2) {
            if (1000 < uVar2) goto LAB_0043625c;
            *(uint *)((int)register0x00000010 + -0x18) = uVar6;
            *(int *)((int)register0x00000010 + -0x14) = iVar1;
            *(undefined4 *)((int)register0x00000010 + -0x34) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined2 **)((int)register0x00000010 + -0x30) = &DAT_005f6f20;
            *(uint *)((int)register0x00000010 + -0x2c) = uVar2;
            *(undefined4 *)((int)register0x00000010 + -0x28) = 1000;
            *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436159;
            FUN_00436280();
            iVar3 = *(int *)((int)register0x00000010 + -0x1c);
            iVar5 = *(int *)((int)register0x00000010 + -0x10);
            uVar6 = *(uint *)((int)register0x00000010 + -0x18);
            iVar1 = *(int *)((int)register0x00000010 + -0x14);
            uVar2 = 0;
          }
          if ((int)uVar6 < 0x10000) {
            if (999 < uVar2) goto LAB_00436250;
            (&DAT_005f6f20)[uVar2] = (short)uVar6;
            uVar2 = uVar2 + 1;
          }
          else {
            if (999 < uVar2) goto LAB_00436244;
            (&DAT_005f6f20)[uVar2] = ((ushort)((int)(uVar6 - 0x10000) >> 10) & 0x3ff) + 0xd800;
            if (999 < uVar2 + 1) goto LAB_00436238;
            (&DAT_005f6f22)[uVar2] = ((ushort)(uVar6 - 0x10000) & 0x3ff) + 0xdc00;
            uVar2 = uVar2 + 2;
          }
        }
        if (uVar2 < 0x3e9) {
          *(undefined4 *)((int)register0x00000010 + -0x34) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined2 **)((int)register0x00000010 + -0x30) = &DAT_005f6f20;
          *(uint *)((int)register0x00000010 + -0x2c) = uVar2;
          *(undefined4 *)((int)register0x00000010 + -0x28) = 1000;
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436212;
          FUN_00436280();
          *(undefined **)((int)register0x00000010 + -0x34) = &DAT_005f5e3c;
          *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436222;
          FUN_0040f0e0();
          *(undefined4 *)((int)register0x00000010 + 0x10) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436238;
        FUN_0046ee30();
LAB_00436238:
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436244;
        FUN_0046edf0();
LAB_00436244:
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436250;
        FUN_0046edf0();
LAB_00436250:
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x43625c;
        FUN_0046edf0();
LAB_0043625c:
        *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436266;
        FUN_0046ee30();
      }
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0x436270;
      FUN_0046ee10();
    }
    *(undefined4 *)(puVar4 + -4) = 0x436276;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_00436280 */

void FUN_00436280(undefined4 param_1,undefined4 param_2,int param_3)

{
  int in_FS_OFFSET;
  undefined4 local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x4362e2;
    FUN_0046d980();
  }
  if (param_3 == 0) {
    return;
  }
  local_4 = 0;
  FUN_00437170(WriteConsoleW_exref,param_1,param_2,param_3,&local_4,0);
  return;
}



/* Function: FUN_004362f0 */

void FUN_004362f0(uint param_1,int param_2)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int in_FS_OFFSET;
  bool bVar7;
  code *in_stack_ffffffc4;
  code *pcVar8;
  int in_stack_ffffffc8;
  uint in_stack_ffffffd0;
  uint local_28;
  uint local_18;
  undefined4 local_10;
  undefined4 local_c;
  undefined1 *local_8 [2];
  
  if (param_2 < 0) {
    local_28 = in_stack_ffffffd0;
    FUN_00437080(WaitForSingleObject_exref,
                 *(undefined4 *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x314),
                 0xffffffff);
  }
  else {
    FUN_0046fa70();
    iVar1 = 0;
    uVar3 = 0;
    while( true ) {
      uVar6 = param_1 - uVar3;
      uVar4 = (param_2 - iVar1) - (uint)(param_1 < uVar3);
      local_18 = 0;
      for (uVar3 = 0x1e; -1 < (int)uVar3; uVar3 = uVar3 - 1) {
        uVar5 = uVar3 - 0x20;
        uVar2 = -(uint)(uVar3 < 0x20) & 1000000 << ((byte)uVar3 & 0x1f);
        uVar5 = 1000000U >> ((byte)-uVar5 & 0x1f) & -(uint)(-uVar5 < 0x20) |
                -(uint)(uVar5 < 0x20) & 1000000 << ((byte)uVar5 & 0x1f);
        if ((int)uVar5 < (int)uVar4 || uVar4 == uVar5 && uVar2 <= uVar6) {
          local_18 = local_18 | 1 << ((byte)uVar3 & 0x1f) & -(uint)(uVar3 < 0x20);
          bVar7 = uVar6 < uVar2;
          uVar6 = uVar6 - uVar2;
          uVar4 = (uVar4 - uVar5) - (uint)bVar7;
        }
      }
      if (999999 < uVar6 && uVar4 == 0 || 0 < (int)uVar4) {
        local_18 = 0x7fffffff;
      }
      if (local_18 == 0) {
        local_18 = 1;
      }
      local_10 = *(undefined4 *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x314);
      local_c = *(undefined4 *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x318);
      iVar1 = 2;
      pcVar8 = WaitForMultipleObjects_exref;
      FUN_00437120(WaitForMultipleObjects_exref,2,&local_10,0,local_18);
      if (local_28 != 1) break;
      FUN_0046fa70();
      uVar3 = (int)pcVar8 - (int)in_stack_ffffffc4;
      iVar1 = (iVar1 - in_stack_ffffffc8) - (uint)(pcVar8 < in_stack_ffffffc4);
      if (param_2 < iVar1 || param_1 <= uVar3 && param_2 == iVar1) {
        return;
      }
    }
  }
  if (local_28 < 0x81) {
    if (local_28 == 0) {
      return;
    }
    if (local_28 == 0x80) {
      FUN_0046d890(&PTR_LAB_00536c74);
      return;
    }
  }
  else {
    if (local_28 == 0x102) {
      return;
    }
    if (local_28 == 0xffffffff) {
      FUN_0046d890(&PTR_LAB_00536c78);
      return;
    }
  }
  local_8[0] = &LAB_004365c0;
  FUN_0046d890(local_8);
  return;
}



/* Function: FUN_00436640 */

void FUN_00436640(int param_1)

{
  int local_4;
  
  FUN_00437030(SetEvent_exref,*(undefined4 *)(param_1 + 0x314));
  if (local_4 == 0) {
    FUN_0046d890(&PTR_LAB_00536c7c);
  }
  return;
}



/* Function: FUN_00436680 */

void FUN_00436680(int param_1)

{
  int local_4;
  
  if (*(int *)(param_1 + 0x314) == 0) {
    FUN_00437120(CreateEventA_exref,0,0,0,0);
    *(int *)(param_1 + 0x314) = local_4;
    if (local_4 == 0) {
      FUN_0046d890(&PTR_LAB_00536c6c);
    }
    FUN_00437120(CreateEventA_exref,0,0,0,0);
    *(int *)(param_1 + 0x318) = local_4;
    if (local_4 == 0) {
      FUN_0046d890(&PTR_LAB_00536c70);
      FUN_00437030(CloseHandle_exref,*(undefined4 *)(param_1 + 0x314));
      *(undefined4 *)(param_1 + 0x314) = 0;
    }
    return;
  }
  return;
}



/* Function: FUN_00436770 */

void FUN_00436770(undefined4 param_1)

{
  int iVar1;
  undefined *puVar2;
  int iVar3;
  int local_10;
  
  iVar3 = 0;
  FUN_004371c0(CreateThread_exref,0,0,&LAB_0046fa40,param_1,0,0);
  if (local_10 != 0) {
    FUN_00437030(CloseHandle_exref,local_10);
    return;
  }
  puVar2 = &DAT_005f5e38;
  FUN_00402510(&DAT_005f5e38);
  if (iVar3 != 0) goto code_r0x0043689c;
  do {
    iVar1 = DAT_005d8518;
    iVar3 = DAT_005d8508;
    FUN_0046f970();
    FUN_0043a810();
    FUN_0043b060(&DAT_004ccbbe,0x2e);
    FUN_0043ae80(iVar3 - iVar1,iVar3 - iVar1 >> 0x1f);
    FUN_0043b060(" already; errno=\nruntime stack:\ninvalid g statuscastogscanstatusbad g transitionschedule: in cgoreflect mismatch untyped locals missing stackmapbad symbol tablenon-Go function\npointerless type not in ranges:\nGetCurrentThreadGetModuleHandleWRtlVirtualUnwindGODEBUG: value \"allowmultiplevcsRCodeFormatError[bisect-match 0xChaCha20Nonce.txtAdjustTokenGroupsIsTokenRestrictedLookupAccountSidWCertFindExtensionCryptDecodeObjectDnsRecordListFreeGetShortPathNameWReadProcessMemoryQueryWorkingSetExGetKeyboardLayoutWSAEnumProtocolsWWTSQueryUserTokenwinreadlinkvolumeRegLoadMUIStringWGTB Standard TimeFLE Standard TimeGMT Standard Timepermission deniedwrong medium typeno data availableexec format errorGetCurrentProcessgoroutine profileAllThreadsSyscallGC assist markingselect (no cases)sync.RWMutex.Lockwait for GC cycletrace proc statusselect (synctest)sync.(*Cond).Wait: missing method notetsleepg on g0bad TinySizeClassruntime: pointer g already scannedmark - bad statusscanobject n == 0swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
                 ,0x10);
    FUN_0043ad50(puVar2,0);
    FUN_0043b060(&DAT_004c2946,2);
    FUN_0043a870();
    FUN_00469a20(&DAT_004c56c6,0x11);
code_r0x0043689c:
    FUN_0040ecf0(&DAT_005f5e54);
    puVar2 = &DAT_005f5e54;
    FUN_0040ecf0();
  } while( true );
}



/* Function: FUN_004368c0 */

void FUN_004368c0(void)

{
  uint uVar1;
  int iVar2;
  uint *puVar3;
  uint uVar4;
  code *pcVar5;
  int iVar6;
  undefined1 *puVar7;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x5c);
      *(undefined4 *)((int)register0x00000010 + -0x38) = 0;
      *(code **)((int)register0x00000010 + -0x5c) = DuplicateHandle_exref;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0xffffffff;
      *(undefined4 *)((int)register0x00000010 + -0x54) = 0xfffffffe;
      *(undefined4 *)((int)register0x00000010 + -0x50) = 0xffffffff;
      *(undefined1 **)((int)register0x00000010 + -0x4c) =
           (undefined1 *)((int)register0x00000010 + -0x38);
      *(undefined4 *)((int)register0x00000010 + -0x48) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x44) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x40) = 2;
      *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436925;
      FUN_00437210();
      if (*(int *)((int)register0x00000010 + -0x3c) != 0) {
        iVar6 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
        *(int *)((int)register0x00000010 + -8) = iVar6;
        iVar6 = iVar6 + 0x30c;
        *(int *)((int)register0x00000010 + -4) = iVar6;
        *(int *)((int)register0x00000010 + -0x5c) = iVar6;
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436957;
        FUN_0040ecf0();
        *(undefined4 *)(*(int *)((int)register0x00000010 + -8) + 0x310) =
             *(undefined4 *)((int)register0x00000010 + -0x38);
        pcVar5 = GetCurrentThreadId_exref;
        iVar6 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
        *(undefined4 *)(iVar6 + 0x1c0) = 0;
        *(undefined4 *)(iVar6 + 0x1c4) = 0;
        *(code **)((int)register0x00000010 + -0x5c) = pcVar5;
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436995;
        FUN_00436f40();
        iVar6 = *(int *)((int)register0x00000010 + -8);
        *(undefined4 *)(iVar6 + 0x28) = *(undefined4 *)((int)register0x00000010 + -0x58);
        *(undefined4 *)(iVar6 + 0x2c) = 0;
        if ((*(int *)(iVar6 + 0x31c) == 0) && (DAT_005f5dab != '\0')) {
          *(code **)((int)register0x00000010 + -0x5c) = CreateWaitableTimerExW_exref;
          *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x54) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x50) = 2;
          *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x100003;
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x4369ea;
          FUN_00437120();
          iVar2 = *(int *)((int)register0x00000010 + -0x48);
          iVar6 = *(int *)((int)register0x00000010 + -8);
          *(int *)(iVar6 + 0x31c) = iVar2;
          if (iVar2 != 0) goto LAB_00436a00;
        }
        else {
LAB_00436a00:
          if ((*(int *)(iVar6 + 0x324) == 0) && (DAT_005f5dbb != '\0')) {
            *(code **)((int)register0x00000010 + -0x5c) = CreateWaitableTimerExW_exref;
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x54) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x50) = 2;
            *(undefined4 *)((int)register0x00000010 + -0x4c) = 0x100003;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436a47;
            FUN_00437120();
            iVar6 = *(int *)((int)register0x00000010 + -0x48);
            iVar2 = *(int *)((int)register0x00000010 + -8);
            *(int *)(iVar2 + 800) = iVar6;
            if (iVar6 != 0) {
              *(undefined4 *)((int)register0x00000010 + -0x5c) = DAT_005d6ddc;
              *(int *)((int)register0x00000010 + -0x58) = iVar2 + 0x324;
              *(undefined4 *)((int)register0x00000010 + -0x54) = 0x10000000;
              *(undefined4 *)((int)register0x00000010 + -0x50) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436a85;
              FUN_004370d0();
              if (*(int *)(*(int *)((int)register0x00000010 + -8) + 0x324) != 0)
              goto code_r0x00436a99;
              goto LAB_00436c0e;
            }
          }
          else {
code_r0x00436a99:
            *(undefined4 *)((int)register0x00000010 + -0x5c) =
                 *(undefined4 *)((int)register0x00000010 + -4);
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436aa5;
            FUN_0040f0e0();
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436ab0;
            FUN_0046ef49();
            *(code **)((int)register0x00000010 + -0x5c) = VirtualQuery_exref;
            *(undefined1 **)((int)register0x00000010 + -0x58) =
                 (undefined1 *)((int)register0x00000010 + -0x34);
            *(undefined1 **)((int)register0x00000010 + -0x54) =
                 (undefined1 *)((int)register0x00000010 + -0x34);
            *(undefined4 *)((int)register0x00000010 + -0x50) = 0x1c;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436ad2;
            FUN_004370d0();
            if (*(int *)((int)register0x00000010 + -0x4c) != 0) {
              uVar1 = *(int *)((int)register0x00000010 + -0x30) + 0x4000;
              *(uint *)((int)register0x00000010 + -0x14) = uVar1;
              puVar3 = (uint *)**(undefined4 **)(in_FS_OFFSET + DAT_005f5ed0);
              uVar4 = puVar3[1];
              *(uint *)((int)register0x00000010 + -0xc) = uVar4;
              if ((uVar1 <= uVar4) &&
                 ((uVar4 - *(int *)((int)register0x00000010 + -0x30)) - 0x4000 < 0x4000001)) {
                *puVar3 = uVar1;
                puVar3[2] = *puVar3 + 0x13a0;
                puVar3[3] = *puVar3 + 0x13a0;
                *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436b25;
                FUN_0046ebd0();
                return;
              }
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436b2e;
              FUN_0043a810();
              *(undefined **)((int)register0x00000010 + -0x5c) = &DAT_004c629a;
              *(undefined4 *)((int)register0x00000010 + -0x58) = 0x13;
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436b44;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x5c) =
                   *(undefined4 *)((int)register0x00000010 + -0x14);
              *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436b58;
              FUN_0043aef0();
              *(undefined **)((int)register0x00000010 + -0x5c) = &DAT_004c292c;
              *(undefined4 *)((int)register0x00000010 + -0x58) = 1;
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436b6e;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x5c) =
                   *(undefined4 *)((int)register0x00000010 + -0xc);
              *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436b82;
              FUN_0043aef0();
              *(undefined **)((int)register0x00000010 + -0x5c) = &DAT_004c2946;
              *(undefined4 *)((int)register0x00000010 + -0x58) = 2;
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436b98;
              FUN_0043b060();
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436b9d;
              FUN_0043a870();
              *(char **)((int)register0x00000010 + -0x5c) =
                   "bad g0 stackself-preempt [recovered]bad recoverybad g statusentersyscallwirep: p->m=) p->status=releasep: m= sysmonwait= preemptoff=cas64 failed m->gsignal=-byte limit\nruntime: sp=abi mismatchwrong timersmultipathtcpnot pollablegotypesaliashttpmuxgo121randautoseedtlsunsafeekmRCodeSuccessRCodeRefusedRtlMoveMemoryDeleteServiceRegEnumKeyExWRegOpenKeyExWStartServiceWCertOpenStoreGetIfEntry2ExFindNextFileWFindResourceWGetDriveTypeWMapViewOfFileModule32NextWThread32FirstVirtualUnlockWaitCommEventWriteConsoleWRtlGetVersionRtlInitStringCoTaskMemFreeEnumProcessesShellExecuteWExitWindowsExGetClassNameWtimeEndPeriodFreeAddrInfoWgethostbynamegetservbynameWTSFreeMemoryFindFirstFileRegDeleteKeyWRegEnumValueWdalTLDpSugct?level 3 resetsrmount errortimer expiredexchange fullwakeableSleepprofMemActiveprofMemFuturetraceStackTabexecRInternaltestRInternalGC sweep waitsynctest.Waitout of memory is nil, not value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaS..." /* TRUNCATED STRING LITERAL */
              ;
              *(undefined4 *)((int)register0x00000010 + -0x58) = 0xc;
              *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436bb3;
              FUN_00469a20();
            }
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436bb8;
            FUN_0046f970();
            *(undefined4 *)((int)register0x00000010 + -0x10) =
                 *(undefined4 *)((int)register0x00000010 + -0x5c);
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436bc4;
            FUN_0043a810();
            *(char **)((int)register0x00000010 + -0x5c) =
                 "runtime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
            ;
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0x24;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436bda;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x5c) =
                 *(undefined4 *)((int)register0x00000010 + -0x10);
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436bee;
            FUN_0043ad50();
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436bf3;
            FUN_0043aa10();
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436bf8;
            FUN_0043a870();
            *(char **)((int)register0x00000010 + -0x5c) =
                 "VirtualQuery for stack base failedforEachP: sched.safePointWait != 0schedule: spinning with local workentersyscallblock inconsistent bp entersyscallblock inconsistent sp runtime: g is running but p is notunexpected runtime.netpoll error: SubscribeServiceChangeNotifications2006-01-02T15:04:05.999999999Z07:00network dropped connection on resettransport endpoint is not connectedpersistentalloc: align is too large/memory/classes/heap/released:bytesgreyobject: obj not pointer-alignedmismatched begin/end of activeSweepmheap.freeSpanLocked - invalid freefailed to get or create weak handleattempt to clear non-empty span setruntime: close polldesc w/o unblockNtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: dupli..." /* TRUNCATED STRING LITERAL */
            ;
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0x22;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c0e;
            FUN_00469a20();
LAB_00436c0e:
            *(undefined4 *)((int)register0x00000010 + -0x18) =
                 *(undefined4 *)((int)register0x00000010 + -0x4c);
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c1b;
            FUN_0043a810();
            *(char **)((int)register0x00000010 + -0x5c) =
                 "runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!trace: non-empty full trace buffer for done generationtrace: non-empty full trace buffer for next generation\tgoroutine running on other thread; stack unavailable\ninternal error: polling on unsupported descriptor typeSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zonesmheap.freeSpanLocked - invalid free of user arena chunkcasfrom_Gscanstatus:top gp->status is not in scan state is currently not supported for use in system callbacksstrings: illegal use of non-zero Builder copied by valuefailed to allocate aligned heap memory; too many retriesprofilealloc called without a P or outside bootstrappingin gcMark expecting to see gcphase as _GCmarkterminationruntime: NtAssociateWaitCompletionPacket failed; errno= runtime: checkmarks found unexpected unmarked object obj=tried to trace goroutine with invalid or unsupported statuscalled CompareAndDelete when value is not of comparable typemanual span allocation called with non-manually-managed typeaddr range base and limit are not in the same memory segmentruntime: netpoll: PostQueuedCompletionStatus failed (errno= runtime: malformed profBuf buffer - tag and data out of syncfound bad pointer in Go heap (incorrect use of unsafe or cgo?)limiterEvent.stop: found wrong event in p\'s limiter event slotruntime: internal error: misuse of lockOSThread/unlockOSThreadinternal/sync.HashTrieMap: ran out of hash bits while iteratinginternal/sync.HashTrieMap: ran out of hash bits while insertingmalformed GOMEMLIMI..." /* TRUNCATED STRING LITERAL */
            ;
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0x34;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c31;
            FUN_0043b060();
            *(undefined4 *)((int)register0x00000010 + -0x5c) =
                 *(undefined4 *)((int)register0x00000010 + -0x18);
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c45;
            FUN_0043ad50();
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c4a;
            FUN_0043aa10();
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c4f;
            FUN_0043a870();
            *(char **)((int)register0x00000010 + -0x5c) =
                 "NtCreateWaitCompletionPacket failedfindrunnable: netpoll with spinningpidleput: P has non-empty run queuetraceback did not unwind completelyruntime: createevent failed; errno=file type does not support deadlineaccessing a corrupted shared librarylfstack node allocated from the heap) is larger than maximum page size (runtime: invalid typeBitsBulkBarrieruncaching span but s.allocCount == 0/memory/classes/metadata/other:bytes/sched/pauses/stopping/other:secondsuser arena span is on the wrong listruntime: marked free object in span runtime: unblock on closing polldescUnable to determine system directoryruntime: VirtualQuery failed; errno=runtime: sudog with non-nil waitlinkruntime: mcall called on m->g0 stackstartm: P required for spinning=true) is not Grunnable or Gscanrunnable\nruntime: bad notifyList size - sync=accessed data from freed user arena runtime: wrong goroutine in newstackruntime: invalid pc-encoded table f=timer moved between synctest bubblesstrings.Builder.Grow: negative countrounded-up capacity overflows uint64invalid pattern syntax (+ after -): UnsubscribeServiceChangeNotificationscannot exec a shared library directlyvalue too large for defined data typeruntime: allocation size out of range) is smaller than minimum page size (/cpu/classes/gc/mark/idle:cpu-secondssetprofilebucket: profile already setfailed to reserve page summary memoryruntime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=ru..." /* TRUNCATED STRING LITERAL */
            ;
            *(undefined4 *)((int)register0x00000010 + -0x58) = 0x23;
            *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c65;
            FUN_00469a20();
          }
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c6a;
          FUN_0046f970();
          *(undefined4 *)((int)register0x00000010 + -0x10) =
               *(undefined4 *)((int)register0x00000010 + -0x5c);
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c76;
          FUN_0043a810();
          *(undefined **)((int)register0x00000010 + -0x5c) = &DAT_004cca23;
          *(undefined4 *)((int)register0x00000010 + -0x58) = 0x2d;
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436c8c;
          FUN_0043b060();
          *(undefined4 *)((int)register0x00000010 + -0x5c) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436ca0;
          FUN_0043ad50();
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436ca5;
          FUN_0043aa10();
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436caa;
          FUN_0043a870();
          *(char **)((int)register0x00000010 + -0x5c) =
               "CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.find..." /* TRUNCATED STRING LITERAL */
          ;
          *(undefined4 *)((int)register0x00000010 + -0x58) = 0x30;
          *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436cc0;
          FUN_00469a20();
        }
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436cc5;
        FUN_0046f970();
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + -0x5c);
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436cd1;
        FUN_0043a810();
        *(undefined **)((int)register0x00000010 + -0x5c) = &DAT_004cca23;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x2d;
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436ce7;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x5c) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436cfb;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d00;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d05;
        FUN_0043a870();
        *(char **)((int)register0x00000010 + -0x5c) =
             "CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.find..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -0x58) = 0x30;
        *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d1b;
        FUN_00469a20();
      }
      *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d20;
      FUN_0046f970();
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + -0x5c);
      *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d2c;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x5c) = &DAT_004cc9f6;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x2d;
      *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d42;
      FUN_0043b060();
      *(undefined4 *)((int)register0x00000010 + -0x5c) =
           *(undefined4 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d56;
      FUN_0043ad50();
      *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d5b;
      FUN_0043aa10();
      *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d60;
      FUN_0043a870();
      *(char **)((int)register0x00000010 + -0x5c) =
           "runtime.minit: duplicatehandle failed_cgo_notify_runtime_init_done missingstartTheWorld: inconsistent mp->nextpruntime: unexpected SPWRITE function all goroutines are asleep - deadlock!internal error: unknown network type godebug: unexpected IncNonDefault of bisect.Hash: unexpected argument typetime: missing Location in call to Datecan not access a needed shared libraryindex out of range [%x] with length %ym changed unexpectedly in cgocallbackgmakechan: invalid channel element typeunreachable method called. linker bug?gcBgMarkWorker: blackening not enabledcannot read stack of running goroutineruntime: blocked read on free polldescruntime: LoadLibraryExW failed; errno=runtime: GetProcAddress failed; errno=runtime: sudog with non-false isSelectarg size to reflect.call more than 1GBv could not fit in traceBytesPerNumberRtlDosPathNameToNtPathName_U_WithStatus2006-01-02 15:04:05.999999999 -0700 MSTtransport endpoint is already connectedmismatched count during itab table copyout of memory allocating heap arena map/cpu/classes/gc/mark/assist:cpu-seconds/cpu/classes/scavenge/total:cpu-seconds/memory/classes/profiling/buckets:bytesmspan.sweep: bad span state after sweepruntime: blocked write on free polldescPowerRegisterSuspendResumeNotification"
      ;
      *(undefined4 *)((int)register0x00000010 + -0x58) = 0x25;
      *(undefined4 *)((int)register0x00000010 + -0x60) = 0x436d76;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar7 + -4) = 0x436d7c;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_00436d90 */

void FUN_00436d90(void)

{
  int iVar1;
  int in_FS_OFFSET;
  
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  FUN_0040ecf0(iVar1 + 0x30c);
  if (*(int *)(iVar1 + 0x310) != 0) {
    FUN_00437030(CloseHandle_exref,*(int *)(iVar1 + 0x310));
    *(undefined4 *)(iVar1 + 0x310) = 0;
  }
  FUN_0040f0e0(iVar1 + 0x30c);
  *(undefined4 *)(iVar1 + 0x28) = 0;
  *(undefined4 *)(iVar1 + 0x2c) = 0;
  return;
}



/* Function: FUN_00436e10 */

void FUN_00436e10(int param_1)

{
  if (*(int *)(param_1 + 0x31c) != 0) {
    FUN_00437030(CloseHandle_exref,*(int *)(param_1 + 0x31c));
    *(undefined4 *)(param_1 + 0x31c) = 0;
  }
  if (*(int *)(param_1 + 800) != 0) {
    FUN_00437030(CloseHandle_exref,*(int *)(param_1 + 800));
    *(undefined4 *)(param_1 + 800) = 0;
  }
  if (*(int *)(param_1 + 0x324) != 0) {
    FUN_00437030(CloseHandle_exref,*(int *)(param_1 + 0x324));
    *(undefined4 *)(param_1 + 0x324) = 0;
  }
  if (*(int *)(param_1 + 0x314) != 0) {
    FUN_00437030(CloseHandle_exref,*(int *)(param_1 + 0x314));
    *(undefined4 *)(param_1 + 0x314) = 0;
  }
  if (*(int *)(param_1 + 0x318) != 0) {
    FUN_00437030(CloseHandle_exref,*(int *)(param_1 + 0x318));
    *(undefined4 *)(param_1 + 0x318) = 0;
  }
  return;
}



/* Function: FUN_00436ef0 */

void FUN_00436ef0(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_4;
  
  local_4 = param_1;
  FUN_0046ef4a();
  local_1c = local_4;
  local_18 = param_2;
  local_14 = param_3;
  thunk_FUN_0046f920(&local_1c);
  return;
}



/* Function: FUN_00436f40 */

void FUN_00436f40(undefined4 param_1,undefined4 param_2)

{
  int iVar1;
  int iVar2;
  bool bVar3;
  int in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  iVar1 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  iVar2 = *(int *)(iVar1 + 0x18);
  *(undefined4 *)(iVar2 + 0x1bc) = param_1;
  if (*(int *)(iVar2 + 0x84) == 0) {
    bVar3 = false;
  }
  else if (*(int *)(iVar2 + 0x1d8) == 0) {
    *(int *)(iVar2 + 0x1dc) = iVar1;
    *(undefined4 *)(iVar2 + 0x1d4) = unaff_retaddr;
    *(undefined4 **)(iVar2 + 0x1d8) = &param_1;
    bVar3 = true;
  }
  else {
    bVar3 = false;
  }
  FUN_0046ea10(DAT_005d6df8,iVar2 + 0x1bc);
  if (bVar3) {
    *(undefined4 *)(iVar2 + 0x1d8) = 0;
  }
  return;
}



/* Function: FUN_00436ff0 */

void FUN_00436ff0(undefined4 param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(undefined4 *)(iVar1 + 0x1c0) = 0;
  *(undefined4 *)(iVar1 + 0x1c4) = 0;
  FUN_00436f40(param_1);
  return;
}



/* Function: FUN_00437030 */

void FUN_00437030(undefined4 param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined4 uStack0000000c;
  
  uStack0000000c = 0;
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(undefined4 *)(iVar1 + 0x1c0) = 1;
  *(undefined1 **)(iVar1 + 0x1c4) = &stack0x00000008;
  FUN_00436f40(param_1);
  return;
}



/* Function: FUN_00437080 */

void FUN_00437080(undefined4 param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined4 uStack00000010;
  
  uStack00000010 = 0;
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(undefined4 *)(iVar1 + 0x1c0) = 2;
  *(undefined1 **)(iVar1 + 0x1c4) = &stack0x00000008;
  FUN_00436f40(param_1);
  return;
}



/* Function: FUN_004370d0 */

void FUN_004370d0(undefined4 param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined4 uStack00000014;
  
  uStack00000014 = 0;
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(undefined4 *)(iVar1 + 0x1c0) = 3;
  *(undefined1 **)(iVar1 + 0x1c4) = &stack0x00000008;
  FUN_00436f40(param_1);
  return;
}



/* Function: FUN_00437120 */

void FUN_00437120(undefined4 param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined4 uStack00000018;
  
  uStack00000018 = 0;
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(undefined4 *)(iVar1 + 0x1c0) = 4;
  *(undefined1 **)(iVar1 + 0x1c4) = &stack0x00000008;
  FUN_00436f40(param_1);
  return;
}



/* Function: FUN_00437170 */

void FUN_00437170(undefined4 param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined4 uStack0000001c;
  
  uStack0000001c = 0;
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(undefined4 *)(iVar1 + 0x1c0) = 5;
  *(undefined1 **)(iVar1 + 0x1c4) = &stack0x00000008;
  FUN_00436f40(param_1);
  return;
}



/* Function: FUN_004371c0 */

void FUN_004371c0(undefined4 param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined4 uStack00000020;
  
  uStack00000020 = 0;
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(undefined4 *)(iVar1 + 0x1c0) = 6;
  *(undefined1 **)(iVar1 + 0x1c4) = &stack0x00000008;
  FUN_00436f40(param_1);
  return;
}



/* Function: FUN_00437210 */

void FUN_00437210(undefined4 param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined4 uStack00000024;
  
  uStack00000024 = 0;
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(undefined4 *)(iVar1 + 0x1c0) = 7;
  *(undefined1 **)(iVar1 + 0x1c4) = &stack0x00000008;
  FUN_00436f40(param_1);
  return;
}



/* Function: FUN_00437260 */

void FUN_00437260(undefined4 param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  undefined4 uStack00000028;
  
  uStack00000028 = 0;
  iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(undefined4 *)(iVar1 + 0x1c0) = 8;
  *(undefined1 **)(iVar1 + 0x1c4) = &stack0x00000008;
  FUN_00436f40(param_1);
  return;
}



/* Function: FUN_004372d0 */

void FUN_004372d0(uint param_1)

{
  undefined4 local_8;
  uint local_4;
  
  local_8 = 0xffffffff;
  local_4 = param_1 / 1000;
  FUN_00436ef0(WaitForSingleObject_exref,2,&local_8);
  return;
}



/* Function: FUN_004373c0 */

void FUN_004373c0(int param_1)

{
  uint uVar1;
  int in_FS_OFFSET;
  undefined4 local_8;
  int local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = 0x437490;
    FUN_0046d980();
  }
  local_8 = 0;
  local_4 = -0x80000000;
  if (param_1 < 1) {
    uVar1 = 0;
  }
  else {
    uVar1 = (uint)(1000 / (long)param_1);
    if (uVar1 == 0) {
      uVar1 = 1;
    }
    local_8 = (undefined4)((ulong)uVar1 * 0xffffd8f0);
    local_4 = ((int)((ulong)uVar1 * 0xffffd8f0 >> 0x20) + ((int)uVar1 >> 0x1f) * -10000) - uVar1;
  }
  FUN_004371c0(SetWaitableTimer_exref,DAT_005f5e40,&local_8,uVar1,0,0,0);
  FUN_00402770(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x84,param_1);
  return;
}



/* Function: FUN_004374a0 */

void FUN_004374a0(void)

{
  int *piVar1;
  uint uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  uint *puVar6;
  undefined4 uVar7;
  char cVar8;
  undefined4 *puVar9;
  undefined1 *puVar10;
  int in_FS_OFFSET;
  byte bVar11;
  
  bVar11 = 0;
  do {
    puVar10 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) <
        (undefined1 *)((int)register0x00000010 + -0x29c)) {
      puVar10 = (undefined1 *)((int)register0x00000010 + -0x31c);
      if (*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) !=
          *(int *)((int)register0x00000010 + 4)) {
        iVar5 = *(int *)((int)register0x00000010 + 4) + 0x328;
        *(int *)((int)register0x00000010 + -4) = iVar5;
        *(int *)((int)register0x00000010 + -0x31c) = iVar5;
        *(undefined4 *)((int)register0x00000010 + -0x318) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x314) = 1;
        *(undefined4 *)((int)register0x00000010 + -800) = 0x437503;
        FUN_00402540();
        if (*(char *)((int)register0x00000010 + -0x310) == '\0') {
          *(int *)((int)register0x00000010 + -0x31c) = *(int *)((int)register0x00000010 + 4) + 0x200
          ;
          *(undefined4 *)((int)register0x00000010 + -0x318) = 1;
          *(undefined4 *)((int)register0x00000010 + -800) = 0x437883;
          FUN_00402690();
          return;
        }
        *(int *)((int)register0x00000010 + -0x10) = *(int *)((int)register0x00000010 + 4) + 0x30c;
        *(int *)((int)register0x00000010 + -0x31c) = *(int *)((int)register0x00000010 + 4) + 0x30c;
        *(undefined4 *)((int)register0x00000010 + -800) = 0x43752c;
        FUN_0040ecf0();
        iVar5 = *(int *)((int)register0x00000010 + 4);
        if (*(int *)(iVar5 + 0x310) == 0) {
          *(int *)((int)register0x00000010 + -8) = iVar5 + 0x200;
          *(undefined4 *)((int)register0x00000010 + -0x31c) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -800) = 0x43755a;
          FUN_0040f0e0();
          *(undefined4 *)((int)register0x00000010 + -0x31c) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x318) = 0;
          *(undefined4 *)((int)register0x00000010 + -800) = 0x437571;
          FUN_00402770();
          *(undefined4 *)((int)register0x00000010 + -0x31c) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x318) = 1;
          *(undefined4 *)((int)register0x00000010 + -800) = 0x437589;
          FUN_00402690();
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x1c) = 0;
        uVar7 = *(undefined4 *)(iVar5 + 0x310);
        *(code **)((int)register0x00000010 + -0x31c) = DuplicateHandle_exref;
        *(undefined4 *)((int)register0x00000010 + -0x318) = 0xffffffff;
        *(undefined4 *)((int)register0x00000010 + -0x314) = uVar7;
        *(undefined4 *)((int)register0x00000010 + -0x310) = 0xffffffff;
        *(undefined1 **)((int)register0x00000010 + -0x30c) =
             (undefined1 *)((int)register0x00000010 + -0x1c);
        *(undefined4 *)((int)register0x00000010 + -0x308) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x304) = 0;
        *(undefined4 *)((int)register0x00000010 + -0x300) = 2;
        *(undefined4 *)((int)register0x00000010 + -800) = 0x4375e6;
        FUN_00437210();
        if (*(int *)((int)register0x00000010 + -0x2fc) != 0) {
          *(undefined4 *)((int)register0x00000010 + -0x31c) =
               *(undefined4 *)((int)register0x00000010 + -0x10);
          *(undefined4 *)((int)register0x00000010 + -800) = 0x437603;
          FUN_0040f0e0();
          *(undefined4 *)((int)register0x00000010 + -0x2f7) = 0;
          puVar9 = (undefined4 *)((int)register0x00000010 + -0x2f4);
          for (iVar5 = 0xb6; iVar5 != 0; iVar5 = iVar5 + -1) {
            *puVar9 = 0;
            puVar9 = puVar9 + (uint)bVar11 * -2 + 1;
          }
          *(undefined4 **)((int)register0x00000010 + -0xc) =
               (undefined4 *)((uint)((int)register0x00000010 + -0x2e8) & 0xfffffff0);
          *(undefined4 *)((uint)((int)register0x00000010 + -0x2e8) & 0xfffffff0) = 0x10001;
          *(undefined **)((int)register0x00000010 + -0x31c) = &DAT_005f5e44;
          *(undefined4 *)((int)register0x00000010 + -800) = 0x43763c;
          FUN_0040ecf0();
          *(code **)((int)register0x00000010 + -0x31c) = SuspendThread_exref;
          *(undefined4 *)((int)register0x00000010 + -0x318) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -800) = 0x437655;
          FUN_00437030();
          if (*(int *)((int)register0x00000010 + -0x314) != -1) {
            *(code **)((int)register0x00000010 + -0x31c) = GetThreadContext_exref;
            *(undefined4 *)((int)register0x00000010 + -0x318) =
                 *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(undefined4 *)((int)register0x00000010 + -0x314) =
                 *(undefined4 *)((int)register0x00000010 + -0xc);
            *(undefined4 *)((int)register0x00000010 + -800) = 0x437684;
            FUN_00437080();
            *(undefined **)((int)register0x00000010 + -0x31c) = &DAT_005f5e44;
            *(undefined4 *)((int)register0x00000010 + -800) = 0x437694;
            FUN_0040f0e0();
            piVar1 = *(int **)((int)register0x00000010 + 4);
            puVar6 = (uint *)*piVar1;
            iVar5 = *(int *)((int)register0x00000010 + -0xc);
            uVar2 = *(uint *)(iVar5 + 0xc4);
            if (((((puVar6 == (uint *)0x0) || (uVar2 <= *puVar6)) || (puVar6[1] <= uVar2)) &&
                (((puVar6 = (uint *)piVar1[0xc], puVar6 == (uint *)0x0 || (uVar2 <= *puVar6)) ||
                 (puVar6[1] <= uVar2)))) &&
               (((puVar6 = (uint *)piVar1[0x14], puVar6 == (uint *)0x0 || (uVar2 <= *puVar6)) ||
                (puVar6[1] <= uVar2)))) {
              puVar6 = (uint *)0x0;
            }
            if (puVar6 == (uint *)0x0) {
              cVar8 = '\0';
              uVar7 = 0;
            }
            else {
              *(uint **)((int)register0x00000010 + -0x14) = puVar6;
              *(uint **)((int)register0x00000010 + -0x31c) = puVar6;
              *(undefined4 *)((int)register0x00000010 + -800) = 0x4376f0;
              FUN_0043a2e0();
              cVar8 = *(char *)((int)register0x00000010 + -0x318);
              uVar7 = *(undefined4 *)((int)register0x00000010 + -0x14);
              iVar5 = *(int *)((int)register0x00000010 + -0xc);
            }
            if (cVar8 != '\0') {
              uVar3 = *(undefined4 *)(iVar5 + 0xb8);
              uVar4 = *(undefined4 *)(iVar5 + 0xc4);
              *(undefined4 *)((int)register0x00000010 + -0x31c) = uVar7;
              *(undefined4 *)((int)register0x00000010 + -0x318) = uVar3;
              *(undefined4 *)((int)register0x00000010 + -0x314) = uVar4;
              *(undefined4 *)((int)register0x00000010 + -0x310) = 0;
              *(undefined4 *)((int)register0x00000010 + -800) = 0x437734;
              FUN_0043a350();
              if (*(char *)((int)register0x00000010 + -0x30c) != '\0') {
                iVar5 = *(int *)((int)register0x00000010 + -0xc);
                puVar9 = (undefined4 *)(*(int *)(iVar5 + 0xc4) + -4);
                *puVar9 = *(undefined4 *)((int)register0x00000010 + -0x308);
                *(undefined4 **)(iVar5 + 0xc4) = puVar9;
                *(undefined1 **)(iVar5 + 0xb8) = &LAB_0046f7e0;
                *(code **)((int)register0x00000010 + -0x31c) = SetThreadContext_exref;
                *(undefined4 *)((int)register0x00000010 + -0x318) =
                     *(undefined4 *)((int)register0x00000010 + -0x1c);
                *(int *)((int)register0x00000010 + -0x314) = iVar5;
                *(undefined4 *)((int)register0x00000010 + -800) = 0x437787;
                FUN_00437080();
              }
            }
            *(undefined4 *)((int)register0x00000010 + -0x31c) =
                 *(undefined4 *)((int)register0x00000010 + -4);
            *(undefined4 *)((int)register0x00000010 + -0x318) = 0;
            *(undefined4 *)((int)register0x00000010 + -800) = 0x43779e;
            FUN_00402770();
            *(int *)((int)register0x00000010 + -0x31c) =
                 *(int *)((int)register0x00000010 + 4) + 0x200;
            *(undefined4 *)((int)register0x00000010 + -0x318) = 1;
            *(undefined4 *)((int)register0x00000010 + -800) = 0x4377bb;
            FUN_00402690();
            *(code **)((int)register0x00000010 + -0x31c) = ResumeThread_exref;
            *(undefined4 *)((int)register0x00000010 + -0x318) =
                 *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(undefined4 *)((int)register0x00000010 + -800) = 0x4377d4;
            FUN_00437030();
            *(code **)((int)register0x00000010 + -0x31c) = CloseHandle_exref;
            *(undefined4 *)((int)register0x00000010 + -0x318) =
                 *(undefined4 *)((int)register0x00000010 + -0x1c);
            *(undefined4 *)((int)register0x00000010 + -800) = 0x4377ed;
            FUN_00437030();
            return;
          }
          *(int *)((int)register0x00000010 + -8) = *(int *)((int)register0x00000010 + 4) + 0x200;
          *(undefined **)((int)register0x00000010 + -0x31c) = &DAT_005f5e44;
          *(undefined4 *)((int)register0x00000010 + -800) = 0x437817;
          FUN_0040f0e0();
          *(code **)((int)register0x00000010 + -0x31c) = CloseHandle_exref;
          *(undefined4 *)((int)register0x00000010 + -0x318) =
               *(undefined4 *)((int)register0x00000010 + -0x1c);
          *(undefined4 *)((int)register0x00000010 + -800) = 0x437830;
          FUN_00437030();
          *(undefined4 *)((int)register0x00000010 + -0x31c) =
               *(undefined4 *)((int)register0x00000010 + -4);
          *(undefined4 *)((int)register0x00000010 + -0x318) = 0;
          *(undefined4 *)((int)register0x00000010 + -800) = 0x437847;
          FUN_00402770();
          *(undefined4 *)((int)register0x00000010 + -0x31c) =
               *(undefined4 *)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x318) = 1;
          *(undefined4 *)((int)register0x00000010 + -800) = 0x43785f;
          FUN_00402690();
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -800) = 0x43788f;
        FUN_0046f970();
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -0x31c);
        *(undefined4 *)((int)register0x00000010 + -800) = 0x43789e;
        FUN_0043a810();
        *(char **)((int)register0x00000010 + -0x31c) =
             "runtime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx failed (errno= runtime: NtCreateWaitCompletionPacket failed; errno=casfrom_Gscanstatus: gp->status is not in scan statenon-concurrent sweep failed to drain all sweep queuesruntime: NtCancelWaitCompletionPacket failed; errno= exited a goroutine internally locked to the OS threadcompileCallback: argument size is larger than uintptrsmall map with no empty slot (concurrent map writes?)runtime.m memory alignment too small for spinbit mutexmin size of malloc header is not a size class boundarygcControllerState.findRunnable: blackening not enabledno goroutines (m..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -0x318) = 0x30;
        *(undefined4 *)((int)register0x00000010 + -800) = 0x4378b4;
        FUN_0043b060();
        *(undefined4 *)((int)register0x00000010 + -0x31c) =
             *(undefined4 *)((int)register0x00000010 + -0x18);
        *(undefined4 *)((int)register0x00000010 + -0x318) = 0;
        *(undefined4 *)((int)register0x00000010 + -800) = 0x4378cb;
        FUN_0043ad50();
        *(undefined4 *)((int)register0x00000010 + -800) = 0x4378d0;
        FUN_0043aa10();
        *(undefined4 *)((int)register0x00000010 + -800) = 0x4378d5;
        FUN_0043a870();
        *(undefined **)((int)register0x00000010 + -0x31c) = &DAT_004cbf58;
        *(undefined4 *)((int)register0x00000010 + -0x318) = 0x28;
        *(undefined4 *)((int)register0x00000010 + -800) = 0x4378eb;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x31c) =
           "self-preempt [recovered]bad recoverybad g statusentersyscallwirep: p->m=) p->status=releasep: m= sysmonwait= preemptoff=cas64 failed m->gsignal=-byte limit\nruntime: sp=abi mismatchwrong timersmultipathtcpnot pollablegotypesaliashttpmuxgo121randautoseedtlsunsafeekmRCodeSuccessRCodeRefusedRtlMoveMemoryDeleteServiceRegEnumKeyExWRegOpenKeyExWStartServiceWCertOpenStoreGetIfEntry2ExFindNextFileWFindResourceWGetDriveTypeWMapViewOfFileModule32NextWThread32FirstVirtualUnlockWaitCommEventWriteConsoleWRtlGetVersionRtlInitStringCoTaskMemFreeEnumProcessesShellExecuteWExitWindowsExGetClassNameWtimeEndPeriodFreeAddrInfoWgethostbynamegetservbynameWTSFreeMemoryFindFirstFileRegDeleteKeyWRegEnumValueWdalTLDpSugct?level 3 resetsrmount errortimer expiredexchange fullwakeableSleepprofMemActiveprofMemFuturetraceStackTabexecRInternaltestRInternalGC sweep waitsynctest.Waitout of memory is nil, not value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedi..." /* TRUNCATED STRING LITERAL */
      ;
      *(undefined4 *)((int)register0x00000010 + -0x318) = 0xc;
      *(undefined4 *)((int)register0x00000010 + -800) = 0x437901;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar10 + -4) = 0x437907;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar10;
  } while( true );
}



/* Function: FUN_00437910 */

void FUN_00437910(int param_1)

{
  char local_4;
  
  while( true ) {
    FUN_00402540(param_1 + 0x328,0,1);
    if (local_4 != '\0') break;
    FUN_0046d890(&PTR_LAB_00536c28);
  }
  return;
}



/* Function: FUN_00437960 */

void FUN_00437960(void)

{
  undefined4 uVar1;
  int iVar2;
  undefined1 *puVar3;
  int in_FS_OFFSET;
  
  do {
    puVar3 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar3 = (undefined1 *)((int)register0x00000010 + -0x10);
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x437983;
      FUN_0046b840();
      if (*(int *)((int)register0x00000010 + -0xc) == 0) {
        iVar2 = 0;
        uVar1 = 0;
      }
      else {
        uVar1 = *(undefined4 *)(*(int *)((int)register0x00000010 + -0xc) + 4);
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0xc) = uVar1;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4379a4;
        FUN_00453940();
        uVar1 = *(undefined4 *)((int)register0x00000010 + -8);
        iVar2 = *(int *)((int)register0x00000010 + -4);
      }
      if (iVar2 < 8) {
LAB_004379d4:
        if (((**(int **)(in_FS_OFFSET + DAT_005f5ed0) == 0) ||
            (iVar2 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18), iVar2 == 0)) ||
           (*(int *)(iVar2 + 0x6c) == 0)) {
          return;
        }
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 0xc);
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x437a09;
        FUN_00469a20();
      }
      else {
        *(undefined4 *)((int)register0x00000010 + -0x10) = uVar1;
        *(undefined **)((int)register0x00000010 + -0xc) = &DAT_004c3162;
        *(undefined4 *)((int)register0x00000010 + -8) = 8;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4379cb;
        FUN_00402aa0();
        if (*(char *)((int)register0x00000010 + -4) == '\0') goto LAB_004379d4;
      }
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x437a1d;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar3 + -4) = 0x437a23;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar3;
  } while( true );
}



/* Function: FUN_00437a30 */

void FUN_00437a30(void)

{
  int iVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -8);
      if (((**(int **)(in_FS_OFFSET + DAT_005f5ed0) == 0) ||
          (iVar1 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18), iVar1 == 0)) ||
         (*(int *)(iVar1 + 0x6c) == 0)) {
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -8) = *(undefined4 *)((int)register0x00000010 + 4);
      *(undefined4 *)((int)register0x00000010 + -4) = *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x437a78;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x437a7e;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00438020 */

void FUN_00438020(void)

{
  undefined *puVar1;
  undefined4 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined4 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined4 *)((int)register0x00000010 + -0xc);
      *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)register0x00000010;
      *(undefined **)((int)register0x00000010 + -8) = &DAT_004c6d26;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x15;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x438051;
      FUN_00437960();
      puVar1 = PTR_PTR_005cefe0;
      if (PTR_PTR_005cefe0 != (undefined *)0x0) {
        puVar1 = *(undefined **)(PTR_PTR_005cefe0 + 4);
      }
      *(undefined **)((int)register0x00000010 + -0xc) = puVar1;
      *(undefined **)((int)register0x00000010 + -8) = PTR_PTR_005cefe4;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x438070;
      FUN_00469650();
    }
    *(undefined4 *)((int)puVar2 + -4) = 0x438076;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_00438080 */

void FUN_00438080(void)

{
  undefined *puVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -8);
      *(undefined **)((int)register0x00000010 + -8) = &DAT_004c724c;
      *(undefined4 *)((int)register0x00000010 + -4) = 0x16;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x4380a9;
      FUN_00437a30();
      puVar1 = PTR_PTR_005cf100;
      if (PTR_PTR_005cf100 != (undefined *)0x0) {
        puVar1 = *(undefined **)(PTR_PTR_005cf100 + 4);
      }
      *(undefined **)((int)register0x00000010 + -8) = puVar1;
      *(undefined **)((int)register0x00000010 + -4) = PTR_PTR_005cf104;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0x4380c8;
      FUN_00469650();
    }
    *(undefined4 *)(puVar2 + -4) = 0x4380ce;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_004380d0 */

void FUN_004380d0(int param_1)

{
  undefined4 uVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  int local_18;
  char local_10;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  uVar1 = *(undefined4 *)(param_1 + 0x14);
  uVar2 = *(undefined4 *)(param_1 + 0x10);
  *(undefined1 *)(param_1 + 1) = 0;
  do {
    FUN_00402520(uVar1);
    FUN_00467dc0(uVar1);
  } while (local_10 == '\0');
  iVar3 = local_18;
  if (local_18 == 0) {
    return;
  }
  do {
    iVar4 = iVar3;
    *(undefined4 *)(iVar4 + 4) = *(undefined4 *)(param_1 + 4);
    *(undefined4 *)(iVar4 + 8) = *(undefined4 *)(param_1 + 8);
    iVar3 = *(int *)(iVar4 + 0x10);
  } while (*(int *)(iVar4 + 0x10) != 0);
  if (DAT_005f5fd0 != 0) {
    FUN_0046eda0();
    *in_EDI = uVar2;
    in_EDI[1] = *(undefined4 *)(iVar4 + 0x10);
    in_EDI[2] = local_18;
    in_EDI[3] = *(undefined4 *)(param_1 + 0x10);
  }
  *(undefined4 *)(iVar4 + 0x10) = uVar2;
  *(int *)(param_1 + 0x10) = local_18;
  return;
}



/* Function: FUN_004381a0 */

void FUN_004381a0(void)

{
  uint uVar1;
  int *piVar2;
  int *piVar3;
  int iVar4;
  int *piVar5;
  int iVar6;
  int *piVar7;
  uint uVar8;
  int iVar9;
  int iVar10;
  undefined1 *puVar11;
  int in_FS_OFFSET;
  
  do {
    puVar11 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar11 = (undefined1 *)((int)register0x00000010 + -0x38);
      iVar4 = *(int *)((int)register0x00000010 + 4);
      piVar2 = *(int **)(iVar4 + 0x14);
      if (DAT_005f5fd0 != 0) {
        iVar9 = piVar2[3];
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4381d4;
        piVar5 = piVar2;
        FUN_0046ed70();
        *piVar5 = iVar9;
      }
      piVar2[3] = 0;
      iVar9 = piVar2[4];
      if (DAT_005f5fd0 != 0) {
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4381f3;
        piVar5 = piVar2;
        FUN_0046ed90();
        *piVar5 = iVar9;
        piVar5[1] = *(int *)(iVar4 + 0x14);
        piVar5[2] = piVar2[4];
      }
      *(int *)(iVar4 + 0x14) = iVar9;
      piVar2[4] = 0;
      if ((char)*piVar2 == '\0') {
        return;
      }
      *(int **)((int)register0x00000010 + -0xc) = piVar2;
      iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      piVar5 = (int *)(*(int *)(iVar4 + 0x18) + 0x7c);
      *piVar5 = *piVar5 + 1;
      iVar9 = *(int *)(iVar4 + 0x18);
      *(int *)((int)register0x00000010 + -0x18) = iVar9;
      iVar4 = *(int *)(iVar9 + 0x58);
      *(int *)((int)register0x00000010 + -4) = iVar4;
      if (*(int *)(iVar4 + 0x54) != *(int *)(iVar4 + 0x50)) {
LAB_0043824d:
        if (DAT_005f5fd0 != 0) {
          *(undefined **)((int)register0x00000010 + -0x38) = &DAT_004bbca0;
          *(int **)((int)register0x00000010 + -0x34) = piVar2;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x438269;
          FUN_00411e00();
          iVar9 = *(int *)((int)register0x00000010 + -0x18);
          iVar4 = *(int *)((int)register0x00000010 + -4);
          piVar2 = *(int **)((int)register0x00000010 + -0xc);
        }
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43827c;
        FUN_0046ef4a();
        uVar1 = *(uint *)(iVar4 + 0x54);
        uVar8 = *(int *)(iVar4 + 0x50) + 1;
        iVar6 = *(int *)(iVar4 + 0x4c);
        if (uVar1 < uVar8) {
          *(int *)((int)register0x00000010 + -0x38) = iVar6;
          *(uint *)((int)register0x00000010 + -0x34) = uVar8;
          *(uint *)((int)register0x00000010 + -0x30) = uVar1;
          *(undefined4 *)((int)register0x00000010 + -0x2c) = 1;
          *(undefined **)((int)register0x00000010 + -0x28) = &DAT_004a8240;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4382ac;
          FUN_0046a830();
          iVar6 = *(int *)((int)register0x00000010 + -0x24);
          uVar8 = *(uint *)((int)register0x00000010 + -0x20);
          iVar4 = *(int *)((int)register0x00000010 + -4);
          *(undefined4 *)(iVar4 + 0x54) = *(undefined4 *)((int)register0x00000010 + -0x1c);
          if (DAT_005f5fd0 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4382ce;
            FUN_0046ed80();
            *piVar2 = iVar6;
            piVar2[1] = *(int *)(iVar4 + 0x4c);
          }
          *(int *)(iVar4 + 0x4c) = iVar6;
          iVar9 = *(int *)((int)register0x00000010 + -0x18);
        }
        *(uint *)(iVar4 + 0x50) = uVar8;
        if (DAT_005f5fd0 == 0) {
          iVar4 = *(int *)((int)register0x00000010 + -0xc);
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4382f9;
          FUN_0046ed80();
          iVar4 = *(int *)((int)register0x00000010 + -0xc);
          *piVar2 = iVar4;
          piVar2[1] = *(int *)(iVar6 + -4 + uVar8 * 4);
        }
        *(int *)(iVar6 + -4 + uVar8 * 4) = iVar4;
        iVar4 = *(int *)(iVar9 + 0x7c);
        iVar6 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
        *(int *)(iVar9 + 0x7c) = iVar4 + -1;
        if ((iVar4 == 1) && (*(char *)(iVar6 + 0x69) != '\0')) {
          *(undefined4 *)(iVar6 + 8) = 0xfffffade;
        }
        return;
      }
      piVar3 = (int *)0x0;
      piVar5 = (int *)0x0;
      while( true ) {
        iVar9 = *(int *)(iVar4 + 0x50);
        if (iVar9 <= (int)(*(uint *)(iVar4 + 0x54) >> 1)) {
          *(int **)((int)register0x00000010 + -8) = piVar5;
          *(int **)((int)register0x00000010 + -0x14) = piVar3;
          *(undefined **)((int)register0x00000010 + -0x38) = &DAT_005d8568;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4383cc;
          FUN_0040ecf0();
          iVar4 = *(int *)((int)register0x00000010 + -0x14);
          iVar9 = DAT_005d856c;
          if (DAT_005f5fd0 == 0) {
            iVar6 = *(int *)((int)register0x00000010 + -8);
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4383ed;
            FUN_0046eda0();
            *piVar2 = iVar9;
            piVar2[1] = *(int *)(iVar4 + 0x10);
            iVar6 = *(int *)((int)register0x00000010 + -8);
            piVar2[2] = iVar6;
            piVar2[3] = DAT_005d856c;
          }
          *(int *)(iVar4 + 0x10) = iVar9;
          *(undefined **)((int)register0x00000010 + -0x38) = &DAT_005d8568;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43841d;
          DAT_005d856c = iVar6;
          FUN_0040f0e0();
          iVar9 = *(int *)((int)register0x00000010 + -0x18);
          iVar4 = *(int *)((int)register0x00000010 + -4);
          piVar2 = *(int **)((int)register0x00000010 + -0xc);
          goto LAB_0043824d;
        }
        iVar6 = *(int *)(iVar4 + 0x4c);
        piVar2 = *(int **)(iVar6 + -4 + iVar9 * 4);
        piVar7 = piVar5;
        if (DAT_005f5fd0 != 0) {
          *(int **)((int)register0x00000010 + -0x10) = piVar2;
          iVar10 = *(int *)(iVar6 + -4 + iVar9 * 4);
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43836b;
          FUN_0046ed70();
          *piVar2 = iVar10;
          piVar7 = piVar5;
          piVar2 = *(int **)((int)register0x00000010 + -0x10);
        }
        piVar5 = piVar2;
        *(undefined4 *)(iVar6 + -4 + iVar9 * 4) = 0;
        if (*(uint *)(iVar4 + 0x54) < iVar9 - 1U) break;
        *(uint *)(iVar4 + 0x50) = iVar9 - 1U;
        piVar2 = piVar5;
        if (piVar7 != (int *)0x0) {
          if (DAT_005f5fd0 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x4383a1;
            FUN_0046ed80();
            *piVar2 = (int)piVar5;
            piVar2[1] = piVar3[4];
            piVar2 = piVar5;
          }
          piVar3[4] = (int)piVar2;
          piVar5 = piVar7;
        }
        piVar3 = piVar2;
        piVar2 = *(int **)((int)register0x00000010 + -0xc);
      }
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x438435;
      FUN_0046ee30();
    }
    *(undefined4 *)(puVar11 + -4) = 0x43843b;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar11;
  } while( true );
}



/* Function: FUN_00438440 */

void FUN_00438440(void)

{
  int in_FS_OFFSET;
  undefined4 *unaff_retaddr;
  char local_38;
  undefined1 local_34 [48];
  undefined4 uStack_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    uStack_4 = 0x4384a7;
    FUN_0046d980();
  }
  FUN_0046ef43();
  uStack_4._0_3_ = CONCAT12(1,(undefined2)uStack_4);
  FUN_00438720(local_34);
  while( true ) {
    FUN_00438860(local_34);
    local_38 = (char)&stack0x00000004;
    if (local_38 == '\0') break;
    (*(code *)*unaff_retaddr)();
  }
  return;
}



/* Function: FUN_004384b0 */

void FUN_004384b0(int param_1)

{
  undefined4 uVar1;
  int iVar2;
  int *in_EDI;
  int in_FS_OFFSET;
  int local_18;
  int local_14;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  for (; param_1 != 0; param_1 = *(int *)(param_1 + 0xc)) {
    iVar2 = *(int *)(param_1 + 4);
    if (iVar2 != 0) {
      uVar1 = *(undefined4 *)(param_1 + 8);
      FUN_0040e3c0(&PTR_DAT_005cf1e0,iVar2);
      if (local_18 == 0) {
        (**(code **)(local_14 + 0xc))(uVar1);
        FUN_004682f0(iVar2,0);
        *(undefined **)(param_1 + 4) = &DAT_004adee0;
        iVar2 = local_18;
        if (DAT_005f5fd0 != 0) {
          FUN_0046ed80();
          *in_EDI = iVar2;
          in_EDI[1] = *(int *)(param_1 + 8);
        }
        *(int *)(param_1 + 8) = iVar2;
      }
      else if (local_18 == 1) {
        (**(code **)(local_14 + 0xc))(uVar1);
        FUN_004682f0(iVar2,1);
        *(undefined **)(param_1 + 4) = &DAT_004adee0;
        iVar2 = local_18;
        if (DAT_005f5fd0 != 0) {
          FUN_0046ed80();
          *in_EDI = iVar2;
          in_EDI[1] = *(int *)(param_1 + 8);
        }
        *(int *)(param_1 + 8) = iVar2;
      }
    }
  }
  FUN_004658e0();
  return;
}



/* Function: FUN_00438600 */

void FUN_00438600(int param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (*(int *)(param_1 + 0xc) != 0) {
    FUN_00438600(*(int *)(param_1 + 0xc));
    if (*(char *)(*(int *)(param_1 + 0xc) + 0x31) == '\0') {
      FUN_0043a810();
      FUN_0043b060(&DAT_0055044c,1);
      FUN_0043a870();
    }
  }
  if (*(char *)(param_1 + 0x31) == '\0') {
    FUN_0043a810();
    FUN_0043b060(&DAT_004c2f31,7);
    FUN_0043a870();
    FUN_0040bf40(*(undefined4 *)(param_1 + 4),*(undefined4 *)(param_1 + 8));
    if (*(char *)(param_1 + 0x30) != '\0') {
      FUN_0043a810();
      FUN_0043b060(" [recovered]bad recoverybad g statusentersyscallwirep: p->m=) p->status=releasep: m= sysmonwait= preemptoff=cas64 failed m->gsignal=-byte limit\nruntime: sp=abi mismatchwrong timersmultipathtcpnot pollablegotypesaliashttpmuxgo121randautoseedtlsunsafeekmRCodeSuccessRCodeRefusedRtlMoveMemoryDeleteServiceRegEnumKeyExWRegOpenKeyExWStartServiceWCertOpenStoreGetIfEntry2ExFindNextFileWFindResourceWGetDriveTypeWMapViewOfFileModule32NextWThread32FirstVirtualUnlockWaitCommEventWriteConsoleWRtlGetVersionRtlInitStringCoTaskMemFreeEnumProcessesShellExecuteWExitWindowsExGetClassNameWtimeEndPeriodFreeAddrInfoWgethostbynamegetservbynameWTSFreeMemoryFindFirstFileRegDeleteKeyWRegEnumValueWdalTLDpSugct?level 3 resetsrmount errortimer expiredexchange fullwakeableSleepprofMemActiveprofMemFuturetraceStackTabexecRInternaltestRInternalGC sweep waitsynctest.Waitout of memory is nil, not value method  span.base()=bad flushGen , not pointer != sweepgen  MB globals,  work.nproc=  work.nwait=  nStackRoots= flushedWork double unlock s.spanclass= MB) workers=min too large-byte block (runtime: val=runtime: seq=fatal error:  idlethreads= syscalltick=load64 failedxadd64 failedxchg64 failednil stackbase}\n\tsched={pc:, gp->status= pluginpath= : unknown pc  called from runtime: pid=GetTempPath2Wcrypto/subtlegocacheverifyinstallgoroothtml/templatetlsmaxrsasizeVirtualProtectis a directoryControlServiceCreateServiceWCryptGenRandomIsWellKnownSidMakeAbsoluteSDOpenSCManagerWSetThreadTokenCertCloseStoreClearCommBreakClearCommErrorCreateEventExWCreateMutexExWCreateProcessWFindFirstFileWFormatMessageWGetConsoleModeGetProcAddressGetTickCount64IsWow64ProcessLoadLibraryExWModule32FirstWProcess32NextWSetConsoleModeSetFilePointerSizeofResourceVirtualQueryExNetUserGetInfoCoInitializeExCoUninitializeGetUserNameExWTranslateNameWGetShellWindowVerQueryValueWgetprotobyname procedure in RegSetValueExWasynctimerchanfile too largelevel 2 haltedlevel 3 haltedtoo many linksno such deviceprotocol errortext file busytoo many userswinapi error #userArenaStateGC (dedicated)read m..." /* TRUNCATED STRING LITERAL */
                   ,0xc);
      FUN_0043a870();
    }
    FUN_0043a810();
    FUN_0043aa10();
    FUN_0043a870();
    return;
  }
  return;
}



/* Function: FUN_00438720 */

void FUN_00438720(int param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined4 *puVar4;
  int iVar5;
  int *in_EDI;
  int in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar5 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(undefined4 *)(param_1 + 0x10) = unaff_retaddr;
  puVar4 = &param_1;
  iVar3 = param_1;
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = (int)puVar4;
    in_EDI[1] = *(int *)(iVar3 + 0x14);
  }
  *(undefined4 **)(iVar3 + 0x14) = puVar4;
  if (*(char *)(iVar3 + 0x32) == '\0') {
    iVar2 = *(int *)(iVar5 + 0x10);
    if (DAT_005f5fd0 != 0) {
      FUN_0046edc0();
      *in_EDI = iVar2;
      in_EDI[1] = *(int *)(iVar3 + 0xc);
      in_EDI[2] = iVar3;
      in_EDI[3] = *(int *)(iVar5 + 0x10);
      in_EDI[4] = param_3;
      in_EDI[5] = *(int *)(iVar3 + 0x20);
    }
    *(int *)(iVar3 + 0xc) = iVar2;
    *(int *)(iVar5 + 0x10) = iVar3;
    *(undefined4 *)(iVar3 + 0x1c) = param_2;
    *(int *)(iVar3 + 0x20) = param_3;
    FUN_00438a10(iVar3);
    return;
  }
  if (DAT_005f5fd0 != 0) {
    FUN_0046ed80();
    *in_EDI = param_3;
    in_EDI[1] = *(int *)(iVar3 + 0x18);
  }
  *(int *)(iVar3 + 0x18) = param_3;
  puVar4 = *(undefined4 **)(iVar5 + 0x48);
  if (puVar4 != (undefined4 *)0x0) {
    iVar2 = param_3;
    if (DAT_005f5fd0 != 0) {
      iVar1 = *(int *)(iVar5 + 0x48);
      FUN_0046ed70();
      *in_EDI = iVar1;
    }
    *(undefined4 *)(iVar5 + 0x48) = 0;
    *(undefined4 *)(iVar3 + 0x24) = *puVar4;
    iVar5 = puVar4[1] + iVar2;
    if (DAT_005f5fd0 != 0) {
      FUN_0046ed80();
      *in_EDI = iVar5;
      in_EDI[1] = *(int *)(iVar3 + 0x28);
    }
    *(int *)(iVar3 + 0x28) = iVar5;
    iVar2 = iVar2 + puVar4[2];
    if (DAT_005f5fd0 != 0) {
      FUN_0046ed80();
      *in_EDI = iVar2;
      in_EDI[1] = *(int *)(iVar3 + 0x2c);
    }
    *(int *)(iVar3 + 0x2c) = iVar2;
  }
  return;
}



/* Function: FUN_00438860 */

void FUN_00438860(void)

{
  byte bVar1;
  byte *pbVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 uVar5;
  uint uVar6;
  int iVar7;
  undefined1 *puVar8;
  undefined4 *in_EDI;
  int in_FS_OFFSET;
  
  do {
    puVar8 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar8 = (undefined1 *)((int)register0x00000010 + -0x10);
      puVar4 = *(undefined4 **)((int)register0x00000010 + 4);
      iVar7 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      if (*(char *)((int)puVar4 + 0x32) != '\0') goto LAB_004388a3;
      if (*(undefined4 **)(iVar7 + 0x10) == puVar4) {
        if (*(char *)(puVar4 + 0xc) == '\0') {
LAB_004388a3:
          uVar5 = puVar4[5];
          if (DAT_005f5fd0 != 0) {
            *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4388b5;
            FUN_0046ed80();
            *in_EDI = uVar5;
            in_EDI[1] = *puVar4;
          }
          *(int *)((int)register0x00000010 + -8) = iVar7;
          *puVar4 = uVar5;
          do {
            pbVar2 = (byte *)puVar4[10];
            if (pbVar2 != (byte *)0x0) {
              bVar1 = *pbVar2;
              if (bVar1 != 0) {
                iVar7 = -7 - ((byte)"lock: sleeping while lock is availableP has cached GC work at end of mark terminationfailed to acquire lock to start a GC transitionfinishGCTransition called without starting one?tried to sleep scavenger from another goroutineruntime: CreateIoCompletionPort failed (errno= racy sudog adjustment due to parking on channelfunction symbol table not sorted by PC offset: attempted to trace a bad status for a goroutineslice bounds out of range [:%x] with capacity %yruntime: waitforsingleobject unexpected; result=CreateWaitableTimerEx when creating timer failedruntime.preemptM: duplicatehandle failed; errno=runtime: malformed profBuf buffer - invalid sizeattempt to trace invalid or unsupported P statusruntime: waitforsingleobject wait_failed; errno=invalid or incomplete multibyte or wide characterslice bounds out of range [::%x] with capacity %yinvalid memory address or nil pointer dereferencepanicwrap: unexpected string after package name: runtime: unexpected waitm - semaphore out of syncs.allocCount != s.nelems && freeIndex == s.nelemssweeper left outstanding across sweep generationsfully empty unfreed span set block found in resetcasgstatus: waiting for Gwaiting but is Grunnableruntime: unable to acquire - semaphore out of syncmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewattempt to execute system stack code on user stackcompileCallback: function argument frame too largeGetFinalPathNameByHandle returned unexpected path: limiterEvent.stop: invalid limiter event type foundpotentially overlapping in-use allocations detectedruntime: netpoll: PostQueuedCompletionStatus failedfatal: systemstack called from unexpected goroutinegodebug: Value of name not listed in godebugs.All: ConvertSecurityDescriptorToStringSecurityDescriptorWConvertStringSecurityDescriptorToSecurityDescriptorWruntime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nspan set block with unpopped elements found in resetruntime: GetQueuedCompletionStatusEx fail..." /* TRUNCATED STRING LITERAL */
                                    [bVar1 + 0x1510] - 8);
                uVar6 = -iVar7;
                *pbVar2 = ~((byte)(1 << ((byte)uVar6 & 0x1f)) & -(uVar6 < 0x20)) & bVar1;
                *(undefined4 *)((int)register0x00000010 + 8) =
                     *(undefined4 *)(puVar4[0xb] + iVar7 * -4);
                *(undefined1 *)((int)register0x00000010 + 0xc) = 1;
                return;
              }
              if (DAT_005f5fd0 != 0) {
                uVar5 = puVar4[10];
                *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4388f2;
                FUN_0046ed70();
                *in_EDI = uVar5;
              }
              puVar4[10] = 0;
            }
            while ((iVar3 = *(int *)(iVar7 + 0x14), iVar3 != 0 && (*(int *)(iVar3 + 4) == puVar4[6])
                   )) {
              if (*(char *)(iVar3 + 1) == '\0') {
                *(undefined4 *)((int)register0x00000010 + -4) = *(undefined4 *)(iVar3 + 0xc);
                puVar4[9] = *(undefined4 *)(iVar3 + 8);
                *(int *)((int)register0x00000010 + -0x10) = iVar7;
                *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4389a5;
                FUN_004381a0();
                *(undefined4 *)((int)register0x00000010 + 8) =
                     *(undefined4 *)((int)register0x00000010 + -4);
                *(undefined1 *)((int)register0x00000010 + 0xc) = 1;
                return;
              }
              *(int *)((int)register0x00000010 + -0x10) = iVar3;
              *(undefined4 *)((int)register0x00000010 + -0x14) = 0x43895b;
              FUN_004380d0();
              *(undefined4 *)((int)register0x00000010 + -0x10) =
                   *(undefined4 *)((int)register0x00000010 + -8);
              *(undefined4 *)((int)register0x00000010 + -0x14) = 0x438967;
              FUN_004381a0();
              iVar7 = *(int *)((int)register0x00000010 + -8);
              puVar4 = *(undefined4 **)((int)register0x00000010 + 4);
            }
            *(undefined4 **)((int)register0x00000010 + -0x10) = puVar4;
            *(undefined4 *)((int)register0x00000010 + -0x14) = 0x438905;
            FUN_00438a10();
            if (*(char *)((int)register0x00000010 + -0xc) == '\0') {
              *(undefined4 *)((int)register0x00000010 + 8) = 0;
              *(undefined1 *)((int)register0x00000010 + 0xc) = 0;
              return;
            }
            iVar7 = *(int *)((int)register0x00000010 + -8);
            puVar4 = *(undefined4 **)((int)register0x00000010 + 4);
          } while( true );
        }
        *(undefined ***)((int)register0x00000010 + -0x10) = &PTR_LAB_00536c54;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4389d5;
        FUN_0046d830();
        *(char **)((int)register0x00000010 + -0x10) =
             "recovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
        ;
        *(undefined4 *)((int)register0x00000010 + -0xc) = 0xf;
        *(undefined4 *)((int)register0x00000010 + -0x14) = 0x4389eb;
        FUN_00469a20();
      }
      *(char **)((int)register0x00000010 + -0x10) =
           "bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid exchangeno route to hostinvalid argumentmessage too longobject is remoteremote I/O errorSetFilePointerExinteger overflowgcshrinkstackofftracefpunwindoffGC scavenge waitGC worker (idle)page trace flush/gc/gogc:percent, not a functiongc: unswept span KiB work (bg),  mheap.sweepgen=runtime: nelems=workbuf is emptymSpanList.removemSpanList.insertbad special kindbad summary dataruntime: addr = runtime: base = runtime: head = timeBeginPeriod"
      ;
      *(undefined4 *)((int)register0x00000010 + -0xc) = 0xf;
      *(undefined4 *)((int)register0x00000010 + -0x14) = 0x438a01;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar8 + -4) = 0x438a07;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar8;
  } while( true );
}



/* Function: FUN_00438a10 */

void FUN_00438a10(int param_1,undefined1 param_2)

{
  int in_FS_OFFSET;
  undefined1 *local_10;
  undefined4 local_c;
  int local_8;
  undefined1 *local_4;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    local_4 = (undefined1 *)0x438a7b;
    FUN_0046d980();
  }
  param_2 = 0;
  if (*(int *)(param_1 + 0x1c) == 0) {
    return;
  }
  local_c = **(undefined4 **)(in_FS_OFFSET + DAT_005f5ed0);
  local_10 = &LAB_00438a80;
  local_8 = param_1;
  local_4 = &param_2;
  FUN_0046d890(&local_10);
  return;
}



/* Function: FUN_00438bc0 */

void FUN_00438bc0(void)

{
  byte bVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  int *piVar4;
  int iVar5;
  byte bVar6;
  int *piVar7;
  int *piVar8;
  char *pcVar9;
  byte *pbVar10;
  int iVar11;
  undefined1 *puVar12;
  uint uVar13;
  int iVar14;
  int in_FS_OFFSET;
  
code_r0x00438bc0:
  puVar12 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
    puVar12 = (undefined1 *)((int)register0x00000010 + -0x1c);
    puVar2 = *(undefined4 **)((int)register0x00000010 + 8);
    if (*(byte *)((int)puVar2 + 0x2b) < 5) {
      pbVar10 = (byte *)0x0;
    }
    else {
      pbVar10 = (byte *)(*(int *)(*(int *)((int)register0x00000010 + 0xc) + 0xa0) +
                         puVar2[puVar2[7] + 0xf] & (puVar2[puVar2[7] + 0xf] == -1) - 1);
    }
    if (pbVar10 == (byte *)0x0) {
      *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
      return;
    }
    if (puVar2[3] != 0) {
      piVar7 = (int *)0x0;
      uVar13 = 0;
      do {
        bVar1 = *pbVar10;
        pbVar10 = pbVar10 + 1;
        bVar6 = (byte)uVar13;
        if (bVar1 < 0x80) {
          if ((int)uVar13 < 0) goto LAB_00438d78;
          pcVar9 = (char *)(*(int *)((int)register0x00000010 + 0x10) -
                           ((int)piVar7 + ((uint)bVar1 << (bVar6 & 0x1f) & -(uint)(uVar13 < 0x20))))
          ;
          if (*pcVar9 == '\0') {
            *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
            return;
          }
          iVar14 = 0;
          piVar4 = (int *)0x0;
          goto LAB_00438c91;
        }
        uVar13 = uVar13 + 7;
        piVar7 = (int *)(((bVar1 & 0x7f) << (bVar6 & 0x1f)) + (int)piVar7);
      } while ((int)uVar13 < 0x1d);
      goto LAB_00438d7d;
    }
    goto LAB_00438d95;
  }
  goto LAB_00438dac;
LAB_00438c91:
  piVar8 = piVar4;
  bVar1 = *pbVar10;
  bVar6 = (byte)iVar14;
  if (bVar1 < 0x80) goto LAB_00438cb4;
  iVar14 = iVar14 + 7;
  if (0x1c < iVar14) goto LAB_00438d60;
  pbVar10 = pbVar10 + 1;
  piVar4 = (int *)(((bVar1 & 0x7f) << (bVar6 & 0x1f)) + (int)piVar8);
  piVar7 = piVar8;
  goto LAB_00438c91;
LAB_00438cb4:
  if (-1 < iVar14) {
    *(char **)((int)register0x00000010 + -4) = pcVar9;
    *(int *)((int)register0x00000010 + -0x10) = iVar14;
    *(int **)((int)register0x00000010 + -0xc) = piVar8;
    *(uint *)((int)register0x00000010 + -8) = (uint)bVar1 << (bVar6 & 0x1f);
    uVar3 = *puVar2;
    *(undefined4 *)((int)register0x00000010 + -0x1c) =
         *(undefined4 *)((int)register0x00000010 + 0xc);
    *(undefined4 *)((int)register0x00000010 + -0x18) = uVar3;
    *(undefined4 *)((int)register0x00000010 + -0x20) = 0x438ce7;
    FUN_00453810();
    iVar14 = *(int *)((int)register0x00000010 + 4);
    *(int *)(iVar14 + 0x24) =
         *(int *)((int)register0x00000010 + -0x14) +
         *(int *)(*(int *)((int)register0x00000010 + 8) + 0xc);
    iVar11 = *(int *)((int)register0x00000010 + -0xc) +
             (*(uint *)((int)register0x00000010 + -8) &
             -(uint)(*(uint *)((int)register0x00000010 + -0x10) < 0x20));
    if (DAT_005f5fd0 == 0) {
      iVar5 = *(int *)((int)register0x00000010 + -4);
    }
    else {
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x438d23;
      FUN_0046ed80();
      iVar5 = *(int *)((int)register0x00000010 + -4);
      *piVar7 = iVar5;
      piVar7[1] = *(int *)(iVar14 + 0x28);
    }
    *(int *)(iVar14 + 0x28) = iVar5;
    iVar11 = *(int *)((int)register0x00000010 + 0x10) - iVar11;
    if (DAT_005f5fd0 != 0) {
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x438d47;
      FUN_0046ed80();
      *piVar7 = iVar11;
      piVar7[1] = *(int *)(iVar14 + 0x2c);
    }
    *(int *)(iVar14 + 0x2c) = iVar11;
    *(undefined1 *)((int)register0x00000010 + 0x14) = 1;
    return;
  }
  *(undefined4 *)((int)register0x00000010 + -0x20) = 0x438d60;
  FUN_00438020();
LAB_00438d60:
  *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004adee0;
  *(undefined ***)((int)register0x00000010 + -0x18) = &PTR_DAT_00550d20;
  *(undefined4 *)((int)register0x00000010 + -0x20) = 0x438d78;
  FUN_00469650();
LAB_00438d78:
  *(undefined4 *)((int)register0x00000010 + -0x20) = 0x438d7d;
  FUN_00438020();
LAB_00438d7d:
  *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004adee0;
  *(undefined ***)((int)register0x00000010 + -0x18) = &PTR_DAT_00550d20;
  *(undefined4 *)((int)register0x00000010 + -0x20) = 0x438d95;
  FUN_00469650();
LAB_00438d95:
  *(undefined **)((int)register0x00000010 + -0x1c) = &DAT_004c62d3;
  *(undefined4 *)((int)register0x00000010 + -0x18) = 0x13;
  *(undefined4 *)((int)register0x00000010 + -0x20) = 0x438dab;
  FUN_00469a20();
LAB_00438dac:
  *(undefined4 *)(puVar12 + -4) = 0x438db1;
  FUN_0046d980();
  register0x00000010 = (BADSPACEBASE *)puVar12;
  goto code_r0x00438bc0;
}



/* Function: FUN_00438dc0 */

void FUN_00438dc0(int param_1)

{
  int *piVar1;
  int in_FS_OFFSET;
  
  piVar1 = *(int **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x10);
  if ((((piVar1 != (int *)0x0) && (*(char *)((int)piVar1 + 0x31) == '\0')) &&
      ((char)piVar1[0xc] == '\0')) && (param_1 == *piVar1)) {
    *(undefined1 *)(piVar1 + 0xc) = 1;
    return;
  }
  return;
}



/* Function: FUN_00438e80 */

void FUN_00438e80(undefined4 param_1,undefined4 param_2)

{
  char cVar1;
  int iVar2;
  int in_FS_OFFSET;
  undefined1 *local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  FUN_0043a810();
  local_c = &LAB_00438f00;
  local_4 = param_2;
  local_8 = param_1;
  FUN_0046d890(&local_c);
  FUN_004391d0(1);
  iVar2 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  cVar1 = *(char *)(iVar2 + 0x8b);
  *(char *)(iVar2 + 0x8b) = cVar1 + -1;
  if (cVar1 == '\x01') {
    FUN_0040f0e0(&DAT_005f5e5c);
  }
  return;
}



/* Function: FUN_004391d0 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_004391d0(undefined4 param_1)

{
  int in_FS_OFFSET;
  undefined1 *local_10;
  int local_c;
  undefined4 *local_4;
  
  local_c = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  local_4 = &param_1;
  if (*(int *)(*(int *)(local_c + 0x18) + 0x70) == 0) {
    *(undefined4 *)(*(int *)(local_c + 0x18) + 0x70) = param_1;
  }
  local_10 = &LAB_00439230;
  FUN_0046d890(&local_10);
  _DAT_00000000 = 0;
  return;
}



/* Function: FUN_004392b0 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_004392b0(undefined4 param_1)

{
  int in_FS_OFFSET;
  char local_19;
  undefined1 *local_18;
  undefined4 local_14;
  char *local_10;
  undefined4 local_c;
  undefined4 *local_4;
  
  local_4 = &param_1;
  local_c = **(undefined4 **)(in_FS_OFFSET + DAT_005f5ed0);
  local_19 = '\0';
  local_18 = &LAB_00439340;
  local_14 = param_1;
  local_10 = &local_19;
  FUN_0046d890(&local_18);
  if (local_19 != '\0') {
    FUN_0044e4b0(0,0);
  }
  FUN_0046d890(&PTR_LAB_00536ad0);
  _DAT_00000000 = 0;
  return;
}



/* Function: FUN_004393f0 */

void FUN_004393f0(void)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  if (DAT_005e2398 == 0) {
    FUN_0043a810();
    FUN_0043b060(&DAT_004ccbec,0x2e);
    FUN_0043a870();
  }
  piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x6c);
  *piVar1 = *piVar1 + 1;
  if (*(int *)(*(int *)(iVar2 + 0x18) + 0x7c) < 0) {
    *(undefined4 *)(*(int *)(iVar2 + 0x18) + 0x7c) = 1;
  }
  iVar2 = *(int *)(iVar2 + 0x18);
  iVar3 = *(int *)(iVar2 + 0x80);
  if (iVar3 != 0) {
    if (iVar3 != 1) {
      if (iVar3 == 2) {
        *(undefined4 *)(iVar2 + 0x80) = 3;
        FUN_0043a810();
        FUN_0043b060(&DAT_004c80d7,0x18);
        FUN_0043a870();
        FUN_00435f00(4);
      }
      FUN_00435f00(5);
      return;
    }
    *(undefined4 *)(iVar2 + 0x80) = 2;
    FUN_0043a810();
    FUN_0043b060(&DAT_004c62f9,0x13);
    FUN_0043a870();
    return;
  }
  *(undefined4 *)(iVar2 + 0x80) = 1;
  FUN_00402690(&DAT_005f5e4c,1);
  FUN_0040ecf0(&DAT_005f5e50);
  if ((0 < DAT_005f623c) || (0 < DAT_005f6238)) {
    FUN_00447e60(1);
  }
  FUN_0043cf00();
  return;
}



/* Function: FUN_00439560 */

void FUN_00439560(int param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int *piVar5;
  int in_FS_OFFSET;
  undefined *in_stack_ffffffd8;
  char cVar6;
  undefined4 in_stack_ffffffdc;
  int in_stack_ffffffe0;
  
  while (cVar6 = (char)in_stack_ffffffdc,
        &stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar1 = *(int *)(param_1 + 0x90);
  if (iVar1 != 0) {
    FUN_0043a810();
    FUN_0043b060(&DAT_004c316a,8);
    FUN_0043aef0(iVar1,0);
    FUN_0043a870();
    uVar2 = *(undefined4 *)(param_1 + 0xa0);
    uVar3 = *(undefined4 *)(param_1 + 0xa4);
    uVar4 = *(undefined4 *)(param_1 + 0xa8);
    FUN_0043a810();
    FUN_0043b060(&DAT_004c2d9e,6);
    FUN_0043aef0(uVar2,0);
    FUN_0043b060(&DAT_004c2da4,6);
    FUN_0043aef0(uVar3,0);
    FUN_0043b060(&DAT_004c2b1d,4);
    FUN_0043aef0(uVar4,0);
    in_stack_ffffffd8 = &DAT_004c2956;
    cVar6 = '\x02';
    FUN_0043b060();
    FUN_0043a870();
  }
  FUN_0044b430();
  if (0 < (int)in_stack_ffffffd8) {
    piVar5 = *(int **)(param_1 + 0x18);
    iVar1 = piVar5[0x14];
    if (*piVar5 == param_1) {
      if ((1 < (int)in_stack_ffffffd8) || (1 < (uint)piVar5[0x1c])) {
        FUN_0043a810();
        FUN_0043b060("\nruntime stack:\ninvalid g statuscastogscanstatusbad g transitionschedule: in cgoreflect mismatch untyped locals missing stackmapbad symbol tablenon-Go function\npointerless type not in ranges:\nGetCurrentThreadGetModuleHandleWRtlVirtualUnwindGODEBUG: value \"allowmultiplevcsRCodeFormatError[bisect-match 0xChaCha20Nonce.txtAdjustTokenGroupsIsTokenRestrictedLookupAccountSidWCertFindExtensionCryptDecodeObjectDnsRecordListFreeGetShortPathNameWReadProcessMemoryQueryWorkingSetExGetKeyboardLayoutWSAEnumProtocolsWWTSQueryUserTokenwinreadlinkvolumeRegLoadMUIStringWGTB Standard TimeFLE Standard TimeGMT Standard Timepermission deniedwrong medium typeno data availableexec format errorGetCurrentProcessgoroutine profileAllThreadsSyscallGC assist markingselect (no cases)sync.RWMutex.Lockwait for GC cycletrace proc statusselect (synctest)sync.(*Cond).Wait: missing method notetsleepg on g0bad TinySizeClassruntime: pointer g already scannedmark - bad statusscanobject n == 0swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
                     ,0x10);
        FUN_0043a870();
        in_stack_ffffffe0 = 0;
        FUN_0045a440(param_2,param_3,0,param_1,0);
      }
    }
    else {
      FUN_0043a810();
      FUN_0043aa10();
      FUN_0043a870();
      FUN_0045ba70(param_1);
      in_stack_ffffffe0 = 0;
      FUN_0045a440(param_2,param_3,0,param_1,0);
    }
    if ((DAT_005f5dac == '\0') && (iVar1 != param_1 || cVar6 != '\0')) {
      DAT_005f5dac = '\x01';
      FUN_0045be60(param_1);
    }
  }
  FUN_0040f0e0(&DAT_005f5e50);
  FUN_00402690(&DAT_005f5e4c,0xffffffff);
  if (in_stack_ffffffe0 != 0) {
    FUN_0040ecf0(&DAT_005f5e54);
    FUN_0040ecf0(&DAT_005f5e54);
  }
  return;
}



/* Function: FUN_00439810 */

void FUN_00439810(void)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int in_FS_OFFSET;
  undefined4 local_c;
  
  iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  piVar1 = (int *)(*(int *)(iVar2 + 0x18) + 0x7c);
  *piVar1 = *piVar1 + 1;
  iVar3 = *(int *)(iVar2 + 0x18);
  if (*(int *)(iVar3 + 0x50) != iVar2) {
    iVar2 = *(int *)(iVar3 + 0x7c);
    iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    *(int *)(iVar3 + 0x7c) = iVar2 + -1;
    if ((iVar2 == 1) && (*(char *)(iVar4 + 0x69) != '\0')) {
      *(undefined4 *)(iVar4 + 8) = 0xfffffade;
    }
    return;
  }
  iVar4 = *(int *)(iVar3 + 0x7c);
  if ((((iVar4 == 1) && (*(int *)(iVar3 + 0x6c) == 0)) && (*(int *)(iVar3 + 0x70) == 0)) &&
     ((*(int *)(iVar3 + 0x78) == 0 && (*(int *)(iVar3 + 0x80) == 0)))) {
    FUN_00402510(iVar2 + 0x4c);
    if (((local_c & 0xffffefff) == 2) && (*(int *)(iVar2 + 0x38) == 0)) {
      if (*(int *)(iVar3 + 0x1d8) != 0) {
        iVar2 = *(int *)(iVar3 + 0x7c);
        iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
        *(int *)(iVar3 + 0x7c) = iVar2 + -1;
        if ((iVar2 == 1) && (*(char *)(iVar4 + 0x69) != '\0')) {
          *(undefined4 *)(iVar4 + 8) = 0xfffffade;
        }
        return;
      }
      iVar2 = *(int *)(iVar3 + 0x7c);
      iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      *(int *)(iVar3 + 0x7c) = iVar2 + -1;
      if ((iVar2 == 1) && (*(char *)(iVar4 + 0x69) != '\0')) {
        *(undefined4 *)(iVar4 + 8) = 0xfffffade;
      }
      return;
    }
    iVar2 = *(int *)(iVar3 + 0x7c);
    iVar4 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
    *(int *)(iVar3 + 0x7c) = iVar2 + -1;
    if ((iVar2 == 1) && (*(char *)(iVar4 + 0x69) != '\0')) {
      *(undefined4 *)(iVar4 + 8) = 0xfffffade;
    }
    return;
  }
  iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(int *)(iVar3 + 0x7c) = iVar4 + -1;
  if ((iVar4 == 1) && (*(char *)(iVar2 + 0x69) != '\0')) {
    *(undefined4 *)(iVar2 + 8) = 0xfffffade;
  }
  return;
}



/* Function: FUN_00439990 */

void FUN_00439990(undefined4 param_1)

{
  undefined4 local_8;
  
  FUN_0046b840(param_1);
  if (local_8 != 0) {
    return;
  }
  return;
}



/* Function: FUN_00439b00 */

void FUN_00439b00(void)

{
  int *piVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  undefined1 *puVar7;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x1c);
      *(int *)((int)register0x00000010 + -4) = *(int *)((int)register0x00000010 + 4) + 0x30;
      *(int *)((int)register0x00000010 + -0x1c) = *(int *)((int)register0x00000010 + 4) + 0x30;
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x439b2d;
      FUN_00402520();
      iVar3 = *(int *)((int)register0x00000010 + -0x18);
      if (iVar3 == 0) {
        return;
      }
      uVar2 = *(ushort *)(*(int *)((int)register0x00000010 + 4) + 0x1a);
      uVar5 = ((uint)uVar2 * 2 + 7 >> 3) + 7;
      uVar6 = uVar5 >> 3;
      if (uVar6 * 8 <= (uint)-iVar3) {
        iVar4 = 0;
        while( true ) {
          if ((int)uVar6 <= iVar4) {
            *(undefined4 *)((int)register0x00000010 + -0x1c) =
                 *(undefined4 *)((int)register0x00000010 + -4);
            *(undefined4 *)((int)register0x00000010 + -0x18) = 0;
            *(undefined4 *)((int)register0x00000010 + -0x20) = 0x439c0c;
            FUN_00408fc0();
            return;
          }
          piVar1 = (int *)(iVar3 + iVar4 * 8);
          if (piVar1[1] != 0 || *piVar1 != 0) break;
          iVar4 = iVar4 + 1;
        }
        *(int *)((int)register0x00000010 + -8) = iVar3;
        *(uint *)((int)register0x00000010 + -0xc) = uVar5 & 0xfffffff8;
        *(uint *)((int)register0x00000010 + -0x1c) = (uint)uVar2 * 2;
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x439bbe;
        FUN_0042c440();
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + -0x18);
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + -0x18);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -8);
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + -0xc);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x439be0;
        FUN_0046f640();
        *(undefined4 *)((int)register0x00000010 + -0x1c) =
             *(undefined4 *)((int)register0x00000010 + -4);
        *(undefined4 *)((int)register0x00000010 + -0x18) =
             *(undefined4 *)((int)register0x00000010 + -0x10);
        *(undefined4 *)((int)register0x00000010 + -0x20) = 0x439bf5;
        FUN_00408fc0();
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x439c15;
      FUN_00464550();
      *(undefined4 *)((int)register0x00000010 + -0x20) = 0x439c1a;
      FUN_00464550();
    }
    *(undefined4 *)(puVar7 + -4) = 0x439c20;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_00439c30 */

void FUN_00439c30(void)

{
  int *piVar1;
  undefined1 uVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined1 *puVar7;
  undefined4 uVar8;
  uint uVar9;
  int iVar10;
  int iVar11;
  int in_FS_OFFSET;
  bool bVar12;
  
code_r0x00439c30:
  puVar7 = (undefined1 *)register0x00000010;
  if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0xc) < register0x00000010) {
    puVar7 = (undefined1 *)((int)register0x00000010 + -0x40);
    iVar10 = *(int *)(*(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18) + 0x50);
    if (iVar10 == 0) {
LAB_00439c73:
      uVar2 = 0;
      uVar4 = 0;
      uVar6 = 0;
      uVar8 = 0;
      iVar10 = 0;
      iVar11 = 0;
      uVar5 = 0;
      *(undefined4 *)((int)register0x00000010 + -0x24) = 0;
      do {
        *(undefined4 *)((int)register0x00000010 + -0x1c) = uVar8;
        *(undefined4 *)((int)register0x00000010 + -0x18) = uVar6;
        *(int *)((int)register0x00000010 + -0x20) = iVar11;
        *(undefined4 *)((int)register0x00000010 + -0xc) = uVar5;
        *(undefined4 *)((int)register0x00000010 + -8) = uVar4;
        *(undefined1 *)((int)register0x00000010 + -0x2e) = uVar2;
        *(int *)((int)register0x00000010 + -0x14) = iVar10;
        *(int *)((int)register0x00000010 + -0x40) = *(int *)((int)register0x00000010 + 4) + 0x4c;
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439cd8;
        FUN_00402510();
        uVar9 = *(uint *)((int)register0x00000010 + -0x3c);
        if (uVar9 < 5) {
          if (uVar9 == 1) {
            uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
          }
          else {
            if (uVar9 == 2) {
              iVar10 = *(int *)((int)register0x00000010 + 4);
              if (*(char *)(iVar10 + 0x6a) == '\0') {
                iVar11 = *(int *)((int)register0x00000010 + -8);
                bVar12 = false;
              }
              else if (*(char *)(iVar10 + 0x69) == '\0') {
                iVar11 = *(int *)((int)register0x00000010 + -8);
                bVar12 = false;
              }
              else if (*(int *)(iVar10 + 8) == -0x522) {
                iVar11 = *(int *)((int)register0x00000010 + -8);
                if (*(int *)(iVar10 + 0x18) == iVar11) {
                  *(int *)((int)register0x00000010 + -0x40) = iVar11 + 0x200;
                  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439d31;
                  FUN_00402510();
                  bVar12 = *(int *)((int)register0x00000010 + -0x3c) ==
                           *(int *)((int)register0x00000010 + -0xc);
                  iVar10 = *(int *)((int)register0x00000010 + 4);
                  iVar11 = *(int *)((int)register0x00000010 + -8);
                }
                else {
                  bVar12 = false;
                }
              }
              else {
                iVar11 = *(int *)((int)register0x00000010 + -8);
                bVar12 = false;
              }
              if (bVar12) {
                uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
                uVar5 = *(undefined4 *)((int)register0x00000010 + -0xc);
                iVar10 = *(int *)((int)register0x00000010 + -0x18);
                uVar9 = *(uint *)((int)register0x00000010 + -0x1c);
              }
              else {
                *(int *)((int)register0x00000010 + -0x40) = iVar10;
                *(undefined4 *)((int)register0x00000010 + -0x3c) = 2;
                *(undefined4 *)((int)register0x00000010 + -0x38) = 0x1002;
                *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439d90;
                FUN_0043d540();
                if (*(char *)((int)register0x00000010 + -0x34) == '\0') {
                  uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
                  iVar11 = *(int *)((int)register0x00000010 + -8);
                  uVar5 = *(undefined4 *)((int)register0x00000010 + -0xc);
                  iVar10 = *(int *)((int)register0x00000010 + -0x18);
                  uVar9 = *(uint *)((int)register0x00000010 + -0x1c);
                }
                else {
                  iVar10 = *(int *)((int)register0x00000010 + 4);
                  *(undefined2 *)(iVar10 + 0x69) = 0x101;
                  *(undefined4 *)(iVar10 + 8) = 0xfffffade;
                  iVar10 = *(int *)(iVar10 + 0x18);
                  *(int *)((int)register0x00000010 + -4) = iVar10;
                  *(int *)((int)register0x00000010 + -0x40) = iVar10 + 0x200;
                  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439dde;
                  FUN_00402510();
                  *(int *)((int)register0x00000010 + -0x10) =
                       *(int *)((int)register0x00000010 + -0x3c);
                  if (*(int *)((int)register0x00000010 + -8) ==
                      *(int *)((int)register0x00000010 + -4)) {
                    bVar12 = *(int *)((int)register0x00000010 + -0xc) !=
                             *(int *)((int)register0x00000010 + -0x3c);
                  }
                  else {
                    bVar12 = true;
                  }
                  *(bool *)((int)register0x00000010 + -0x2d) = bVar12;
                  *(undefined4 *)((int)register0x00000010 + -0x40) =
                       *(undefined4 *)((int)register0x00000010 + 4);
                  *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x1002;
                  *(undefined4 *)((int)register0x00000010 + -0x38) = 2;
                  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439e22;
                  FUN_0043d350();
                  if (DAT_005f6244 == 0) {
                    if (*(char *)((int)register0x00000010 + -0x2d) == '\0') {
                      iVar10 = *(int *)((int)register0x00000010 + -0x18);
                      uVar9 = *(uint *)((int)register0x00000010 + -0x1c);
                    }
                    else {
                      *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439e45;
                      FUN_0046fa70();
                      iVar11 = *(int *)((int)register0x00000010 + -0x3c);
                      iVar10 = *(int *)((int)register0x00000010 + -0x18);
                      uVar9 = *(uint *)((int)register0x00000010 + -0x1c);
                      if (iVar10 < iVar11 ||
                          uVar9 <= *(uint *)((int)register0x00000010 + -0x40) && iVar10 == iVar11) {
                        *(int *)((int)register0x00000010 + -0x28) = iVar11;
                        *(uint *)((int)register0x00000010 + -0x2c) =
                             *(uint *)((int)register0x00000010 + -0x40);
                        *(undefined4 *)((int)register0x00000010 + -0x40) =
                             *(undefined4 *)((int)register0x00000010 + -4);
                        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439e87;
                        FUN_004374a0();
                        uVar9 = *(uint *)((int)register0x00000010 + -0x2c) + 5000;
                        iVar10 = *(int *)((int)register0x00000010 + -0x28) +
                                 (uint)(0xffffec77 < *(uint *)((int)register0x00000010 + -0x2c));
                      }
                    }
                  }
                  else {
                    iVar10 = *(int *)((int)register0x00000010 + -0x18);
                    uVar9 = *(uint *)((int)register0x00000010 + -0x1c);
                  }
                  iVar11 = *(int *)((int)register0x00000010 + -4);
                  uVar5 = *(undefined4 *)((int)register0x00000010 + -0x10);
                  uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
                }
              }
              goto LAB_00439fbe;
            }
            if (uVar9 < 3) goto LAB_00439f08;
            uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
          }
LAB_00439f7b:
          *(undefined1 *)((int)register0x00000010 + -0x2e) = uVar2;
          *(undefined4 *)((int)register0x00000010 + -0x40) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(uint *)((int)register0x00000010 + -0x3c) = uVar9;
          *(uint *)((int)register0x00000010 + -0x38) = uVar9 | 0x1000;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439f98;
          FUN_0043d540();
          if (*(char *)((int)register0x00000010 + -0x34) != '\0') {
            piVar1 = *(int **)((int)register0x00000010 + 4);
            *(undefined2 *)((int)piVar1 + 0x69) = 0;
            piVar1[2] = *piVar1 + 0x13a0;
            *(int **)((int)register0x00000010 + 8) = piVar1;
            *(undefined1 *)((int)register0x00000010 + 0xc) = 0;
            *(undefined1 *)((int)register0x00000010 + 0xd) =
                 *(undefined1 *)((int)register0x00000010 + -0x2e);
            return;
          }
          uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
          iVar11 = *(int *)((int)register0x00000010 + -8);
          uVar5 = *(undefined4 *)((int)register0x00000010 + -0xc);
          iVar10 = *(int *)((int)register0x00000010 + -0x18);
          uVar9 = *(uint *)((int)register0x00000010 + -0x1c);
        }
        else {
          if (uVar9 == 6) {
            *(undefined4 *)((int)register0x00000010 + 8) = 0;
            *(undefined2 *)((int)register0x00000010 + 0xc) = 1;
            return;
          }
          if (uVar9 == 8) {
            uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
            iVar11 = *(int *)((int)register0x00000010 + -8);
            uVar5 = *(undefined4 *)((int)register0x00000010 + -0xc);
            iVar10 = *(int *)((int)register0x00000010 + -0x18);
            uVar9 = *(uint *)((int)register0x00000010 + -0x1c);
          }
          else if (uVar9 == 9) {
            *(undefined4 *)((int)register0x00000010 + -0x40) =
                 *(undefined4 *)((int)register0x00000010 + 4);
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 9;
            *(undefined4 *)((int)register0x00000010 + -0x38) = 4;
            *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439f4d;
            FUN_0043dbd0();
            if (*(char *)((int)register0x00000010 + -0x34) != '\0') {
              uVar9 = 4;
              uVar2 = 1;
              goto LAB_00439f7b;
            }
            uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
            iVar11 = *(int *)((int)register0x00000010 + -8);
            uVar5 = *(undefined4 *)((int)register0x00000010 + -0xc);
            iVar10 = *(int *)((int)register0x00000010 + -0x18);
            uVar9 = *(uint *)((int)register0x00000010 + -0x1c);
          }
          else {
LAB_00439f08:
            if ((uVar9 & 0x1000) == 0) goto LAB_0043a0a0;
            uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
            iVar11 = *(int *)((int)register0x00000010 + -8);
            uVar5 = *(undefined4 *)((int)register0x00000010 + -0xc);
            iVar10 = *(int *)((int)register0x00000010 + -0x18);
            uVar9 = *(uint *)((int)register0x00000010 + -0x1c);
          }
        }
LAB_00439fbe:
        *(undefined4 *)((int)register0x00000010 + -0xc) = uVar5;
        *(uint *)((int)register0x00000010 + -0x1c) = uVar9;
        *(int *)((int)register0x00000010 + -8) = iVar11;
        *(int *)((int)register0x00000010 + -0x18) = iVar10;
        *(undefined1 *)((int)register0x00000010 + -0x2e) = uVar2;
        if (*(int *)((int)register0x00000010 + -0x14) == 0) {
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439fdf;
          FUN_0046fa70();
          *(uint *)((int)register0x00000010 + -0x20) =
               *(int *)((int)register0x00000010 + -0x3c) +
               (uint)(0xffffd8ef < *(uint *)((int)register0x00000010 + -0x40));
          *(uint *)((int)register0x00000010 + -0x24) =
               *(uint *)((int)register0x00000010 + -0x40) + 10000;
        }
        *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439ffb;
        FUN_0046fa70();
        if (*(int *)((int)register0x00000010 + -0x3c) < *(int *)((int)register0x00000010 + -0x20) ||
            *(uint *)((int)register0x00000010 + -0x40) < *(uint *)((int)register0x00000010 + -0x24)
            && *(int *)((int)register0x00000010 + -0x20) ==
               *(int *)((int)register0x00000010 + -0x3c)) {
          *(undefined4 *)((int)register0x00000010 + -0x40) = 10;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43a02d;
          FUN_0046e9f0();
          iVar11 = *(int *)((int)register0x00000010 + -0x20);
          iVar3 = *(int *)((int)register0x00000010 + -0x24);
        }
        else {
          *(undefined ***)((int)register0x00000010 + -0x40) = &PTR_LAB_00536c80;
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43a049;
          FUN_0046d890();
          *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43a04e;
          FUN_0046fa70();
          iVar3 = *(uint *)((int)register0x00000010 + -0x40) + 5000;
          iVar11 = *(int *)((int)register0x00000010 + -0x3c) +
                   (uint)(0xffffec77 < *(uint *)((int)register0x00000010 + -0x40));
        }
        iVar10 = *(int *)((int)register0x00000010 + -0x14) + 1;
        uVar5 = *(undefined4 *)((int)register0x00000010 + -0xc);
        uVar6 = *(undefined4 *)((int)register0x00000010 + -0x18);
        uVar8 = *(undefined4 *)((int)register0x00000010 + -0x1c);
        *(int *)((int)register0x00000010 + -0x24) = iVar3;
        uVar2 = *(undefined1 *)((int)register0x00000010 + -0x2e);
        uVar4 = *(undefined4 *)((int)register0x00000010 + -8);
      } while( true );
    }
    *(int *)((int)register0x00000010 + -0x40) = iVar10 + 0x4c;
    *(undefined4 *)((int)register0x00000010 + -0x44) = 0x439c68;
    FUN_00402510();
    if (*(int *)((int)register0x00000010 + -0x3c) != 2) goto LAB_00439c73;
    goto LAB_0043a0c2;
  }
  goto LAB_0043a0d9;
LAB_0043a0a0:
  *(undefined4 *)((int)register0x00000010 + -0x40) = *(undefined4 *)((int)register0x00000010 + 4);
  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43a0ac;
  FUN_0043c810();
  *(char **)((int)register0x00000010 + -0x40) =
       "invalid g statuscastogscanstatusbad g transitionschedule: in cgoreflect mismatch untyped locals missing stackmapbad symbol tablenon-Go function\npointerless type not in ranges:\nGetCurrentThreadGetModuleHandleWRtlVirtualUnwindGODEBUG: value \"allowmultiplevcsRCodeFormatError[bisect-match 0xChaCha20Nonce.txtAdjustTokenGroupsIsTokenRestrictedLookupAccountSidWCertFindExtensionCryptDecodeObjectDnsRecordListFreeGetShortPathNameWReadProcessMemoryQueryWorkingSetExGetKeyboardLayoutWSAEnumProtocolsWWTSQueryUserTokenwinreadlinkvolumeRegLoadMUIStringWGTB Standard TimeFLE Standard TimeGMT Standard Timepermission deniedwrong medium typeno data availableexec format errorGetCurrentProcessgoroutine profileAllThreadsSyscallGC assist markingselect (no cases)sync.RWMutex.Lockwait for GC cycletrace proc statusselect (synctest)sync.(*Cond).Wait: missing method notetsleepg on g0bad TinySizeClassruntime: pointer g already scannedmark - bad statusscanobject n == 0swept cached spanmarkBits overflowruntime: summary[runtime: level = , p.searchAddr = RtlGetCurrentPeb"
  ;
  *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x10;
  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43a0c2;
  FUN_00469a20();
LAB_0043a0c2:
  *(undefined **)((int)register0x00000010 + -0x40) = &DAT_004cbcdd;
  *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x27;
  *(undefined4 *)((int)register0x00000010 + -0x44) = 0x43a0d8;
  FUN_00469a20();
LAB_0043a0d9:
  *(undefined4 *)(puVar7 + -4) = 0x43a0de;
  FUN_0046afb0();
  register0x00000010 = (BADSPACEBASE *)puVar7;
  goto code_r0x00439c30;
}



/* Function: FUN_0043a0f0 */

void FUN_0043a0f0(void)

{
  uint uVar1;
  undefined1 *puVar2;
  int in_FS_OFFSET;
  
  do {
    puVar2 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar2 = (undefined1 *)((int)register0x00000010 + -0xc);
      if (*(char *)((int)register0x00000010 + 8) != '\0') {
        return;
      }
      *(int *)((int)register0x00000010 + -0xc) = *(int *)((int)register0x00000010 + 4) + 0x4c;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x43a122;
      FUN_00402510();
      uVar1 = *(uint *)((int)register0x00000010 + -8);
      if ((uVar1 == 0x1001) || (uVar1 - 0x1003 < 2)) {
        *(undefined4 *)((int)register0x00000010 + -0xc) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(uint *)((int)register0x00000010 + -4) = uVar1 & 0xffffefff;
        *(undefined4 *)((int)register0x00000010 + -0x10) = 0x43a14d;
        FUN_0043d350();
        if (*(char *)((int)register0x00000010 + 9) != '\0') {
          *(undefined4 *)((int)register0x00000010 + -0xc) =
               *(undefined4 *)((int)register0x00000010 + 4);
          *(undefined4 *)((int)register0x00000010 + -8) = 0;
          *(undefined1 *)((int)register0x00000010 + -4) = 1;
          *(undefined4 *)((int)register0x00000010 + -0x10) = 0x43a16f;
          FUN_0043cda0();
        }
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0xc) = *(undefined4 *)((int)register0x00000010 + 4)
      ;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x43a183;
      FUN_0043c810();
      *(undefined **)((int)register0x00000010 + -0xc) = &DAT_004c630c;
      *(undefined4 *)((int)register0x00000010 + -8) = 0x13;
      *(undefined4 *)((int)register0x00000010 + -0x10) = 0x43a199;
      FUN_00469a20();
    }
    *(undefined4 *)(puVar2 + -4) = 0x43a19f;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar2;
  } while( true );
}



/* Function: FUN_0043a1b0 */

void FUN_0043a1b0(void)

{
  int iVar1;
  int in_FS_OFFSET;
  
  iVar1 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
  *(undefined1 *)(iVar1 + 0x6c) = 1;
  if (*(char *)(iVar1 + 0x6a) == '\0') {
    FUN_0046d830(&PTR_LAB_00536b0c);
  }
  else {
    FUN_0046d830(&PTR_FUN_00536c44);
  }
  *(undefined1 *)(iVar1 + 0x6c) = 0;
  return;
}



/* Function: FUN_0043a2e0 */

void FUN_0043a2e0(int param_1)

{
  int iVar1;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if ((*(char *)(param_1 + 0x69) != '\0') ||
     ((iVar1 = *(int *)(*(int *)(param_1 + 0x18) + 0x58), iVar1 != 0 &&
      (*(char *)(iVar1 + 0x11e8) != '\0')))) {
    FUN_00402510(param_1 + 0x4c);
  }
  return;
}



/* Function: FUN_0043a350 */

void FUN_0043a350(void)

{
  uint *puVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  char cVar5;
  int iVar6;
  undefined1 *puVar7;
  uint uVar8;
  int in_FS_OFFSET;
  
  do {
    puVar7 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar7 = (undefined1 *)((int)register0x00000010 + -0x38);
      puVar1 = *(uint **)((int)register0x00000010 + 4);
      uVar8 = puVar1[6];
      if (*(uint **)(uVar8 + 0x50) != puVar1) {
        *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x18) = 0;
        return;
      }
      if ((((*(int *)(uVar8 + 0x58) == 0) || (*(int *)(uVar8 + 0x7c) != 0)) ||
          (*(int *)(uVar8 + 0x6c) != 0)) ||
         ((*(int *)(uVar8 + 0x78) != 0 || (*(int *)(*(int *)(uVar8 + 0x58) + 4) != 1)))) {
        *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x18) = 0;
        return;
      }
      if ((*(uint *)((int)register0x00000010 + 0xc) < *puVar1) ||
         (*(uint *)((int)register0x00000010 + 0xc) - *puVar1 < DAT_005cc288)) {
        *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x18) = 0;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x38) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a3de;
      FUN_0046b840();
      iVar4 = *(int *)((int)register0x00000010 + -0x34);
      if (iVar4 == 0) {
        *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x18) = 0;
        return;
      }
      *(int *)((int)register0x00000010 + -8) = iVar4;
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           *(undefined4 *)((int)register0x00000010 + -0x30);
      *(int *)((int)register0x00000010 + -0x38) = iVar4;
      *(undefined4 *)((int)register0x00000010 + -0x34) =
           *(undefined4 *)((int)register0x00000010 + -0x30);
      *(undefined4 *)((int)register0x00000010 + -0x30) = 0;
      *(undefined4 *)((int)register0x00000010 + -0x2c) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a412;
      FUN_004544c0();
      if (*(int *)((int)register0x00000010 + -0x28) == -2) {
        *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x18) = 0;
        return;
      }
      iVar4 = *(int *)((int)register0x00000010 + -8);
      if (*(byte *)(iVar4 + 0x2b) < 2) {
        iVar6 = *(int *)((int)register0x00000010 + -0xc);
        uVar8 = 0;
      }
      else {
        iVar6 = *(int *)((int)register0x00000010 + -0xc);
        iVar2 = *(int *)(iVar4 + 0x30 + *(int *)(iVar4 + 0x1c) * 4);
        uVar8 = *(int *)(iVar6 + 0xa0) + iVar2 & (iVar2 == -1) - 1;
      }
      if ((uVar8 == 0) || ((*(byte *)(iVar4 + 0x29) & 4) != 0)) {
        *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
        *(undefined4 *)((int)register0x00000010 + 0x18) = 0;
        return;
      }
      *(int *)((int)register0x00000010 + -0x14) = *(int *)((int)register0x00000010 + -0x28);
      *(undefined4 *)((int)register0x00000010 + -0x10) =
           *(undefined4 *)((int)register0x00000010 + -0x24);
      *(int *)((int)register0x00000010 + -0x38) = iVar4;
      *(int *)((int)register0x00000010 + -0x34) = iVar6;
      *(undefined4 *)((int)register0x00000010 + -0x30) =
           *(undefined4 *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a48d;
      FUN_0046bac0();
      uVar8 = *(uint *)((int)register0x00000010 + -0x1c);
      iVar4 = *(int *)((int)register0x00000010 + -0x28);
      if ((int)uVar8 < 0) {
        if (*(int *)((int)register0x00000010 + -0x2c) == 0) {
          uVar3 = 0;
          iVar4 = 0;
        }
        else {
          uVar3 = *(undefined4 *)(*(int *)((int)register0x00000010 + -0x2c) + 4);
        }
LAB_0043a4c4:
        if (iVar4 == 0) {
          iVar4 = 0;
          uVar3 = 0;
        }
        else {
          *(int *)((int)register0x00000010 + -0x38) = iVar4;
          *(undefined4 *)((int)register0x00000010 + -0x34) = uVar3;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a4da;
          FUN_00453940();
          uVar3 = *(undefined4 *)((int)register0x00000010 + -0x30);
          iVar4 = *(int *)((int)register0x00000010 + -0x2c);
        }
        *(int *)((int)register0x00000010 + -0x18) = iVar4;
        *(undefined4 *)((int)register0x00000010 + -4) = uVar3;
        if (iVar4 < 8) {
          cVar5 = '\0';
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x38) = uVar3;
          *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004c3162;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 8;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a50d;
          FUN_00402aa0();
          cVar5 = *(char *)((int)register0x00000010 + -0x2c);
          iVar4 = *(int *)((int)register0x00000010 + -0x18);
          uVar3 = *(undefined4 *)((int)register0x00000010 + -4);
        }
        if (cVar5 == '\0') {
          if (iVar4 < 0x11) {
            cVar5 = '\0';
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x38) = uVar3;
            *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004c56d7;
            *(undefined4 *)((int)register0x00000010 + -0x30) = 0x11;
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a54a;
            FUN_00402aa0();
            cVar5 = *(char *)((int)register0x00000010 + -0x2c);
            iVar4 = *(int *)((int)register0x00000010 + -0x18);
            uVar3 = *(undefined4 *)((int)register0x00000010 + -4);
          }
        }
        else {
          cVar5 = '\x01';
        }
        if (cVar5 == '\0') {
          if (iVar4 < 0x11) {
            cVar5 = '\0';
          }
          else {
            *(undefined4 *)((int)register0x00000010 + -0x38) = uVar3;
            *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004c56e8;
            *(undefined4 *)((int)register0x00000010 + -0x30) = 0x11;
            *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a587;
            FUN_00402aa0();
            cVar5 = *(char *)((int)register0x00000010 + -0x2c);
            iVar4 = *(int *)((int)register0x00000010 + -0x18);
            uVar3 = *(undefined4 *)((int)register0x00000010 + -4);
          }
        }
        else {
          cVar5 = '\x01';
        }
        if (cVar5 != '\0') {
LAB_0043a5c6:
          *(undefined1 *)((int)register0x00000010 + 0x14) = 0;
          *(undefined4 *)((int)register0x00000010 + 0x18) = 0;
          return;
        }
        if (iVar4 < 8) {
          cVar5 = '\0';
        }
        else {
          *(undefined4 *)((int)register0x00000010 + -0x38) = uVar3;
          *(undefined **)((int)register0x00000010 + -0x34) = &DAT_004c3172;
          *(undefined4 *)((int)register0x00000010 + -0x30) = 8;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a5bd;
          FUN_00402aa0();
          cVar5 = *(char *)((int)register0x00000010 + -0x2c);
        }
        if (cVar5 != '\0') goto LAB_0043a5c6;
        if (*(int *)((int)register0x00000010 + -0x14) == -5) {
          uVar3 = **(undefined4 **)((int)register0x00000010 + -8);
          *(undefined4 *)((int)register0x00000010 + -0x38) =
               *(undefined4 *)((int)register0x00000010 + -0xc);
          *(undefined4 *)((int)register0x00000010 + -0x34) = uVar3;
          *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a63f;
          FUN_00453810();
          *(undefined1 *)((int)register0x00000010 + 0x14) = 1;
          *(undefined4 *)((int)register0x00000010 + 0x18) =
               *(undefined4 *)((int)register0x00000010 + -0x30);
          return;
        }
        if (1 < *(int *)((int)register0x00000010 + -0x14) + 4U) {
          *(undefined1 *)((int)register0x00000010 + 0x14) = 1;
          *(undefined4 *)((int)register0x00000010 + 0x18) =
               *(undefined4 *)((int)register0x00000010 + 8);
          return;
        }
        uVar8 = *(uint *)((int)register0x00000010 + -0x10);
        if (((uVar8 != 0) && (uVar8 <= *(uint *)((int)register0x00000010 + 8))) &&
           (*(uint *)((int)register0x00000010 + 8) - uVar8 < 0x15)) {
          *(undefined1 *)((int)register0x00000010 + 0x14) = 1;
          *(uint *)((int)register0x00000010 + 0x18) = uVar8;
          return;
        }
        *(char **)((int)register0x00000010 + -0x38) =
             "bad restart PC-thread limit\nstopm spinning nmidlelocked= needspinning=randinit twicestore64 failedmemprofileratesemaRoot queuebad allocCountbad span statestack overflow untyped args  out of range no module data in goroutine runtime: seq1=runtime: goid=unreachable:  unsafe.Pointercrypto/fips140mime/multipartRCodeNameErrorChaCha20Key.txtGetSecurityInfoImpersonateSelfOpenThreadTokenSetSecurityInfoGetAdaptersInfoAddDllDirectoryCreateHardLinkWDeviceIoControlDuplicateHandleFindNextVolumeWFindVolumeCloseFlushViewOfFileGetCommTimeoutsGetCommandLineWGetProcessTimesGetStartupInfoWIsWow64Process2Process32FirstWQueryDosDeviceWSetCommTimeoutsSetVolumeLabelWUnmapViewOfFileRtlDefaultNpAclCLSIDFromStringStringFromGUID2IsWindowUnicodeIsWindowVisibletimeBeginPeriodFailed to load Failed to find RegCreateKeyExWRegDeleteValueW,M3.2.0,M11.1.0advertise errorkey has expirednetwork is downno medium foundno such processallocmRInternalGC (fractional)write heap dumpasyncpreemptoffforce gc (idle)sync.Mutex.Lockruntime.Goschedmalloc deadlockruntime error: scan missed a gmisaligned maskruntime: min = runtime: inUse=runtime: max = requested skip=bad panic stackrecovery failedstopm holding pstartm: m has ppreempt SPWRITEmissing mcache?ms: gomaxprocs=randinit missed]\n\tmorebuf={pc:: no frame (sp=runtime: frame ts set in timertraceback stuckruntime.gopanicunexpected kindjstmpllitinterptarinsecurepathx509keypairleafx509usepolicieszipinsecurepathXorEncrypted.txtGetThreadDesktopAesEncrypted.txtDuplicateTokenExOpenProcessTokenRegQueryInfoKeyWRegQueryValueExWSetEntriesInAclWSetServiceStatusCryptProtectDataCryptQueryObjectDnsNameCompare_WConnectNamedPipeCreateDirectoryWCreateJobObjectWCreateNamedPipeWDefineDosDeviceWFindFirstVolumeWFlushFileBuffersGetComputerNameWGetFullPathNameWGetLogicalDrivesGetLongPathNameWGetNamedPipeInfoGetPriorityClassRemoveDirectoryWSetDllDirectoryWSetFileValidDataSetPriorityClassTerminateProcessVirtualProtectExNetApiBufferFreeRtlGetCurrentPebEnumChildWindowsGetDesktopWindowGetGUIThreadInfoWinVerifyTrustEx0123456789abcdefinvalid ..." /* TRUNCATED STRING LITERAL */
        ;
        *(undefined4 *)((int)register0x00000010 + -0x34) = 0xe;
        *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a6bb;
        FUN_00469a20();
      }
      else if (uVar8 < 0x100000) {
        uVar3 = *(undefined4 *)(*(int *)((int)register0x00000010 + -0x24) + 4 + uVar8 * 0x10);
        goto LAB_0043a4c4;
      }
      *(undefined4 *)((int)register0x00000010 + -0x3c) = 0x43a6c5;
      FUN_0046edf0();
    }
    *(undefined4 *)(puVar7 + -4) = 0x43a6cb;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar7;
  } while( true );
}



/* Function: FUN_0043a6d0 */

void FUN_0043a6d0(void)

{
  int iVar1;
  char cVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  undefined *puVar8;
  undefined1 *puVar9;
  int in_FS_OFFSET;
  
  do {
    puVar9 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar9 = (undefined1 *)((int)register0x00000010 + -0x14);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a6ec;
      FUN_0043a810();
      *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005f5e4c;
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a6fa;
      FUN_00402510();
      if (*(int *)((int)register0x00000010 + -0x10) != 0) {
LAB_0043a712:
        iVar7 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
        cVar2 = *(char *)(iVar7 + 0x8b);
        *(char *)(iVar7 + 0x8b) = cVar2 + -1;
        if (cVar2 == '\x01') {
          *(undefined **)((int)register0x00000010 + -0x14) = &DAT_005f5e5c;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a746;
          FUN_0040f0e0();
        }
        return;
      }
      uVar4 = *(uint *)((int)register0x00000010 + 8);
      iVar6 = *(int *)((int)register0x00000010 + 4);
      iVar7 = *(int *)((int)register0x00000010 + 0xc);
      uVar3 = 0;
      while( true ) {
        if ((int)uVar4 <= (int)uVar3) goto LAB_0043a712;
        if (0x200 < DAT_005f5e58) goto LAB_0043a7f6;
        iVar1 = DAT_005f5e58 - 0x200;
        if (uVar4 < uVar3) break;
        iVar5 = uVar4 - uVar3;
        puVar8 = (undefined *)(((int)-(iVar7 - uVar3) >> 0x1f & uVar3) + iVar6);
        if (-iVar5 == iVar1 || -iVar1 < iVar5) {
          iVar5 = -iVar1;
        }
        if (puVar8 != &DAT_005f6920 + (iVar1 >> 0x1f & DAT_005f5e58)) {
          *(uint *)((int)register0x00000010 + -4) = uVar3;
          *(int *)((int)register0x00000010 + -8) = iVar5;
          *(undefined **)((int)register0x00000010 + -0x14) =
               &DAT_005f6920 + (iVar1 >> 0x1f & DAT_005f5e58);
          *(undefined **)((int)register0x00000010 + -0x10) = puVar8;
          *(int *)((int)register0x00000010 + -0xc) = iVar5;
          *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a7da;
          FUN_0046f640();
          uVar3 = *(uint *)((int)register0x00000010 + -4);
          iVar5 = *(int *)((int)register0x00000010 + -8);
          iVar6 = *(int *)((int)register0x00000010 + 4);
        }
        DAT_005f5e58 = (int)(DAT_005f5e58 + iVar5) % 0x200;
        uVar3 = uVar3 + iVar5;
        uVar4 = *(uint *)((int)register0x00000010 + 8);
        iVar7 = *(int *)((int)register0x00000010 + 0xc);
      }
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a7f6;
      FUN_0046ee50();
LAB_0043a7f6:
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a802;
      FUN_0046ee50();
    }
    *(undefined4 *)(puVar9 + -4) = 0x43a808;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar9;
  } while( true );
}



/* Function: FUN_0043a810 */

void FUN_0043a810(void)

{
  char cVar1;
  int iVar2;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar2 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  *(int *)(iVar2 + 0x7c) = *(int *)(iVar2 + 0x7c) + 1;
  cVar1 = *(char *)(iVar2 + 0x8b);
  *(char *)(iVar2 + 0x8b) = cVar1 + '\x01';
  if (cVar1 == '\0') {
    FUN_0040ecf0(&DAT_005f5e5c);
  }
  *(int *)(iVar2 + 0x7c) = *(int *)(iVar2 + 0x7c) + -1;
  return;
}



/* Function: FUN_0043a870 */

void FUN_0043a870(void)

{
  char cVar1;
  int iVar2;
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  iVar2 = *(int *)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 0x18);
  cVar1 = *(char *)(iVar2 + 0x8b);
  *(char *)(iVar2 + 0x8b) = cVar1 + -1;
  if (cVar1 == '\x01') {
    FUN_0040f0e0(&DAT_005f5e5c);
  }
  return;
}



/* Function: FUN_0043a8d0 */

void FUN_0043a8d0(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  undefined1 *puVar4;
  int iVar5;
  int iVar6;
  int in_FS_OFFSET;
  
  do {
    puVar4 = (undefined1 *)register0x00000010;
    if (*(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8) < register0x00000010) {
      puVar4 = (undefined1 *)((int)register0x00000010 + -0x14);
      if (*(int *)((int)register0x00000010 + 8) == 0) {
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x14) =
           *(undefined4 *)((int)register0x00000010 + 4);
      *(int *)((int)register0x00000010 + -0x10) = *(int *)((int)register0x00000010 + 8);
      *(undefined4 *)((int)register0x00000010 + -0xc) =
           *(undefined4 *)((int)register0x00000010 + 0xc);
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a90b;
      FUN_0043a6d0();
      iVar2 = **(int **)(in_FS_OFFSET + DAT_005f5ed0);
      if (((iVar2 == 0) || (*(int *)(iVar2 + 0x94) == 0)) ||
         (0 < *(int *)(*(int *)(iVar2 + 0x18) + 0x80))) {
        *(undefined4 *)((int)register0x00000010 + -0x14) =
             *(undefined4 *)((int)register0x00000010 + 4);
        *(undefined4 *)((int)register0x00000010 + -0x10) =
             *(undefined4 *)((int)register0x00000010 + 8);
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a9b6;
        FUN_0044b390();
        return;
      }
      iVar6 = *(int *)(iVar2 + 0x9c) - *(uint *)(iVar2 + 0x98);
      iVar3 = *(int *)(iVar2 + 0x94) + (*(uint *)(iVar2 + 0x98) & -iVar6 >> 0x1f);
      iVar5 = *(int *)((int)register0x00000010 + 8);
      if (iVar6 <= *(int *)((int)register0x00000010 + 8)) {
        iVar5 = iVar6;
      }
      if (*(int *)((int)register0x00000010 + 4) != iVar3) {
        *(int *)((int)register0x00000010 + -4) = iVar2;
        *(int *)((int)register0x00000010 + -8) = iVar5;
        *(int *)((int)register0x00000010 + -0x14) = iVar3;
        *(int *)((int)register0x00000010 + -0x10) = *(int *)((int)register0x00000010 + 4);
        *(int *)((int)register0x00000010 + -0xc) = iVar5;
        *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a97c;
        FUN_0046f640();
        iVar2 = *(int *)((int)register0x00000010 + -4);
        iVar5 = *(int *)((int)register0x00000010 + -8);
      }
      uVar1 = *(int *)(iVar2 + 0x98) + iVar5;
      if (uVar1 <= *(uint *)(iVar2 + 0x9c)) {
        *(uint *)(iVar2 + 0x98) = uVar1;
        return;
      }
      *(undefined4 *)((int)register0x00000010 + -0x18) = 0x43a9c3;
      FUN_0046ee30();
    }
    *(undefined4 *)(puVar4 + -4) = 0x43a9c9;
    FUN_0046d980();
    register0x00000010 = (BADSPACEBASE *)puVar4;
  } while( true );
}



/* Function: FUN_0043a9d0 */

void FUN_0043a9d0(void)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0043b060(&DAT_00550468,1);
  return;
}



/* Function: FUN_0043aa10 */

void FUN_0043aa10(void)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  FUN_0043b060(&DAT_00550444,1);
  return;
}



/* Function: FUN_0043aa50 */

void FUN_0043aa50(char param_1)

{
  int in_FS_OFFSET;
  
  while (&stack0x00000000 <= *(undefined1 **)(**(int **)(in_FS_OFFSET + DAT_005f5ed0) + 8)) {
    FUN_0046d980();
  }
  if (param_1 == '\0') {
    FUN_0043b060(&DAT_004c2bf6,5);
  }
  else {
    FUN_0043b060(&DAT_004c2add,4);
  }
  return;
}



/* Function: FUN_0043aab0 */
